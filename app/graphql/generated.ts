// this file is autogenerated by codegen
/* eslint-disable */
import { gql } from "@apollo/client"
import * as Apollo from "@apollo/client"
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
const defaultOptions = {} as const
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /** An Opaque Bearer token */
  AuthToken: string
  /** (Positive) Cent amount (1/100 of a dollar) */
  CentAmount: number
  /** An alias name that a user can set for a wallet (with which they have transactions) */
  ContactAlias: string
  /** A CCA2 country code (ex US, FR, etc) */
  CountryCode: string
  /** Display currency of an account */
  DisplayCurrency: string
  /** Email address */
  EmailAddress: string
  /** An id to be passed between registrationInitiate and registrationValidate for confirming email */
  EmailRegistrationId: string
  EndpointId: string
  /** Url that will be fetched on events for the account */
  EndpointUrl: string
  /** Feedback shared with our user */
  Feedback: string
  /** Hex-encoded string of 32 bytes */
  Hex32Bytes: string
  Language: string
  LeaderboardName: string
  LnPaymentPreImage: string
  /** BOLT11 lightning invoice payment request with the amount included */
  LnPaymentRequest: string
  LnPaymentSecret: string
  /** Text field in a lightning payment transaction */
  Memo: string
  /** (Positive) amount of minutes */
  Minutes: string
  NotificationCategory: string
  /** An address for an on-chain bitcoin destination */
  OnChainAddress: string
  OnChainTxHash: string
  /** An authentication code valid for a single use */
  OneTimeAuthCode: string
  PaymentHash: string
  /** Phone number which includes country code */
  Phone: string
  /** Non-fractional signed whole numeric value between -(2^53) + 1 and 2^53 - 1 */
  SafeInt: number
  /** (Positive) Satoshi amount */
  SatAmount: number
  /** (Positive) amount of seconds */
  Seconds: number
  /** An amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedAmount: number
  /** A string amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedDisplayMajorAmount: string
  /** Timestamp field, serialized as Unix time (the number of seconds since the Unix epoch) */
  Timestamp: number
  /** A time-based one-time password */
  TotpCode: string
  /** An id to be passed between set and verify for confirming totp */
  TotpRegistrationId: string
  /** A secret to generate time-based one-time password */
  TotpSecret: string
  /** Unique identifier of a user */
  Username: string
  /** Unique identifier of a wallet */
  WalletId: string
}

export type Account = {
  readonly btcWallet?: Maybe<BtcWallet>
  readonly callbackEndpoints: ReadonlyArray<CallbackEndpoint>
  readonly csvTransactions: Scalars["String"]
  readonly defaultWallet?: Maybe<Wallet>
  readonly defaultWalletId: Scalars["WalletId"]
  readonly displayCurrency: Scalars["DisplayCurrency"]
  readonly id: Scalars["ID"]
  readonly level: AccountLevel
  readonly limits: AccountLimits
  readonly notificationSettings: NotificationSettings
  readonly realtimePrice: RealtimePrice
  readonly transactions?: Maybe<TransactionConnection>
  readonly usdWallet?: Maybe<UsdWallet>
  readonly wallets: ReadonlyArray<Wallet>
}

export type AccountCsvTransactionsArgs = {
  walletIds: ReadonlyArray<Scalars["WalletId"]>
}

export type AccountTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["WalletId"]>>>
}

export type AccountDeletePayload = {
  readonly __typename: "AccountDeletePayload"
  readonly errors: ReadonlyArray<Error>
  readonly success: Scalars["Boolean"]
}

export type AccountDisableNotificationCategoryInput = {
  readonly category: Scalars["NotificationCategory"]
  readonly channel?: InputMaybe<NotificationChannel>
}

export type AccountDisableNotificationChannelInput = {
  readonly channel: NotificationChannel
}

export type AccountEnableNotificationCategoryInput = {
  readonly category: Scalars["NotificationCategory"]
  readonly channel?: InputMaybe<NotificationChannel>
}

export type AccountEnableNotificationChannelInput = {
  readonly channel: NotificationChannel
}

export const AccountLevel = {
  One: "ONE",
  Two: "TWO",
  Zero: "ZERO",
} as const

export type AccountLevel = (typeof AccountLevel)[keyof typeof AccountLevel]
export type AccountLimit = {
  /** The rolling time interval in seconds that the limits would apply for. */
  readonly interval?: Maybe<Scalars["Seconds"]>
  /** The amount of cents remaining below the limit for the current 24 hour period. */
  readonly remainingLimit?: Maybe<Scalars["CentAmount"]>
  /** The current maximum limit for a given 24 hour period. */
  readonly totalLimit: Scalars["CentAmount"]
}

export type AccountLimits = {
  readonly __typename: "AccountLimits"
  /** Limits for converting between currencies among a account's own wallets. */
  readonly convert: ReadonlyArray<AccountLimit>
  /** Limits for sending to other internal accounts. */
  readonly internalSend: ReadonlyArray<AccountLimit>
  /** Limits for withdrawing to external onchain or lightning destinations. */
  readonly withdrawal: ReadonlyArray<AccountLimit>
}

export type AccountUpdateDefaultWalletIdInput = {
  readonly walletId: Scalars["WalletId"]
}

export type AccountUpdateDefaultWalletIdPayload = {
  readonly __typename: "AccountUpdateDefaultWalletIdPayload"
  readonly account?: Maybe<ConsumerAccount>
  readonly errors: ReadonlyArray<Error>
}

export type AccountUpdateDisplayCurrencyInput = {
  readonly currency: Scalars["DisplayCurrency"]
}

export type AccountUpdateDisplayCurrencyPayload = {
  readonly __typename: "AccountUpdateDisplayCurrencyPayload"
  readonly account?: Maybe<ConsumerAccount>
  readonly errors: ReadonlyArray<Error>
}

export type AccountUpdateNotificationSettingsPayload = {
  readonly __typename: "AccountUpdateNotificationSettingsPayload"
  readonly account?: Maybe<ConsumerAccount>
  readonly errors: ReadonlyArray<Error>
}

export type AuthTokenPayload = {
  readonly __typename: "AuthTokenPayload"
  readonly authToken?: Maybe<Scalars["AuthToken"]>
  readonly errors: ReadonlyArray<Error>
  readonly totpRequired?: Maybe<Scalars["Boolean"]>
}

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWallet = Wallet & {
  readonly __typename: "BTCWallet"
  readonly accountId: Scalars["ID"]
  /** A balance stored in BTC. */
  readonly balance: Scalars["SignedAmount"]
  readonly id: Scalars["ID"]
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars["SignedAmount"]
  /** A list of BTC transactions associated with this wallet. */
  readonly transactions?: Maybe<TransactionConnection>
  readonly transactionsByAddress?: Maybe<TransactionConnection>
  readonly walletCurrency: WalletCurrency
}

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByAddressArgs = {
  address: Scalars["OnChainAddress"]
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

export type BuildInformation = {
  readonly __typename: "BuildInformation"
  readonly commitHash?: Maybe<Scalars["String"]>
  readonly helmRevision?: Maybe<Scalars["Int"]>
}

export type CallbackEndpoint = {
  readonly __typename: "CallbackEndpoint"
  readonly id: Scalars["EndpointId"]
  readonly url: Scalars["EndpointUrl"]
}

export type CallbackEndpointAddInput = {
  /** callback endpoint to be called */
  readonly url: Scalars["EndpointUrl"]
}

export type CallbackEndpointAddPayload = {
  readonly __typename: "CallbackEndpointAddPayload"
  readonly errors: ReadonlyArray<Error>
  readonly id?: Maybe<Scalars["EndpointId"]>
}

export type CallbackEndpointDeleteInput = {
  readonly id: Scalars["EndpointId"]
}

export type CaptchaCreateChallengePayload = {
  readonly __typename: "CaptchaCreateChallengePayload"
  readonly errors: ReadonlyArray<Error>
  readonly result?: Maybe<CaptchaCreateChallengeResult>
}

export type CaptchaCreateChallengeResult = {
  readonly __typename: "CaptchaCreateChallengeResult"
  readonly challengeCode: Scalars["String"]
  readonly failbackMode: Scalars["Boolean"]
  readonly id: Scalars["String"]
  readonly newCaptcha: Scalars["Boolean"]
}

export type CaptchaRequestAuthCodeInput = {
  readonly challengeCode: Scalars["String"]
  readonly channel?: InputMaybe<PhoneCodeChannelType>
  readonly phone: Scalars["Phone"]
  readonly secCode: Scalars["String"]
  readonly validationCode: Scalars["String"]
}

export type CentAmountPayload = {
  readonly __typename: "CentAmountPayload"
  readonly amount?: Maybe<Scalars["CentAmount"]>
  readonly errors: ReadonlyArray<Error>
}

export type ConsumerAccount = Account & {
  readonly __typename: "ConsumerAccount"
  readonly btcWallet?: Maybe<BtcWallet>
  readonly callbackEndpoints: ReadonlyArray<CallbackEndpoint>
  /** return CSV stream, base64 encoded, of the list of transactions in the wallet */
  readonly csvTransactions: Scalars["String"]
  readonly defaultWallet?: Maybe<Wallet>
  readonly defaultWalletId: Scalars["WalletId"]
  readonly displayCurrency: Scalars["DisplayCurrency"]
  readonly id: Scalars["ID"]
  readonly level: AccountLevel
  readonly limits: AccountLimits
  readonly notificationSettings: NotificationSettings
  readonly onboardingStatus?: Maybe<OnboardingStatus>
  /** List the quiz questions of the consumer account */
  readonly quiz: ReadonlyArray<Quiz>
  readonly realtimePrice: RealtimePrice
  /** A list of all transactions associated with walletIds optionally passed. */
  readonly transactions?: Maybe<TransactionConnection>
  readonly usdWallet?: Maybe<UsdWallet>
  readonly wallets: ReadonlyArray<Wallet>
  readonly welcomeProfile?: Maybe<WelcomeProfile>
}

export type ConsumerAccountCsvTransactionsArgs = {
  walletIds: ReadonlyArray<Scalars["WalletId"]>
}

export type ConsumerAccountTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars["WalletId"]>>>
}

export type Contact = {
  readonly __typename: "Contact"
  readonly prettyName: Scalars["String"]
}

export type Coordinates = {
  readonly __typename: "Coordinates"
  readonly latitude: Scalars["Float"]
  readonly longitude: Scalars["Float"]
}

export type Country = {
  readonly __typename: "Country"
  readonly id: Scalars["CountryCode"]
  readonly supportedAuthChannels: ReadonlyArray<PhoneCodeChannelType>
}

export type Currency = {
  readonly __typename: "Currency"
  readonly flag: Scalars["String"]
  readonly fractionDigits: Scalars["Int"]
  readonly id: Scalars["ID"]
  readonly name: Scalars["String"]
  readonly symbol: Scalars["String"]
}

export type DepositFeesInformation = {
  readonly __typename: "DepositFeesInformation"
  readonly minBankFee: Scalars["String"]
  /** below this amount minBankFee will be charged */
  readonly minBankFeeThreshold: Scalars["String"]
  /** ratio to charge as basis points above minBankFeeThreshold amount */
  readonly ratio: Scalars["String"]
}

export type DeviceNotificationTokenCreateInput = {
  readonly deviceToken: Scalars["String"]
}

export type Email = {
  readonly __typename: "Email"
  readonly address?: Maybe<Scalars["EmailAddress"]>
  readonly verified?: Maybe<Scalars["Boolean"]>
}

export type Error = {
  readonly code?: Maybe<Scalars["String"]>
  readonly message: Scalars["String"]
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars["String"]>>>
}

export const ExchangeCurrencyUnit = {
  Btcsat: "BTCSAT",
  Usdcent: "USDCENT",
} as const

export type ExchangeCurrencyUnit =
  (typeof ExchangeCurrencyUnit)[keyof typeof ExchangeCurrencyUnit]
export type FeedbackSubmitInput = {
  readonly feedback: Scalars["Feedback"]
}

export type FeesInformation = {
  readonly __typename: "FeesInformation"
  readonly deposit: DepositFeesInformation
}

/** Provides global settings for the application which might have an impact for the user. */
export type Globals = {
  readonly __typename: "Globals"
  readonly buildInformation: BuildInformation
  readonly feesInformation: FeesInformation
  /** The domain name for lightning addresses accepted by this Galoy instance */
  readonly lightningAddressDomain: Scalars["String"]
  readonly lightningAddressDomainAliases: ReadonlyArray<Scalars["String"]>
  /** Which network (mainnet, testnet, regtest, signet) this instance is running on. */
  readonly network: Network
  /**
   * A list of public keys for the running lightning nodes.
   * This can be used to know if an invoice belongs to one of our nodes.
   */
  readonly nodesIds: ReadonlyArray<Scalars["String"]>
  /** A list of countries and their supported auth channels */
  readonly supportedCountries: ReadonlyArray<Country>
}

export type GraphQlApplicationError = Error & {
  readonly __typename: "GraphQLApplicationError"
  readonly code?: Maybe<Scalars["String"]>
  readonly message: Scalars["String"]
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars["String"]>>>
}

export const Icon = {
  ArrowLeft: "ARROW_LEFT",
  ArrowRight: "ARROW_RIGHT",
  BackSpace: "BACK_SPACE",
  Bank: "BANK",
  Bell: "BELL",
  Bitcoin: "BITCOIN",
  Book: "BOOK",
  BtcBook: "BTC_BOOK",
  CaretDown: "CARET_DOWN",
  CaretLeft: "CARET_LEFT",
  CaretRight: "CARET_RIGHT",
  CaretUp: "CARET_UP",
  Check: "CHECK",
  CheckCircle: "CHECK_CIRCLE",
  Close: "CLOSE",
  CloseCrossWithBackground: "CLOSE_CROSS_WITH_BACKGROUND",
  Coins: "COINS",
  CopyPaste: "COPY_PASTE",
  Dollar: "DOLLAR",
  Eye: "EYE",
  EyeSlash: "EYE_SLASH",
  Filter: "FILTER",
  Globe: "GLOBE",
  Graph: "GRAPH",
  Image: "IMAGE",
  Info: "INFO",
  Lightning: "LIGHTNING",
  Link: "LINK",
  Loading: "LOADING",
  MagnifyingGlass: "MAGNIFYING_GLASS",
  Map: "MAP",
  Menu: "MENU",
  Note: "NOTE",
  PaymentError: "PAYMENT_ERROR",
  PaymentPending: "PAYMENT_PENDING",
  PaymentSuccess: "PAYMENT_SUCCESS",
  Pencil: "PENCIL",
  People: "PEOPLE",
  QrCode: "QR_CODE",
  Question: "QUESTION",
  Rank: "RANK",
  Receive: "RECEIVE",
  Refresh: "REFRESH",
  Send: "SEND",
  Settings: "SETTINGS",
  Share: "SHARE",
  Transfer: "TRANSFER",
  User: "USER",
  Video: "VIDEO",
  Warning: "WARNING",
  WarningWithBackground: "WARNING_WITH_BACKGROUND",
} as const

export type Icon = (typeof Icon)[keyof typeof Icon]

export type InitiationVia =
  | InitiationViaIntraLedger
  | InitiationViaLn
  | InitiationViaOnChain

export type InitiationViaIntraLedger = {
  readonly __typename: "InitiationViaIntraLedger"
  readonly counterPartyUsername?: Maybe<Scalars["Username"]>
  readonly counterPartyWalletId?: Maybe<Scalars["WalletId"]>
}

export type InitiationViaLn = {
  readonly __typename: "InitiationViaLn"
  readonly paymentHash: Scalars["PaymentHash"]
}

export type InitiationViaOnChain = {
  readonly __typename: "InitiationViaOnChain"
  readonly address: Scalars["OnChainAddress"]
}

export type IntraLedgerPaymentSendInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars["SatAmount"]
  /** Optional memo to be attached to the payment. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly recipientWalletId: Scalars["WalletId"]
  /** The wallet ID of the sender. */
  readonly walletId: Scalars["WalletId"]
}

export type IntraLedgerUpdate = {
  readonly __typename: "IntraLedgerUpdate"
  readonly amount: Scalars["SatAmount"]
  readonly displayCurrencyPerSat: Scalars["Float"]
  readonly txNotificationType: TxNotificationType
  /** @deprecated updated over displayCurrencyPerSat */
  readonly usdPerSat: Scalars["Float"]
  readonly walletId: Scalars["WalletId"]
}

export type IntraLedgerUsdPaymentSendInput = {
  /** Amount in cents. */
  readonly amount: Scalars["CentAmount"]
  /** Optional memo to be attached to the payment. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly recipientWalletId: Scalars["WalletId"]
  /** The wallet ID of the sender. */
  readonly walletId: Scalars["WalletId"]
}

export const InvoicePaymentStatus = {
  Expired: "EXPIRED",
  Paid: "PAID",
  Pending: "PENDING",
} as const

export type InvoicePaymentStatus =
  (typeof InvoicePaymentStatus)[keyof typeof InvoicePaymentStatus]
export type Leader = {
  readonly __typename: "Leader"
  readonly name?: Maybe<Scalars["LeaderboardName"]>
  readonly points: Scalars["Int"]
  readonly rank: Scalars["Int"]
}

export type Leaderboard = {
  readonly __typename: "Leaderboard"
  readonly leaders: ReadonlyArray<Leader>
  readonly range: WelcomeRange
}

export type LnInvoice = {
  readonly __typename: "LnInvoice"
  readonly paymentHash: Scalars["PaymentHash"]
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly paymentSecret: Scalars["LnPaymentSecret"]
  readonly satoshis?: Maybe<Scalars["SatAmount"]>
}

export type LnInvoiceCreateInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars["SatAmount"]
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a BTC wallet belonging to the current account. */
  readonly walletId: Scalars["WalletId"]
}

export type LnInvoiceCreateOnBehalfOfRecipientInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars["SatAmount"]
  readonly descriptionHash?: InputMaybe<Scalars["Hex32Bytes"]>
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a BTC wallet which belongs to any account. */
  readonly recipientWalletId: Scalars["WalletId"]
}

export type LnInvoiceFeeProbeInput = {
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly walletId: Scalars["WalletId"]
}

export type LnInvoicePayload = {
  readonly __typename: "LnInvoicePayload"
  readonly errors: ReadonlyArray<Error>
  readonly invoice?: Maybe<LnInvoice>
}

export type LnInvoicePaymentInput = {
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  /** Wallet ID with sufficient balance to cover amount of invoice.  Must belong to the account of the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnInvoicePaymentStatusInput = {
  readonly paymentRequest: Scalars["LnPaymentRequest"]
}

export type LnInvoicePaymentStatusPayload = {
  readonly __typename: "LnInvoicePaymentStatusPayload"
  readonly errors: ReadonlyArray<Error>
  readonly status?: Maybe<InvoicePaymentStatus>
}

export type LnNoAmountInvoice = {
  readonly __typename: "LnNoAmountInvoice"
  readonly paymentHash: Scalars["PaymentHash"]
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly paymentSecret: Scalars["LnPaymentSecret"]
}

export type LnNoAmountInvoiceCreateInput = {
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** ID for either a USD or BTC wallet belonging to the account of the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnNoAmountInvoiceCreateOnBehalfOfRecipientInput = {
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** ID for either a USD or BTC wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars["WalletId"]
}

export type LnNoAmountInvoiceFeeProbeInput = {
  readonly amount: Scalars["SatAmount"]
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly walletId: Scalars["WalletId"]
}

export type LnNoAmountInvoicePayload = {
  readonly __typename: "LnNoAmountInvoicePayload"
  readonly errors: ReadonlyArray<Error>
  readonly invoice?: Maybe<LnNoAmountInvoice>
}

export type LnNoAmountInvoicePaymentInput = {
  /** Amount to pay in satoshis. */
  readonly amount: Scalars["SatAmount"]
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  /** Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnNoAmountUsdInvoiceFeeProbeInput = {
  readonly amount: Scalars["CentAmount"]
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly walletId: Scalars["WalletId"]
}

export type LnNoAmountUsdInvoicePaymentInput = {
  /** Amount to pay in USD cents. */
  readonly amount: Scalars["CentAmount"]
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  /** Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnUpdate = {
  readonly __typename: "LnUpdate"
  readonly paymentHash: Scalars["PaymentHash"]
  readonly status: InvoicePaymentStatus
  readonly walletId: Scalars["WalletId"]
}

export type LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars["SatAmount"]
  readonly descriptionHash?: InputMaybe<Scalars["Hex32Bytes"]>
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. Acts as a note to the recipient. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a USD wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars["WalletId"]
}

export type LnUsdInvoiceCreateInput = {
  /** Amount in USD cents. */
  readonly amount: Scalars["CentAmount"]
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a USD wallet belonging to the current user. */
  readonly walletId: Scalars["WalletId"]
}

export type LnUsdInvoiceCreateOnBehalfOfRecipientInput = {
  /** Amount in USD cents. */
  readonly amount: Scalars["CentAmount"]
  readonly descriptionHash?: InputMaybe<Scalars["Hex32Bytes"]>
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars["Minutes"]>
  /** Optional memo for the lightning invoice. Acts as a note to the recipient. */
  readonly memo?: InputMaybe<Scalars["Memo"]>
  /** Wallet ID for a USD wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars["WalletId"]
}

export type LnUsdInvoiceFeeProbeInput = {
  readonly paymentRequest: Scalars["LnPaymentRequest"]
  readonly walletId: Scalars["WalletId"]
}

export type MapInfo = {
  readonly __typename: "MapInfo"
  readonly coordinates: Coordinates
  readonly title: Scalars["String"]
}

export type MapMarker = {
  readonly __typename: "MapMarker"
  readonly mapInfo: MapInfo
  readonly username?: Maybe<Scalars["Username"]>
}

export type MobileVersions = {
  readonly __typename: "MobileVersions"
  readonly currentSupported: Scalars["Int"]
  readonly minSupported: Scalars["Int"]
  readonly platform: Scalars["String"]
}

export type Mutation = {
  readonly __typename: "Mutation"
  readonly accountDelete: AccountDeletePayload
  readonly accountDisableNotificationCategory: AccountUpdateNotificationSettingsPayload
  readonly accountDisableNotificationChannel: AccountUpdateNotificationSettingsPayload
  readonly accountEnableNotificationCategory: AccountUpdateNotificationSettingsPayload
  readonly accountEnableNotificationChannel: AccountUpdateNotificationSettingsPayload
  readonly accountUpdateDefaultWalletId: AccountUpdateDefaultWalletIdPayload
  readonly accountUpdateDisplayCurrency: AccountUpdateDisplayCurrencyPayload
  readonly callbackEndpointAdd: CallbackEndpointAddPayload
  readonly callbackEndpointDelete: SuccessPayload
  readonly captchaCreateChallenge: CaptchaCreateChallengePayload
  readonly captchaRequestAuthCode: SuccessPayload
  readonly deviceNotificationTokenCreate: SuccessPayload
  readonly feedbackSubmit: SuccessPayload
  /**
   * Actions a payment which is internal to the ledger e.g. it does
   * not use onchain/lightning. Returns payment status (success,
   * failed, pending, already_paid).
   */
  readonly intraLedgerPaymentSend: PaymentSendPayload
  /**
   * Actions a payment which is internal to the ledger e.g. it does
   * not use onchain/lightning. Returns payment status (success,
   * failed, pending, already_paid).
   */
  readonly intraLedgerUsdPaymentSend: PaymentSendPayload
  /**
   * Returns a lightning invoice for an associated wallet.
   * When invoice is paid the value will be credited to a BTC wallet.
   * Expires after 'expiresIn' or 24 hours.
   */
  readonly lnInvoiceCreate: LnInvoicePayload
  /**
   * Returns a lightning invoice for an associated wallet.
   * When invoice is paid the value will be credited to a BTC wallet.
   * Expires after 'expiresIn' or 24 hours.
   */
  readonly lnInvoiceCreateOnBehalfOfRecipient: LnInvoicePayload
  readonly lnInvoiceFeeProbe: SatAmountPayload
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet can be USD or BTC and must have sufficient balance to cover amount in lightning invoice.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnInvoicePaymentSend: PaymentSendPayload
  /**
   * Returns a lightning invoice for an associated wallet.
   * Can be used to receive any supported currency value (currently USD or BTC).
   * Expires after 'expiresIn' or 24 hours for BTC invoices or 5 minutes for USD invoices.
   */
  readonly lnNoAmountInvoiceCreate: LnNoAmountInvoicePayload
  /**
   * Returns a lightning invoice for an associated wallet.
   * Can be used to receive any supported currency value (currently USD or BTC).
   * Expires after 'expiresIn' or 24 hours for BTC invoices or 5 minutes for USD invoices.
   */
  readonly lnNoAmountInvoiceCreateOnBehalfOfRecipient: LnNoAmountInvoicePayload
  readonly lnNoAmountInvoiceFeeProbe: SatAmountPayload
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet must be BTC and must have sufficient balance to cover amount specified in mutation request.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnNoAmountInvoicePaymentSend: PaymentSendPayload
  readonly lnNoAmountUsdInvoiceFeeProbe: CentAmountPayload
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet must be USD and have sufficient balance to cover amount specified in mutation request.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnNoAmountUsdInvoicePaymentSend: PaymentSendPayload
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   *   associated with the amount).
   */
  readonly lnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipient: LnInvoicePayload
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   * associated with the amount).
   */
  readonly lnUsdInvoiceCreate: LnInvoicePayload
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   *   associated with the amount).
   */
  readonly lnUsdInvoiceCreateOnBehalfOfRecipient: LnInvoicePayload
  readonly lnUsdInvoiceFeeProbe: SatAmountPayload
  readonly onChainAddressCreate: OnChainAddressPayload
  readonly onChainAddressCurrent: OnChainAddressPayload
  readonly onChainPaymentSend: PaymentSendPayload
  readonly onChainPaymentSendAll: PaymentSendPayload
  readonly onChainUsdPaymentSend: PaymentSendPayload
  readonly onChainUsdPaymentSendAsBtcDenominated: PaymentSendPayload
  readonly onboardingFlowStart: OnboardingFlowStartResult
  readonly quizCompleted: QuizCompletedPayload
  /** @deprecated will be moved to AccountContact */
  readonly userContactUpdateAlias: UserContactUpdateAliasPayload
  readonly userEmailDelete: UserEmailDeletePayload
  readonly userEmailRegistrationInitiate: UserEmailRegistrationInitiatePayload
  readonly userEmailRegistrationValidate: UserEmailRegistrationValidatePayload
  readonly userLogin: AuthTokenPayload
  readonly userLoginUpgrade: UpgradePayload
  readonly userLogout: SuccessPayload
  readonly userPhoneDelete: UserPhoneDeletePayload
  readonly userPhoneRegistrationInitiate: SuccessPayload
  readonly userPhoneRegistrationValidate: UserPhoneRegistrationValidatePayload
  readonly userTotpDelete: UserTotpDeletePayload
  readonly userTotpRegistrationInitiate: UserTotpRegistrationInitiatePayload
  readonly userTotpRegistrationValidate: UserTotpRegistrationValidatePayload
  readonly userUpdateLanguage: UserUpdateLanguagePayload
  /** @deprecated Username will be moved to @Handle in Accounts. Also SetUsername naming should be used instead of UpdateUsername to reflect the idempotency of Handles */
  readonly userUpdateUsername: UserUpdateUsernamePayload
}

export type MutationAccountDisableNotificationCategoryArgs = {
  input: AccountDisableNotificationCategoryInput
}

export type MutationAccountDisableNotificationChannelArgs = {
  input: AccountDisableNotificationChannelInput
}

export type MutationAccountEnableNotificationCategoryArgs = {
  input: AccountEnableNotificationCategoryInput
}

export type MutationAccountEnableNotificationChannelArgs = {
  input: AccountEnableNotificationChannelInput
}

export type MutationAccountUpdateDefaultWalletIdArgs = {
  input: AccountUpdateDefaultWalletIdInput
}

export type MutationAccountUpdateDisplayCurrencyArgs = {
  input: AccountUpdateDisplayCurrencyInput
}

export type MutationCallbackEndpointAddArgs = {
  input: CallbackEndpointAddInput
}

export type MutationCallbackEndpointDeleteArgs = {
  input: CallbackEndpointDeleteInput
}

export type MutationCaptchaRequestAuthCodeArgs = {
  input: CaptchaRequestAuthCodeInput
}

export type MutationDeviceNotificationTokenCreateArgs = {
  input: DeviceNotificationTokenCreateInput
}

export type MutationFeedbackSubmitArgs = {
  input: FeedbackSubmitInput
}

export type MutationIntraLedgerPaymentSendArgs = {
  input: IntraLedgerPaymentSendInput
}

export type MutationIntraLedgerUsdPaymentSendArgs = {
  input: IntraLedgerUsdPaymentSendInput
}

export type MutationLnInvoiceCreateArgs = {
  input: LnInvoiceCreateInput
}

export type MutationLnInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnInvoiceCreateOnBehalfOfRecipientInput
}

export type MutationLnInvoiceFeeProbeArgs = {
  input: LnInvoiceFeeProbeInput
}

export type MutationLnInvoicePaymentSendArgs = {
  input: LnInvoicePaymentInput
}

export type MutationLnNoAmountInvoiceCreateArgs = {
  input: LnNoAmountInvoiceCreateInput
}

export type MutationLnNoAmountInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput
}

export type MutationLnNoAmountInvoiceFeeProbeArgs = {
  input: LnNoAmountInvoiceFeeProbeInput
}

export type MutationLnNoAmountInvoicePaymentSendArgs = {
  input: LnNoAmountInvoicePaymentInput
}

export type MutationLnNoAmountUsdInvoiceFeeProbeArgs = {
  input: LnNoAmountUsdInvoiceFeeProbeInput
}

export type MutationLnNoAmountUsdInvoicePaymentSendArgs = {
  input: LnNoAmountUsdInvoicePaymentInput
}

export type MutationLnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientArgs = {
  input: LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput
}

export type MutationLnUsdInvoiceCreateArgs = {
  input: LnUsdInvoiceCreateInput
}

export type MutationLnUsdInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnUsdInvoiceCreateOnBehalfOfRecipientInput
}

export type MutationLnUsdInvoiceFeeProbeArgs = {
  input: LnUsdInvoiceFeeProbeInput
}

export type MutationOnChainAddressCreateArgs = {
  input: OnChainAddressCreateInput
}

export type MutationOnChainAddressCurrentArgs = {
  input: OnChainAddressCurrentInput
}

export type MutationOnChainPaymentSendArgs = {
  input: OnChainPaymentSendInput
}

export type MutationOnChainPaymentSendAllArgs = {
  input: OnChainPaymentSendAllInput
}

export type MutationOnChainUsdPaymentSendArgs = {
  input: OnChainUsdPaymentSendInput
}

export type MutationOnChainUsdPaymentSendAsBtcDenominatedArgs = {
  input: OnChainUsdPaymentSendAsBtcDenominatedInput
}

export type MutationOnboardingFlowStartArgs = {
  input: OnboardingFlowStartInput
}

export type MutationQuizCompletedArgs = {
  input: QuizCompletedInput
}

export type MutationUserContactUpdateAliasArgs = {
  input: UserContactUpdateAliasInput
}

export type MutationUserEmailRegistrationInitiateArgs = {
  input: UserEmailRegistrationInitiateInput
}

export type MutationUserEmailRegistrationValidateArgs = {
  input: UserEmailRegistrationValidateInput
}

export type MutationUserLoginArgs = {
  input: UserLoginInput
}

export type MutationUserLoginUpgradeArgs = {
  input: UserLoginUpgradeInput
}

export type MutationUserLogoutArgs = {
  input?: InputMaybe<UserLogoutInput>
}

export type MutationUserPhoneRegistrationInitiateArgs = {
  input: UserPhoneRegistrationInitiateInput
}

export type MutationUserPhoneRegistrationValidateArgs = {
  input: UserPhoneRegistrationValidateInput
}

export type MutationUserTotpDeleteArgs = {
  input: UserTotpDeleteInput
}

export type MutationUserTotpRegistrationInitiateArgs = {
  input: UserTotpRegistrationInitiateInput
}

export type MutationUserTotpRegistrationValidateArgs = {
  input: UserTotpRegistrationValidateInput
}

export type MutationUserUpdateLanguageArgs = {
  input: UserUpdateLanguageInput
}

export type MutationUserUpdateUsernameArgs = {
  input: UserUpdateUsernameInput
}

export type MyUpdatesPayload = {
  readonly __typename: "MyUpdatesPayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
  readonly update?: Maybe<UserUpdate>
}

export const Network = {
  Mainnet: "mainnet",
  Regtest: "regtest",
  Signet: "signet",
  Testnet: "testnet",
} as const

export type Network = (typeof Network)[keyof typeof Network]
export type NotificationAction = OpenDeepLinkAction | OpenExternalLinkAction

export const NotificationChannel = {
  Push: "PUSH",
} as const

export type NotificationChannel =
  (typeof NotificationChannel)[keyof typeof NotificationChannel]
export type NotificationChannelSettings = {
  readonly __typename: "NotificationChannelSettings"
  readonly disabledCategories: ReadonlyArray<Scalars["NotificationCategory"]>
  readonly enabled: Scalars["Boolean"]
}

export type NotificationSettings = {
  readonly __typename: "NotificationSettings"
  readonly push: NotificationChannelSettings
}

export type OnChainAddressCreateInput = {
  readonly walletId: Scalars["WalletId"]
}

export type OnChainAddressCurrentInput = {
  readonly walletId: Scalars["WalletId"]
}

export type OnChainAddressPayload = {
  readonly __typename: "OnChainAddressPayload"
  readonly address?: Maybe<Scalars["OnChainAddress"]>
  readonly errors: ReadonlyArray<Error>
}

export type OnChainPaymentSendAllInput = {
  readonly address: Scalars["OnChainAddress"]
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly speed?: InputMaybe<PayoutSpeed>
  readonly walletId: Scalars["WalletId"]
}

export type OnChainPaymentSendInput = {
  readonly address: Scalars["OnChainAddress"]
  readonly amount: Scalars["SatAmount"]
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly speed?: InputMaybe<PayoutSpeed>
  readonly walletId: Scalars["WalletId"]
}

export type OnChainTxFee = {
  readonly __typename: "OnChainTxFee"
  readonly amount: Scalars["SatAmount"]
}

export type OnChainUpdate = {
  readonly __typename: "OnChainUpdate"
  readonly amount: Scalars["SatAmount"]
  readonly displayCurrencyPerSat: Scalars["Float"]
  readonly txHash: Scalars["OnChainTxHash"]
  readonly txNotificationType: TxNotificationType
  /** @deprecated updated over displayCurrencyPerSat */
  readonly usdPerSat: Scalars["Float"]
  readonly walletId: Scalars["WalletId"]
}

export type OnChainUsdPaymentSendAsBtcDenominatedInput = {
  readonly address: Scalars["OnChainAddress"]
  readonly amount: Scalars["SatAmount"]
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly speed?: InputMaybe<PayoutSpeed>
  readonly walletId: Scalars["WalletId"]
}

export type OnChainUsdPaymentSendInput = {
  readonly address: Scalars["OnChainAddress"]
  readonly amount: Scalars["CentAmount"]
  readonly memo?: InputMaybe<Scalars["Memo"]>
  readonly speed?: InputMaybe<PayoutSpeed>
  readonly walletId: Scalars["WalletId"]
}

export type OnChainUsdTxFee = {
  readonly __typename: "OnChainUsdTxFee"
  readonly amount: Scalars["CentAmount"]
}

export type OnboardingFlowStartInput = {
  readonly firstName: Scalars["String"]
  readonly lastName: Scalars["String"]
}

export type OnboardingFlowStartResult = {
  readonly __typename: "OnboardingFlowStartResult"
  readonly tokenAndroid: Scalars["String"]
  readonly tokenIos: Scalars["String"]
  readonly workflowRunId: Scalars["String"]
}

export const OnboardingStatus = {
  Abandoned: "ABANDONED",
  Approved: "APPROVED",
  AwaitingInput: "AWAITING_INPUT",
  Declined: "DECLINED",
  Error: "ERROR",
  NotStarted: "NOT_STARTED",
  Processing: "PROCESSING",
  Review: "REVIEW",
} as const

export type OnboardingStatus = (typeof OnboardingStatus)[keyof typeof OnboardingStatus]
export type OneDayAccountLimit = AccountLimit & {
  readonly __typename: "OneDayAccountLimit"
  /** The rolling time interval value in seconds for the current 24 hour period. */
  readonly interval?: Maybe<Scalars["Seconds"]>
  /** The amount of cents remaining below the limit for the current 24 hour period. */
  readonly remainingLimit?: Maybe<Scalars["CentAmount"]>
  /** The current maximum limit for a given 24 hour period. */
  readonly totalLimit: Scalars["CentAmount"]
}

export type OpenDeepLinkAction = {
  readonly __typename: "OpenDeepLinkAction"
  readonly deepLink: Scalars["String"]
}

export type OpenExternalLinkAction = {
  readonly __typename: "OpenExternalLinkAction"
  readonly url: Scalars["String"]
}

/** Information about pagination in a connection. */
export type PageInfo = {
  readonly __typename: "PageInfo"
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars["String"]>
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars["Boolean"]
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars["Boolean"]
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars["String"]>
}

export type PaymentSendPayload = {
  readonly __typename: "PaymentSendPayload"
  readonly errors: ReadonlyArray<Error>
  readonly status?: Maybe<PaymentSendResult>
}

export const PaymentSendResult = {
  AlreadyPaid: "ALREADY_PAID",
  Failure: "FAILURE",
  Pending: "PENDING",
  Success: "SUCCESS",
} as const

export type PaymentSendResult = (typeof PaymentSendResult)[keyof typeof PaymentSendResult]
export const PayoutSpeed = {
  Fast: "FAST",
} as const

export type PayoutSpeed = (typeof PayoutSpeed)[keyof typeof PayoutSpeed]
export const PhoneCodeChannelType = {
  Sms: "SMS",
  Whatsapp: "WHATSAPP",
} as const

export type PhoneCodeChannelType =
  (typeof PhoneCodeChannelType)[keyof typeof PhoneCodeChannelType]
/** Price amount expressed in base/offset. To calculate, use: `base / 10^offset` */
export type Price = {
  readonly __typename: "Price"
  readonly base: Scalars["SafeInt"]
  readonly currencyUnit: Scalars["String"]
  readonly formattedAmount: Scalars["String"]
  readonly offset: Scalars["Int"]
}

/** The range for the X axis in the BTC price graph */
export const PriceGraphRange = {
  FiveYears: "FIVE_YEARS",
  OneDay: "ONE_DAY",
  OneMonth: "ONE_MONTH",
  OneWeek: "ONE_WEEK",
  OneYear: "ONE_YEAR",
} as const

export type PriceGraphRange = (typeof PriceGraphRange)[keyof typeof PriceGraphRange]
export type PriceInput = {
  readonly amount: Scalars["SatAmount"]
  readonly amountCurrencyUnit: ExchangeCurrencyUnit
  readonly priceCurrencyUnit: ExchangeCurrencyUnit
}

export type PriceInterface = {
  readonly base: Scalars["SafeInt"]
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars["String"]
  readonly offset: Scalars["Int"]
}

/** Price of 1 sat in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSatInMinorUnit = PriceInterface & {
  readonly __typename: "PriceOfOneSatInMinorUnit"
  readonly base: Scalars["SafeInt"]
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars["String"]
  readonly offset: Scalars["Int"]
}

/** Price of 1 sat or 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSettlementMinorUnitInDisplayMinorUnit = PriceInterface & {
  readonly __typename: "PriceOfOneSettlementMinorUnitInDisplayMinorUnit"
  readonly base: Scalars["SafeInt"]
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars["String"]
  /** @deprecated Deprecated please use `base / 10^offset` */
  readonly formattedAmount: Scalars["String"]
  readonly offset: Scalars["Int"]
}

/** Price of 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneUsdCentInMinorUnit = PriceInterface & {
  readonly __typename: "PriceOfOneUsdCentInMinorUnit"
  readonly base: Scalars["SafeInt"]
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars["String"]
  readonly offset: Scalars["Int"]
}

export type PricePayload = {
  readonly __typename: "PricePayload"
  readonly errors: ReadonlyArray<Error>
  readonly price?: Maybe<Price>
}

export type PricePoint = {
  readonly __typename: "PricePoint"
  readonly price: Price
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars["Timestamp"]
}

/** A public view of a generic wallet which stores value in one of our supported currencies. */
export type PublicWallet = {
  readonly __typename: "PublicWallet"
  readonly id: Scalars["ID"]
  readonly walletCurrency: WalletCurrency
}

export type Query = {
  readonly __typename: "Query"
  readonly accountDefaultWallet: PublicWallet
  readonly beta: Scalars["Boolean"]
  readonly btcPriceList?: Maybe<ReadonlyArray<Maybe<PricePoint>>>
  readonly businessMapMarkers?: Maybe<ReadonlyArray<Maybe<MapMarker>>>
  readonly colorScheme: Scalars["String"]
  readonly currencyList: ReadonlyArray<Currency>
  readonly feedbackModalShown: Scalars["Boolean"]
  readonly globals?: Maybe<Globals>
  readonly hasPromptedSetDefaultAccount: Scalars["Boolean"]
  readonly hiddenBalanceToolTip: Scalars["Boolean"]
  readonly hideBalance: Scalars["Boolean"]
  readonly lnInvoicePaymentStatus: LnInvoicePaymentStatusPayload
  readonly me?: Maybe<User>
  readonly mobileVersions?: Maybe<ReadonlyArray<Maybe<MobileVersions>>>
  readonly onChainTxFee: OnChainTxFee
  readonly onChainUsdTxFee: OnChainUsdTxFee
  readonly onChainUsdTxFeeAsBtcDenominated: OnChainUsdTxFee
  readonly price?: Maybe<Scalars["String"]>
  /** @deprecated TODO: remove. we don't need a non authenticated version of this query. the users can only do the query while authenticated */
  readonly quizQuestions?: Maybe<ReadonlyArray<Maybe<QuizQuestion>>>
  /** Returns 1 Sat and 1 Usd Cent price for the given currency */
  readonly realtimePrice: RealtimePrice
  /** @deprecated will be migrated to AccountDefaultWalletId */
  readonly userDefaultWalletId: Scalars["WalletId"]
  readonly usernameAvailable?: Maybe<Scalars["Boolean"]>
  readonly welcomeLeaderboard: Leaderboard
}

export type QueryAccountDefaultWalletArgs = {
  username: Scalars["Username"]
  walletCurrency?: InputMaybe<WalletCurrency>
}

export type QueryBtcPriceListArgs = {
  range: PriceGraphRange
}

export type QueryLnInvoicePaymentStatusArgs = {
  input: LnInvoicePaymentStatusInput
}

export type QueryOnChainTxFeeArgs = {
  address: Scalars["OnChainAddress"]
  amount: Scalars["SatAmount"]
  speed?: InputMaybe<PayoutSpeed>
  walletId: Scalars["WalletId"]
}

export type QueryOnChainUsdTxFeeArgs = {
  address: Scalars["OnChainAddress"]
  amount: Scalars["CentAmount"]
  speed?: InputMaybe<PayoutSpeed>
  walletId: Scalars["WalletId"]
}

export type QueryOnChainUsdTxFeeAsBtcDenominatedArgs = {
  address: Scalars["OnChainAddress"]
  amount: Scalars["SatAmount"]
  speed?: InputMaybe<PayoutSpeed>
  walletId: Scalars["WalletId"]
}

export type QueryRealtimePriceArgs = {
  currency?: InputMaybe<Scalars["DisplayCurrency"]>
}

export type QueryUserDefaultWalletIdArgs = {
  username: Scalars["Username"]
}

export type QueryUsernameAvailableArgs = {
  username: Scalars["Username"]
}

export type QueryWelcomeLeaderboardArgs = {
  input: WelcomeLeaderboardInput
}

export type Quiz = {
  readonly __typename: "Quiz"
  /** The reward in Satoshis for the quiz question */
  readonly amount: Scalars["SatAmount"]
  readonly completed: Scalars["Boolean"]
  readonly id: Scalars["ID"]
}

export type QuizCompletedInput = {
  readonly id: Scalars["ID"]
}

export type QuizCompletedPayload = {
  readonly __typename: "QuizCompletedPayload"
  readonly errors: ReadonlyArray<Error>
  readonly quiz?: Maybe<Quiz>
}

export type QuizQuestion = {
  readonly __typename: "QuizQuestion"
  /** The earn reward in Satoshis for the quiz question */
  readonly earnAmount: Scalars["SatAmount"]
  readonly id: Scalars["ID"]
}

export type RealtimePrice = {
  readonly __typename: "RealtimePrice"
  readonly btcSatPrice: PriceOfOneSatInMinorUnit
  readonly denominatorCurrency: Scalars["DisplayCurrency"]
  readonly id: Scalars["ID"]
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars["Timestamp"]
  readonly usdCentPrice: PriceOfOneUsdCentInMinorUnit
}

export type RealtimePriceInput = {
  readonly currency?: InputMaybe<Scalars["DisplayCurrency"]>
}

export type RealtimePricePayload = {
  readonly __typename: "RealtimePricePayload"
  readonly errors: ReadonlyArray<Error>
  readonly realtimePrice?: Maybe<RealtimePrice>
}

export type SatAmountPayload = {
  readonly __typename: "SatAmountPayload"
  readonly amount?: Maybe<Scalars["SatAmount"]>
  readonly errors: ReadonlyArray<Error>
}

export type SettlementVia =
  | SettlementViaIntraLedger
  | SettlementViaLn
  | SettlementViaOnChain

export type SettlementViaIntraLedger = {
  readonly __typename: "SettlementViaIntraLedger"
  /** Settlement destination: Could be null if the payee does not have a username */
  readonly counterPartyUsername?: Maybe<Scalars["Username"]>
  readonly counterPartyWalletId?: Maybe<Scalars["WalletId"]>
}

export type SettlementViaLn = {
  readonly __typename: "SettlementViaLn"
  /** @deprecated Shifting property to 'preImage' to improve granularity of the LnPaymentSecret type */
  readonly paymentSecret?: Maybe<Scalars["LnPaymentSecret"]>
  readonly preImage?: Maybe<Scalars["LnPaymentPreImage"]>
}

export type SettlementViaOnChain = {
  readonly __typename: "SettlementViaOnChain"
  readonly transactionHash?: Maybe<Scalars["OnChainTxHash"]>
  readonly vout?: Maybe<Scalars["Int"]>
}

export type StatefulNotification = {
  readonly __typename: "StatefulNotification"
  readonly acknowledgedAt?: Maybe<Scalars["Timestamp"]>
  readonly action?: Maybe<NotificationAction>
  readonly body: Scalars["String"]
  readonly bulletinEnabled: Scalars["Boolean"]
  readonly createdAt: Scalars["Timestamp"]
  readonly deepLink?: Maybe<Scalars["String"]>
  readonly icon?: Maybe<Icon>
  readonly id: Scalars["ID"]
  readonly title: Scalars["String"]
}

export type StatefulNotificationAcknowledgeInput = {
  readonly notificationId: Scalars["ID"]
}

export type StatefulNotificationAcknowledgePayload = {
  readonly __typename: "StatefulNotificationAcknowledgePayload"
  readonly notification: StatefulNotification
}

export type StatefulNotificationConnection = {
  readonly __typename: "StatefulNotificationConnection"
  /** A list of edges. */
  readonly edges: ReadonlyArray<StatefulNotificationEdge>
  /** A list of nodes. */
  readonly nodes: ReadonlyArray<StatefulNotification>
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo
}

/** An edge in a connection. */
export type StatefulNotificationEdge = {
  readonly __typename: "StatefulNotificationEdge"
  /** A cursor for use in pagination */
  readonly cursor: Scalars["String"]
  /** The item at the end of the edge */
  readonly node: StatefulNotification
}

export type Subscription = {
  readonly __typename: "Subscription"
  readonly lnInvoicePaymentStatus: LnInvoicePaymentStatusPayload
  readonly myUpdates: MyUpdatesPayload
  readonly price: PricePayload
  /** Returns the price of 1 satoshi */
  readonly realtimePrice: RealtimePricePayload
}

export type SubscriptionLnInvoicePaymentStatusArgs = {
  input: LnInvoicePaymentStatusInput
}

export type SubscriptionPriceArgs = {
  input: PriceInput
}

export type SubscriptionRealtimePriceArgs = {
  input: RealtimePriceInput
}

export type SuccessPayload = {
  readonly __typename: "SuccessPayload"
  readonly errors: ReadonlyArray<Error>
  readonly success?: Maybe<Scalars["Boolean"]>
}

/**
 * Give details about an individual transaction.
 * Galoy have a smart routing system which is automatically
 * settling intraledger when both the payer and payee use the same wallet
 * therefore it's possible the transactions is being initiated onchain
 * or with lightning but settled intraledger.
 */
export type Transaction = {
  readonly __typename: "Transaction"
  readonly createdAt: Scalars["Timestamp"]
  readonly date: Scalars["String"]
  readonly date_format: Scalars["String"]
  readonly date_nice_print: Scalars["String"]
  readonly direction: TxDirection
  readonly id: Scalars["ID"]
  /** From which protocol the payment has been initiated. */
  readonly initiationVia: InitiationVia
  readonly isReceive: Scalars["Boolean"]
  readonly memo?: Maybe<Scalars["Memo"]>
  /** Amount of the settlement currency sent or received. */
  readonly settlementAmount: Scalars["SignedAmount"]
  /** Wallet currency for transaction. */
  readonly settlementCurrency: WalletCurrency
  readonly settlementDisplayAmount: Scalars["SignedDisplayMajorAmount"]
  readonly settlementDisplayCurrency: Scalars["DisplayCurrency"]
  readonly settlementDisplayFee: Scalars["SignedDisplayMajorAmount"]
  readonly settlementFee: Scalars["SignedAmount"]
  /** Price in WALLETCURRENCY/SETTLEMENTUNIT at time of settlement. */
  readonly settlementPrice: PriceOfOneSettlementMinorUnitInDisplayMinorUnit
  /** To which protocol the payment has settled on. */
  readonly settlementVia: SettlementVia
  readonly status: TxStatus
  readonly text: Scalars["String"]
}

/** A connection to a list of items. */
export type TransactionConnection = {
  readonly __typename: "TransactionConnection"
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<TransactionEdge>>
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo
}

/** An edge in a connection. */
export type TransactionEdge = {
  readonly __typename: "TransactionEdge"
  /** A cursor for use in pagination */
  readonly cursor: Scalars["String"]
  /** The item at the end of the edge */
  readonly node: Transaction
}

export const TxDirection = {
  Receive: "RECEIVE",
  Send: "SEND",
} as const

export type TxDirection = (typeof TxDirection)[keyof typeof TxDirection]
export const TxNotificationType = {
  IntraLedgerPayment: "IntraLedgerPayment",
  IntraLedgerReceipt: "IntraLedgerReceipt",
  LnInvoicePaid: "LnInvoicePaid",
  OnchainPayment: "OnchainPayment",
  OnchainReceipt: "OnchainReceipt",
  OnchainReceiptPending: "OnchainReceiptPending",
} as const

export type TxNotificationType =
  (typeof TxNotificationType)[keyof typeof TxNotificationType]
export const TxStatus = {
  Failure: "FAILURE",
  Pending: "PENDING",
  Success: "SUCCESS",
} as const

export type TxStatus = (typeof TxStatus)[keyof typeof TxStatus]
export type UpgradePayload = {
  readonly __typename: "UpgradePayload"
  readonly authToken?: Maybe<Scalars["AuthToken"]>
  readonly errors: ReadonlyArray<Error>
  readonly success: Scalars["Boolean"]
}

/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWallet = Wallet & {
  readonly __typename: "UsdWallet"
  readonly accountId: Scalars["ID"]
  readonly balance: Scalars["SignedAmount"]
  readonly id: Scalars["ID"]
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars["SignedAmount"]
  readonly transactions?: Maybe<TransactionConnection>
  readonly transactionsByAddress?: Maybe<TransactionConnection>
  readonly walletCurrency: WalletCurrency
}

/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByAddressArgs = {
  address: Scalars["OnChainAddress"]
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

export type User = {
  readonly __typename: "User"
  /**
   * Get single contact details.
   * Can include the transactions associated with the contact.
   * @deprecated will be moved to Accounts
   */
  readonly contactByUsername: UserContact
  /**
   * Get full list of contacts.
   * Can include the transactions associated with each contact.
   * @deprecated will be moved to account
   */
  readonly contacts: ReadonlyArray<UserContact>
  readonly createdAt: Scalars["Timestamp"]
  readonly defaultAccount: Account
  /** Email address */
  readonly email?: Maybe<Email>
  readonly id: Scalars["ID"]
  /**
   * Preferred language for user.
   * When value is 'default' the intent is to use preferred language from OS settings.
   */
  readonly language: Scalars["Language"]
  /** Phone number with international calling code. */
  readonly phone?: Maybe<Scalars["Phone"]>
  /**
   * List the quiz questions the user may have completed.
   * @deprecated use Quiz from Account instead
   */
  readonly quizQuestions: ReadonlyArray<UserQuizQuestion>
  /** Whether TOTP is enabled for this user. */
  readonly totpEnabled: Scalars["Boolean"]
  /**
   * Optional immutable user friendly identifier.
   * @deprecated will be moved to @Handle in Account and Wallet
   */
  readonly username?: Maybe<Scalars["Username"]>
}

export type UserContactByUsernameArgs = {
  username: Scalars["Username"]
}

export type UserContact = {
  readonly __typename: "UserContact"
  /**
   * Alias the user can set for this contact.
   * Only the user can see the alias attached to their contact.
   */
  readonly alias?: Maybe<Scalars["ContactAlias"]>
  readonly id: Scalars["Username"]
  /** Paginated list of transactions sent to/from this contact. */
  readonly transactions?: Maybe<TransactionConnection>
  readonly transactionsCount: Scalars["Int"]
  /** Actual identifier of the contact. */
  readonly username: Scalars["Username"]
}

export type UserContactTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

export type UserContactUpdateAliasInput = {
  readonly alias: Scalars["ContactAlias"]
  readonly username: Scalars["Username"]
}

export type UserContactUpdateAliasPayload = {
  readonly __typename: "UserContactUpdateAliasPayload"
  readonly contact?: Maybe<UserContact>
  readonly errors: ReadonlyArray<Error>
}

export type UserEmailDeletePayload = {
  readonly __typename: "UserEmailDeletePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserEmailRegistrationInitiateInput = {
  readonly email: Scalars["EmailAddress"]
}

export type UserEmailRegistrationInitiatePayload = {
  readonly __typename: "UserEmailRegistrationInitiatePayload"
  readonly emailRegistrationId?: Maybe<Scalars["EmailRegistrationId"]>
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserEmailRegistrationValidateInput = {
  readonly code: Scalars["OneTimeAuthCode"]
  readonly emailRegistrationId: Scalars["EmailRegistrationId"]
}

export type UserEmailRegistrationValidatePayload = {
  readonly __typename: "UserEmailRegistrationValidatePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserLoginInput = {
  readonly code: Scalars["OneTimeAuthCode"]
  readonly phone: Scalars["Phone"]
}

export type UserLoginUpgradeInput = {
  readonly code: Scalars["OneTimeAuthCode"]
  readonly phone: Scalars["Phone"]
}

export type UserLogoutInput = {
  readonly deviceToken: Scalars["String"]
}

export type UserPhoneDeletePayload = {
  readonly __typename: "UserPhoneDeletePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserPhoneRegistrationInitiateInput = {
  readonly channel?: InputMaybe<PhoneCodeChannelType>
  readonly phone: Scalars["Phone"]
}

export type UserPhoneRegistrationValidateInput = {
  readonly code: Scalars["OneTimeAuthCode"]
  readonly phone: Scalars["Phone"]
}

export type UserPhoneRegistrationValidatePayload = {
  readonly __typename: "UserPhoneRegistrationValidatePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserQuizQuestion = {
  readonly __typename: "UserQuizQuestion"
  readonly completed: Scalars["Boolean"]
  readonly question: QuizQuestion
}

export type UserTotpDeleteInput = {
  readonly authToken: Scalars["AuthToken"]
}

export type UserTotpDeletePayload = {
  readonly __typename: "UserTotpDeletePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserTotpRegistrationInitiateInput = {
  readonly authToken: Scalars["AuthToken"]
}

export type UserTotpRegistrationInitiatePayload = {
  readonly __typename: "UserTotpRegistrationInitiatePayload"
  readonly errors: ReadonlyArray<Error>
  readonly totpRegistrationId?: Maybe<Scalars["TotpRegistrationId"]>
  readonly totpSecret?: Maybe<Scalars["TotpSecret"]>
}

export type UserTotpRegistrationValidateInput = {
  readonly authToken: Scalars["AuthToken"]
  readonly totpCode: Scalars["TotpCode"]
  readonly totpRegistrationId: Scalars["TotpRegistrationId"]
}

export type UserTotpRegistrationValidatePayload = {
  readonly __typename: "UserTotpRegistrationValidatePayload"
  readonly errors: ReadonlyArray<Error>
  readonly me?: Maybe<User>
}

export type UserUpdate =
  | IntraLedgerUpdate
  | LnUpdate
  | OnChainUpdate
  | Price
  | RealtimePrice

export type UserUpdateLanguageInput = {
  readonly language: Scalars["Language"]
}

export type UserUpdateLanguagePayload = {
  readonly __typename: "UserUpdateLanguagePayload"
  readonly errors: ReadonlyArray<Error>
  readonly user?: Maybe<User>
}

export type UserUpdateUsernameInput = {
  readonly username: Scalars["Username"]
}

export type UserUpdateUsernamePayload = {
  readonly __typename: "UserUpdateUsernamePayload"
  readonly errors: ReadonlyArray<Error>
  readonly user?: Maybe<User>
}

/** A generic wallet which stores value in one of our supported currencies. */
export type Wallet = {
  readonly accountId: Scalars["ID"]
  readonly balance: Scalars["SignedAmount"]
  readonly id: Scalars["ID"]
  readonly pendingIncomingBalance: Scalars["SignedAmount"]
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactions?: Maybe<TransactionConnection>
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactionsByAddress?: Maybe<TransactionConnection>
  readonly walletCurrency: WalletCurrency
}

/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsArgs = {
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByAddressArgs = {
  address: Scalars["OnChainAddress"]
  after?: InputMaybe<Scalars["String"]>
  before?: InputMaybe<Scalars["String"]>
  first?: InputMaybe<Scalars["Int"]>
  last?: InputMaybe<Scalars["Int"]>
}

export const WalletCurrency = {
  Btc: "BTC",
  Usd: "USD",
} as const

export type WalletCurrency = (typeof WalletCurrency)[keyof typeof WalletCurrency]
export type WelcomeLeaderboardInput = {
  readonly range: WelcomeRange
}

export type WelcomeProfile = {
  readonly __typename: "WelcomeProfile"
  readonly allTimePoints: Scalars["Int"]
  readonly allTimeRank: Scalars["Int"]
  readonly innerCircleAllTimeCount: Scalars["Int"]
  readonly innerCircleThisMonthCount: Scalars["Int"]
  readonly leaderboardName?: Maybe<Scalars["LeaderboardName"]>
  readonly outerCircleAllTimeCount: Scalars["Int"]
  readonly outerCircleThisMonthCount: Scalars["Int"]
  readonly thisMonthPoints: Scalars["Int"]
  readonly thisMonthRank: Scalars["Int"]
}

export const WelcomeRange = {
  AllTime: "AllTime",
  ThisMonth: "ThisMonth",
} as const

export type WelcomeRange = (typeof WelcomeRange)[keyof typeof WelcomeRange]
export type MobileUpdateQueryVariables = Exact<{ [key: string]: never }>

export type MobileUpdateQuery = {
  readonly __typename: "Query"
  readonly mobileVersions?: ReadonlyArray<{
    readonly __typename: "MobileVersions"
    readonly platform: string
    readonly currentSupported: number
    readonly minSupported: number
  } | null> | null
}

export type BalanceHeaderQueryVariables = Exact<{ [key: string]: never }>

export type BalanceHeaderQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type BtcPriceListQueryVariables = Exact<{
  range: PriceGraphRange
}>

export type BtcPriceListQuery = {
  readonly __typename: "Query"
  readonly btcPriceList?: ReadonlyArray<{
    readonly __typename: "PricePoint"
    readonly timestamp: number
    readonly price: {
      readonly __typename: "Price"
      readonly base: number
      readonly offset: number
      readonly currencyUnit: string
    }
  } | null> | null
}

export type SetDefaultAccountModalQueryVariables = Exact<{ [key: string]: never }>

export type SetDefaultAccountModalQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly defaultWalletId: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type UserUpdateUsernameMutationVariables = Exact<{
  input: UserUpdateUsernameInput
}>

export type UserUpdateUsernameMutation = {
  readonly __typename: "Mutation"
  readonly userUpdateUsername: {
    readonly __typename: "UserUpdateUsernamePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly code?: string | null
    }>
    readonly user?: {
      readonly __typename: "User"
      readonly id: string
      readonly username?: string | null
    } | null
  }
}

export type MyUserIdQueryVariables = Exact<{ [key: string]: never }>

export type MyUserIdQuery = {
  readonly __typename: "Query"
  readonly me?: { readonly __typename: "User"; readonly id: string } | null
}

export type WalletOverviewScreenQueryVariables = Exact<{ [key: string]: never }>

export type WalletOverviewScreenQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type AnalyticsQueryVariables = Exact<{ [key: string]: never }>

export type AnalyticsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly username?: string | null
    readonly id: string
  } | null
  readonly globals?: { readonly __typename: "Globals"; readonly network: Network } | null
}

export type MyWalletsFragment = {
  readonly __typename: "ConsumerAccount"
  readonly wallets: ReadonlyArray<
    | {
        readonly __typename: "BTCWallet"
        readonly id: string
        readonly balance: number
        readonly walletCurrency: WalletCurrency
      }
    | {
        readonly __typename: "UsdWallet"
        readonly id: string
        readonly balance: number
        readonly walletCurrency: WalletCurrency
      }
  >
}

export type RealtimePriceQueryVariables = Exact<{ [key: string]: never }>

export type RealtimePriceQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly realtimePrice: {
        readonly __typename: "RealtimePrice"
        readonly denominatorCurrency: string
        readonly id: string
        readonly timestamp: number
        readonly btcSatPrice: {
          readonly __typename: "PriceOfOneSatInMinorUnit"
          readonly base: number
          readonly offset: number
        }
        readonly usdCentPrice: {
          readonly __typename: "PriceOfOneUsdCentInMinorUnit"
          readonly base: number
          readonly offset: number
        }
      }
    }
  } | null
}

export type HideBalanceQueryVariables = Exact<{ [key: string]: never }>

export type HideBalanceQuery = {
  readonly __typename: "Query"
  readonly hideBalance: boolean
}

export type HiddenBalanceToolTipQueryVariables = Exact<{ [key: string]: never }>

export type HiddenBalanceToolTipQuery = {
  readonly __typename: "Query"
  readonly hiddenBalanceToolTip: boolean
}

export type BetaQueryVariables = Exact<{ [key: string]: never }>

export type BetaQuery = { readonly __typename: "Query"; readonly beta: boolean }

export type ColorSchemeQueryVariables = Exact<{ [key: string]: never }>

export type ColorSchemeQuery = {
  readonly __typename: "Query"
  readonly colorScheme: string
}

export type FeedbackModalShownQueryVariables = Exact<{ [key: string]: never }>

export type FeedbackModalShownQuery = {
  readonly __typename: "Query"
  readonly feedbackModalShown: boolean
}

export type HasPromptedSetDefaultAccountQueryVariables = Exact<{ [key: string]: never }>

export type HasPromptedSetDefaultAccountQuery = {
  readonly __typename: "Query"
  readonly hasPromptedSetDefaultAccount: boolean
}

export type TransactionFragment = {
  readonly __typename: "Transaction"
  readonly id: string
  readonly status: TxStatus
  readonly direction: TxDirection
  readonly memo?: string | null
  readonly createdAt: number
  readonly settlementAmount: number
  readonly settlementFee: number
  readonly settlementDisplayFee: string
  readonly settlementCurrency: WalletCurrency
  readonly settlementDisplayAmount: string
  readonly settlementDisplayCurrency: string
  readonly settlementPrice: {
    readonly __typename: "PriceOfOneSettlementMinorUnitInDisplayMinorUnit"
    readonly base: number
    readonly offset: number
    readonly currencyUnit: string
    readonly formattedAmount: string
  }
  readonly initiationVia:
    | {
        readonly __typename: "InitiationViaIntraLedger"
        readonly counterPartyWalletId?: string | null
        readonly counterPartyUsername?: string | null
      }
    | { readonly __typename: "InitiationViaLn"; readonly paymentHash: string }
    | { readonly __typename: "InitiationViaOnChain"; readonly address: string }
  readonly settlementVia:
    | {
        readonly __typename: "SettlementViaIntraLedger"
        readonly counterPartyWalletId?: string | null
        readonly counterPartyUsername?: string | null
      }
    | { readonly __typename: "SettlementViaLn"; readonly paymentSecret?: string | null }
    | {
        readonly __typename: "SettlementViaOnChain"
        readonly transactionHash?: string | null
      }
}

export type TransactionListFragment = {
  readonly __typename: "TransactionConnection"
  readonly pageInfo: {
    readonly __typename: "PageInfo"
    readonly hasNextPage: boolean
    readonly hasPreviousPage: boolean
    readonly startCursor?: string | null
    readonly endCursor?: string | null
  }
  readonly edges?: ReadonlyArray<{
    readonly __typename: "TransactionEdge"
    readonly cursor: string
    readonly node: {
      readonly __typename: "Transaction"
      readonly id: string
      readonly status: TxStatus
      readonly direction: TxDirection
      readonly memo?: string | null
      readonly createdAt: number
      readonly settlementAmount: number
      readonly settlementFee: number
      readonly settlementDisplayFee: string
      readonly settlementCurrency: WalletCurrency
      readonly settlementDisplayAmount: string
      readonly settlementDisplayCurrency: string
      readonly settlementPrice: {
        readonly __typename: "PriceOfOneSettlementMinorUnitInDisplayMinorUnit"
        readonly base: number
        readonly offset: number
        readonly currencyUnit: string
        readonly formattedAmount: string
      }
      readonly initiationVia:
        | {
            readonly __typename: "InitiationViaIntraLedger"
            readonly counterPartyWalletId?: string | null
            readonly counterPartyUsername?: string | null
          }
        | { readonly __typename: "InitiationViaLn"; readonly paymentHash: string }
        | { readonly __typename: "InitiationViaOnChain"; readonly address: string }
      readonly settlementVia:
        | {
            readonly __typename: "SettlementViaIntraLedger"
            readonly counterPartyWalletId?: string | null
            readonly counterPartyUsername?: string | null
          }
        | {
            readonly __typename: "SettlementViaLn"
            readonly paymentSecret?: string | null
          }
        | {
            readonly __typename: "SettlementViaOnChain"
            readonly transactionHash?: string | null
          }
    }
  }> | null
}

export type NetworkQueryVariables = Exact<{ [key: string]: never }>

export type NetworkQuery = {
  readonly __typename: "Query"
  readonly globals?: { readonly __typename: "Globals"; readonly network: Network } | null
}

export type LevelQueryVariables = Exact<{ [key: string]: never }>

export type LevelQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly level: AccountLevel
    }
  } | null
}

export type DisplayCurrencyQueryVariables = Exact<{ [key: string]: never }>

export type DisplayCurrencyQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly displayCurrency: string
    }
  } | null
}

export type CurrencyListQueryVariables = Exact<{ [key: string]: never }>

export type CurrencyListQuery = {
  readonly __typename: "Query"
  readonly currencyList: ReadonlyArray<{
    readonly __typename: "Currency"
    readonly id: string
    readonly flag: string
    readonly name: string
    readonly symbol: string
    readonly fractionDigits: number
  }>
}

export type CaptchaCreateChallengeMutationVariables = Exact<{ [key: string]: never }>

export type CaptchaCreateChallengeMutation = {
  readonly __typename: "Mutation"
  readonly captchaCreateChallenge: {
    readonly __typename: "CaptchaCreateChallengePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly result?: {
      readonly __typename: "CaptchaCreateChallengeResult"
      readonly id: string
      readonly challengeCode: string
      readonly newCaptcha: boolean
      readonly failbackMode: boolean
    } | null
  }
}

export type TransactionListForContactQueryVariables = Exact<{
  username: Scalars["Username"]
  first?: InputMaybe<Scalars["Int"]>
  after?: InputMaybe<Scalars["String"]>
  last?: InputMaybe<Scalars["Int"]>
  before?: InputMaybe<Scalars["String"]>
}>

export type TransactionListForContactQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly contactByUsername: {
      readonly __typename: "UserContact"
      readonly transactions?: {
        readonly __typename: "TransactionConnection"
        readonly pageInfo: {
          readonly __typename: "PageInfo"
          readonly hasNextPage: boolean
          readonly hasPreviousPage: boolean
          readonly startCursor?: string | null
          readonly endCursor?: string | null
        }
        readonly edges?: ReadonlyArray<{
          readonly __typename: "TransactionEdge"
          readonly cursor: string
          readonly node: {
            readonly __typename: "Transaction"
            readonly id: string
            readonly status: TxStatus
            readonly direction: TxDirection
            readonly memo?: string | null
            readonly createdAt: number
            readonly settlementAmount: number
            readonly settlementFee: number
            readonly settlementDisplayFee: string
            readonly settlementCurrency: WalletCurrency
            readonly settlementDisplayAmount: string
            readonly settlementDisplayCurrency: string
            readonly settlementPrice: {
              readonly __typename: "PriceOfOneSettlementMinorUnitInDisplayMinorUnit"
              readonly base: number
              readonly offset: number
              readonly currencyUnit: string
              readonly formattedAmount: string
            }
            readonly initiationVia:
              | {
                  readonly __typename: "InitiationViaIntraLedger"
                  readonly counterPartyWalletId?: string | null
                  readonly counterPartyUsername?: string | null
                }
              | { readonly __typename: "InitiationViaLn"; readonly paymentHash: string }
              | { readonly __typename: "InitiationViaOnChain"; readonly address: string }
            readonly settlementVia:
              | {
                  readonly __typename: "SettlementViaIntraLedger"
                  readonly counterPartyWalletId?: string | null
                  readonly counterPartyUsername?: string | null
                }
              | {
                  readonly __typename: "SettlementViaLn"
                  readonly paymentSecret?: string | null
                }
              | {
                  readonly __typename: "SettlementViaOnChain"
                  readonly transactionHash?: string | null
                }
          }
        }> | null
      } | null
    }
  } | null
}

export type ContactsQueryVariables = Exact<{ [key: string]: never }>

export type ContactsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly contacts: ReadonlyArray<{
      readonly __typename: "UserContact"
      readonly id: string
      readonly username: string
      readonly alias?: string | null
      readonly transactionsCount: number
    }>
  } | null
}

export type UserContactUpdateAliasMutationVariables = Exact<{
  input: UserContactUpdateAliasInput
}>

export type UserContactUpdateAliasMutation = {
  readonly __typename: "Mutation"
  readonly userContactUpdateAlias: {
    readonly __typename: "UserContactUpdateAliasPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly contact?: {
      readonly __typename: "UserContact"
      readonly alias?: string | null
      readonly id: string
    } | null
  }
}

export type UserLogoutMutationVariables = Exact<{
  input: UserLogoutInput
}>

export type UserLogoutMutation = {
  readonly __typename: "Mutation"
  readonly userLogout: {
    readonly __typename: "SuccessPayload"
    readonly success?: boolean | null
  }
}

export type ConversionScreenQueryVariables = Exact<{ [key: string]: never }>

export type ConversionScreenQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type QuizSatsQueryVariables = Exact<{ [key: string]: never }>

export type QuizSatsQuery = {
  readonly __typename: "Query"
  readonly quizQuestions?: ReadonlyArray<{
    readonly __typename: "QuizQuestion"
    readonly id: string
    readonly earnAmount: number
  } | null> | null
}

export type MyQuizQuestionsQueryVariables = Exact<{ [key: string]: never }>

export type MyQuizQuestionsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly quiz: ReadonlyArray<{
        readonly __typename: "Quiz"
        readonly id: string
        readonly amount: number
        readonly completed: boolean
      }>
    }
  } | null
}

export type QuizCompletedMutationVariables = Exact<{
  input: QuizCompletedInput
}>

export type QuizCompletedMutation = {
  readonly __typename: "Mutation"
  readonly quizCompleted: {
    readonly __typename: "QuizCompletedPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly quiz?: {
      readonly __typename: "Quiz"
      readonly id: string
      readonly completed: boolean
    } | null
  }
}

export type UserEmailRegistrationInitiateMutationVariables = Exact<{
  input: UserEmailRegistrationInitiateInput
}>

export type UserEmailRegistrationInitiateMutation = {
  readonly __typename: "Mutation"
  readonly userEmailRegistrationInitiate: {
    readonly __typename: "UserEmailRegistrationInitiatePayload"
    readonly emailRegistrationId?: string | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly me?: {
      readonly __typename: "User"
      readonly id: string
      readonly email?: {
        readonly __typename: "Email"
        readonly address?: string | null
        readonly verified?: boolean | null
      } | null
    } | null
  }
}

export type UserEmailRegistrationValidateMutationVariables = Exact<{
  input: UserEmailRegistrationValidateInput
}>

export type UserEmailRegistrationValidateMutation = {
  readonly __typename: "Mutation"
  readonly userEmailRegistrationValidate: {
    readonly __typename: "UserEmailRegistrationValidatePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly me?: {
      readonly __typename: "User"
      readonly id: string
      readonly email?: {
        readonly __typename: "Email"
        readonly address?: string | null
        readonly verified?: boolean | null
      } | null
    } | null
  }
}

export type AddressScreenQueryVariables = Exact<{ [key: string]: never }>

export type AddressScreenQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly username?: string | null
  } | null
}

export type HomeAuthedQueryVariables = Exact<{ [key: string]: never }>

export type HomeAuthedQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly language: string
    readonly username?: string | null
    readonly phone?: string | null
    readonly email?: {
      readonly __typename: "Email"
      readonly address?: string | null
      readonly verified?: boolean | null
    } | null
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly level: AccountLevel
      readonly defaultWalletId: string
      readonly transactions?: {
        readonly __typename: "TransactionConnection"
        readonly pageInfo: {
          readonly __typename: "PageInfo"
          readonly hasNextPage: boolean
          readonly hasPreviousPage: boolean
          readonly startCursor?: string | null
          readonly endCursor?: string | null
        }
        readonly edges?: ReadonlyArray<{
          readonly __typename: "TransactionEdge"
          readonly cursor: string
          readonly node: {
            readonly __typename: "Transaction"
            readonly id: string
            readonly status: TxStatus
            readonly direction: TxDirection
            readonly memo?: string | null
            readonly createdAt: number
            readonly settlementAmount: number
            readonly settlementFee: number
            readonly settlementDisplayFee: string
            readonly settlementCurrency: WalletCurrency
            readonly settlementDisplayAmount: string
            readonly settlementDisplayCurrency: string
            readonly settlementPrice: {
              readonly __typename: "PriceOfOneSettlementMinorUnitInDisplayMinorUnit"
              readonly base: number
              readonly offset: number
              readonly currencyUnit: string
              readonly formattedAmount: string
            }
            readonly initiationVia:
              | {
                  readonly __typename: "InitiationViaIntraLedger"
                  readonly counterPartyWalletId?: string | null
                  readonly counterPartyUsername?: string | null
                }
              | { readonly __typename: "InitiationViaLn"; readonly paymentHash: string }
              | { readonly __typename: "InitiationViaOnChain"; readonly address: string }
            readonly settlementVia:
              | {
                  readonly __typename: "SettlementViaIntraLedger"
                  readonly counterPartyWalletId?: string | null
                  readonly counterPartyUsername?: string | null
                }
              | {
                  readonly __typename: "SettlementViaLn"
                  readonly paymentSecret?: string | null
                }
              | {
                  readonly __typename: "SettlementViaOnChain"
                  readonly transactionHash?: string | null
                }
          }
        }> | null
      } | null
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type HomeUnauthedQueryVariables = Exact<{ [key: string]: never }>

export type HomeUnauthedQuery = {
  readonly __typename: "Query"
  readonly globals?: { readonly __typename: "Globals"; readonly network: Network } | null
  readonly currencyList: ReadonlyArray<{
    readonly __typename: "Currency"
    readonly id: string
    readonly flag: string
    readonly name: string
    readonly symbol: string
    readonly fractionDigits: number
  }>
}

export type BulletinsQueryVariables = Exact<{
  first: Scalars["Int"]
  after?: InputMaybe<Scalars["String"]>
}>

export type BulletinsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly unacknowledgedStatefulNotificationsWithBulletinEnabled: {
      readonly __typename: "StatefulNotificationConnection"
      readonly pageInfo: {
        readonly __typename: "PageInfo"
        readonly endCursor?: string | null
        readonly hasNextPage: boolean
        readonly hasPreviousPage: boolean
        readonly startCursor?: string | null
      }
      readonly edges: ReadonlyArray<{
        readonly __typename: "StatefulNotificationEdge"
        readonly cursor: string
        readonly node: {
          readonly __typename: "StatefulNotification"
          readonly id: string
          readonly title: string
          readonly body: string
          readonly createdAt: number
          readonly acknowledgedAt?: number | null
          readonly bulletinEnabled: boolean
          readonly icon?: Icon | null
          readonly action?:
            | { readonly __typename: "OpenDeepLinkAction"; readonly deepLink: string }
            | { readonly __typename: "OpenExternalLinkAction"; readonly url: string }
            | null
        }
      }>
    }
  } | null
}

export type BusinessMapMarkersQueryVariables = Exact<{ [key: string]: never }>

export type BusinessMapMarkersQuery = {
  readonly __typename: "Query"
  readonly businessMapMarkers?: ReadonlyArray<{
    readonly __typename: "MapMarker"
    readonly username?: string | null
    readonly mapInfo: {
      readonly __typename: "MapInfo"
      readonly title: string
      readonly coordinates: {
        readonly __typename: "Coordinates"
        readonly longitude: number
        readonly latitude: number
      }
    }
  } | null> | null
}

export type StatefulNotificationsQueryVariables = Exact<{
  after?: InputMaybe<Scalars["String"]>
}>

export type StatefulNotificationsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly statefulNotificationsWithoutBulletinEnabled: {
      readonly __typename: "StatefulNotificationConnection"
      readonly nodes: ReadonlyArray<{
        readonly __typename: "StatefulNotification"
        readonly id: string
        readonly title: string
        readonly body: string
        readonly createdAt: number
        readonly acknowledgedAt?: number | null
        readonly bulletinEnabled: boolean
        readonly icon?: Icon | null
        readonly action?:
          | { readonly __typename: "OpenDeepLinkAction"; readonly deepLink: string }
          | { readonly __typename: "OpenExternalLinkAction"; readonly url: string }
          | null
      }>
      readonly pageInfo: {
        readonly __typename: "PageInfo"
        readonly endCursor?: string | null
        readonly hasNextPage: boolean
        readonly hasPreviousPage: boolean
        readonly startCursor?: string | null
      }
    }
  } | null
}

export type StatefulNotificationAcknowledgeMutationVariables = Exact<{
  input: StatefulNotificationAcknowledgeInput
}>

export type StatefulNotificationAcknowledgeMutation = {
  readonly __typename: "Mutation"
  readonly statefulNotificationAcknowledge: {
    readonly __typename: "StatefulNotificationAcknowledgePayload"
    readonly notification: {
      readonly __typename: "StatefulNotification"
      readonly acknowledgedAt?: number | null
    }
  }
}

export type UserLoginMutationVariables = Exact<{
  input: UserLoginInput
}>

export type UserLoginMutation = {
  readonly __typename: "Mutation"
  readonly userLogin: {
    readonly __typename: "AuthTokenPayload"
    readonly authToken?: string | null
    readonly totpRequired?: boolean | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
      readonly code?: string | null
    }>
  }
}

export type UserLoginUpgradeMutationVariables = Exact<{
  input: UserLoginUpgradeInput
}>

export type UserLoginUpgradeMutation = {
  readonly __typename: "Mutation"
  readonly userLoginUpgrade: {
    readonly __typename: "UpgradePayload"
    readonly success: boolean
    readonly authToken?: string | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
      readonly code?: string | null
    }>
  }
}

export type UserPhoneRegistrationValidateMutationVariables = Exact<{
  input: UserPhoneRegistrationValidateInput
}>

export type UserPhoneRegistrationValidateMutation = {
  readonly __typename: "Mutation"
  readonly userPhoneRegistrationValidate: {
    readonly __typename: "UserPhoneRegistrationValidatePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
      readonly code?: string | null
    }>
    readonly me?: {
      readonly __typename: "User"
      readonly id: string
      readonly phone?: string | null
      readonly email?: {
        readonly __typename: "Email"
        readonly address?: string | null
        readonly verified?: boolean | null
      } | null
    } | null
  }
}

export type CaptchaRequestAuthCodeMutationVariables = Exact<{
  input: CaptchaRequestAuthCodeInput
}>

export type CaptchaRequestAuthCodeMutation = {
  readonly __typename: "Mutation"
  readonly captchaRequestAuthCode: {
    readonly __typename: "SuccessPayload"
    readonly success?: boolean | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
      readonly code?: string | null
    }>
  }
}

export type SupportedCountriesQueryVariables = Exact<{ [key: string]: never }>

export type SupportedCountriesQuery = {
  readonly __typename: "Query"
  readonly globals?: {
    readonly __typename: "Globals"
    readonly supportedCountries: ReadonlyArray<{
      readonly __typename: "Country"
      readonly id: string
      readonly supportedAuthChannels: ReadonlyArray<PhoneCodeChannelType>
    }>
  } | null
}

export type UserPhoneRegistrationInitiateMutationVariables = Exact<{
  input: UserPhoneRegistrationInitiateInput
}>

export type UserPhoneRegistrationInitiateMutation = {
  readonly __typename: "Mutation"
  readonly userPhoneRegistrationInitiate: {
    readonly __typename: "SuccessPayload"
    readonly success?: boolean | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type MyLnUpdatesSubscriptionVariables = Exact<{ [key: string]: never }>

export type MyLnUpdatesSubscription = {
  readonly __typename: "Subscription"
  readonly myUpdates: {
    readonly __typename: "MyUpdatesPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly update?:
      | { readonly __typename: "IntraLedgerUpdate" }
      | {
          readonly __typename: "LnUpdate"
          readonly paymentHash: string
          readonly status: InvoicePaymentStatus
        }
      | { readonly __typename: "OnChainUpdate" }
      | { readonly __typename: "Price" }
      | { readonly __typename: "RealtimePrice" }
      | null
  }
}

export type PaymentRequestQueryVariables = Exact<{ [key: string]: never }>

export type PaymentRequestQuery = {
  readonly __typename: "Query"
  readonly globals?: {
    readonly __typename: "Globals"
    readonly network: Network
    readonly feesInformation: {
      readonly __typename: "FeesInformation"
      readonly deposit: {
        readonly __typename: "DepositFeesInformation"
        readonly minBankFee: string
        readonly minBankFeeThreshold: string
      }
    }
  } | null
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly username?: string | null
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly defaultWalletId: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type LnNoAmountInvoiceCreateMutationVariables = Exact<{
  input: LnNoAmountInvoiceCreateInput
}>

export type LnNoAmountInvoiceCreateMutation = {
  readonly __typename: "Mutation"
  readonly lnNoAmountInvoiceCreate: {
    readonly __typename: "LnNoAmountInvoicePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly invoice?: {
      readonly __typename: "LnNoAmountInvoice"
      readonly paymentHash: string
      readonly paymentRequest: string
      readonly paymentSecret: string
    } | null
  }
}

export type LnInvoiceCreateMutationVariables = Exact<{
  input: LnInvoiceCreateInput
}>

export type LnInvoiceCreateMutation = {
  readonly __typename: "Mutation"
  readonly lnInvoiceCreate: {
    readonly __typename: "LnInvoicePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly invoice?: {
      readonly __typename: "LnInvoice"
      readonly paymentHash: string
      readonly paymentRequest: string
      readonly paymentSecret: string
      readonly satoshis?: number | null
    } | null
  }
}

export type OnChainAddressCurrentMutationVariables = Exact<{
  input: OnChainAddressCurrentInput
}>

export type OnChainAddressCurrentMutation = {
  readonly __typename: "Mutation"
  readonly onChainAddressCurrent: {
    readonly __typename: "OnChainAddressPayload"
    readonly address?: string | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnUsdInvoiceCreateMutationVariables = Exact<{
  input: LnUsdInvoiceCreateInput
}>

export type LnUsdInvoiceCreateMutation = {
  readonly __typename: "Mutation"
  readonly lnUsdInvoiceCreate: {
    readonly __typename: "LnInvoicePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly invoice?: {
      readonly __typename: "LnInvoice"
      readonly paymentHash: string
      readonly paymentRequest: string
      readonly paymentSecret: string
      readonly satoshis?: number | null
    } | null
  }
}

export type ScanningQrCodeScreenQueryVariables = Exact<{ [key: string]: never }>

export type ScanningQrCodeScreenQuery = {
  readonly __typename: "Query"
  readonly globals?: { readonly __typename: "Globals"; readonly network: Network } | null
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly wallets: ReadonlyArray<
        | { readonly __typename: "BTCWallet"; readonly id: string }
        | { readonly __typename: "UsdWallet"; readonly id: string }
      >
    }
    readonly contacts: ReadonlyArray<{
      readonly __typename: "UserContact"
      readonly id: string
      readonly username: string
    }>
  } | null
}

export type SendBitcoinConfirmationScreenQueryVariables = Exact<{ [key: string]: never }>

export type SendBitcoinConfirmationScreenQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type SendBitcoinDestinationQueryVariables = Exact<{ [key: string]: never }>

export type SendBitcoinDestinationQuery = {
  readonly __typename: "Query"
  readonly globals?: { readonly __typename: "Globals"; readonly network: Network } | null
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly wallets: ReadonlyArray<
        | { readonly __typename: "BTCWallet"; readonly id: string }
        | { readonly __typename: "UsdWallet"; readonly id: string }
      >
    }
    readonly contacts: ReadonlyArray<{
      readonly __typename: "UserContact"
      readonly id: string
      readonly username: string
    }>
  } | null
}

export type AccountDefaultWalletQueryVariables = Exact<{
  username: Scalars["Username"]
}>

export type AccountDefaultWalletQuery = {
  readonly __typename: "Query"
  readonly accountDefaultWallet: {
    readonly __typename: "PublicWallet"
    readonly id: string
    readonly walletCurrency: string
    readonly lnurlp: string
  }
}

export type SendBitcoinDetailsScreenQueryVariables = Exact<{ [key: string]: never }>

export type SendBitcoinDetailsScreenQuery = {
  readonly __typename: "Query"
  readonly globals?: { readonly __typename: "Globals"; readonly network: Network } | null
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly defaultWalletId: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly walletCurrency: WalletCurrency
            readonly balance: number
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly walletCurrency: WalletCurrency
            readonly balance: number
          }
      >
    }
  } | null
}

export type SendBitcoinWithdrawalLimitsQueryVariables = Exact<{ [key: string]: never }>

export type SendBitcoinWithdrawalLimitsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly limits: {
        readonly __typename: "AccountLimits"
        readonly withdrawal: ReadonlyArray<{
          readonly __typename: "OneDayAccountLimit"
          readonly totalLimit: number
          readonly remainingLimit?: number | null
          readonly interval?: number | null
        }>
      }
    }
  } | null
}

export type SendBitcoinInternalLimitsQueryVariables = Exact<{ [key: string]: never }>

export type SendBitcoinInternalLimitsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly limits: {
        readonly __typename: "AccountLimits"
        readonly internalSend: ReadonlyArray<{
          readonly __typename: "OneDayAccountLimit"
          readonly totalLimit: number
          readonly remainingLimit?: number | null
          readonly interval?: number | null
        }>
      }
    }
  } | null
}

export type FeedbackSubmitMutationVariables = Exact<{
  input: FeedbackSubmitInput
}>

export type FeedbackSubmitMutation = {
  readonly __typename: "Mutation"
  readonly feedbackSubmit: {
    readonly __typename: "SuccessPayload"
    readonly success?: boolean | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnNoAmountInvoiceFeeProbeMutationVariables = Exact<{
  input: LnNoAmountInvoiceFeeProbeInput
}>

export type LnNoAmountInvoiceFeeProbeMutation = {
  readonly __typename: "Mutation"
  readonly lnNoAmountInvoiceFeeProbe: {
    readonly __typename: "SatAmountPayload"
    readonly amount?: number | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnInvoiceFeeProbeMutationVariables = Exact<{
  input: LnInvoiceFeeProbeInput
}>

export type LnInvoiceFeeProbeMutation = {
  readonly __typename: "Mutation"
  readonly lnInvoiceFeeProbe: {
    readonly __typename: "SatAmountPayload"
    readonly amount?: number | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnUsdInvoiceFeeProbeMutationVariables = Exact<{
  input: LnUsdInvoiceFeeProbeInput
}>

export type LnUsdInvoiceFeeProbeMutation = {
  readonly __typename: "Mutation"
  readonly lnUsdInvoiceFeeProbe: {
    readonly __typename: "SatAmountPayload"
    readonly amount?: number | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnNoAmountUsdInvoiceFeeProbeMutationVariables = Exact<{
  input: LnNoAmountUsdInvoiceFeeProbeInput
}>

export type LnNoAmountUsdInvoiceFeeProbeMutation = {
  readonly __typename: "Mutation"
  readonly lnNoAmountUsdInvoiceFeeProbe: {
    readonly __typename: "CentAmountPayload"
    readonly amount?: number | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type OnChainTxFeeQueryVariables = Exact<{
  walletId: Scalars["WalletId"]
  address: Scalars["OnChainAddress"]
  amount: Scalars["SatAmount"]
}>

export type OnChainTxFeeQuery = {
  readonly __typename: "Query"
  readonly onChainTxFee: { readonly __typename: "OnChainTxFee"; readonly amount: number }
}

export type OnChainUsdTxFeeQueryVariables = Exact<{
  walletId: Scalars["WalletId"]
  address: Scalars["OnChainAddress"]
  amount: Scalars["CentAmount"]
}>

export type OnChainUsdTxFeeQuery = {
  readonly __typename: "Query"
  readonly onChainUsdTxFee: {
    readonly __typename: "OnChainUsdTxFee"
    readonly amount: number
  }
}

export type OnChainUsdTxFeeAsBtcDenominatedQueryVariables = Exact<{
  walletId: Scalars["WalletId"]
  address: Scalars["OnChainAddress"]
  amount: Scalars["SatAmount"]
}>

export type OnChainUsdTxFeeAsBtcDenominatedQuery = {
  readonly __typename: "Query"
  readonly onChainUsdTxFeeAsBtcDenominated: {
    readonly __typename: "OnChainUsdTxFee"
    readonly amount: number
  }
}

export type IntraLedgerPaymentSendMutationVariables = Exact<{
  input: IntraLedgerPaymentSendInput
}>

export type IntraLedgerPaymentSendMutation = {
  readonly __typename: "Mutation"
  readonly intraLedgerPaymentSend: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type IntraLedgerUsdPaymentSendMutationVariables = Exact<{
  input: IntraLedgerUsdPaymentSendInput
}>

export type IntraLedgerUsdPaymentSendMutation = {
  readonly __typename: "Mutation"
  readonly intraLedgerUsdPaymentSend: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnNoAmountInvoicePaymentSendMutationVariables = Exact<{
  input: LnNoAmountInvoicePaymentInput
}>

export type LnNoAmountInvoicePaymentSendMutation = {
  readonly __typename: "Mutation"
  readonly lnNoAmountInvoicePaymentSend: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnInvoicePaymentSendMutationVariables = Exact<{
  input: LnInvoicePaymentInput
}>

export type LnInvoicePaymentSendMutation = {
  readonly __typename: "Mutation"
  readonly lnInvoicePaymentSend: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type LnNoAmountUsdInvoicePaymentSendMutationVariables = Exact<{
  input: LnNoAmountUsdInvoicePaymentInput
}>

export type LnNoAmountUsdInvoicePaymentSendMutation = {
  readonly __typename: "Mutation"
  readonly lnNoAmountUsdInvoicePaymentSend: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type OnChainPaymentSendMutationVariables = Exact<{
  input: OnChainPaymentSendInput
}>

export type OnChainPaymentSendMutation = {
  readonly __typename: "Mutation"
  readonly onChainPaymentSend: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type OnChainPaymentSendAllMutationVariables = Exact<{
  input: OnChainPaymentSendAllInput
}>

export type OnChainPaymentSendAllMutation = {
  readonly __typename: "Mutation"
  readonly onChainPaymentSendAll: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type OnChainUsdPaymentSendMutationVariables = Exact<{
  input: OnChainUsdPaymentSendInput
}>

export type OnChainUsdPaymentSendMutation = {
  readonly __typename: "Mutation"
  readonly onChainUsdPaymentSend: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type OnChainUsdPaymentSendAsBtcDenominatedMutationVariables = Exact<{
  input: OnChainUsdPaymentSendAsBtcDenominatedInput
}>

export type OnChainUsdPaymentSendAsBtcDenominatedMutation = {
  readonly __typename: "Mutation"
  readonly onChainUsdPaymentSendAsBtcDenominated: {
    readonly __typename: "PaymentSendPayload"
    readonly status?: PaymentSendResult | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type AccountScreenQueryVariables = Exact<{ [key: string]: never }>

export type AccountScreenQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly phone?: string | null
    readonly totpEnabled: boolean
    readonly email?: {
      readonly __typename: "Email"
      readonly address?: string | null
      readonly verified?: boolean | null
    } | null
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly level: AccountLevel
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type AccountDeleteMutationVariables = Exact<{ [key: string]: never }>

export type AccountDeleteMutation = {
  readonly __typename: "Mutation"
  readonly accountDelete: {
    readonly __typename: "AccountDeletePayload"
    readonly success: boolean
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type UserEmailDeleteMutationVariables = Exact<{ [key: string]: never }>

export type UserEmailDeleteMutation = {
  readonly __typename: "Mutation"
  readonly userEmailDelete: {
    readonly __typename: "UserEmailDeletePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly me?: {
      readonly __typename: "User"
      readonly id: string
      readonly phone?: string | null
      readonly totpEnabled: boolean
      readonly email?: {
        readonly __typename: "Email"
        readonly address?: string | null
        readonly verified?: boolean | null
      } | null
    } | null
  }
}

export type UserPhoneDeleteMutationVariables = Exact<{ [key: string]: never }>

export type UserPhoneDeleteMutation = {
  readonly __typename: "Mutation"
  readonly userPhoneDelete: {
    readonly __typename: "UserPhoneDeletePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly me?: {
      readonly __typename: "User"
      readonly id: string
      readonly phone?: string | null
      readonly totpEnabled: boolean
      readonly email?: {
        readonly __typename: "Email"
        readonly address?: string | null
        readonly verified?: boolean | null
      } | null
    } | null
  }
}

export type UserTotpDeleteMutationVariables = Exact<{
  input: UserTotpDeleteInput
}>

export type UserTotpDeleteMutation = {
  readonly __typename: "Mutation"
  readonly userTotpDelete: {
    readonly __typename: "UserTotpDeletePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly me?: {
      readonly __typename: "User"
      readonly id: string
      readonly phone?: string | null
      readonly totpEnabled: boolean
      readonly email?: {
        readonly __typename: "Email"
        readonly address?: string | null
        readonly verified?: boolean | null
      } | null
    } | null
  }
}

export type AccountUpdateDefaultWalletIdMutationVariables = Exact<{
  input: AccountUpdateDefaultWalletIdInput
}>

export type AccountUpdateDefaultWalletIdMutation = {
  readonly __typename: "Mutation"
  readonly accountUpdateDefaultWalletId: {
    readonly __typename: "AccountUpdateDefaultWalletIdPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly account?: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly defaultWalletId: string
    } | null
  }
}

export type SetDefaultWalletScreenQueryVariables = Exact<{ [key: string]: never }>

export type SetDefaultWalletScreenQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly defaultWalletId: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type AccountUpdateDisplayCurrencyMutationVariables = Exact<{
  input: AccountUpdateDisplayCurrencyInput
}>

export type AccountUpdateDisplayCurrencyMutation = {
  readonly __typename: "Mutation"
  readonly accountUpdateDisplayCurrency: {
    readonly __typename: "AccountUpdateDisplayCurrencyPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly account?: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly displayCurrency: string
    } | null
  }
}

export type LanguageQueryVariables = Exact<{ [key: string]: never }>

export type LanguageQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly language: string
  } | null
}

export type UserUpdateLanguageMutationVariables = Exact<{
  input: UserUpdateLanguageInput
}>

export type UserUpdateLanguageMutation = {
  readonly __typename: "Mutation"
  readonly userUpdateLanguage: {
    readonly __typename: "UserUpdateLanguagePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly user?: {
      readonly __typename: "User"
      readonly id: string
      readonly language: string
    } | null
  }
}

export type NotificationSettingsQueryVariables = Exact<{ [key: string]: never }>

export type NotificationSettingsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly notificationSettings: {
        readonly __typename: "NotificationSettings"
        readonly push: {
          readonly __typename: "NotificationChannelSettings"
          readonly enabled: boolean
          readonly disabledCategories: ReadonlyArray<string>
        }
      }
    }
  } | null
}

export type AccountEnableNotificationChannelMutationVariables = Exact<{
  input: AccountEnableNotificationChannelInput
}>

export type AccountEnableNotificationChannelMutation = {
  readonly __typename: "Mutation"
  readonly accountEnableNotificationChannel: {
    readonly __typename: "AccountUpdateNotificationSettingsPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly account?: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly notificationSettings: {
        readonly __typename: "NotificationSettings"
        readonly push: {
          readonly __typename: "NotificationChannelSettings"
          readonly enabled: boolean
          readonly disabledCategories: ReadonlyArray<string>
        }
      }
    } | null
  }
}

export type AccountDisableNotificationChannelMutationVariables = Exact<{
  input: AccountDisableNotificationChannelInput
}>

export type AccountDisableNotificationChannelMutation = {
  readonly __typename: "Mutation"
  readonly accountDisableNotificationChannel: {
    readonly __typename: "AccountUpdateNotificationSettingsPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly account?: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly notificationSettings: {
        readonly __typename: "NotificationSettings"
        readonly push: {
          readonly __typename: "NotificationChannelSettings"
          readonly enabled: boolean
          readonly disabledCategories: ReadonlyArray<string>
        }
      }
    } | null
  }
}

export type AccountEnableNotificationCategoryMutationVariables = Exact<{
  input: AccountEnableNotificationCategoryInput
}>

export type AccountEnableNotificationCategoryMutation = {
  readonly __typename: "Mutation"
  readonly accountEnableNotificationCategory: {
    readonly __typename: "AccountUpdateNotificationSettingsPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly account?: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly notificationSettings: {
        readonly __typename: "NotificationSettings"
        readonly push: {
          readonly __typename: "NotificationChannelSettings"
          readonly enabled: boolean
          readonly disabledCategories: ReadonlyArray<string>
        }
      }
    } | null
  }
}

export type AccountDisableNotificationCategoryMutationVariables = Exact<{
  input: AccountDisableNotificationCategoryInput
}>

export type AccountDisableNotificationCategoryMutation = {
  readonly __typename: "Mutation"
  readonly accountDisableNotificationCategory: {
    readonly __typename: "AccountUpdateNotificationSettingsPayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly account?: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly notificationSettings: {
        readonly __typename: "NotificationSettings"
        readonly push: {
          readonly __typename: "NotificationChannelSettings"
          readonly enabled: boolean
          readonly disabledCategories: ReadonlyArray<string>
        }
      }
    } | null
  }
}

export type UnacknowledgedNotificationCountQueryVariables = Exact<{
  [key: string]: never
}>

export type UnacknowledgedNotificationCountQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly unacknowledgedStatefulNotificationsWithoutBulletinEnabledCount: number
  } | null
}

export type WalletCsvTransactionsQueryVariables = Exact<{
  walletIds: ReadonlyArray<Scalars["WalletId"]> | Scalars["WalletId"]
}>

export type WalletCsvTransactionsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly csvTransactions: string
    }
  } | null
}

export type SettingsScreenQueryVariables = Exact<{ [key: string]: never }>

export type SettingsScreenQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly phone?: string | null
    readonly username?: string | null
    readonly totpEnabled: boolean
    readonly email?: {
      readonly __typename: "Email"
      readonly address?: string | null
      readonly verified?: boolean | null
    } | null
    readonly language: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly defaultWalletId: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type WarningSecureAccountQueryVariables = Exact<{ [key: string]: never }>

export type WarningSecureAccountQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly level: AccountLevel
      readonly id: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
        | {
            readonly __typename: "UsdWallet"
            readonly id: string
            readonly balance: number
            readonly walletCurrency: WalletCurrency
          }
      >
    }
  } | null
}

export type AccountLimitsQueryVariables = Exact<{ [key: string]: never }>

export type AccountLimitsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly limits: {
        readonly __typename: "AccountLimits"
        readonly withdrawal: ReadonlyArray<{
          readonly __typename: "OneDayAccountLimit"
          readonly totalLimit: number
          readonly remainingLimit?: number | null
          readonly interval?: number | null
        }>
        readonly internalSend: ReadonlyArray<{
          readonly __typename: "OneDayAccountLimit"
          readonly totalLimit: number
          readonly remainingLimit?: number | null
          readonly interval?: number | null
        }>
        readonly convert: ReadonlyArray<{
          readonly __typename: "OneDayAccountLimit"
          readonly totalLimit: number
          readonly remainingLimit?: number | null
          readonly interval?: number | null
        }>
      }
    }
  } | null
}

export type TotpRegistrationScreenQueryVariables = Exact<{ [key: string]: never }>

export type TotpRegistrationScreenQuery = {
  readonly __typename: "Query"
  readonly me?: { readonly __typename: "User"; readonly username?: string | null } | null
}

export type UserTotpRegistrationInitiateMutationVariables = Exact<{
  input: UserTotpRegistrationInitiateInput
}>

export type UserTotpRegistrationInitiateMutation = {
  readonly __typename: "Mutation"
  readonly userTotpRegistrationInitiate: {
    readonly __typename: "UserTotpRegistrationInitiatePayload"
    readonly totpRegistrationId?: string | null
    readonly totpSecret?: string | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type UserTotpRegistrationValidateMutationVariables = Exact<{
  input: UserTotpRegistrationValidateInput
}>

export type UserTotpRegistrationValidateMutation = {
  readonly __typename: "Mutation"
  readonly userTotpRegistrationValidate: {
    readonly __typename: "UserTotpRegistrationValidatePayload"
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
    readonly me?: {
      readonly __typename: "User"
      readonly totpEnabled: boolean
      readonly phone?: string | null
      readonly email?: {
        readonly __typename: "Email"
        readonly address?: string | null
        readonly verified?: boolean | null
      } | null
    } | null
  }
}

export type TransactionListForDefaultAccountQueryVariables = Exact<{
  first?: InputMaybe<Scalars["Int"]>
  after?: InputMaybe<Scalars["String"]>
  last?: InputMaybe<Scalars["Int"]>
  before?: InputMaybe<Scalars["String"]>
}>

export type TransactionListForDefaultAccountQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly transactions?: {
        readonly __typename: "TransactionConnection"
        readonly pageInfo: {
          readonly __typename: "PageInfo"
          readonly hasNextPage: boolean
          readonly hasPreviousPage: boolean
          readonly startCursor?: string | null
          readonly endCursor?: string | null
        }
        readonly edges?: ReadonlyArray<{
          readonly __typename: "TransactionEdge"
          readonly cursor: string
          readonly node: {
            readonly __typename: "Transaction"
            readonly id: string
            readonly status: TxStatus
            readonly direction: TxDirection
            readonly memo?: string | null
            readonly createdAt: number
            readonly settlementAmount: number
            readonly settlementFee: number
            readonly settlementDisplayFee: string
            readonly settlementCurrency: WalletCurrency
            readonly settlementDisplayAmount: string
            readonly settlementDisplayCurrency: string
            readonly settlementPrice: {
              readonly __typename: "PriceOfOneSettlementMinorUnitInDisplayMinorUnit"
              readonly base: number
              readonly offset: number
              readonly currencyUnit: string
              readonly formattedAmount: string
            }
            readonly initiationVia:
              | {
                  readonly __typename: "InitiationViaIntraLedger"
                  readonly counterPartyWalletId?: string | null
                  readonly counterPartyUsername?: string | null
                }
              | { readonly __typename: "InitiationViaLn"; readonly paymentHash: string }
              | { readonly __typename: "InitiationViaOnChain"; readonly address: string }
            readonly settlementVia:
              | {
                  readonly __typename: "SettlementViaIntraLedger"
                  readonly counterPartyWalletId?: string | null
                  readonly counterPartyUsername?: string | null
                }
              | {
                  readonly __typename: "SettlementViaLn"
                  readonly paymentSecret?: string | null
                }
              | {
                  readonly __typename: "SettlementViaOnChain"
                  readonly transactionHash?: string | null
                }
          }
        }> | null
      } | null
    }
  } | null
}

export type DeviceNotificationTokenCreateMutationVariables = Exact<{
  input: DeviceNotificationTokenCreateInput
}>

export type DeviceNotificationTokenCreateMutation = {
  readonly __typename: "Mutation"
  readonly deviceNotificationTokenCreate: {
    readonly __typename: "SuccessPayload"
    readonly success?: boolean | null
    readonly errors: ReadonlyArray<{
      readonly __typename: "GraphQLApplicationError"
      readonly message: string
    }>
  }
}

export type WalletsQueryVariables = Exact<{ [key: string]: never }>

export type WalletsQuery = {
  readonly __typename: "Query"
  readonly me?: {
    readonly __typename: "User"
    readonly id: string
    readonly defaultAccount: {
      readonly __typename: "ConsumerAccount"
      readonly id: string
      readonly wallets: ReadonlyArray<
        | {
            readonly __typename: "BTCWallet"
            readonly walletCurrency: WalletCurrency
            readonly id: string
          }
        | {
            readonly __typename: "UsdWallet"
            readonly walletCurrency: WalletCurrency
            readonly id: string
          }
      >
    }
  } | null
}

export const MyWalletsFragmentDoc = gql`
  fragment MyWallets on ConsumerAccount {
    wallets {
      id
      balance
      walletCurrency
    }
  }
`
export const TransactionFragmentDoc = gql`
  fragment Transaction on Transaction {
    __typename
    id
    status
    direction
    memo
    createdAt
    settlementAmount
    settlementFee
    settlementDisplayFee
    settlementCurrency
    settlementDisplayAmount
    settlementDisplayCurrency
    settlementPrice {
      base
      offset
      currencyUnit
      formattedAmount
    }
    initiationVia {
      ... on InitiationViaIntraLedger {
        counterPartyWalletId
        counterPartyUsername
      }
      ... on InitiationViaLn {
        paymentHash
      }
      ... on InitiationViaOnChain {
        address
      }
    }
    settlementVia {
      ... on SettlementViaIntraLedger {
        counterPartyWalletId
        counterPartyUsername
      }
      ... on SettlementViaLn {
        paymentSecret
      }
      ... on SettlementViaOnChain {
        transactionHash
      }
    }
  }
`
export const TransactionListFragmentDoc = gql`
  fragment TransactionList on TransactionConnection {
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        ...Transaction
      }
    }
  }
  ${TransactionFragmentDoc}
`
export const MobileUpdateDocument = gql`
  query mobileUpdate {
    mobileVersions {
      platform
      currentSupported
      minSupported
    }
  }
`

/**
 * __useMobileUpdateQuery__
 *
 * To run a query within a React component, call `useMobileUpdateQuery` and pass it any options that fit your needs.
 * When your component renders, `useMobileUpdateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMobileUpdateQuery({
 *   variables: {
 *   },
 * });
 */
export function useMobileUpdateQuery(
  baseOptions?: Apollo.QueryHookOptions<MobileUpdateQuery, MobileUpdateQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<MobileUpdateQuery, MobileUpdateQueryVariables>(
    MobileUpdateDocument,
    options,
  )
}
export function useMobileUpdateLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    MobileUpdateQuery,
    MobileUpdateQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<MobileUpdateQuery, MobileUpdateQueryVariables>(
    MobileUpdateDocument,
    options,
  )
}
export type MobileUpdateQueryHookResult = ReturnType<typeof useMobileUpdateQuery>
export type MobileUpdateLazyQueryHookResult = ReturnType<typeof useMobileUpdateLazyQuery>
export type MobileUpdateQueryResult = Apollo.QueryResult<
  MobileUpdateQuery,
  MobileUpdateQueryVariables
>
export const BalanceHeaderDocument = gql`
  query balanceHeader {
    me {
      id
      defaultAccount {
        id
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
`

/**
 * __useBalanceHeaderQuery__
 *
 * To run a query within a React component, call `useBalanceHeaderQuery` and pass it any options that fit your needs.
 * When your component renders, `useBalanceHeaderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBalanceHeaderQuery({
 *   variables: {
 *   },
 * });
 */
export function useBalanceHeaderQuery(
  baseOptions?: Apollo.QueryHookOptions<BalanceHeaderQuery, BalanceHeaderQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BalanceHeaderQuery, BalanceHeaderQueryVariables>(
    BalanceHeaderDocument,
    options,
  )
}
export function useBalanceHeaderLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    BalanceHeaderQuery,
    BalanceHeaderQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BalanceHeaderQuery, BalanceHeaderQueryVariables>(
    BalanceHeaderDocument,
    options,
  )
}
export type BalanceHeaderQueryHookResult = ReturnType<typeof useBalanceHeaderQuery>
export type BalanceHeaderLazyQueryHookResult = ReturnType<
  typeof useBalanceHeaderLazyQuery
>
export type BalanceHeaderQueryResult = Apollo.QueryResult<
  BalanceHeaderQuery,
  BalanceHeaderQueryVariables
>
export const BtcPriceListDocument = gql`
  query btcPriceList($range: PriceGraphRange!) {
    btcPriceList(range: $range) {
      timestamp
      price {
        base
        offset
        currencyUnit
      }
    }
  }
`

/**
 * __useBtcPriceListQuery__
 *
 * To run a query within a React component, call `useBtcPriceListQuery` and pass it any options that fit your needs.
 * When your component renders, `useBtcPriceListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBtcPriceListQuery({
 *   variables: {
 *      range: // value for 'range'
 *   },
 * });
 */
export function useBtcPriceListQuery(
  baseOptions: Apollo.QueryHookOptions<BtcPriceListQuery, BtcPriceListQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BtcPriceListQuery, BtcPriceListQueryVariables>(
    BtcPriceListDocument,
    options,
  )
}
export function useBtcPriceListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    BtcPriceListQuery,
    BtcPriceListQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BtcPriceListQuery, BtcPriceListQueryVariables>(
    BtcPriceListDocument,
    options,
  )
}
export type BtcPriceListQueryHookResult = ReturnType<typeof useBtcPriceListQuery>
export type BtcPriceListLazyQueryHookResult = ReturnType<typeof useBtcPriceListLazyQuery>
export type BtcPriceListQueryResult = Apollo.QueryResult<
  BtcPriceListQuery,
  BtcPriceListQueryVariables
>
export const SetDefaultAccountModalDocument = gql`
  query setDefaultAccountModal {
    me {
      id
      defaultAccount {
        id
        defaultWalletId
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
`

/**
 * __useSetDefaultAccountModalQuery__
 *
 * To run a query within a React component, call `useSetDefaultAccountModalQuery` and pass it any options that fit your needs.
 * When your component renders, `useSetDefaultAccountModalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSetDefaultAccountModalQuery({
 *   variables: {
 *   },
 * });
 */
export function useSetDefaultAccountModalQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SetDefaultAccountModalQuery,
    SetDefaultAccountModalQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    SetDefaultAccountModalQuery,
    SetDefaultAccountModalQueryVariables
  >(SetDefaultAccountModalDocument, options)
}
export function useSetDefaultAccountModalLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SetDefaultAccountModalQuery,
    SetDefaultAccountModalQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SetDefaultAccountModalQuery,
    SetDefaultAccountModalQueryVariables
  >(SetDefaultAccountModalDocument, options)
}
export type SetDefaultAccountModalQueryHookResult = ReturnType<
  typeof useSetDefaultAccountModalQuery
>
export type SetDefaultAccountModalLazyQueryHookResult = ReturnType<
  typeof useSetDefaultAccountModalLazyQuery
>
export type SetDefaultAccountModalQueryResult = Apollo.QueryResult<
  SetDefaultAccountModalQuery,
  SetDefaultAccountModalQueryVariables
>
export const UserUpdateUsernameDocument = gql`
  mutation userUpdateUsername($input: UserUpdateUsernameInput!) {
    userUpdateUsername(input: $input) {
      errors {
        code
      }
      user {
        id
        username
      }
    }
  }
`
export type UserUpdateUsernameMutationFn = Apollo.MutationFunction<
  UserUpdateUsernameMutation,
  UserUpdateUsernameMutationVariables
>

/**
 * __useUserUpdateUsernameMutation__
 *
 * To run a mutation, you first call `useUserUpdateUsernameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserUpdateUsernameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userUpdateUsernameMutation, { data, loading, error }] = useUserUpdateUsernameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserUpdateUsernameMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserUpdateUsernameMutation,
    UserUpdateUsernameMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserUpdateUsernameMutation,
    UserUpdateUsernameMutationVariables
  >(UserUpdateUsernameDocument, options)
}
export type UserUpdateUsernameMutationHookResult = ReturnType<
  typeof useUserUpdateUsernameMutation
>
export type UserUpdateUsernameMutationResult =
  Apollo.MutationResult<UserUpdateUsernameMutation>
export type UserUpdateUsernameMutationOptions = Apollo.BaseMutationOptions<
  UserUpdateUsernameMutation,
  UserUpdateUsernameMutationVariables
>
export const MyUserIdDocument = gql`
  query myUserId {
    me {
      id
    }
  }
`

/**
 * __useMyUserIdQuery__
 *
 * To run a query within a React component, call `useMyUserIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyUserIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyUserIdQuery({
 *   variables: {
 *   },
 * });
 */
export function useMyUserIdQuery(
  baseOptions?: Apollo.QueryHookOptions<MyUserIdQuery, MyUserIdQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<MyUserIdQuery, MyUserIdQueryVariables>(MyUserIdDocument, options)
}
export function useMyUserIdLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<MyUserIdQuery, MyUserIdQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<MyUserIdQuery, MyUserIdQueryVariables>(
    MyUserIdDocument,
    options,
  )
}
export type MyUserIdQueryHookResult = ReturnType<typeof useMyUserIdQuery>
export type MyUserIdLazyQueryHookResult = ReturnType<typeof useMyUserIdLazyQuery>
export type MyUserIdQueryResult = Apollo.QueryResult<
  MyUserIdQuery,
  MyUserIdQueryVariables
>
export const WalletOverviewScreenDocument = gql`
  query walletOverviewScreen {
    me {
      id
      defaultAccount {
        id
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
`

/**
 * __useWalletOverviewScreenQuery__
 *
 * To run a query within a React component, call `useWalletOverviewScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useWalletOverviewScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWalletOverviewScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useWalletOverviewScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<
    WalletOverviewScreenQuery,
    WalletOverviewScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<WalletOverviewScreenQuery, WalletOverviewScreenQueryVariables>(
    WalletOverviewScreenDocument,
    options,
  )
}
export function useWalletOverviewScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    WalletOverviewScreenQuery,
    WalletOverviewScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    WalletOverviewScreenQuery,
    WalletOverviewScreenQueryVariables
  >(WalletOverviewScreenDocument, options)
}
export type WalletOverviewScreenQueryHookResult = ReturnType<
  typeof useWalletOverviewScreenQuery
>
export type WalletOverviewScreenLazyQueryHookResult = ReturnType<
  typeof useWalletOverviewScreenLazyQuery
>
export type WalletOverviewScreenQueryResult = Apollo.QueryResult<
  WalletOverviewScreenQuery,
  WalletOverviewScreenQueryVariables
>
export const AnalyticsDocument = gql`
  query analytics {
    me {
      username
      id
    }
    globals {
      network
    }
  }
`

/**
 * __useAnalyticsQuery__
 *
 * To run a query within a React component, call `useAnalyticsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAnalyticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAnalyticsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAnalyticsQuery(
  baseOptions?: Apollo.QueryHookOptions<AnalyticsQuery, AnalyticsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AnalyticsQuery, AnalyticsQueryVariables>(
    AnalyticsDocument,
    options,
  )
}
export function useAnalyticsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<AnalyticsQuery, AnalyticsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<AnalyticsQuery, AnalyticsQueryVariables>(
    AnalyticsDocument,
    options,
  )
}
export type AnalyticsQueryHookResult = ReturnType<typeof useAnalyticsQuery>
export type AnalyticsLazyQueryHookResult = ReturnType<typeof useAnalyticsLazyQuery>
export type AnalyticsQueryResult = Apollo.QueryResult<
  AnalyticsQuery,
  AnalyticsQueryVariables
>
export const RealtimePriceDocument = gql`
  query realtimePrice {
    me {
      id
      defaultAccount {
        id
        realtimePrice {
          btcSatPrice {
            base
            offset
          }
          denominatorCurrency
          id
          timestamp
          usdCentPrice {
            base
            offset
          }
        }
      }
    }
  }
`

/**
 * __useRealtimePriceQuery__
 *
 * To run a query within a React component, call `useRealtimePriceQuery` and pass it any options that fit your needs.
 * When your component renders, `useRealtimePriceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRealtimePriceQuery({
 *   variables: {
 *   },
 * });
 */
export function useRealtimePriceQuery(
  baseOptions?: Apollo.QueryHookOptions<RealtimePriceQuery, RealtimePriceQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<RealtimePriceQuery, RealtimePriceQueryVariables>(
    RealtimePriceDocument,
    options,
  )
}
export function useRealtimePriceLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    RealtimePriceQuery,
    RealtimePriceQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<RealtimePriceQuery, RealtimePriceQueryVariables>(
    RealtimePriceDocument,
    options,
  )
}
export type RealtimePriceQueryHookResult = ReturnType<typeof useRealtimePriceQuery>
export type RealtimePriceLazyQueryHookResult = ReturnType<
  typeof useRealtimePriceLazyQuery
>
export type RealtimePriceQueryResult = Apollo.QueryResult<
  RealtimePriceQuery,
  RealtimePriceQueryVariables
>
export const HideBalanceDocument = gql`
  query hideBalance {
    hideBalance @client
  }
`

/**
 * __useHideBalanceQuery__
 *
 * To run a query within a React component, call `useHideBalanceQuery` and pass it any options that fit your needs.
 * When your component renders, `useHideBalanceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHideBalanceQuery({
 *   variables: {
 *   },
 * });
 */
export function useHideBalanceQuery(
  baseOptions?: Apollo.QueryHookOptions<HideBalanceQuery, HideBalanceQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<HideBalanceQuery, HideBalanceQueryVariables>(
    HideBalanceDocument,
    options,
  )
}
export function useHideBalanceLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<HideBalanceQuery, HideBalanceQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<HideBalanceQuery, HideBalanceQueryVariables>(
    HideBalanceDocument,
    options,
  )
}
export type HideBalanceQueryHookResult = ReturnType<typeof useHideBalanceQuery>
export type HideBalanceLazyQueryHookResult = ReturnType<typeof useHideBalanceLazyQuery>
export type HideBalanceQueryResult = Apollo.QueryResult<
  HideBalanceQuery,
  HideBalanceQueryVariables
>
export const HiddenBalanceToolTipDocument = gql`
  query hiddenBalanceToolTip {
    hiddenBalanceToolTip @client
  }
`

/**
 * __useHiddenBalanceToolTipQuery__
 *
 * To run a query within a React component, call `useHiddenBalanceToolTipQuery` and pass it any options that fit your needs.
 * When your component renders, `useHiddenBalanceToolTipQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHiddenBalanceToolTipQuery({
 *   variables: {
 *   },
 * });
 */
export function useHiddenBalanceToolTipQuery(
  baseOptions?: Apollo.QueryHookOptions<
    HiddenBalanceToolTipQuery,
    HiddenBalanceToolTipQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<HiddenBalanceToolTipQuery, HiddenBalanceToolTipQueryVariables>(
    HiddenBalanceToolTipDocument,
    options,
  )
}
export function useHiddenBalanceToolTipLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    HiddenBalanceToolTipQuery,
    HiddenBalanceToolTipQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    HiddenBalanceToolTipQuery,
    HiddenBalanceToolTipQueryVariables
  >(HiddenBalanceToolTipDocument, options)
}
export type HiddenBalanceToolTipQueryHookResult = ReturnType<
  typeof useHiddenBalanceToolTipQuery
>
export type HiddenBalanceToolTipLazyQueryHookResult = ReturnType<
  typeof useHiddenBalanceToolTipLazyQuery
>
export type HiddenBalanceToolTipQueryResult = Apollo.QueryResult<
  HiddenBalanceToolTipQuery,
  HiddenBalanceToolTipQueryVariables
>
export const BetaDocument = gql`
  query beta {
    beta @client
  }
`

/**
 * __useBetaQuery__
 *
 * To run a query within a React component, call `useBetaQuery` and pass it any options that fit your needs.
 * When your component renders, `useBetaQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBetaQuery({
 *   variables: {
 *   },
 * });
 */
export function useBetaQuery(
  baseOptions?: Apollo.QueryHookOptions<BetaQuery, BetaQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BetaQuery, BetaQueryVariables>(BetaDocument, options)
}
export function useBetaLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BetaQuery, BetaQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BetaQuery, BetaQueryVariables>(BetaDocument, options)
}
export type BetaQueryHookResult = ReturnType<typeof useBetaQuery>
export type BetaLazyQueryHookResult = ReturnType<typeof useBetaLazyQuery>
export type BetaQueryResult = Apollo.QueryResult<BetaQuery, BetaQueryVariables>
export const ColorSchemeDocument = gql`
  query colorScheme {
    colorScheme @client
  }
`

/**
 * __useColorSchemeQuery__
 *
 * To run a query within a React component, call `useColorSchemeQuery` and pass it any options that fit your needs.
 * When your component renders, `useColorSchemeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useColorSchemeQuery({
 *   variables: {
 *   },
 * });
 */
export function useColorSchemeQuery(
  baseOptions?: Apollo.QueryHookOptions<ColorSchemeQuery, ColorSchemeQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ColorSchemeQuery, ColorSchemeQueryVariables>(
    ColorSchemeDocument,
    options,
  )
}
export function useColorSchemeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ColorSchemeQuery, ColorSchemeQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ColorSchemeQuery, ColorSchemeQueryVariables>(
    ColorSchemeDocument,
    options,
  )
}
export type ColorSchemeQueryHookResult = ReturnType<typeof useColorSchemeQuery>
export type ColorSchemeLazyQueryHookResult = ReturnType<typeof useColorSchemeLazyQuery>
export type ColorSchemeQueryResult = Apollo.QueryResult<
  ColorSchemeQuery,
  ColorSchemeQueryVariables
>
export const FeedbackModalShownDocument = gql`
  query feedbackModalShown {
    feedbackModalShown @client
  }
`

/**
 * __useFeedbackModalShownQuery__
 *
 * To run a query within a React component, call `useFeedbackModalShownQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeedbackModalShownQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeedbackModalShownQuery({
 *   variables: {
 *   },
 * });
 */
export function useFeedbackModalShownQuery(
  baseOptions?: Apollo.QueryHookOptions<
    FeedbackModalShownQuery,
    FeedbackModalShownQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>(
    FeedbackModalShownDocument,
    options,
  )
}
export function useFeedbackModalShownLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    FeedbackModalShownQuery,
    FeedbackModalShownQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>(
    FeedbackModalShownDocument,
    options,
  )
}
export type FeedbackModalShownQueryHookResult = ReturnType<
  typeof useFeedbackModalShownQuery
>
export type FeedbackModalShownLazyQueryHookResult = ReturnType<
  typeof useFeedbackModalShownLazyQuery
>
export type FeedbackModalShownQueryResult = Apollo.QueryResult<
  FeedbackModalShownQuery,
  FeedbackModalShownQueryVariables
>
export const HasPromptedSetDefaultAccountDocument = gql`
  query hasPromptedSetDefaultAccount {
    hasPromptedSetDefaultAccount @client
  }
`

/**
 * __useHasPromptedSetDefaultAccountQuery__
 *
 * To run a query within a React component, call `useHasPromptedSetDefaultAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useHasPromptedSetDefaultAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHasPromptedSetDefaultAccountQuery({
 *   variables: {
 *   },
 * });
 */
export function useHasPromptedSetDefaultAccountQuery(
  baseOptions?: Apollo.QueryHookOptions<
    HasPromptedSetDefaultAccountQuery,
    HasPromptedSetDefaultAccountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    HasPromptedSetDefaultAccountQuery,
    HasPromptedSetDefaultAccountQueryVariables
  >(HasPromptedSetDefaultAccountDocument, options)
}
export function useHasPromptedSetDefaultAccountLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    HasPromptedSetDefaultAccountQuery,
    HasPromptedSetDefaultAccountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    HasPromptedSetDefaultAccountQuery,
    HasPromptedSetDefaultAccountQueryVariables
  >(HasPromptedSetDefaultAccountDocument, options)
}
export type HasPromptedSetDefaultAccountQueryHookResult = ReturnType<
  typeof useHasPromptedSetDefaultAccountQuery
>
export type HasPromptedSetDefaultAccountLazyQueryHookResult = ReturnType<
  typeof useHasPromptedSetDefaultAccountLazyQuery
>
export type HasPromptedSetDefaultAccountQueryResult = Apollo.QueryResult<
  HasPromptedSetDefaultAccountQuery,
  HasPromptedSetDefaultAccountQueryVariables
>
export const NetworkDocument = gql`
  query network {
    globals {
      network
    }
  }
`

/**
 * __useNetworkQuery__
 *
 * To run a query within a React component, call `useNetworkQuery` and pass it any options that fit your needs.
 * When your component renders, `useNetworkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNetworkQuery({
 *   variables: {
 *   },
 * });
 */
export function useNetworkQuery(
  baseOptions?: Apollo.QueryHookOptions<NetworkQuery, NetworkQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<NetworkQuery, NetworkQueryVariables>(NetworkDocument, options)
}
export function useNetworkLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<NetworkQuery, NetworkQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<NetworkQuery, NetworkQueryVariables>(
    NetworkDocument,
    options,
  )
}
export type NetworkQueryHookResult = ReturnType<typeof useNetworkQuery>
export type NetworkLazyQueryHookResult = ReturnType<typeof useNetworkLazyQuery>
export type NetworkQueryResult = Apollo.QueryResult<NetworkQuery, NetworkQueryVariables>
export const LevelDocument = gql`
  query level {
    me {
      id
      defaultAccount {
        id
        level
      }
    }
  }
`

/**
 * __useLevelQuery__
 *
 * To run a query within a React component, call `useLevelQuery` and pass it any options that fit your needs.
 * When your component renders, `useLevelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLevelQuery({
 *   variables: {
 *   },
 * });
 */
export function useLevelQuery(
  baseOptions?: Apollo.QueryHookOptions<LevelQuery, LevelQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<LevelQuery, LevelQueryVariables>(LevelDocument, options)
}
export function useLevelLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<LevelQuery, LevelQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<LevelQuery, LevelQueryVariables>(LevelDocument, options)
}
export type LevelQueryHookResult = ReturnType<typeof useLevelQuery>
export type LevelLazyQueryHookResult = ReturnType<typeof useLevelLazyQuery>
export type LevelQueryResult = Apollo.QueryResult<LevelQuery, LevelQueryVariables>
export const DisplayCurrencyDocument = gql`
  query displayCurrency {
    me {
      id
      defaultAccount {
        id
        displayCurrency
      }
    }
  }
`

/**
 * __useDisplayCurrencyQuery__
 *
 * To run a query within a React component, call `useDisplayCurrencyQuery` and pass it any options that fit your needs.
 * When your component renders, `useDisplayCurrencyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDisplayCurrencyQuery({
 *   variables: {
 *   },
 * });
 */
export function useDisplayCurrencyQuery(
  baseOptions?: Apollo.QueryHookOptions<
    DisplayCurrencyQuery,
    DisplayCurrencyQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>(
    DisplayCurrencyDocument,
    options,
  )
}
export function useDisplayCurrencyLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    DisplayCurrencyQuery,
    DisplayCurrencyQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>(
    DisplayCurrencyDocument,
    options,
  )
}
export type DisplayCurrencyQueryHookResult = ReturnType<typeof useDisplayCurrencyQuery>
export type DisplayCurrencyLazyQueryHookResult = ReturnType<
  typeof useDisplayCurrencyLazyQuery
>
export type DisplayCurrencyQueryResult = Apollo.QueryResult<
  DisplayCurrencyQuery,
  DisplayCurrencyQueryVariables
>
export const CurrencyListDocument = gql`
  query currencyList {
    currencyList {
      __typename
      id
      flag
      name
      symbol
      fractionDigits
    }
  }
`

/**
 * __useCurrencyListQuery__
 *
 * To run a query within a React component, call `useCurrencyListQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrencyListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrencyListQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrencyListQuery(
  baseOptions?: Apollo.QueryHookOptions<CurrencyListQuery, CurrencyListQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<CurrencyListQuery, CurrencyListQueryVariables>(
    CurrencyListDocument,
    options,
  )
}
export function useCurrencyListLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    CurrencyListQuery,
    CurrencyListQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<CurrencyListQuery, CurrencyListQueryVariables>(
    CurrencyListDocument,
    options,
  )
}
export type CurrencyListQueryHookResult = ReturnType<typeof useCurrencyListQuery>
export type CurrencyListLazyQueryHookResult = ReturnType<typeof useCurrencyListLazyQuery>
export type CurrencyListQueryResult = Apollo.QueryResult<
  CurrencyListQuery,
  CurrencyListQueryVariables
>
export const CaptchaCreateChallengeDocument = gql`
  mutation captchaCreateChallenge {
    captchaCreateChallenge {
      errors {
        message
      }
      result {
        id
        challengeCode
        newCaptcha
        failbackMode
      }
    }
  }
`
export type CaptchaCreateChallengeMutationFn = Apollo.MutationFunction<
  CaptchaCreateChallengeMutation,
  CaptchaCreateChallengeMutationVariables
>

/**
 * __useCaptchaCreateChallengeMutation__
 *
 * To run a mutation, you first call `useCaptchaCreateChallengeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCaptchaCreateChallengeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [captchaCreateChallengeMutation, { data, loading, error }] = useCaptchaCreateChallengeMutation({
 *   variables: {
 *   },
 * });
 */
export function useCaptchaCreateChallengeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CaptchaCreateChallengeMutation,
    CaptchaCreateChallengeMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    CaptchaCreateChallengeMutation,
    CaptchaCreateChallengeMutationVariables
  >(CaptchaCreateChallengeDocument, options)
}
export type CaptchaCreateChallengeMutationHookResult = ReturnType<
  typeof useCaptchaCreateChallengeMutation
>
export type CaptchaCreateChallengeMutationResult =
  Apollo.MutationResult<CaptchaCreateChallengeMutation>
export type CaptchaCreateChallengeMutationOptions = Apollo.BaseMutationOptions<
  CaptchaCreateChallengeMutation,
  CaptchaCreateChallengeMutationVariables
>
export const TransactionListForContactDocument = gql`
  query transactionListForContact(
    $username: Username!
    $first: Int
    $after: String
    $last: Int
    $before: String
  ) {
    me {
      id
      contactByUsername(username: $username) {
        transactions(first: $first, after: $after, last: $last, before: $before) {
          ...TransactionList
        }
      }
    }
  }
  ${TransactionListFragmentDoc}
`

/**
 * __useTransactionListForContactQuery__
 *
 * To run a query within a React component, call `useTransactionListForContactQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionListForContactQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionListForContactQuery({
 *   variables: {
 *      username: // value for 'username'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      last: // value for 'last'
 *      before: // value for 'before'
 *   },
 * });
 */
export function useTransactionListForContactQuery(
  baseOptions: Apollo.QueryHookOptions<
    TransactionListForContactQuery,
    TransactionListForContactQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    TransactionListForContactQuery,
    TransactionListForContactQueryVariables
  >(TransactionListForContactDocument, options)
}
export function useTransactionListForContactLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    TransactionListForContactQuery,
    TransactionListForContactQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    TransactionListForContactQuery,
    TransactionListForContactQueryVariables
  >(TransactionListForContactDocument, options)
}
export type TransactionListForContactQueryHookResult = ReturnType<
  typeof useTransactionListForContactQuery
>
export type TransactionListForContactLazyQueryHookResult = ReturnType<
  typeof useTransactionListForContactLazyQuery
>
export type TransactionListForContactQueryResult = Apollo.QueryResult<
  TransactionListForContactQuery,
  TransactionListForContactQueryVariables
>
export const ContactsDocument = gql`
  query contacts {
    me {
      id
      contacts {
        id
        username
        alias
        transactionsCount
      }
    }
  }
`

/**
 * __useContactsQuery__
 *
 * To run a query within a React component, call `useContactsQuery` and pass it any options that fit your needs.
 * When your component renders, `useContactsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContactsQuery({
 *   variables: {
 *   },
 * });
 */
export function useContactsQuery(
  baseOptions?: Apollo.QueryHookOptions<ContactsQuery, ContactsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ContactsQuery, ContactsQueryVariables>(ContactsDocument, options)
}
export function useContactsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<ContactsQuery, ContactsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ContactsQuery, ContactsQueryVariables>(
    ContactsDocument,
    options,
  )
}
export type ContactsQueryHookResult = ReturnType<typeof useContactsQuery>
export type ContactsLazyQueryHookResult = ReturnType<typeof useContactsLazyQuery>
export type ContactsQueryResult = Apollo.QueryResult<
  ContactsQuery,
  ContactsQueryVariables
>
export const UserContactUpdateAliasDocument = gql`
  mutation userContactUpdateAlias($input: UserContactUpdateAliasInput!) {
    userContactUpdateAlias(input: $input) {
      errors {
        message
      }
      contact {
        alias
        id
      }
    }
  }
`
export type UserContactUpdateAliasMutationFn = Apollo.MutationFunction<
  UserContactUpdateAliasMutation,
  UserContactUpdateAliasMutationVariables
>

/**
 * __useUserContactUpdateAliasMutation__
 *
 * To run a mutation, you first call `useUserContactUpdateAliasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserContactUpdateAliasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userContactUpdateAliasMutation, { data, loading, error }] = useUserContactUpdateAliasMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserContactUpdateAliasMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserContactUpdateAliasMutation,
    UserContactUpdateAliasMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserContactUpdateAliasMutation,
    UserContactUpdateAliasMutationVariables
  >(UserContactUpdateAliasDocument, options)
}
export type UserContactUpdateAliasMutationHookResult = ReturnType<
  typeof useUserContactUpdateAliasMutation
>
export type UserContactUpdateAliasMutationResult =
  Apollo.MutationResult<UserContactUpdateAliasMutation>
export type UserContactUpdateAliasMutationOptions = Apollo.BaseMutationOptions<
  UserContactUpdateAliasMutation,
  UserContactUpdateAliasMutationVariables
>
export const UserLogoutDocument = gql`
  mutation userLogout($input: UserLogoutInput!) {
    userLogout(input: $input) {
      success
    }
  }
`
export type UserLogoutMutationFn = Apollo.MutationFunction<
  UserLogoutMutation,
  UserLogoutMutationVariables
>

/**
 * __useUserLogoutMutation__
 *
 * To run a mutation, you first call `useUserLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userLogoutMutation, { data, loading, error }] = useUserLogoutMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserLogoutMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserLogoutMutation,
    UserLogoutMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserLogoutMutation, UserLogoutMutationVariables>(
    UserLogoutDocument,
    options,
  )
}
export type UserLogoutMutationHookResult = ReturnType<typeof useUserLogoutMutation>
export type UserLogoutMutationResult = Apollo.MutationResult<UserLogoutMutation>
export type UserLogoutMutationOptions = Apollo.BaseMutationOptions<
  UserLogoutMutation,
  UserLogoutMutationVariables
>
export const ConversionScreenDocument = gql`
  query conversionScreen {
    me {
      id
      defaultAccount {
        id
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
`

/**
 * __useConversionScreenQuery__
 *
 * To run a query within a React component, call `useConversionScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useConversionScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConversionScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useConversionScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<
    ConversionScreenQuery,
    ConversionScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ConversionScreenQuery, ConversionScreenQueryVariables>(
    ConversionScreenDocument,
    options,
  )
}
export function useConversionScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    ConversionScreenQuery,
    ConversionScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<ConversionScreenQuery, ConversionScreenQueryVariables>(
    ConversionScreenDocument,
    options,
  )
}
export type ConversionScreenQueryHookResult = ReturnType<typeof useConversionScreenQuery>
export type ConversionScreenLazyQueryHookResult = ReturnType<
  typeof useConversionScreenLazyQuery
>
export type ConversionScreenQueryResult = Apollo.QueryResult<
  ConversionScreenQuery,
  ConversionScreenQueryVariables
>
export const QuizSatsDocument = gql`
  query quizSats {
    quizQuestions {
      id
      earnAmount
    }
  }
`

/**
 * __useQuizSatsQuery__
 *
 * To run a query within a React component, call `useQuizSatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useQuizSatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useQuizSatsQuery({
 *   variables: {
 *   },
 * });
 */
export function useQuizSatsQuery(
  baseOptions?: Apollo.QueryHookOptions<QuizSatsQuery, QuizSatsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<QuizSatsQuery, QuizSatsQueryVariables>(QuizSatsDocument, options)
}
export function useQuizSatsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<QuizSatsQuery, QuizSatsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<QuizSatsQuery, QuizSatsQueryVariables>(
    QuizSatsDocument,
    options,
  )
}
export type QuizSatsQueryHookResult = ReturnType<typeof useQuizSatsQuery>
export type QuizSatsLazyQueryHookResult = ReturnType<typeof useQuizSatsLazyQuery>
export type QuizSatsQueryResult = Apollo.QueryResult<
  QuizSatsQuery,
  QuizSatsQueryVariables
>
export const MyQuizQuestionsDocument = gql`
  query myQuizQuestions {
    me {
      id
      defaultAccount {
        id
        ... on ConsumerAccount {
          quiz {
            id
            amount
            completed
          }
        }
      }
    }
  }
`

/**
 * __useMyQuizQuestionsQuery__
 *
 * To run a query within a React component, call `useMyQuizQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyQuizQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyQuizQuestionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useMyQuizQuestionsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    MyQuizQuestionsQuery,
    MyQuizQuestionsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>(
    MyQuizQuestionsDocument,
    options,
  )
}
export function useMyQuizQuestionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    MyQuizQuestionsQuery,
    MyQuizQuestionsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>(
    MyQuizQuestionsDocument,
    options,
  )
}
export type MyQuizQuestionsQueryHookResult = ReturnType<typeof useMyQuizQuestionsQuery>
export type MyQuizQuestionsLazyQueryHookResult = ReturnType<
  typeof useMyQuizQuestionsLazyQuery
>
export type MyQuizQuestionsQueryResult = Apollo.QueryResult<
  MyQuizQuestionsQuery,
  MyQuizQuestionsQueryVariables
>
export const QuizCompletedDocument = gql`
  mutation quizCompleted($input: QuizCompletedInput!) {
    quizCompleted(input: $input) {
      errors {
        message
      }
      quiz {
        id
        completed
      }
    }
  }
`
export type QuizCompletedMutationFn = Apollo.MutationFunction<
  QuizCompletedMutation,
  QuizCompletedMutationVariables
>

/**
 * __useQuizCompletedMutation__
 *
 * To run a mutation, you first call `useQuizCompletedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useQuizCompletedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [quizCompletedMutation, { data, loading, error }] = useQuizCompletedMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useQuizCompletedMutation(
  baseOptions?: Apollo.MutationHookOptions<
    QuizCompletedMutation,
    QuizCompletedMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<QuizCompletedMutation, QuizCompletedMutationVariables>(
    QuizCompletedDocument,
    options,
  )
}
export type QuizCompletedMutationHookResult = ReturnType<typeof useQuizCompletedMutation>
export type QuizCompletedMutationResult = Apollo.MutationResult<QuizCompletedMutation>
export type QuizCompletedMutationOptions = Apollo.BaseMutationOptions<
  QuizCompletedMutation,
  QuizCompletedMutationVariables
>
export const UserEmailRegistrationInitiateDocument = gql`
  mutation userEmailRegistrationInitiate($input: UserEmailRegistrationInitiateInput!) {
    userEmailRegistrationInitiate(input: $input) {
      errors {
        message
      }
      emailRegistrationId
      me {
        id
        email {
          address
          verified
        }
      }
    }
  }
`
export type UserEmailRegistrationInitiateMutationFn = Apollo.MutationFunction<
  UserEmailRegistrationInitiateMutation,
  UserEmailRegistrationInitiateMutationVariables
>

/**
 * __useUserEmailRegistrationInitiateMutation__
 *
 * To run a mutation, you first call `useUserEmailRegistrationInitiateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailRegistrationInitiateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailRegistrationInitiateMutation, { data, loading, error }] = useUserEmailRegistrationInitiateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserEmailRegistrationInitiateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserEmailRegistrationInitiateMutation,
    UserEmailRegistrationInitiateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserEmailRegistrationInitiateMutation,
    UserEmailRegistrationInitiateMutationVariables
  >(UserEmailRegistrationInitiateDocument, options)
}
export type UserEmailRegistrationInitiateMutationHookResult = ReturnType<
  typeof useUserEmailRegistrationInitiateMutation
>
export type UserEmailRegistrationInitiateMutationResult =
  Apollo.MutationResult<UserEmailRegistrationInitiateMutation>
export type UserEmailRegistrationInitiateMutationOptions = Apollo.BaseMutationOptions<
  UserEmailRegistrationInitiateMutation,
  UserEmailRegistrationInitiateMutationVariables
>
export const UserEmailRegistrationValidateDocument = gql`
  mutation userEmailRegistrationValidate($input: UserEmailRegistrationValidateInput!) {
    userEmailRegistrationValidate(input: $input) {
      errors {
        message
      }
      me {
        id
        email {
          address
          verified
        }
      }
    }
  }
`
export type UserEmailRegistrationValidateMutationFn = Apollo.MutationFunction<
  UserEmailRegistrationValidateMutation,
  UserEmailRegistrationValidateMutationVariables
>

/**
 * __useUserEmailRegistrationValidateMutation__
 *
 * To run a mutation, you first call `useUserEmailRegistrationValidateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailRegistrationValidateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailRegistrationValidateMutation, { data, loading, error }] = useUserEmailRegistrationValidateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserEmailRegistrationValidateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserEmailRegistrationValidateMutation,
    UserEmailRegistrationValidateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserEmailRegistrationValidateMutation,
    UserEmailRegistrationValidateMutationVariables
  >(UserEmailRegistrationValidateDocument, options)
}
export type UserEmailRegistrationValidateMutationHookResult = ReturnType<
  typeof useUserEmailRegistrationValidateMutation
>
export type UserEmailRegistrationValidateMutationResult =
  Apollo.MutationResult<UserEmailRegistrationValidateMutation>
export type UserEmailRegistrationValidateMutationOptions = Apollo.BaseMutationOptions<
  UserEmailRegistrationValidateMutation,
  UserEmailRegistrationValidateMutationVariables
>
export const AddressScreenDocument = gql`
  query addressScreen {
    me {
      id
      username
    }
  }
`

/**
 * __useAddressScreenQuery__
 *
 * To run a query within a React component, call `useAddressScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddressScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddressScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useAddressScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<AddressScreenQuery, AddressScreenQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AddressScreenQuery, AddressScreenQueryVariables>(
    AddressScreenDocument,
    options,
  )
}
export function useAddressScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    AddressScreenQuery,
    AddressScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<AddressScreenQuery, AddressScreenQueryVariables>(
    AddressScreenDocument,
    options,
  )
}
export type AddressScreenQueryHookResult = ReturnType<typeof useAddressScreenQuery>
export type AddressScreenLazyQueryHookResult = ReturnType<
  typeof useAddressScreenLazyQuery
>
export type AddressScreenQueryResult = Apollo.QueryResult<
  AddressScreenQuery,
  AddressScreenQueryVariables
>
export const HomeAuthedDocument = gql`
  query homeAuthed {
    me {
      id
      language
      username
      phone
      email {
        address
        verified
      }
      defaultAccount {
        id
        level
        defaultWalletId
        transactions(first: 20) {
          ...TransactionList
        }
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
  ${TransactionListFragmentDoc}
`

/**
 * __useHomeAuthedQuery__
 *
 * To run a query within a React component, call `useHomeAuthedQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeAuthedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeAuthedQuery({
 *   variables: {
 *   },
 * });
 */
export function useHomeAuthedQuery(
  baseOptions?: Apollo.QueryHookOptions<HomeAuthedQuery, HomeAuthedQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<HomeAuthedQuery, HomeAuthedQueryVariables>(
    HomeAuthedDocument,
    options,
  )
}
export function useHomeAuthedLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<HomeAuthedQuery, HomeAuthedQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<HomeAuthedQuery, HomeAuthedQueryVariables>(
    HomeAuthedDocument,
    options,
  )
}
export type HomeAuthedQueryHookResult = ReturnType<typeof useHomeAuthedQuery>
export type HomeAuthedLazyQueryHookResult = ReturnType<typeof useHomeAuthedLazyQuery>
export type HomeAuthedQueryResult = Apollo.QueryResult<
  HomeAuthedQuery,
  HomeAuthedQueryVariables
>
export const HomeUnauthedDocument = gql`
  query homeUnauthed {
    globals {
      network
    }
    currencyList {
      id
      flag
      name
      symbol
      fractionDigits
    }
  }
`

/**
 * __useHomeUnauthedQuery__
 *
 * To run a query within a React component, call `useHomeUnauthedQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeUnauthedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeUnauthedQuery({
 *   variables: {
 *   },
 * });
 */
export function useHomeUnauthedQuery(
  baseOptions?: Apollo.QueryHookOptions<HomeUnauthedQuery, HomeUnauthedQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<HomeUnauthedQuery, HomeUnauthedQueryVariables>(
    HomeUnauthedDocument,
    options,
  )
}
export function useHomeUnauthedLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    HomeUnauthedQuery,
    HomeUnauthedQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<HomeUnauthedQuery, HomeUnauthedQueryVariables>(
    HomeUnauthedDocument,
    options,
  )
}
export type HomeUnauthedQueryHookResult = ReturnType<typeof useHomeUnauthedQuery>
export type HomeUnauthedLazyQueryHookResult = ReturnType<typeof useHomeUnauthedLazyQuery>
export type HomeUnauthedQueryResult = Apollo.QueryResult<
  HomeUnauthedQuery,
  HomeUnauthedQueryVariables
>
export const BulletinsDocument = gql`
  query Bulletins($first: Int!, $after: String) {
    me {
      id
      unacknowledgedStatefulNotificationsWithBulletinEnabled(
        first: $first
        after: $after
      ) {
        pageInfo {
          endCursor
          hasNextPage
          hasPreviousPage
          startCursor
        }
        edges {
          node {
            id
            title
            body
            createdAt
            acknowledgedAt
            bulletinEnabled
            icon
            action {
              ... on OpenDeepLinkAction {
                deepLink
              }
              ... on OpenExternalLinkAction {
                url
              }
            }
          }
          cursor
        }
      }
    }
  }
`

/**
 * __useBulletinsQuery__
 *
 * To run a query within a React component, call `useBulletinsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBulletinsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBulletinsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useBulletinsQuery(
  baseOptions: Apollo.QueryHookOptions<BulletinsQuery, BulletinsQueryVariables> &
    ({ variables: BulletinsQueryVariables; skip?: boolean } | { skip: boolean }),
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BulletinsQuery, BulletinsQueryVariables>(
    BulletinsDocument,
    options,
  )
}
export function useBulletinsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<BulletinsQuery, BulletinsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BulletinsQuery, BulletinsQueryVariables>(
    BulletinsDocument,
    options,
  )
}
export function useBulletinsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<BulletinsQuery, BulletinsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<BulletinsQuery, BulletinsQueryVariables>(
    BulletinsDocument,
    options,
  )
}
export type BulletinsQueryHookResult = ReturnType<typeof useBulletinsQuery>
export type BulletinsLazyQueryHookResult = ReturnType<typeof useBulletinsLazyQuery>
export type BulletinsSuspenseQueryHookResult = ReturnType<
  typeof useBulletinsSuspenseQuery
>
export type BulletinsQueryResult = Apollo.QueryResult<
  BulletinsQuery,
  BulletinsQueryVariables
>
export const BusinessMapMarkersDocument = gql`
  query businessMapMarkers {
    businessMapMarkers {
      username
      mapInfo {
        title
        coordinates {
          longitude
          latitude
        }
      }
    }
  }
`

/**
 * __useBusinessMapMarkersQuery__
 *
 * To run a query within a React component, call `useBusinessMapMarkersQuery` and pass it any options that fit your needs.
 * When your component renders, `useBusinessMapMarkersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBusinessMapMarkersQuery({
 *   variables: {
 *   },
 * });
 */
export function useBusinessMapMarkersQuery(
  baseOptions?: Apollo.QueryHookOptions<
    BusinessMapMarkersQuery,
    BusinessMapMarkersQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>(
    BusinessMapMarkersDocument,
    options,
  )
}
export function useBusinessMapMarkersLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    BusinessMapMarkersQuery,
    BusinessMapMarkersQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>(
    BusinessMapMarkersDocument,
    options,
  )
}
export type BusinessMapMarkersQueryHookResult = ReturnType<
  typeof useBusinessMapMarkersQuery
>
export type BusinessMapMarkersLazyQueryHookResult = ReturnType<
  typeof useBusinessMapMarkersLazyQuery
>
export type BusinessMapMarkersQueryResult = Apollo.QueryResult<
  BusinessMapMarkersQuery,
  BusinessMapMarkersQueryVariables
>

export const StatefulNotificationsDocument = gql`
  query StatefulNotifications($after: String) {
    me {
      statefulNotificationsWithoutBulletinEnabled(first: 20, after: $after) {
        nodes {
          id
          title
          body
          createdAt
          acknowledgedAt
          bulletinEnabled
          icon
          action {
            ... on OpenDeepLinkAction {
              deepLink
            }
            ... on OpenExternalLinkAction {
              url
            }
          }
        }
        pageInfo {
          endCursor
          hasNextPage
          hasPreviousPage
          startCursor
        }
      }
    }
  }
`

/**
 * __useStatefulNotificationsQuery__
 *
 * To run a query within a React component, call `useStatefulNotificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStatefulNotificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStatefulNotificationsQuery({
 *   variables: {
 *      after: // value for 'after'
 *   },
 * });
 */
export function useStatefulNotificationsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    StatefulNotificationsQuery,
    StatefulNotificationsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<StatefulNotificationsQuery, StatefulNotificationsQueryVariables>(
    StatefulNotificationsDocument,
    options,
  )
}
export function useStatefulNotificationsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    StatefulNotificationsQuery,
    StatefulNotificationsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    StatefulNotificationsQuery,
    StatefulNotificationsQueryVariables
  >(StatefulNotificationsDocument, options)
}
export function useStatefulNotificationsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    StatefulNotificationsQuery,
    StatefulNotificationsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<
    StatefulNotificationsQuery,
    StatefulNotificationsQueryVariables
  >(StatefulNotificationsDocument, options)
}
export type StatefulNotificationsQueryHookResult = ReturnType<
  typeof useStatefulNotificationsQuery
>
export type StatefulNotificationsLazyQueryHookResult = ReturnType<
  typeof useStatefulNotificationsLazyQuery
>
export type StatefulNotificationsSuspenseQueryHookResult = ReturnType<
  typeof useStatefulNotificationsSuspenseQuery
>
export type StatefulNotificationsQueryResult = Apollo.QueryResult<
  StatefulNotificationsQuery,
  StatefulNotificationsQueryVariables
>
export const StatefulNotificationAcknowledgeDocument = gql`
  mutation StatefulNotificationAcknowledge(
    $input: StatefulNotificationAcknowledgeInput!
  ) {
    statefulNotificationAcknowledge(input: $input) {
      notification {
        acknowledgedAt
      }
    }
  }
`
export type StatefulNotificationAcknowledgeMutationFn = Apollo.MutationFunction<
  StatefulNotificationAcknowledgeMutation,
  StatefulNotificationAcknowledgeMutationVariables
>

/**
 * __useStatefulNotificationAcknowledgeMutation__
 *
 * To run a mutation, you first call `useStatefulNotificationAcknowledgeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStatefulNotificationAcknowledgeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [statefulNotificationAcknowledgeMutation, { data, loading, error }] = useStatefulNotificationAcknowledgeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useStatefulNotificationAcknowledgeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    StatefulNotificationAcknowledgeMutation,
    StatefulNotificationAcknowledgeMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    StatefulNotificationAcknowledgeMutation,
    StatefulNotificationAcknowledgeMutationVariables
  >(StatefulNotificationAcknowledgeDocument, options)
}
export type StatefulNotificationAcknowledgeMutationHookResult = ReturnType<
  typeof useStatefulNotificationAcknowledgeMutation
>
export type StatefulNotificationAcknowledgeMutationResult =
  Apollo.MutationResult<StatefulNotificationAcknowledgeMutation>
export type StatefulNotificationAcknowledgeMutationOptions = Apollo.BaseMutationOptions<
  StatefulNotificationAcknowledgeMutation,
  StatefulNotificationAcknowledgeMutationVariables
>

export const UserLoginDocument = gql`
  mutation userLogin($input: UserLoginInput!) {
    userLogin(input: $input) {
      errors {
        message
        code
      }
      authToken
      totpRequired
    }
  }
`
export type UserLoginMutationFn = Apollo.MutationFunction<
  UserLoginMutation,
  UserLoginMutationVariables
>

/**
 * __useUserLoginMutation__
 *
 * To run a mutation, you first call `useUserLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userLoginMutation, { data, loading, error }] = useUserLoginMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserLoginMutation(
  baseOptions?: Apollo.MutationHookOptions<UserLoginMutation, UserLoginMutationVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserLoginMutation, UserLoginMutationVariables>(
    UserLoginDocument,
    options,
  )
}
export type UserLoginMutationHookResult = ReturnType<typeof useUserLoginMutation>
export type UserLoginMutationResult = Apollo.MutationResult<UserLoginMutation>
export type UserLoginMutationOptions = Apollo.BaseMutationOptions<
  UserLoginMutation,
  UserLoginMutationVariables
>
export const UserLoginUpgradeDocument = gql`
  mutation userLoginUpgrade($input: UserLoginUpgradeInput!) {
    userLoginUpgrade(input: $input) {
      errors {
        message
        code
      }
      success
      authToken
    }
  }
`
export type UserLoginUpgradeMutationFn = Apollo.MutationFunction<
  UserLoginUpgradeMutation,
  UserLoginUpgradeMutationVariables
>

/**
 * __useUserLoginUpgradeMutation__
 *
 * To run a mutation, you first call `useUserLoginUpgradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserLoginUpgradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userLoginUpgradeMutation, { data, loading, error }] = useUserLoginUpgradeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserLoginUpgradeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserLoginUpgradeMutation,
    UserLoginUpgradeMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserLoginUpgradeMutation, UserLoginUpgradeMutationVariables>(
    UserLoginUpgradeDocument,
    options,
  )
}
export type UserLoginUpgradeMutationHookResult = ReturnType<
  typeof useUserLoginUpgradeMutation
>
export type UserLoginUpgradeMutationResult =
  Apollo.MutationResult<UserLoginUpgradeMutation>
export type UserLoginUpgradeMutationOptions = Apollo.BaseMutationOptions<
  UserLoginUpgradeMutation,
  UserLoginUpgradeMutationVariables
>
export const UserPhoneRegistrationValidateDocument = gql`
  mutation userPhoneRegistrationValidate($input: UserPhoneRegistrationValidateInput!) {
    userPhoneRegistrationValidate(input: $input) {
      errors {
        message
        code
      }
      me {
        id
        phone
        email {
          address
          verified
        }
      }
    }
  }
`
export type UserPhoneRegistrationValidateMutationFn = Apollo.MutationFunction<
  UserPhoneRegistrationValidateMutation,
  UserPhoneRegistrationValidateMutationVariables
>

/**
 * __useUserPhoneRegistrationValidateMutation__
 *
 * To run a mutation, you first call `useUserPhoneRegistrationValidateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPhoneRegistrationValidateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPhoneRegistrationValidateMutation, { data, loading, error }] = useUserPhoneRegistrationValidateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserPhoneRegistrationValidateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserPhoneRegistrationValidateMutation,
    UserPhoneRegistrationValidateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserPhoneRegistrationValidateMutation,
    UserPhoneRegistrationValidateMutationVariables
  >(UserPhoneRegistrationValidateDocument, options)
}
export type UserPhoneRegistrationValidateMutationHookResult = ReturnType<
  typeof useUserPhoneRegistrationValidateMutation
>
export type UserPhoneRegistrationValidateMutationResult =
  Apollo.MutationResult<UserPhoneRegistrationValidateMutation>
export type UserPhoneRegistrationValidateMutationOptions = Apollo.BaseMutationOptions<
  UserPhoneRegistrationValidateMutation,
  UserPhoneRegistrationValidateMutationVariables
>
export const CaptchaRequestAuthCodeDocument = gql`
  mutation captchaRequestAuthCode($input: CaptchaRequestAuthCodeInput!) {
    captchaRequestAuthCode(input: $input) {
      errors {
        message
        code
      }
      success
    }
  }
`
export type CaptchaRequestAuthCodeMutationFn = Apollo.MutationFunction<
  CaptchaRequestAuthCodeMutation,
  CaptchaRequestAuthCodeMutationVariables
>

/**
 * __useCaptchaRequestAuthCodeMutation__
 *
 * To run a mutation, you first call `useCaptchaRequestAuthCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCaptchaRequestAuthCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [captchaRequestAuthCodeMutation, { data, loading, error }] = useCaptchaRequestAuthCodeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCaptchaRequestAuthCodeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    CaptchaRequestAuthCodeMutation,
    CaptchaRequestAuthCodeMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    CaptchaRequestAuthCodeMutation,
    CaptchaRequestAuthCodeMutationVariables
  >(CaptchaRequestAuthCodeDocument, options)
}
export type CaptchaRequestAuthCodeMutationHookResult = ReturnType<
  typeof useCaptchaRequestAuthCodeMutation
>
export type CaptchaRequestAuthCodeMutationResult =
  Apollo.MutationResult<CaptchaRequestAuthCodeMutation>
export type CaptchaRequestAuthCodeMutationOptions = Apollo.BaseMutationOptions<
  CaptchaRequestAuthCodeMutation,
  CaptchaRequestAuthCodeMutationVariables
>
export const SupportedCountriesDocument = gql`
  query supportedCountries {
    globals {
      supportedCountries {
        id
        supportedAuthChannels
      }
    }
  }
`

/**
 * __useSupportedCountriesQuery__
 *
 * To run a query within a React component, call `useSupportedCountriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSupportedCountriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSupportedCountriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useSupportedCountriesQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SupportedCountriesQuery,
    SupportedCountriesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<SupportedCountriesQuery, SupportedCountriesQueryVariables>(
    SupportedCountriesDocument,
    options,
  )
}
export function useSupportedCountriesLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SupportedCountriesQuery,
    SupportedCountriesQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<SupportedCountriesQuery, SupportedCountriesQueryVariables>(
    SupportedCountriesDocument,
    options,
  )
}
export type SupportedCountriesQueryHookResult = ReturnType<
  typeof useSupportedCountriesQuery
>
export type SupportedCountriesLazyQueryHookResult = ReturnType<
  typeof useSupportedCountriesLazyQuery
>
export type SupportedCountriesQueryResult = Apollo.QueryResult<
  SupportedCountriesQuery,
  SupportedCountriesQueryVariables
>
export const UserPhoneRegistrationInitiateDocument = gql`
  mutation userPhoneRegistrationInitiate($input: UserPhoneRegistrationInitiateInput!) {
    userPhoneRegistrationInitiate(input: $input) {
      errors {
        message
      }
      success
    }
  }
`
export type UserPhoneRegistrationInitiateMutationFn = Apollo.MutationFunction<
  UserPhoneRegistrationInitiateMutation,
  UserPhoneRegistrationInitiateMutationVariables
>

/**
 * __useUserPhoneRegistrationInitiateMutation__
 *
 * To run a mutation, you first call `useUserPhoneRegistrationInitiateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPhoneRegistrationInitiateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPhoneRegistrationInitiateMutation, { data, loading, error }] = useUserPhoneRegistrationInitiateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserPhoneRegistrationInitiateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserPhoneRegistrationInitiateMutation,
    UserPhoneRegistrationInitiateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserPhoneRegistrationInitiateMutation,
    UserPhoneRegistrationInitiateMutationVariables
  >(UserPhoneRegistrationInitiateDocument, options)
}
export type UserPhoneRegistrationInitiateMutationHookResult = ReturnType<
  typeof useUserPhoneRegistrationInitiateMutation
>
export type UserPhoneRegistrationInitiateMutationResult =
  Apollo.MutationResult<UserPhoneRegistrationInitiateMutation>
export type UserPhoneRegistrationInitiateMutationOptions = Apollo.BaseMutationOptions<
  UserPhoneRegistrationInitiateMutation,
  UserPhoneRegistrationInitiateMutationVariables
>
export const MyLnUpdatesDocument = gql`
  subscription myLnUpdates {
    myUpdates {
      errors {
        message
      }
      update {
        ... on LnUpdate {
          paymentHash
          status
        }
      }
    }
  }
`

/**
 * __useMyLnUpdatesSubscription__
 *
 * To run a query within a React component, call `useMyLnUpdatesSubscription` and pass it any options that fit your needs.
 * When your component renders, `useMyLnUpdatesSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyLnUpdatesSubscription({
 *   variables: {
 *   },
 * });
 */
export function useMyLnUpdatesSubscription(
  baseOptions?: Apollo.SubscriptionHookOptions<
    MyLnUpdatesSubscription,
    MyLnUpdatesSubscriptionVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSubscription<
    MyLnUpdatesSubscription,
    MyLnUpdatesSubscriptionVariables
  >(MyLnUpdatesDocument, options)
}
export type MyLnUpdatesSubscriptionHookResult = ReturnType<
  typeof useMyLnUpdatesSubscription
>
export type MyLnUpdatesSubscriptionResult =
  Apollo.SubscriptionResult<MyLnUpdatesSubscription>
export const PaymentRequestDocument = gql`
  query paymentRequest {
    globals {
      network
      feesInformation {
        deposit {
          minBankFee
          minBankFeeThreshold
        }
      }
    }
    me {
      id
      username
      defaultAccount {
        id
        wallets {
          id
          balance
          walletCurrency
        }
        defaultWalletId
      }
    }
  }
`

/**
 * __usePaymentRequestQuery__
 *
 * To run a query within a React component, call `usePaymentRequestQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentRequestQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentRequestQuery({
 *   variables: {
 *   },
 * });
 */
export function usePaymentRequestQuery(
  baseOptions?: Apollo.QueryHookOptions<
    PaymentRequestQuery,
    PaymentRequestQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<PaymentRequestQuery, PaymentRequestQueryVariables>(
    PaymentRequestDocument,
    options,
  )
}
export function usePaymentRequestLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    PaymentRequestQuery,
    PaymentRequestQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<PaymentRequestQuery, PaymentRequestQueryVariables>(
    PaymentRequestDocument,
    options,
  )
}
export type PaymentRequestQueryHookResult = ReturnType<typeof usePaymentRequestQuery>
export type PaymentRequestLazyQueryHookResult = ReturnType<
  typeof usePaymentRequestLazyQuery
>
export type PaymentRequestQueryResult = Apollo.QueryResult<
  PaymentRequestQuery,
  PaymentRequestQueryVariables
>
export const LnNoAmountInvoiceCreateDocument = gql`
  mutation lnNoAmountInvoiceCreate($input: LnNoAmountInvoiceCreateInput!) {
    lnNoAmountInvoiceCreate(input: $input) {
      errors {
        message
      }
      invoice {
        paymentHash
        paymentRequest
        paymentSecret
      }
    }
  }
`
export type LnNoAmountInvoiceCreateMutationFn = Apollo.MutationFunction<
  LnNoAmountInvoiceCreateMutation,
  LnNoAmountInvoiceCreateMutationVariables
>

/**
 * __useLnNoAmountInvoiceCreateMutation__
 *
 * To run a mutation, you first call `useLnNoAmountInvoiceCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountInvoiceCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountInvoiceCreateMutation, { data, loading, error }] = useLnNoAmountInvoiceCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountInvoiceCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnNoAmountInvoiceCreateMutation,
    LnNoAmountInvoiceCreateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnNoAmountInvoiceCreateMutation,
    LnNoAmountInvoiceCreateMutationVariables
  >(LnNoAmountInvoiceCreateDocument, options)
}
export type LnNoAmountInvoiceCreateMutationHookResult = ReturnType<
  typeof useLnNoAmountInvoiceCreateMutation
>
export type LnNoAmountInvoiceCreateMutationResult =
  Apollo.MutationResult<LnNoAmountInvoiceCreateMutation>
export type LnNoAmountInvoiceCreateMutationOptions = Apollo.BaseMutationOptions<
  LnNoAmountInvoiceCreateMutation,
  LnNoAmountInvoiceCreateMutationVariables
>
export const LnInvoiceCreateDocument = gql`
  mutation lnInvoiceCreate($input: LnInvoiceCreateInput!) {
    lnInvoiceCreate(input: $input) {
      errors {
        message
      }
      invoice {
        paymentHash
        paymentRequest
        paymentSecret
        satoshis
      }
    }
  }
`
export type LnInvoiceCreateMutationFn = Apollo.MutationFunction<
  LnInvoiceCreateMutation,
  LnInvoiceCreateMutationVariables
>

/**
 * __useLnInvoiceCreateMutation__
 *
 * To run a mutation, you first call `useLnInvoiceCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoiceCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoiceCreateMutation, { data, loading, error }] = useLnInvoiceCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoiceCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnInvoiceCreateMutation,
    LnInvoiceCreateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<LnInvoiceCreateMutation, LnInvoiceCreateMutationVariables>(
    LnInvoiceCreateDocument,
    options,
  )
}
export type LnInvoiceCreateMutationHookResult = ReturnType<
  typeof useLnInvoiceCreateMutation
>
export type LnInvoiceCreateMutationResult = Apollo.MutationResult<LnInvoiceCreateMutation>
export type LnInvoiceCreateMutationOptions = Apollo.BaseMutationOptions<
  LnInvoiceCreateMutation,
  LnInvoiceCreateMutationVariables
>
export const OnChainAddressCurrentDocument = gql`
  mutation onChainAddressCurrent($input: OnChainAddressCurrentInput!) {
    onChainAddressCurrent(input: $input) {
      errors {
        message
      }
      address
    }
  }
`
export type OnChainAddressCurrentMutationFn = Apollo.MutationFunction<
  OnChainAddressCurrentMutation,
  OnChainAddressCurrentMutationVariables
>

/**
 * __useOnChainAddressCurrentMutation__
 *
 * To run a mutation, you first call `useOnChainAddressCurrentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainAddressCurrentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainAddressCurrentMutation, { data, loading, error }] = useOnChainAddressCurrentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainAddressCurrentMutation(
  baseOptions?: Apollo.MutationHookOptions<
    OnChainAddressCurrentMutation,
    OnChainAddressCurrentMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    OnChainAddressCurrentMutation,
    OnChainAddressCurrentMutationVariables
  >(OnChainAddressCurrentDocument, options)
}
export type OnChainAddressCurrentMutationHookResult = ReturnType<
  typeof useOnChainAddressCurrentMutation
>
export type OnChainAddressCurrentMutationResult =
  Apollo.MutationResult<OnChainAddressCurrentMutation>
export type OnChainAddressCurrentMutationOptions = Apollo.BaseMutationOptions<
  OnChainAddressCurrentMutation,
  OnChainAddressCurrentMutationVariables
>
export const LnUsdInvoiceCreateDocument = gql`
  mutation lnUsdInvoiceCreate($input: LnUsdInvoiceCreateInput!) {
    lnUsdInvoiceCreate(input: $input) {
      errors {
        message
      }
      invoice {
        paymentHash
        paymentRequest
        paymentSecret
        satoshis
      }
    }
  }
`
export type LnUsdInvoiceCreateMutationFn = Apollo.MutationFunction<
  LnUsdInvoiceCreateMutation,
  LnUsdInvoiceCreateMutationVariables
>

/**
 * __useLnUsdInvoiceCreateMutation__
 *
 * To run a mutation, you first call `useLnUsdInvoiceCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnUsdInvoiceCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnUsdInvoiceCreateMutation, { data, loading, error }] = useLnUsdInvoiceCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnUsdInvoiceCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnUsdInvoiceCreateMutation,
    LnUsdInvoiceCreateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnUsdInvoiceCreateMutation,
    LnUsdInvoiceCreateMutationVariables
  >(LnUsdInvoiceCreateDocument, options)
}
export type LnUsdInvoiceCreateMutationHookResult = ReturnType<
  typeof useLnUsdInvoiceCreateMutation
>
export type LnUsdInvoiceCreateMutationResult =
  Apollo.MutationResult<LnUsdInvoiceCreateMutation>
export type LnUsdInvoiceCreateMutationOptions = Apollo.BaseMutationOptions<
  LnUsdInvoiceCreateMutation,
  LnUsdInvoiceCreateMutationVariables
>
export const ScanningQrCodeScreenDocument = gql`
  query scanningQRCodeScreen {
    globals {
      network
    }
    me {
      id
      defaultAccount {
        id
        wallets {
          id
        }
      }
      contacts {
        id
        username
      }
    }
  }
`

/**
 * __useScanningQrCodeScreenQuery__
 *
 * To run a query within a React component, call `useScanningQrCodeScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useScanningQrCodeScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScanningQrCodeScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useScanningQrCodeScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<
    ScanningQrCodeScreenQuery,
    ScanningQrCodeScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<ScanningQrCodeScreenQuery, ScanningQrCodeScreenQueryVariables>(
    ScanningQrCodeScreenDocument,
    options,
  )
}
export function useScanningQrCodeScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    ScanningQrCodeScreenQuery,
    ScanningQrCodeScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    ScanningQrCodeScreenQuery,
    ScanningQrCodeScreenQueryVariables
  >(ScanningQrCodeScreenDocument, options)
}
export type ScanningQrCodeScreenQueryHookResult = ReturnType<
  typeof useScanningQrCodeScreenQuery
>
export type ScanningQrCodeScreenLazyQueryHookResult = ReturnType<
  typeof useScanningQrCodeScreenLazyQuery
>
export type ScanningQrCodeScreenQueryResult = Apollo.QueryResult<
  ScanningQrCodeScreenQuery,
  ScanningQrCodeScreenQueryVariables
>
export const SendBitcoinConfirmationScreenDocument = gql`
  query sendBitcoinConfirmationScreen {
    me {
      id
      defaultAccount {
        id
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
`

/**
 * __useSendBitcoinConfirmationScreenQuery__
 *
 * To run a query within a React component, call `useSendBitcoinConfirmationScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinConfirmationScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinConfirmationScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinConfirmationScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SendBitcoinConfirmationScreenQuery,
    SendBitcoinConfirmationScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    SendBitcoinConfirmationScreenQuery,
    SendBitcoinConfirmationScreenQueryVariables
  >(SendBitcoinConfirmationScreenDocument, options)
}
export function useSendBitcoinConfirmationScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SendBitcoinConfirmationScreenQuery,
    SendBitcoinConfirmationScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SendBitcoinConfirmationScreenQuery,
    SendBitcoinConfirmationScreenQueryVariables
  >(SendBitcoinConfirmationScreenDocument, options)
}
export type SendBitcoinConfirmationScreenQueryHookResult = ReturnType<
  typeof useSendBitcoinConfirmationScreenQuery
>
export type SendBitcoinConfirmationScreenLazyQueryHookResult = ReturnType<
  typeof useSendBitcoinConfirmationScreenLazyQuery
>
export type SendBitcoinConfirmationScreenQueryResult = Apollo.QueryResult<
  SendBitcoinConfirmationScreenQuery,
  SendBitcoinConfirmationScreenQueryVariables
>
export const SendBitcoinDestinationDocument = gql`
  query sendBitcoinDestination {
    globals {
      network
    }
    me {
      id
      defaultAccount {
        id
        wallets {
          id
        }
      }
      contacts {
        id
        username
      }
    }
  }
`

/**
 * __useSendBitcoinDestinationQuery__
 *
 * To run a query within a React component, call `useSendBitcoinDestinationQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinDestinationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinDestinationQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinDestinationQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SendBitcoinDestinationQuery,
    SendBitcoinDestinationQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    SendBitcoinDestinationQuery,
    SendBitcoinDestinationQueryVariables
  >(SendBitcoinDestinationDocument, options)
}
export function useSendBitcoinDestinationLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SendBitcoinDestinationQuery,
    SendBitcoinDestinationQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SendBitcoinDestinationQuery,
    SendBitcoinDestinationQueryVariables
  >(SendBitcoinDestinationDocument, options)
}
export type SendBitcoinDestinationQueryHookResult = ReturnType<
  typeof useSendBitcoinDestinationQuery
>
export type SendBitcoinDestinationLazyQueryHookResult = ReturnType<
  typeof useSendBitcoinDestinationLazyQuery
>
export type SendBitcoinDestinationQueryResult = Apollo.QueryResult<
  SendBitcoinDestinationQuery,
  SendBitcoinDestinationQueryVariables
>

export const AccountDefaultWalletDocument = gql`
  query accountDefaultWallet($username: Username!) {
    accountDefaultWallet(username: $username) {
      id
      walletCurrency
      lnurlp
    }
  }
`

/**
 * __useAccountDefaultWalletQuery__
 *
 * To run a query within a React component, call `useAccountDefaultWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountDefaultWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDefaultWalletQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useAccountDefaultWalletQuery(
  baseOptions: Apollo.QueryHookOptions<
    AccountDefaultWalletQuery,
    AccountDefaultWalletQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>(
    AccountDefaultWalletDocument,
    options,
  )
}
export function useAccountDefaultWalletLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    AccountDefaultWalletQuery,
    AccountDefaultWalletQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    AccountDefaultWalletQuery,
    AccountDefaultWalletQueryVariables
  >(AccountDefaultWalletDocument, options)
}
export type AccountDefaultWalletQueryHookResult = ReturnType<
  typeof useAccountDefaultWalletQuery
>
export type AccountDefaultWalletLazyQueryHookResult = ReturnType<
  typeof useAccountDefaultWalletLazyQuery
>
export type AccountDefaultWalletQueryResult = Apollo.QueryResult<
  AccountDefaultWalletQuery,
  AccountDefaultWalletQueryVariables
>
export const SendBitcoinDetailsScreenDocument = gql`
  query sendBitcoinDetailsScreen {
    globals {
      network
    }
    me {
      id
      defaultAccount {
        id
        defaultWalletId
        wallets {
          id
          walletCurrency
          balance
        }
      }
    }
  }
`

/**
 * __useSendBitcoinDetailsScreenQuery__
 *
 * To run a query within a React component, call `useSendBitcoinDetailsScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinDetailsScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinDetailsScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinDetailsScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SendBitcoinDetailsScreenQuery,
    SendBitcoinDetailsScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    SendBitcoinDetailsScreenQuery,
    SendBitcoinDetailsScreenQueryVariables
  >(SendBitcoinDetailsScreenDocument, options)
}
export function useSendBitcoinDetailsScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SendBitcoinDetailsScreenQuery,
    SendBitcoinDetailsScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SendBitcoinDetailsScreenQuery,
    SendBitcoinDetailsScreenQueryVariables
  >(SendBitcoinDetailsScreenDocument, options)
}
export type SendBitcoinDetailsScreenQueryHookResult = ReturnType<
  typeof useSendBitcoinDetailsScreenQuery
>
export type SendBitcoinDetailsScreenLazyQueryHookResult = ReturnType<
  typeof useSendBitcoinDetailsScreenLazyQuery
>
export type SendBitcoinDetailsScreenQueryResult = Apollo.QueryResult<
  SendBitcoinDetailsScreenQuery,
  SendBitcoinDetailsScreenQueryVariables
>
export const SendBitcoinWithdrawalLimitsDocument = gql`
  query sendBitcoinWithdrawalLimits {
    me {
      id
      defaultAccount {
        id
        limits {
          withdrawal {
            totalLimit
            remainingLimit
            interval
          }
        }
      }
    }
  }
`

/**
 * __useSendBitcoinWithdrawalLimitsQuery__
 *
 * To run a query within a React component, call `useSendBitcoinWithdrawalLimitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinWithdrawalLimitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinWithdrawalLimitsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinWithdrawalLimitsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SendBitcoinWithdrawalLimitsQuery,
    SendBitcoinWithdrawalLimitsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    SendBitcoinWithdrawalLimitsQuery,
    SendBitcoinWithdrawalLimitsQueryVariables
  >(SendBitcoinWithdrawalLimitsDocument, options)
}
export function useSendBitcoinWithdrawalLimitsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SendBitcoinWithdrawalLimitsQuery,
    SendBitcoinWithdrawalLimitsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SendBitcoinWithdrawalLimitsQuery,
    SendBitcoinWithdrawalLimitsQueryVariables
  >(SendBitcoinWithdrawalLimitsDocument, options)
}
export type SendBitcoinWithdrawalLimitsQueryHookResult = ReturnType<
  typeof useSendBitcoinWithdrawalLimitsQuery
>
export type SendBitcoinWithdrawalLimitsLazyQueryHookResult = ReturnType<
  typeof useSendBitcoinWithdrawalLimitsLazyQuery
>
export type SendBitcoinWithdrawalLimitsQueryResult = Apollo.QueryResult<
  SendBitcoinWithdrawalLimitsQuery,
  SendBitcoinWithdrawalLimitsQueryVariables
>
export const SendBitcoinInternalLimitsDocument = gql`
  query sendBitcoinInternalLimits {
    me {
      id
      defaultAccount {
        id
        limits {
          internalSend {
            totalLimit
            remainingLimit
            interval
          }
        }
      }
    }
  }
`

/**
 * __useSendBitcoinInternalLimitsQuery__
 *
 * To run a query within a React component, call `useSendBitcoinInternalLimitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinInternalLimitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinInternalLimitsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinInternalLimitsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SendBitcoinInternalLimitsQuery,
    SendBitcoinInternalLimitsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    SendBitcoinInternalLimitsQuery,
    SendBitcoinInternalLimitsQueryVariables
  >(SendBitcoinInternalLimitsDocument, options)
}
export function useSendBitcoinInternalLimitsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SendBitcoinInternalLimitsQuery,
    SendBitcoinInternalLimitsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SendBitcoinInternalLimitsQuery,
    SendBitcoinInternalLimitsQueryVariables
  >(SendBitcoinInternalLimitsDocument, options)
}
export type SendBitcoinInternalLimitsQueryHookResult = ReturnType<
  typeof useSendBitcoinInternalLimitsQuery
>
export type SendBitcoinInternalLimitsLazyQueryHookResult = ReturnType<
  typeof useSendBitcoinInternalLimitsLazyQuery
>
export type SendBitcoinInternalLimitsQueryResult = Apollo.QueryResult<
  SendBitcoinInternalLimitsQuery,
  SendBitcoinInternalLimitsQueryVariables
>
export const FeedbackSubmitDocument = gql`
  mutation feedbackSubmit($input: FeedbackSubmitInput!) {
    feedbackSubmit(input: $input) {
      errors {
        message
        __typename
      }
      success
      __typename
    }
  }
`
export type FeedbackSubmitMutationFn = Apollo.MutationFunction<
  FeedbackSubmitMutation,
  FeedbackSubmitMutationVariables
>

/**
 * __useFeedbackSubmitMutation__
 *
 * To run a mutation, you first call `useFeedbackSubmitMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFeedbackSubmitMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [feedbackSubmitMutation, { data, loading, error }] = useFeedbackSubmitMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFeedbackSubmitMutation(
  baseOptions?: Apollo.MutationHookOptions<
    FeedbackSubmitMutation,
    FeedbackSubmitMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<FeedbackSubmitMutation, FeedbackSubmitMutationVariables>(
    FeedbackSubmitDocument,
    options,
  )
}
export type FeedbackSubmitMutationHookResult = ReturnType<
  typeof useFeedbackSubmitMutation
>
export type FeedbackSubmitMutationResult = Apollo.MutationResult<FeedbackSubmitMutation>
export type FeedbackSubmitMutationOptions = Apollo.BaseMutationOptions<
  FeedbackSubmitMutation,
  FeedbackSubmitMutationVariables
>
export const LnNoAmountInvoiceFeeProbeDocument = gql`
  mutation lnNoAmountInvoiceFeeProbe($input: LnNoAmountInvoiceFeeProbeInput!) {
    lnNoAmountInvoiceFeeProbe(input: $input) {
      errors {
        message
      }
      amount
    }
  }
`
export type LnNoAmountInvoiceFeeProbeMutationFn = Apollo.MutationFunction<
  LnNoAmountInvoiceFeeProbeMutation,
  LnNoAmountInvoiceFeeProbeMutationVariables
>

/**
 * __useLnNoAmountInvoiceFeeProbeMutation__
 *
 * To run a mutation, you first call `useLnNoAmountInvoiceFeeProbeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountInvoiceFeeProbeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountInvoiceFeeProbeMutation, { data, loading, error }] = useLnNoAmountInvoiceFeeProbeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountInvoiceFeeProbeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnNoAmountInvoiceFeeProbeMutation,
    LnNoAmountInvoiceFeeProbeMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnNoAmountInvoiceFeeProbeMutation,
    LnNoAmountInvoiceFeeProbeMutationVariables
  >(LnNoAmountInvoiceFeeProbeDocument, options)
}
export type LnNoAmountInvoiceFeeProbeMutationHookResult = ReturnType<
  typeof useLnNoAmountInvoiceFeeProbeMutation
>
export type LnNoAmountInvoiceFeeProbeMutationResult =
  Apollo.MutationResult<LnNoAmountInvoiceFeeProbeMutation>
export type LnNoAmountInvoiceFeeProbeMutationOptions = Apollo.BaseMutationOptions<
  LnNoAmountInvoiceFeeProbeMutation,
  LnNoAmountInvoiceFeeProbeMutationVariables
>
export const LnInvoiceFeeProbeDocument = gql`
  mutation lnInvoiceFeeProbe($input: LnInvoiceFeeProbeInput!) {
    lnInvoiceFeeProbe(input: $input) {
      errors {
        message
      }
      amount
    }
  }
`
export type LnInvoiceFeeProbeMutationFn = Apollo.MutationFunction<
  LnInvoiceFeeProbeMutation,
  LnInvoiceFeeProbeMutationVariables
>

/**
 * __useLnInvoiceFeeProbeMutation__
 *
 * To run a mutation, you first call `useLnInvoiceFeeProbeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoiceFeeProbeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoiceFeeProbeMutation, { data, loading, error }] = useLnInvoiceFeeProbeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoiceFeeProbeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnInvoiceFeeProbeMutation,
    LnInvoiceFeeProbeMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnInvoiceFeeProbeMutation,
    LnInvoiceFeeProbeMutationVariables
  >(LnInvoiceFeeProbeDocument, options)
}
export type LnInvoiceFeeProbeMutationHookResult = ReturnType<
  typeof useLnInvoiceFeeProbeMutation
>
export type LnInvoiceFeeProbeMutationResult =
  Apollo.MutationResult<LnInvoiceFeeProbeMutation>
export type LnInvoiceFeeProbeMutationOptions = Apollo.BaseMutationOptions<
  LnInvoiceFeeProbeMutation,
  LnInvoiceFeeProbeMutationVariables
>
export const LnUsdInvoiceFeeProbeDocument = gql`
  mutation lnUsdInvoiceFeeProbe($input: LnUsdInvoiceFeeProbeInput!) {
    lnUsdInvoiceFeeProbe(input: $input) {
      errors {
        message
      }
      amount
    }
  }
`
export type LnUsdInvoiceFeeProbeMutationFn = Apollo.MutationFunction<
  LnUsdInvoiceFeeProbeMutation,
  LnUsdInvoiceFeeProbeMutationVariables
>

/**
 * __useLnUsdInvoiceFeeProbeMutation__
 *
 * To run a mutation, you first call `useLnUsdInvoiceFeeProbeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnUsdInvoiceFeeProbeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnUsdInvoiceFeeProbeMutation, { data, loading, error }] = useLnUsdInvoiceFeeProbeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnUsdInvoiceFeeProbeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnUsdInvoiceFeeProbeMutation,
    LnUsdInvoiceFeeProbeMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnUsdInvoiceFeeProbeMutation,
    LnUsdInvoiceFeeProbeMutationVariables
  >(LnUsdInvoiceFeeProbeDocument, options)
}
export type LnUsdInvoiceFeeProbeMutationHookResult = ReturnType<
  typeof useLnUsdInvoiceFeeProbeMutation
>
export type LnUsdInvoiceFeeProbeMutationResult =
  Apollo.MutationResult<LnUsdInvoiceFeeProbeMutation>
export type LnUsdInvoiceFeeProbeMutationOptions = Apollo.BaseMutationOptions<
  LnUsdInvoiceFeeProbeMutation,
  LnUsdInvoiceFeeProbeMutationVariables
>
export const LnNoAmountUsdInvoiceFeeProbeDocument = gql`
  mutation lnNoAmountUsdInvoiceFeeProbe($input: LnNoAmountUsdInvoiceFeeProbeInput!) {
    lnNoAmountUsdInvoiceFeeProbe(input: $input) {
      errors {
        message
      }
      amount
    }
  }
`
export type LnNoAmountUsdInvoiceFeeProbeMutationFn = Apollo.MutationFunction<
  LnNoAmountUsdInvoiceFeeProbeMutation,
  LnNoAmountUsdInvoiceFeeProbeMutationVariables
>

/**
 * __useLnNoAmountUsdInvoiceFeeProbeMutation__
 *
 * To run a mutation, you first call `useLnNoAmountUsdInvoiceFeeProbeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountUsdInvoiceFeeProbeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountUsdInvoiceFeeProbeMutation, { data, loading, error }] = useLnNoAmountUsdInvoiceFeeProbeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountUsdInvoiceFeeProbeMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnNoAmountUsdInvoiceFeeProbeMutation,
    LnNoAmountUsdInvoiceFeeProbeMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnNoAmountUsdInvoiceFeeProbeMutation,
    LnNoAmountUsdInvoiceFeeProbeMutationVariables
  >(LnNoAmountUsdInvoiceFeeProbeDocument, options)
}
export type LnNoAmountUsdInvoiceFeeProbeMutationHookResult = ReturnType<
  typeof useLnNoAmountUsdInvoiceFeeProbeMutation
>
export type LnNoAmountUsdInvoiceFeeProbeMutationResult =
  Apollo.MutationResult<LnNoAmountUsdInvoiceFeeProbeMutation>
export type LnNoAmountUsdInvoiceFeeProbeMutationOptions = Apollo.BaseMutationOptions<
  LnNoAmountUsdInvoiceFeeProbeMutation,
  LnNoAmountUsdInvoiceFeeProbeMutationVariables
>
export const OnChainTxFeeDocument = gql`
  query onChainTxFee(
    $walletId: WalletId!
    $address: OnChainAddress!
    $amount: SatAmount!
  ) {
    onChainTxFee(walletId: $walletId, address: $address, amount: $amount) {
      amount
    }
  }
`

/**
 * __useOnChainTxFeeQuery__
 *
 * To run a query within a React component, call `useOnChainTxFeeQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnChainTxFeeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnChainTxFeeQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      address: // value for 'address'
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useOnChainTxFeeQuery(
  baseOptions: Apollo.QueryHookOptions<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>(
    OnChainTxFeeDocument,
    options,
  )
}
export function useOnChainTxFeeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    OnChainTxFeeQuery,
    OnChainTxFeeQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>(
    OnChainTxFeeDocument,
    options,
  )
}
export type OnChainTxFeeQueryHookResult = ReturnType<typeof useOnChainTxFeeQuery>
export type OnChainTxFeeLazyQueryHookResult = ReturnType<typeof useOnChainTxFeeLazyQuery>
export type OnChainTxFeeQueryResult = Apollo.QueryResult<
  OnChainTxFeeQuery,
  OnChainTxFeeQueryVariables
>
export const OnChainUsdTxFeeDocument = gql`
  query onChainUsdTxFee(
    $walletId: WalletId!
    $address: OnChainAddress!
    $amount: CentAmount!
  ) {
    onChainUsdTxFee(walletId: $walletId, address: $address, amount: $amount) {
      amount
    }
  }
`

/**
 * __useOnChainUsdTxFeeQuery__
 *
 * To run a query within a React component, call `useOnChainUsdTxFeeQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnChainUsdTxFeeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnChainUsdTxFeeQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      address: // value for 'address'
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useOnChainUsdTxFeeQuery(
  baseOptions: Apollo.QueryHookOptions<
    OnChainUsdTxFeeQuery,
    OnChainUsdTxFeeQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables>(
    OnChainUsdTxFeeDocument,
    options,
  )
}
export function useOnChainUsdTxFeeLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    OnChainUsdTxFeeQuery,
    OnChainUsdTxFeeQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables>(
    OnChainUsdTxFeeDocument,
    options,
  )
}
export type OnChainUsdTxFeeQueryHookResult = ReturnType<typeof useOnChainUsdTxFeeQuery>
export type OnChainUsdTxFeeLazyQueryHookResult = ReturnType<
  typeof useOnChainUsdTxFeeLazyQuery
>
export type OnChainUsdTxFeeQueryResult = Apollo.QueryResult<
  OnChainUsdTxFeeQuery,
  OnChainUsdTxFeeQueryVariables
>
export const OnChainUsdTxFeeAsBtcDenominatedDocument = gql`
  query onChainUsdTxFeeAsBtcDenominated(
    $walletId: WalletId!
    $address: OnChainAddress!
    $amount: SatAmount!
  ) {
    onChainUsdTxFeeAsBtcDenominated(
      walletId: $walletId
      address: $address
      amount: $amount
    ) {
      amount
    }
  }
`

/**
 * __useOnChainUsdTxFeeAsBtcDenominatedQuery__
 *
 * To run a query within a React component, call `useOnChainUsdTxFeeAsBtcDenominatedQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnChainUsdTxFeeAsBtcDenominatedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnChainUsdTxFeeAsBtcDenominatedQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      address: // value for 'address'
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useOnChainUsdTxFeeAsBtcDenominatedQuery(
  baseOptions: Apollo.QueryHookOptions<
    OnChainUsdTxFeeAsBtcDenominatedQuery,
    OnChainUsdTxFeeAsBtcDenominatedQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    OnChainUsdTxFeeAsBtcDenominatedQuery,
    OnChainUsdTxFeeAsBtcDenominatedQueryVariables
  >(OnChainUsdTxFeeAsBtcDenominatedDocument, options)
}
export function useOnChainUsdTxFeeAsBtcDenominatedLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    OnChainUsdTxFeeAsBtcDenominatedQuery,
    OnChainUsdTxFeeAsBtcDenominatedQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    OnChainUsdTxFeeAsBtcDenominatedQuery,
    OnChainUsdTxFeeAsBtcDenominatedQueryVariables
  >(OnChainUsdTxFeeAsBtcDenominatedDocument, options)
}
export type OnChainUsdTxFeeAsBtcDenominatedQueryHookResult = ReturnType<
  typeof useOnChainUsdTxFeeAsBtcDenominatedQuery
>
export type OnChainUsdTxFeeAsBtcDenominatedLazyQueryHookResult = ReturnType<
  typeof useOnChainUsdTxFeeAsBtcDenominatedLazyQuery
>
export type OnChainUsdTxFeeAsBtcDenominatedQueryResult = Apollo.QueryResult<
  OnChainUsdTxFeeAsBtcDenominatedQuery,
  OnChainUsdTxFeeAsBtcDenominatedQueryVariables
>
export const IntraLedgerPaymentSendDocument = gql`
  mutation intraLedgerPaymentSend($input: IntraLedgerPaymentSendInput!) {
    intraLedgerPaymentSend(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type IntraLedgerPaymentSendMutationFn = Apollo.MutationFunction<
  IntraLedgerPaymentSendMutation,
  IntraLedgerPaymentSendMutationVariables
>

/**
 * __useIntraLedgerPaymentSendMutation__
 *
 * To run a mutation, you first call `useIntraLedgerPaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useIntraLedgerPaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [intraLedgerPaymentSendMutation, { data, loading, error }] = useIntraLedgerPaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useIntraLedgerPaymentSendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    IntraLedgerPaymentSendMutation,
    IntraLedgerPaymentSendMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    IntraLedgerPaymentSendMutation,
    IntraLedgerPaymentSendMutationVariables
  >(IntraLedgerPaymentSendDocument, options)
}
export type IntraLedgerPaymentSendMutationHookResult = ReturnType<
  typeof useIntraLedgerPaymentSendMutation
>
export type IntraLedgerPaymentSendMutationResult =
  Apollo.MutationResult<IntraLedgerPaymentSendMutation>
export type IntraLedgerPaymentSendMutationOptions = Apollo.BaseMutationOptions<
  IntraLedgerPaymentSendMutation,
  IntraLedgerPaymentSendMutationVariables
>
export const IntraLedgerUsdPaymentSendDocument = gql`
  mutation intraLedgerUsdPaymentSend($input: IntraLedgerUsdPaymentSendInput!) {
    intraLedgerUsdPaymentSend(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type IntraLedgerUsdPaymentSendMutationFn = Apollo.MutationFunction<
  IntraLedgerUsdPaymentSendMutation,
  IntraLedgerUsdPaymentSendMutationVariables
>

/**
 * __useIntraLedgerUsdPaymentSendMutation__
 *
 * To run a mutation, you first call `useIntraLedgerUsdPaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useIntraLedgerUsdPaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [intraLedgerUsdPaymentSendMutation, { data, loading, error }] = useIntraLedgerUsdPaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useIntraLedgerUsdPaymentSendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    IntraLedgerUsdPaymentSendMutation,
    IntraLedgerUsdPaymentSendMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    IntraLedgerUsdPaymentSendMutation,
    IntraLedgerUsdPaymentSendMutationVariables
  >(IntraLedgerUsdPaymentSendDocument, options)
}
export type IntraLedgerUsdPaymentSendMutationHookResult = ReturnType<
  typeof useIntraLedgerUsdPaymentSendMutation
>
export type IntraLedgerUsdPaymentSendMutationResult =
  Apollo.MutationResult<IntraLedgerUsdPaymentSendMutation>
export type IntraLedgerUsdPaymentSendMutationOptions = Apollo.BaseMutationOptions<
  IntraLedgerUsdPaymentSendMutation,
  IntraLedgerUsdPaymentSendMutationVariables
>
export const LnNoAmountInvoicePaymentSendDocument = gql`
  mutation lnNoAmountInvoicePaymentSend($input: LnNoAmountInvoicePaymentInput!) {
    lnNoAmountInvoicePaymentSend(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type LnNoAmountInvoicePaymentSendMutationFn = Apollo.MutationFunction<
  LnNoAmountInvoicePaymentSendMutation,
  LnNoAmountInvoicePaymentSendMutationVariables
>

/**
 * __useLnNoAmountInvoicePaymentSendMutation__
 *
 * To run a mutation, you first call `useLnNoAmountInvoicePaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountInvoicePaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountInvoicePaymentSendMutation, { data, loading, error }] = useLnNoAmountInvoicePaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountInvoicePaymentSendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnNoAmountInvoicePaymentSendMutation,
    LnNoAmountInvoicePaymentSendMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnNoAmountInvoicePaymentSendMutation,
    LnNoAmountInvoicePaymentSendMutationVariables
  >(LnNoAmountInvoicePaymentSendDocument, options)
}
export type LnNoAmountInvoicePaymentSendMutationHookResult = ReturnType<
  typeof useLnNoAmountInvoicePaymentSendMutation
>
export type LnNoAmountInvoicePaymentSendMutationResult =
  Apollo.MutationResult<LnNoAmountInvoicePaymentSendMutation>
export type LnNoAmountInvoicePaymentSendMutationOptions = Apollo.BaseMutationOptions<
  LnNoAmountInvoicePaymentSendMutation,
  LnNoAmountInvoicePaymentSendMutationVariables
>
export const LnInvoicePaymentSendDocument = gql`
  mutation lnInvoicePaymentSend($input: LnInvoicePaymentInput!) {
    lnInvoicePaymentSend(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type LnInvoicePaymentSendMutationFn = Apollo.MutationFunction<
  LnInvoicePaymentSendMutation,
  LnInvoicePaymentSendMutationVariables
>

/**
 * __useLnInvoicePaymentSendMutation__
 *
 * To run a mutation, you first call `useLnInvoicePaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoicePaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoicePaymentSendMutation, { data, loading, error }] = useLnInvoicePaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoicePaymentSendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnInvoicePaymentSendMutation,
    LnInvoicePaymentSendMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnInvoicePaymentSendMutation,
    LnInvoicePaymentSendMutationVariables
  >(LnInvoicePaymentSendDocument, options)
}
export type LnInvoicePaymentSendMutationHookResult = ReturnType<
  typeof useLnInvoicePaymentSendMutation
>
export type LnInvoicePaymentSendMutationResult =
  Apollo.MutationResult<LnInvoicePaymentSendMutation>
export type LnInvoicePaymentSendMutationOptions = Apollo.BaseMutationOptions<
  LnInvoicePaymentSendMutation,
  LnInvoicePaymentSendMutationVariables
>
export const LnNoAmountUsdInvoicePaymentSendDocument = gql`
  mutation lnNoAmountUsdInvoicePaymentSend($input: LnNoAmountUsdInvoicePaymentInput!) {
    lnNoAmountUsdInvoicePaymentSend(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type LnNoAmountUsdInvoicePaymentSendMutationFn = Apollo.MutationFunction<
  LnNoAmountUsdInvoicePaymentSendMutation,
  LnNoAmountUsdInvoicePaymentSendMutationVariables
>

/**
 * __useLnNoAmountUsdInvoicePaymentSendMutation__
 *
 * To run a mutation, you first call `useLnNoAmountUsdInvoicePaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountUsdInvoicePaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountUsdInvoicePaymentSendMutation, { data, loading, error }] = useLnNoAmountUsdInvoicePaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountUsdInvoicePaymentSendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    LnNoAmountUsdInvoicePaymentSendMutation,
    LnNoAmountUsdInvoicePaymentSendMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    LnNoAmountUsdInvoicePaymentSendMutation,
    LnNoAmountUsdInvoicePaymentSendMutationVariables
  >(LnNoAmountUsdInvoicePaymentSendDocument, options)
}
export type LnNoAmountUsdInvoicePaymentSendMutationHookResult = ReturnType<
  typeof useLnNoAmountUsdInvoicePaymentSendMutation
>
export type LnNoAmountUsdInvoicePaymentSendMutationResult =
  Apollo.MutationResult<LnNoAmountUsdInvoicePaymentSendMutation>
export type LnNoAmountUsdInvoicePaymentSendMutationOptions = Apollo.BaseMutationOptions<
  LnNoAmountUsdInvoicePaymentSendMutation,
  LnNoAmountUsdInvoicePaymentSendMutationVariables
>
export const OnChainPaymentSendDocument = gql`
  mutation onChainPaymentSend($input: OnChainPaymentSendInput!) {
    onChainPaymentSend(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type OnChainPaymentSendMutationFn = Apollo.MutationFunction<
  OnChainPaymentSendMutation,
  OnChainPaymentSendMutationVariables
>

/**
 * __useOnChainPaymentSendMutation__
 *
 * To run a mutation, you first call `useOnChainPaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainPaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainPaymentSendMutation, { data, loading, error }] = useOnChainPaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainPaymentSendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    OnChainPaymentSendMutation,
    OnChainPaymentSendMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    OnChainPaymentSendMutation,
    OnChainPaymentSendMutationVariables
  >(OnChainPaymentSendDocument, options)
}
export type OnChainPaymentSendMutationHookResult = ReturnType<
  typeof useOnChainPaymentSendMutation
>
export type OnChainPaymentSendMutationResult =
  Apollo.MutationResult<OnChainPaymentSendMutation>
export type OnChainPaymentSendMutationOptions = Apollo.BaseMutationOptions<
  OnChainPaymentSendMutation,
  OnChainPaymentSendMutationVariables
>
export const OnChainPaymentSendAllDocument = gql`
  mutation onChainPaymentSendAll($input: OnChainPaymentSendAllInput!) {
    onChainPaymentSendAll(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type OnChainPaymentSendAllMutationFn = Apollo.MutationFunction<
  OnChainPaymentSendAllMutation,
  OnChainPaymentSendAllMutationVariables
>

/**
 * __useOnChainPaymentSendAllMutation__
 *
 * To run a mutation, you first call `useOnChainPaymentSendAllMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainPaymentSendAllMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainPaymentSendAllMutation, { data, loading, error }] = useOnChainPaymentSendAllMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainPaymentSendAllMutation(
  baseOptions?: Apollo.MutationHookOptions<
    OnChainPaymentSendAllMutation,
    OnChainPaymentSendAllMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    OnChainPaymentSendAllMutation,
    OnChainPaymentSendAllMutationVariables
  >(OnChainPaymentSendAllDocument, options)
}
export type OnChainPaymentSendAllMutationHookResult = ReturnType<
  typeof useOnChainPaymentSendAllMutation
>
export type OnChainPaymentSendAllMutationResult =
  Apollo.MutationResult<OnChainPaymentSendAllMutation>
export type OnChainPaymentSendAllMutationOptions = Apollo.BaseMutationOptions<
  OnChainPaymentSendAllMutation,
  OnChainPaymentSendAllMutationVariables
>
export const OnChainUsdPaymentSendDocument = gql`
  mutation onChainUsdPaymentSend($input: OnChainUsdPaymentSendInput!) {
    onChainUsdPaymentSend(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type OnChainUsdPaymentSendMutationFn = Apollo.MutationFunction<
  OnChainUsdPaymentSendMutation,
  OnChainUsdPaymentSendMutationVariables
>

/**
 * __useOnChainUsdPaymentSendMutation__
 *
 * To run a mutation, you first call `useOnChainUsdPaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainUsdPaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainUsdPaymentSendMutation, { data, loading, error }] = useOnChainUsdPaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainUsdPaymentSendMutation(
  baseOptions?: Apollo.MutationHookOptions<
    OnChainUsdPaymentSendMutation,
    OnChainUsdPaymentSendMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    OnChainUsdPaymentSendMutation,
    OnChainUsdPaymentSendMutationVariables
  >(OnChainUsdPaymentSendDocument, options)
}
export type OnChainUsdPaymentSendMutationHookResult = ReturnType<
  typeof useOnChainUsdPaymentSendMutation
>
export type OnChainUsdPaymentSendMutationResult =
  Apollo.MutationResult<OnChainUsdPaymentSendMutation>
export type OnChainUsdPaymentSendMutationOptions = Apollo.BaseMutationOptions<
  OnChainUsdPaymentSendMutation,
  OnChainUsdPaymentSendMutationVariables
>
export const OnChainUsdPaymentSendAsBtcDenominatedDocument = gql`
  mutation onChainUsdPaymentSendAsBtcDenominated(
    $input: OnChainUsdPaymentSendAsBtcDenominatedInput!
  ) {
    onChainUsdPaymentSendAsBtcDenominated(input: $input) {
      errors {
        message
      }
      status
    }
  }
`
export type OnChainUsdPaymentSendAsBtcDenominatedMutationFn = Apollo.MutationFunction<
  OnChainUsdPaymentSendAsBtcDenominatedMutation,
  OnChainUsdPaymentSendAsBtcDenominatedMutationVariables
>

/**
 * __useOnChainUsdPaymentSendAsBtcDenominatedMutation__
 *
 * To run a mutation, you first call `useOnChainUsdPaymentSendAsBtcDenominatedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainUsdPaymentSendAsBtcDenominatedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainUsdPaymentSendAsBtcDenominatedMutation, { data, loading, error }] = useOnChainUsdPaymentSendAsBtcDenominatedMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainUsdPaymentSendAsBtcDenominatedMutation(
  baseOptions?: Apollo.MutationHookOptions<
    OnChainUsdPaymentSendAsBtcDenominatedMutation,
    OnChainUsdPaymentSendAsBtcDenominatedMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    OnChainUsdPaymentSendAsBtcDenominatedMutation,
    OnChainUsdPaymentSendAsBtcDenominatedMutationVariables
  >(OnChainUsdPaymentSendAsBtcDenominatedDocument, options)
}
export type OnChainUsdPaymentSendAsBtcDenominatedMutationHookResult = ReturnType<
  typeof useOnChainUsdPaymentSendAsBtcDenominatedMutation
>
export type OnChainUsdPaymentSendAsBtcDenominatedMutationResult =
  Apollo.MutationResult<OnChainUsdPaymentSendAsBtcDenominatedMutation>
export type OnChainUsdPaymentSendAsBtcDenominatedMutationOptions =
  Apollo.BaseMutationOptions<
    OnChainUsdPaymentSendAsBtcDenominatedMutation,
    OnChainUsdPaymentSendAsBtcDenominatedMutationVariables
  >
export const AccountScreenDocument = gql`
  query accountScreen {
    me {
      id
      phone
      totpEnabled
      email {
        address
        verified
      }
      defaultAccount {
        id
        level
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
`

/**
 * __useAccountScreenQuery__
 *
 * To run a query within a React component, call `useAccountScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useAccountScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<AccountScreenQuery, AccountScreenQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AccountScreenQuery, AccountScreenQueryVariables>(
    AccountScreenDocument,
    options,
  )
}
export function useAccountScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    AccountScreenQuery,
    AccountScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<AccountScreenQuery, AccountScreenQueryVariables>(
    AccountScreenDocument,
    options,
  )
}
export type AccountScreenQueryHookResult = ReturnType<typeof useAccountScreenQuery>
export type AccountScreenLazyQueryHookResult = ReturnType<
  typeof useAccountScreenLazyQuery
>
export type AccountScreenQueryResult = Apollo.QueryResult<
  AccountScreenQuery,
  AccountScreenQueryVariables
>
export const AccountDeleteDocument = gql`
  mutation accountDelete {
    accountDelete {
      errors {
        message
      }
      success
    }
  }
`
export type AccountDeleteMutationFn = Apollo.MutationFunction<
  AccountDeleteMutation,
  AccountDeleteMutationVariables
>

/**
 * __useAccountDeleteMutation__
 *
 * To run a mutation, you first call `useAccountDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountDeleteMutation, { data, loading, error }] = useAccountDeleteMutation({
 *   variables: {
 *   },
 * });
 */
export function useAccountDeleteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AccountDeleteMutation,
    AccountDeleteMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<AccountDeleteMutation, AccountDeleteMutationVariables>(
    AccountDeleteDocument,
    options,
  )
}
export type AccountDeleteMutationHookResult = ReturnType<typeof useAccountDeleteMutation>
export type AccountDeleteMutationResult = Apollo.MutationResult<AccountDeleteMutation>
export type AccountDeleteMutationOptions = Apollo.BaseMutationOptions<
  AccountDeleteMutation,
  AccountDeleteMutationVariables
>
export const UserEmailDeleteDocument = gql`
  mutation userEmailDelete {
    userEmailDelete {
      errors {
        message
      }
      me {
        id
        phone
        totpEnabled
        email {
          address
          verified
        }
      }
    }
  }
`
export type UserEmailDeleteMutationFn = Apollo.MutationFunction<
  UserEmailDeleteMutation,
  UserEmailDeleteMutationVariables
>

/**
 * __useUserEmailDeleteMutation__
 *
 * To run a mutation, you first call `useUserEmailDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailDeleteMutation, { data, loading, error }] = useUserEmailDeleteMutation({
 *   variables: {
 *   },
 * });
 */
export function useUserEmailDeleteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserEmailDeleteMutation,
    UserEmailDeleteMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserEmailDeleteMutation, UserEmailDeleteMutationVariables>(
    UserEmailDeleteDocument,
    options,
  )
}
export type UserEmailDeleteMutationHookResult = ReturnType<
  typeof useUserEmailDeleteMutation
>
export type UserEmailDeleteMutationResult = Apollo.MutationResult<UserEmailDeleteMutation>
export type UserEmailDeleteMutationOptions = Apollo.BaseMutationOptions<
  UserEmailDeleteMutation,
  UserEmailDeleteMutationVariables
>
export const UserPhoneDeleteDocument = gql`
  mutation userPhoneDelete {
    userPhoneDelete {
      errors {
        message
      }
      me {
        id
        phone
        totpEnabled
        email {
          address
          verified
        }
      }
    }
  }
`
export type UserPhoneDeleteMutationFn = Apollo.MutationFunction<
  UserPhoneDeleteMutation,
  UserPhoneDeleteMutationVariables
>

/**
 * __useUserPhoneDeleteMutation__
 *
 * To run a mutation, you first call `useUserPhoneDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPhoneDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPhoneDeleteMutation, { data, loading, error }] = useUserPhoneDeleteMutation({
 *   variables: {
 *   },
 * });
 */
export function useUserPhoneDeleteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserPhoneDeleteMutation,
    UserPhoneDeleteMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserPhoneDeleteMutation, UserPhoneDeleteMutationVariables>(
    UserPhoneDeleteDocument,
    options,
  )
}
export type UserPhoneDeleteMutationHookResult = ReturnType<
  typeof useUserPhoneDeleteMutation
>
export type UserPhoneDeleteMutationResult = Apollo.MutationResult<UserPhoneDeleteMutation>
export type UserPhoneDeleteMutationOptions = Apollo.BaseMutationOptions<
  UserPhoneDeleteMutation,
  UserPhoneDeleteMutationVariables
>
export const UserTotpDeleteDocument = gql`
  mutation userTotpDelete($input: UserTotpDeleteInput!) {
    userTotpDelete(input: $input) {
      errors {
        message
      }
      me {
        id
        phone
        totpEnabled
        email {
          address
          verified
        }
      }
    }
  }
`
export type UserTotpDeleteMutationFn = Apollo.MutationFunction<
  UserTotpDeleteMutation,
  UserTotpDeleteMutationVariables
>

/**
 * __useUserTotpDeleteMutation__
 *
 * To run a mutation, you first call `useUserTotpDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserTotpDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userTotpDeleteMutation, { data, loading, error }] = useUserTotpDeleteMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserTotpDeleteMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserTotpDeleteMutation,
    UserTotpDeleteMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<UserTotpDeleteMutation, UserTotpDeleteMutationVariables>(
    UserTotpDeleteDocument,
    options,
  )
}
export type UserTotpDeleteMutationHookResult = ReturnType<
  typeof useUserTotpDeleteMutation
>
export type UserTotpDeleteMutationResult = Apollo.MutationResult<UserTotpDeleteMutation>
export type UserTotpDeleteMutationOptions = Apollo.BaseMutationOptions<
  UserTotpDeleteMutation,
  UserTotpDeleteMutationVariables
>
export const AccountUpdateDefaultWalletIdDocument = gql`
  mutation accountUpdateDefaultWalletId($input: AccountUpdateDefaultWalletIdInput!) {
    accountUpdateDefaultWalletId(input: $input) {
      errors {
        message
      }
      account {
        id
        defaultWalletId
      }
    }
  }
`
export type AccountUpdateDefaultWalletIdMutationFn = Apollo.MutationFunction<
  AccountUpdateDefaultWalletIdMutation,
  AccountUpdateDefaultWalletIdMutationVariables
>

/**
 * __useAccountUpdateDefaultWalletIdMutation__
 *
 * To run a mutation, you first call `useAccountUpdateDefaultWalletIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountUpdateDefaultWalletIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountUpdateDefaultWalletIdMutation, { data, loading, error }] = useAccountUpdateDefaultWalletIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountUpdateDefaultWalletIdMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AccountUpdateDefaultWalletIdMutation,
    AccountUpdateDefaultWalletIdMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AccountUpdateDefaultWalletIdMutation,
    AccountUpdateDefaultWalletIdMutationVariables
  >(AccountUpdateDefaultWalletIdDocument, options)
}
export type AccountUpdateDefaultWalletIdMutationHookResult = ReturnType<
  typeof useAccountUpdateDefaultWalletIdMutation
>
export type AccountUpdateDefaultWalletIdMutationResult =
  Apollo.MutationResult<AccountUpdateDefaultWalletIdMutation>
export type AccountUpdateDefaultWalletIdMutationOptions = Apollo.BaseMutationOptions<
  AccountUpdateDefaultWalletIdMutation,
  AccountUpdateDefaultWalletIdMutationVariables
>
export const SetDefaultWalletScreenDocument = gql`
  query setDefaultWalletScreen {
    me {
      id
      defaultAccount {
        id
        defaultWalletId
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
`

/**
 * __useSetDefaultWalletScreenQuery__
 *
 * To run a query within a React component, call `useSetDefaultWalletScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSetDefaultWalletScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSetDefaultWalletScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useSetDefaultWalletScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SetDefaultWalletScreenQuery,
    SetDefaultWalletScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    SetDefaultWalletScreenQuery,
    SetDefaultWalletScreenQueryVariables
  >(SetDefaultWalletScreenDocument, options)
}
export function useSetDefaultWalletScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SetDefaultWalletScreenQuery,
    SetDefaultWalletScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    SetDefaultWalletScreenQuery,
    SetDefaultWalletScreenQueryVariables
  >(SetDefaultWalletScreenDocument, options)
}
export type SetDefaultWalletScreenQueryHookResult = ReturnType<
  typeof useSetDefaultWalletScreenQuery
>
export type SetDefaultWalletScreenLazyQueryHookResult = ReturnType<
  typeof useSetDefaultWalletScreenLazyQuery
>
export type SetDefaultWalletScreenQueryResult = Apollo.QueryResult<
  SetDefaultWalletScreenQuery,
  SetDefaultWalletScreenQueryVariables
>
export const AccountUpdateDisplayCurrencyDocument = gql`
  mutation accountUpdateDisplayCurrency($input: AccountUpdateDisplayCurrencyInput!) {
    accountUpdateDisplayCurrency(input: $input) {
      errors {
        message
      }
      account {
        id
        displayCurrency
      }
    }
  }
`
export type AccountUpdateDisplayCurrencyMutationFn = Apollo.MutationFunction<
  AccountUpdateDisplayCurrencyMutation,
  AccountUpdateDisplayCurrencyMutationVariables
>

/**
 * __useAccountUpdateDisplayCurrencyMutation__
 *
 * To run a mutation, you first call `useAccountUpdateDisplayCurrencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountUpdateDisplayCurrencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountUpdateDisplayCurrencyMutation, { data, loading, error }] = useAccountUpdateDisplayCurrencyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountUpdateDisplayCurrencyMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AccountUpdateDisplayCurrencyMutation,
    AccountUpdateDisplayCurrencyMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AccountUpdateDisplayCurrencyMutation,
    AccountUpdateDisplayCurrencyMutationVariables
  >(AccountUpdateDisplayCurrencyDocument, options)
}
export type AccountUpdateDisplayCurrencyMutationHookResult = ReturnType<
  typeof useAccountUpdateDisplayCurrencyMutation
>
export type AccountUpdateDisplayCurrencyMutationResult =
  Apollo.MutationResult<AccountUpdateDisplayCurrencyMutation>
export type AccountUpdateDisplayCurrencyMutationOptions = Apollo.BaseMutationOptions<
  AccountUpdateDisplayCurrencyMutation,
  AccountUpdateDisplayCurrencyMutationVariables
>
export const LanguageDocument = gql`
  query language {
    me {
      id
      language
    }
  }
`

/**
 * __useLanguageQuery__
 *
 * To run a query within a React component, call `useLanguageQuery` and pass it any options that fit your needs.
 * When your component renders, `useLanguageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLanguageQuery({
 *   variables: {
 *   },
 * });
 */
export function useLanguageQuery(
  baseOptions?: Apollo.QueryHookOptions<LanguageQuery, LanguageQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<LanguageQuery, LanguageQueryVariables>(LanguageDocument, options)
}
export function useLanguageLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<LanguageQuery, LanguageQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<LanguageQuery, LanguageQueryVariables>(
    LanguageDocument,
    options,
  )
}
export type LanguageQueryHookResult = ReturnType<typeof useLanguageQuery>
export type LanguageLazyQueryHookResult = ReturnType<typeof useLanguageLazyQuery>
export type LanguageQueryResult = Apollo.QueryResult<
  LanguageQuery,
  LanguageQueryVariables
>
export const UserUpdateLanguageDocument = gql`
  mutation userUpdateLanguage($input: UserUpdateLanguageInput!) {
    userUpdateLanguage(input: $input) {
      errors {
        message
      }
      user {
        id
        language
      }
    }
  }
`
export type UserUpdateLanguageMutationFn = Apollo.MutationFunction<
  UserUpdateLanguageMutation,
  UserUpdateLanguageMutationVariables
>

/**
 * __useUserUpdateLanguageMutation__
 *
 * To run a mutation, you first call `useUserUpdateLanguageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserUpdateLanguageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userUpdateLanguageMutation, { data, loading, error }] = useUserUpdateLanguageMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserUpdateLanguageMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserUpdateLanguageMutation,
    UserUpdateLanguageMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserUpdateLanguageMutation,
    UserUpdateLanguageMutationVariables
  >(UserUpdateLanguageDocument, options)
}
export type UserUpdateLanguageMutationHookResult = ReturnType<
  typeof useUserUpdateLanguageMutation
>
export type UserUpdateLanguageMutationResult =
  Apollo.MutationResult<UserUpdateLanguageMutation>
export type UserUpdateLanguageMutationOptions = Apollo.BaseMutationOptions<
  UserUpdateLanguageMutation,
  UserUpdateLanguageMutationVariables
>
export const NotificationSettingsDocument = gql`
  query notificationSettings {
    me {
      id
      defaultAccount {
        id
        notificationSettings {
          push {
            enabled
            disabledCategories
          }
        }
      }
    }
  }
`

/**
 * __useNotificationSettingsQuery__
 *
 * To run a query within a React component, call `useNotificationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useNotificationSettingsQuery(
  baseOptions?: Apollo.QueryHookOptions<
    NotificationSettingsQuery,
    NotificationSettingsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<NotificationSettingsQuery, NotificationSettingsQueryVariables>(
    NotificationSettingsDocument,
    options,
  )
}
export function useNotificationSettingsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    NotificationSettingsQuery,
    NotificationSettingsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    NotificationSettingsQuery,
    NotificationSettingsQueryVariables
  >(NotificationSettingsDocument, options)
}
export function useNotificationSettingsSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    NotificationSettingsQuery,
    NotificationSettingsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<
    NotificationSettingsQuery,
    NotificationSettingsQueryVariables
  >(NotificationSettingsDocument, options)
}
export type NotificationSettingsQueryHookResult = ReturnType<
  typeof useNotificationSettingsQuery
>
export type NotificationSettingsLazyQueryHookResult = ReturnType<
  typeof useNotificationSettingsLazyQuery
>
export type NotificationSettingsSuspenseQueryHookResult = ReturnType<
  typeof useNotificationSettingsSuspenseQuery
>
export type NotificationSettingsQueryResult = Apollo.QueryResult<
  NotificationSettingsQuery,
  NotificationSettingsQueryVariables
>
export const AccountEnableNotificationChannelDocument = gql`
  mutation accountEnableNotificationChannel(
    $input: AccountEnableNotificationChannelInput!
  ) {
    accountEnableNotificationChannel(input: $input) {
      errors {
        message
      }
      account {
        id
        notificationSettings {
          push {
            enabled
            disabledCategories
          }
        }
      }
    }
  }
`
export type AccountEnableNotificationChannelMutationFn = Apollo.MutationFunction<
  AccountEnableNotificationChannelMutation,
  AccountEnableNotificationChannelMutationVariables
>

/**
 * __useAccountEnableNotificationChannelMutation__
 *
 * To run a mutation, you first call `useAccountEnableNotificationChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountEnableNotificationChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountEnableNotificationChannelMutation, { data, loading, error }] = useAccountEnableNotificationChannelMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountEnableNotificationChannelMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AccountEnableNotificationChannelMutation,
    AccountEnableNotificationChannelMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AccountEnableNotificationChannelMutation,
    AccountEnableNotificationChannelMutationVariables
  >(AccountEnableNotificationChannelDocument, options)
}
export type AccountEnableNotificationChannelMutationHookResult = ReturnType<
  typeof useAccountEnableNotificationChannelMutation
>
export type AccountEnableNotificationChannelMutationResult =
  Apollo.MutationResult<AccountEnableNotificationChannelMutation>
export type AccountEnableNotificationChannelMutationOptions = Apollo.BaseMutationOptions<
  AccountEnableNotificationChannelMutation,
  AccountEnableNotificationChannelMutationVariables
>
export const AccountDisableNotificationChannelDocument = gql`
  mutation accountDisableNotificationChannel(
    $input: AccountDisableNotificationChannelInput!
  ) {
    accountDisableNotificationChannel(input: $input) {
      errors {
        message
      }
      account {
        id
        notificationSettings {
          push {
            enabled
            disabledCategories
          }
        }
      }
    }
  }
`
export type AccountDisableNotificationChannelMutationFn = Apollo.MutationFunction<
  AccountDisableNotificationChannelMutation,
  AccountDisableNotificationChannelMutationVariables
>

/**
 * __useAccountDisableNotificationChannelMutation__
 *
 * To run a mutation, you first call `useAccountDisableNotificationChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountDisableNotificationChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountDisableNotificationChannelMutation, { data, loading, error }] = useAccountDisableNotificationChannelMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountDisableNotificationChannelMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AccountDisableNotificationChannelMutation,
    AccountDisableNotificationChannelMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AccountDisableNotificationChannelMutation,
    AccountDisableNotificationChannelMutationVariables
  >(AccountDisableNotificationChannelDocument, options)
}
export type AccountDisableNotificationChannelMutationHookResult = ReturnType<
  typeof useAccountDisableNotificationChannelMutation
>
export type AccountDisableNotificationChannelMutationResult =
  Apollo.MutationResult<AccountDisableNotificationChannelMutation>
export type AccountDisableNotificationChannelMutationOptions = Apollo.BaseMutationOptions<
  AccountDisableNotificationChannelMutation,
  AccountDisableNotificationChannelMutationVariables
>
export const AccountEnableNotificationCategoryDocument = gql`
  mutation accountEnableNotificationCategory(
    $input: AccountEnableNotificationCategoryInput!
  ) {
    accountEnableNotificationCategory(input: $input) {
      errors {
        message
      }
      account {
        id
        notificationSettings {
          push {
            enabled
            disabledCategories
          }
        }
      }
    }
  }
`
export type AccountEnableNotificationCategoryMutationFn = Apollo.MutationFunction<
  AccountEnableNotificationCategoryMutation,
  AccountEnableNotificationCategoryMutationVariables
>

/**
 * __useAccountEnableNotificationCategoryMutation__
 *
 * To run a mutation, you first call `useAccountEnableNotificationCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountEnableNotificationCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountEnableNotificationCategoryMutation, { data, loading, error }] = useAccountEnableNotificationCategoryMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountEnableNotificationCategoryMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AccountEnableNotificationCategoryMutation,
    AccountEnableNotificationCategoryMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AccountEnableNotificationCategoryMutation,
    AccountEnableNotificationCategoryMutationVariables
  >(AccountEnableNotificationCategoryDocument, options)
}
export type AccountEnableNotificationCategoryMutationHookResult = ReturnType<
  typeof useAccountEnableNotificationCategoryMutation
>
export type AccountEnableNotificationCategoryMutationResult =
  Apollo.MutationResult<AccountEnableNotificationCategoryMutation>
export type AccountEnableNotificationCategoryMutationOptions = Apollo.BaseMutationOptions<
  AccountEnableNotificationCategoryMutation,
  AccountEnableNotificationCategoryMutationVariables
>
export const AccountDisableNotificationCategoryDocument = gql`
  mutation accountDisableNotificationCategory(
    $input: AccountDisableNotificationCategoryInput!
  ) {
    accountDisableNotificationCategory(input: $input) {
      errors {
        message
      }
      account {
        id
        notificationSettings {
          push {
            enabled
            disabledCategories
          }
        }
      }
    }
  }
`
export type AccountDisableNotificationCategoryMutationFn = Apollo.MutationFunction<
  AccountDisableNotificationCategoryMutation,
  AccountDisableNotificationCategoryMutationVariables
>

/**
 * __useAccountDisableNotificationCategoryMutation__
 *
 * To run a mutation, you first call `useAccountDisableNotificationCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountDisableNotificationCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountDisableNotificationCategoryMutation, { data, loading, error }] = useAccountDisableNotificationCategoryMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountDisableNotificationCategoryMutation(
  baseOptions?: Apollo.MutationHookOptions<
    AccountDisableNotificationCategoryMutation,
    AccountDisableNotificationCategoryMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    AccountDisableNotificationCategoryMutation,
    AccountDisableNotificationCategoryMutationVariables
  >(AccountDisableNotificationCategoryDocument, options)
}
export type AccountDisableNotificationCategoryMutationHookResult = ReturnType<
  typeof useAccountDisableNotificationCategoryMutation
>
export type AccountDisableNotificationCategoryMutationResult =
  Apollo.MutationResult<AccountDisableNotificationCategoryMutation>
export type AccountDisableNotificationCategoryMutationOptions =
  Apollo.BaseMutationOptions<
    AccountDisableNotificationCategoryMutation,
    AccountDisableNotificationCategoryMutationVariables
  >
export const UnacknowledgedNotificationCountDocument = gql`
  query UnacknowledgedNotificationCount {
    me {
      id
      unacknowledgedStatefulNotificationsWithoutBulletinEnabledCount
    }
  }
`

/**
 * __useUnacknowledgedNotificationCountQuery__
 *
 * To run a query within a React component, call `useUnacknowledgedNotificationCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useUnacknowledgedNotificationCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUnacknowledgedNotificationCountQuery({
 *   variables: {
 *   },
 * });
 */
export function useUnacknowledgedNotificationCountQuery(
  baseOptions?: Apollo.QueryHookOptions<
    UnacknowledgedNotificationCountQuery,
    UnacknowledgedNotificationCountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    UnacknowledgedNotificationCountQuery,
    UnacknowledgedNotificationCountQueryVariables
  >(UnacknowledgedNotificationCountDocument, options)
}
export function useUnacknowledgedNotificationCountLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    UnacknowledgedNotificationCountQuery,
    UnacknowledgedNotificationCountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    UnacknowledgedNotificationCountQuery,
    UnacknowledgedNotificationCountQueryVariables
  >(UnacknowledgedNotificationCountDocument, options)
}
export function useUnacknowledgedNotificationCountSuspenseQuery(
  baseOptions?: Apollo.SuspenseQueryHookOptions<
    UnacknowledgedNotificationCountQuery,
    UnacknowledgedNotificationCountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useSuspenseQuery<
    UnacknowledgedNotificationCountQuery,
    UnacknowledgedNotificationCountQueryVariables
  >(UnacknowledgedNotificationCountDocument, options)
}
export type UnacknowledgedNotificationCountQueryHookResult = ReturnType<
  typeof useUnacknowledgedNotificationCountQuery
>
export type UnacknowledgedNotificationCountLazyQueryHookResult = ReturnType<
  typeof useUnacknowledgedNotificationCountLazyQuery
>
export type UnacknowledgedNotificationCountSuspenseQueryHookResult = ReturnType<
  typeof useUnacknowledgedNotificationCountSuspenseQuery
>
export type UnacknowledgedNotificationCountQueryResult = Apollo.QueryResult<
  UnacknowledgedNotificationCountQuery,
  UnacknowledgedNotificationCountQueryVariables
>

export const WalletCsvTransactionsDocument = gql`
  query walletCSVTransactions($walletIds: [WalletId!]!) {
    me {
      id
      defaultAccount {
        id
        csvTransactions(walletIds: $walletIds)
      }
    }
  }
`

/**
 * __useWalletCsvTransactionsQuery__
 *
 * To run a query within a React component, call `useWalletCsvTransactionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useWalletCsvTransactionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWalletCsvTransactionsQuery({
 *   variables: {
 *      walletIds: // value for 'walletIds'
 *   },
 * });
 */
export function useWalletCsvTransactionsQuery(
  baseOptions: Apollo.QueryHookOptions<
    WalletCsvTransactionsQuery,
    WalletCsvTransactionsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<WalletCsvTransactionsQuery, WalletCsvTransactionsQueryVariables>(
    WalletCsvTransactionsDocument,
    options,
  )
}
export function useWalletCsvTransactionsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    WalletCsvTransactionsQuery,
    WalletCsvTransactionsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    WalletCsvTransactionsQuery,
    WalletCsvTransactionsQueryVariables
  >(WalletCsvTransactionsDocument, options)
}
export type WalletCsvTransactionsQueryHookResult = ReturnType<
  typeof useWalletCsvTransactionsQuery
>
export type WalletCsvTransactionsLazyQueryHookResult = ReturnType<
  typeof useWalletCsvTransactionsLazyQuery
>
export type WalletCsvTransactionsQueryResult = Apollo.QueryResult<
  WalletCsvTransactionsQuery,
  WalletCsvTransactionsQueryVariables
>
export const SettingsScreenDocument = gql`
  query settingsScreen {
    me {
      id
      phone
      username
      language
      defaultAccount {
        id
        defaultWalletId
        wallets {
          id
          balance
          walletCurrency
        }
      }
      email {
        address
        verified
      }
    }
  }
`

/**
 * __useSettingsScreenQuery__
 *
 * To run a query within a React component, call `useSettingsScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSettingsScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSettingsScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useSettingsScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<
    SettingsScreenQuery,
    SettingsScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<SettingsScreenQuery, SettingsScreenQueryVariables>(
    SettingsScreenDocument,
    options,
  )
}
export function useSettingsScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    SettingsScreenQuery,
    SettingsScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<SettingsScreenQuery, SettingsScreenQueryVariables>(
    SettingsScreenDocument,
    options,
  )
}
export type SettingsScreenQueryHookResult = ReturnType<typeof useSettingsScreenQuery>
export type SettingsScreenLazyQueryHookResult = ReturnType<
  typeof useSettingsScreenLazyQuery
>
export type SettingsScreenQueryResult = Apollo.QueryResult<
  SettingsScreenQuery,
  SettingsScreenQueryVariables
>
export const WarningSecureAccountDocument = gql`
  query warningSecureAccount {
    me {
      id
      defaultAccount {
        level
        id
        wallets {
          id
          balance
          walletCurrency
        }
      }
    }
  }
`

/**
 * __useWarningSecureAccountQuery__
 *
 * To run a query within a React component, call `useWarningSecureAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useWarningSecureAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWarningSecureAccountQuery({
 *   variables: {
 *   },
 * });
 */
export function useWarningSecureAccountQuery(
  baseOptions?: Apollo.QueryHookOptions<
    WarningSecureAccountQuery,
    WarningSecureAccountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<WarningSecureAccountQuery, WarningSecureAccountQueryVariables>(
    WarningSecureAccountDocument,
    options,
  )
}
export function useWarningSecureAccountLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    WarningSecureAccountQuery,
    WarningSecureAccountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    WarningSecureAccountQuery,
    WarningSecureAccountQueryVariables
  >(WarningSecureAccountDocument, options)
}
export type WarningSecureAccountQueryHookResult = ReturnType<
  typeof useWarningSecureAccountQuery
>
export type WarningSecureAccountLazyQueryHookResult = ReturnType<
  typeof useWarningSecureAccountLazyQuery
>
export type WarningSecureAccountQueryResult = Apollo.QueryResult<
  WarningSecureAccountQuery,
  WarningSecureAccountQueryVariables
>
export const AccountLimitsDocument = gql`
  query accountLimits {
    me {
      id
      defaultAccount {
        id
        limits {
          withdrawal {
            totalLimit
            remainingLimit
            interval
          }
          internalSend {
            totalLimit
            remainingLimit
            interval
          }
          convert {
            totalLimit
            remainingLimit
            interval
          }
        }
      }
    }
  }
`

/**
 * __useAccountLimitsQuery__
 *
 * To run a query within a React component, call `useAccountLimitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountLimitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountLimitsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAccountLimitsQuery(
  baseOptions?: Apollo.QueryHookOptions<AccountLimitsQuery, AccountLimitsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<AccountLimitsQuery, AccountLimitsQueryVariables>(
    AccountLimitsDocument,
    options,
  )
}
export function useAccountLimitsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    AccountLimitsQuery,
    AccountLimitsQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<AccountLimitsQuery, AccountLimitsQueryVariables>(
    AccountLimitsDocument,
    options,
  )
}
export type AccountLimitsQueryHookResult = ReturnType<typeof useAccountLimitsQuery>
export type AccountLimitsLazyQueryHookResult = ReturnType<
  typeof useAccountLimitsLazyQuery
>
export type AccountLimitsQueryResult = Apollo.QueryResult<
  AccountLimitsQuery,
  AccountLimitsQueryVariables
>
export const TotpRegistrationScreenDocument = gql`
  query totpRegistrationScreen {
    me {
      username
    }
  }
`

/**
 * __useTotpRegistrationScreenQuery__
 *
 * To run a query within a React component, call `useTotpRegistrationScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useTotpRegistrationScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTotpRegistrationScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useTotpRegistrationScreenQuery(
  baseOptions?: Apollo.QueryHookOptions<
    TotpRegistrationScreenQuery,
    TotpRegistrationScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    TotpRegistrationScreenQuery,
    TotpRegistrationScreenQueryVariables
  >(TotpRegistrationScreenDocument, options)
}
export function useTotpRegistrationScreenLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    TotpRegistrationScreenQuery,
    TotpRegistrationScreenQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    TotpRegistrationScreenQuery,
    TotpRegistrationScreenQueryVariables
  >(TotpRegistrationScreenDocument, options)
}
export type TotpRegistrationScreenQueryHookResult = ReturnType<
  typeof useTotpRegistrationScreenQuery
>
export type TotpRegistrationScreenLazyQueryHookResult = ReturnType<
  typeof useTotpRegistrationScreenLazyQuery
>
export type TotpRegistrationScreenQueryResult = Apollo.QueryResult<
  TotpRegistrationScreenQuery,
  TotpRegistrationScreenQueryVariables
>
export const UserTotpRegistrationInitiateDocument = gql`
  mutation userTotpRegistrationInitiate($input: UserTotpRegistrationInitiateInput!) {
    userTotpRegistrationInitiate(input: $input) {
      errors {
        message
      }
      totpRegistrationId
      totpSecret
    }
  }
`
export type UserTotpRegistrationInitiateMutationFn = Apollo.MutationFunction<
  UserTotpRegistrationInitiateMutation,
  UserTotpRegistrationInitiateMutationVariables
>

/**
 * __useUserTotpRegistrationInitiateMutation__
 *
 * To run a mutation, you first call `useUserTotpRegistrationInitiateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserTotpRegistrationInitiateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userTotpRegistrationInitiateMutation, { data, loading, error }] = useUserTotpRegistrationInitiateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserTotpRegistrationInitiateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserTotpRegistrationInitiateMutation,
    UserTotpRegistrationInitiateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserTotpRegistrationInitiateMutation,
    UserTotpRegistrationInitiateMutationVariables
  >(UserTotpRegistrationInitiateDocument, options)
}
export type UserTotpRegistrationInitiateMutationHookResult = ReturnType<
  typeof useUserTotpRegistrationInitiateMutation
>
export type UserTotpRegistrationInitiateMutationResult =
  Apollo.MutationResult<UserTotpRegistrationInitiateMutation>
export type UserTotpRegistrationInitiateMutationOptions = Apollo.BaseMutationOptions<
  UserTotpRegistrationInitiateMutation,
  UserTotpRegistrationInitiateMutationVariables
>
export const UserTotpRegistrationValidateDocument = gql`
  mutation userTotpRegistrationValidate($input: UserTotpRegistrationValidateInput!) {
    userTotpRegistrationValidate(input: $input) {
      errors {
        message
      }
      me {
        totpEnabled
        phone
        email {
          address
          verified
        }
      }
    }
  }
`
export type UserTotpRegistrationValidateMutationFn = Apollo.MutationFunction<
  UserTotpRegistrationValidateMutation,
  UserTotpRegistrationValidateMutationVariables
>

/**
 * __useUserTotpRegistrationValidateMutation__
 *
 * To run a mutation, you first call `useUserTotpRegistrationValidateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserTotpRegistrationValidateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userTotpRegistrationValidateMutation, { data, loading, error }] = useUserTotpRegistrationValidateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserTotpRegistrationValidateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    UserTotpRegistrationValidateMutation,
    UserTotpRegistrationValidateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    UserTotpRegistrationValidateMutation,
    UserTotpRegistrationValidateMutationVariables
  >(UserTotpRegistrationValidateDocument, options)
}
export type UserTotpRegistrationValidateMutationHookResult = ReturnType<
  typeof useUserTotpRegistrationValidateMutation
>
export type UserTotpRegistrationValidateMutationResult =
  Apollo.MutationResult<UserTotpRegistrationValidateMutation>
export type UserTotpRegistrationValidateMutationOptions = Apollo.BaseMutationOptions<
  UserTotpRegistrationValidateMutation,
  UserTotpRegistrationValidateMutationVariables
>
export const TransactionListForDefaultAccountDocument = gql`
  query transactionListForDefaultAccount(
    $first: Int
    $after: String
    $last: Int
    $before: String
  ) {
    me {
      id
      defaultAccount {
        id
        transactions(first: $first, after: $after, last: $last, before: $before) {
          ...TransactionList
        }
      }
    }
  }
  ${TransactionListFragmentDoc}
`

/**
 * __useTransactionListForDefaultAccountQuery__
 *
 * To run a query within a React component, call `useTransactionListForDefaultAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionListForDefaultAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionListForDefaultAccountQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      last: // value for 'last'
 *      before: // value for 'before'
 *   },
 * });
 */
export function useTransactionListForDefaultAccountQuery(
  baseOptions?: Apollo.QueryHookOptions<
    TransactionListForDefaultAccountQuery,
    TransactionListForDefaultAccountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<
    TransactionListForDefaultAccountQuery,
    TransactionListForDefaultAccountQueryVariables
  >(TransactionListForDefaultAccountDocument, options)
}
export function useTransactionListForDefaultAccountLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<
    TransactionListForDefaultAccountQuery,
    TransactionListForDefaultAccountQueryVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<
    TransactionListForDefaultAccountQuery,
    TransactionListForDefaultAccountQueryVariables
  >(TransactionListForDefaultAccountDocument, options)
}
export type TransactionListForDefaultAccountQueryHookResult = ReturnType<
  typeof useTransactionListForDefaultAccountQuery
>
export type TransactionListForDefaultAccountLazyQueryHookResult = ReturnType<
  typeof useTransactionListForDefaultAccountLazyQuery
>
export type TransactionListForDefaultAccountQueryResult = Apollo.QueryResult<
  TransactionListForDefaultAccountQuery,
  TransactionListForDefaultAccountQueryVariables
>
export const DeviceNotificationTokenCreateDocument = gql`
  mutation deviceNotificationTokenCreate($input: DeviceNotificationTokenCreateInput!) {
    deviceNotificationTokenCreate(input: $input) {
      errors {
        message
      }
      success
    }
  }
`
export type DeviceNotificationTokenCreateMutationFn = Apollo.MutationFunction<
  DeviceNotificationTokenCreateMutation,
  DeviceNotificationTokenCreateMutationVariables
>

/**
 * __useDeviceNotificationTokenCreateMutation__
 *
 * To run a mutation, you first call `useDeviceNotificationTokenCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeviceNotificationTokenCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deviceNotificationTokenCreateMutation, { data, loading, error }] = useDeviceNotificationTokenCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeviceNotificationTokenCreateMutation(
  baseOptions?: Apollo.MutationHookOptions<
    DeviceNotificationTokenCreateMutation,
    DeviceNotificationTokenCreateMutationVariables
  >,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useMutation<
    DeviceNotificationTokenCreateMutation,
    DeviceNotificationTokenCreateMutationVariables
  >(DeviceNotificationTokenCreateDocument, options)
}
export type DeviceNotificationTokenCreateMutationHookResult = ReturnType<
  typeof useDeviceNotificationTokenCreateMutation
>
export type DeviceNotificationTokenCreateMutationResult =
  Apollo.MutationResult<DeviceNotificationTokenCreateMutation>
export type DeviceNotificationTokenCreateMutationOptions = Apollo.BaseMutationOptions<
  DeviceNotificationTokenCreateMutation,
  DeviceNotificationTokenCreateMutationVariables
>
export const WalletsDocument = gql`
  query wallets {
    me {
      id
      defaultAccount {
        id
        wallets {
          walletCurrency
          id
          lnurlp
        }
      }
    }
  }
`

/**
 * __useWalletsQuery__
 *
 * To run a query within a React component, call `useWalletsQuery` and pass it any options that fit your needs.
 * When your component renders, `useWalletsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWalletsQuery({
 *   variables: {
 *   },
 * });
 */
export function useWalletsQuery(
  baseOptions?: Apollo.QueryHookOptions<WalletsQuery, WalletsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useQuery<WalletsQuery, WalletsQueryVariables>(WalletsDocument, options)
}
export function useWalletsLazyQuery(
  baseOptions?: Apollo.LazyQueryHookOptions<WalletsQuery, WalletsQueryVariables>,
) {
  const options = { ...defaultOptions, ...baseOptions }
  return Apollo.useLazyQuery<WalletsQuery, WalletsQueryVariables>(
    WalletsDocument,
    options,
  )
}
export type WalletsQueryHookResult = ReturnType<typeof useWalletsQuery>
export type WalletsLazyQueryHookResult = ReturnType<typeof useWalletsLazyQuery>
export type WalletsQueryResult = Apollo.QueryResult<WalletsQuery, WalletsQueryVariables>
