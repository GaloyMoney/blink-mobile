// this file is autogenerated by codegen
/* eslint-disable */
import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  /** An Opaque Bearer token */
  AuthToken: { input: string; output: string; }
  /** (Positive) Cent amount (1/100 of a dollar) */
  CentAmount: { input: number; output: number; }
  /** An alias name that a user can set for a wallet (with which they have transactions) */
  ContactAlias: { input: string; output: string; }
  /** A CCA2 country code (ex US, FR, etc) */
  CountryCode: { input: string; output: string; }
  /** Display currency of an account */
  DisplayCurrency: { input: string; output: string; }
  /** Email address */
  EmailAddress: { input: string; output: string; }
  /** An id to be passed between registrationInitiate and registrationValidate for confirming email */
  EmailRegistrationId: { input: string; output: string; }
  EndpointId: { input: string; output: string; }
  /** Url that will be fetched on events for the account */
  EndpointUrl: { input: string; output: string; }
  /** Feedback shared with our user */
  Feedback: { input: string; output: string; }
  /** Hex-encoded string of 32 bytes */
  Hex32Bytes: { input: string; output: string; }
  Language: { input: string; output: string; }
  LeaderboardName: { input: string; output: string; }
  LnPaymentPreImage: { input: string; output: string; }
  /** BOLT11 lightning invoice payment request with the amount included */
  LnPaymentRequest: { input: string; output: string; }
  LnPaymentSecret: { input: string; output: string; }
  /** Text field in a lightning payment transaction */
  Memo: { input: string; output: string; }
  /** (Positive) amount of minutes */
  Minutes: { input: string; output: string; }
  NotificationCategory: { input: string; output: string; }
  /** An address for an on-chain bitcoin destination */
  OnChainAddress: { input: string; output: string; }
  OnChainTxHash: { input: string; output: string; }
  /** An authentication code valid for a single use */
  OneTimeAuthCode: { input: string; output: string; }
  PaymentHash: { input: string; output: string; }
  /** Phone number which includes country code */
  Phone: { input: string; output: string; }
  /** Non-fractional signed whole numeric value between -(2^53) + 1 and 2^53 - 1 */
  SafeInt: { input: number; output: number; }
  /** (Positive) Satoshi amount */
  SatAmount: { input: number; output: number; }
  /** (Positive) amount of seconds */
  Seconds: { input: number; output: number; }
  /** An amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedAmount: { input: number; output: number; }
  /** A string amount (of a currency) that can be negative (e.g. in a transaction) */
  SignedDisplayMajorAmount: { input: string; output: string; }
  /** Timestamp field, serialized as Unix time (the number of seconds since the Unix epoch) */
  Timestamp: { input: number; output: number; }
  /** A time-based one-time password */
  TotpCode: { input: string; output: string; }
  /** An id to be passed between set and verify for confirming totp */
  TotpRegistrationId: { input: string; output: string; }
  /** A secret to generate time-based one-time password */
  TotpSecret: { input: string; output: string; }
  /** An external reference id that can be optionally added for transactions. */
  TxExternalId: { input: string; output: string; }
  /** Unique identifier of a user */
  Username: { input: string; output: string; }
  /** Unique identifier of a wallet */
  WalletId: { input: string; output: string; }
  _FieldSet: { input: string; output: string; }
};

export type Account = {
  readonly btcWallet?: Maybe<BtcWallet>;
  readonly callbackEndpoints: ReadonlyArray<CallbackEndpoint>;
  readonly callbackPortalUrl: Scalars['String']['output'];
  readonly csvTransactions: Scalars['String']['output'];
  readonly defaultWallet: PublicWallet;
  /** @deprecated Shifting property to 'defaultWallet.id' */
  readonly defaultWalletId: Scalars['WalletId']['output'];
  readonly displayCurrency: Scalars['DisplayCurrency']['output'];
  readonly id: Scalars['ID']['output'];
  readonly invoices?: Maybe<InvoiceConnection>;
  readonly level: AccountLevel;
  readonly limits: AccountLimits;
  readonly notificationSettings: NotificationSettings;
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  readonly realtimePrice: RealtimePrice;
  readonly transactions?: Maybe<TransactionConnection>;
  readonly usdWallet?: Maybe<UsdWallet>;
  readonly walletById: Wallet;
  readonly wallets: ReadonlyArray<Wallet>;
};


export type AccountCsvTransactionsArgs = {
  walletIds: ReadonlyArray<Scalars['WalletId']['input']>;
};


export type AccountInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']['input']>>>;
};


export type AccountPendingIncomingTransactionsArgs = {
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']['input']>>>;
};


export type AccountTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']['input']>>>;
};


export type AccountWalletByIdArgs = {
  walletId: Scalars['WalletId']['input'];
};

export type AccountDeletePayload = {
  readonly __typename: 'AccountDeletePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly success: Scalars['Boolean']['output'];
};

export type AccountDisableNotificationCategoryInput = {
  readonly category: Scalars['NotificationCategory']['input'];
  readonly channel?: InputMaybe<NotificationChannel>;
};

export type AccountDisableNotificationChannelInput = {
  readonly channel: NotificationChannel;
};

export type AccountEnableNotificationCategoryInput = {
  readonly category: Scalars['NotificationCategory']['input'];
  readonly channel?: InputMaybe<NotificationChannel>;
};

export type AccountEnableNotificationChannelInput = {
  readonly channel: NotificationChannel;
};

export const AccountLevel = {
  One: 'ONE',
  Two: 'TWO',
  Zero: 'ZERO'
} as const;

export type AccountLevel = typeof AccountLevel[keyof typeof AccountLevel];
export type AccountLimit = {
  /** The rolling time interval in seconds that the limits would apply for. */
  readonly interval?: Maybe<Scalars['Seconds']['output']>;
  /** The amount of cents remaining below the limit for the current 24 hour period. */
  readonly remainingLimit?: Maybe<Scalars['CentAmount']['output']>;
  /** The current maximum limit for a given 24 hour period. */
  readonly totalLimit: Scalars['CentAmount']['output'];
};

export type AccountLimits = {
  readonly __typename: 'AccountLimits';
  /** Limits for converting between currencies among a account's own wallets. */
  readonly convert: ReadonlyArray<AccountLimit>;
  /** Limits for sending to other internal accounts. */
  readonly internalSend: ReadonlyArray<AccountLimit>;
  /** Limits for withdrawing to external onchain or lightning destinations. */
  readonly withdrawal: ReadonlyArray<AccountLimit>;
};

export type AccountUpdateDefaultWalletIdInput = {
  readonly walletId: Scalars['WalletId']['input'];
};

export type AccountUpdateDefaultWalletIdPayload = {
  readonly __typename: 'AccountUpdateDefaultWalletIdPayload';
  readonly account?: Maybe<ConsumerAccount>;
  readonly errors: ReadonlyArray<Error>;
};

export type AccountUpdateDisplayCurrencyInput = {
  readonly currency: Scalars['DisplayCurrency']['input'];
};

export type AccountUpdateDisplayCurrencyPayload = {
  readonly __typename: 'AccountUpdateDisplayCurrencyPayload';
  readonly account?: Maybe<ConsumerAccount>;
  readonly errors: ReadonlyArray<Error>;
};

export type AccountUpdateNotificationSettingsPayload = {
  readonly __typename: 'AccountUpdateNotificationSettingsPayload';
  readonly account?: Maybe<ConsumerAccount>;
  readonly errors: ReadonlyArray<Error>;
};

export type ApiKey = {
  readonly __typename: 'ApiKey';
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly expired: Scalars['Boolean']['output'];
  readonly expiresAt?: Maybe<Scalars['Timestamp']['output']>;
  readonly id: Scalars['ID']['output'];
  readonly lastUsedAt?: Maybe<Scalars['Timestamp']['output']>;
  readonly name: Scalars['String']['output'];
  readonly readOnly: Scalars['Boolean']['output'];
  readonly revoked: Scalars['Boolean']['output'];
  readonly scopes: ReadonlyArray<Scope>;
};

export type ApiKeyCreateInput = {
  readonly expireInDays?: InputMaybe<Scalars['Int']['input']>;
  readonly name: Scalars['String']['input'];
  readonly scopes?: ReadonlyArray<Scope>;
};

export type ApiKeyCreatePayload = {
  readonly __typename: 'ApiKeyCreatePayload';
  readonly apiKey: ApiKey;
  readonly apiKeySecret: Scalars['String']['output'];
};

export type ApiKeyRevokeInput = {
  readonly id: Scalars['ID']['input'];
};

export type ApiKeyRevokePayload = {
  readonly __typename: 'ApiKeyRevokePayload';
  readonly apiKey: ApiKey;
};

export type AuthTokenPayload = {
  readonly __typename: 'AuthTokenPayload';
  readonly authToken?: Maybe<Scalars['AuthToken']['output']>;
  readonly errors: ReadonlyArray<Error>;
  readonly totpRequired?: Maybe<Scalars['Boolean']['output']>;
};

export type Authorization = {
  readonly __typename: 'Authorization';
  readonly scopes: ReadonlyArray<Scope>;
};

/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWallet = Wallet & {
  readonly __typename: 'BTCWallet';
  readonly accountId: Scalars['ID']['output'];
  /** A balance stored in BTC. */
  readonly balance: Scalars['SignedAmount']['output'];
  readonly id: Scalars['ID']['output'];
  readonly invoiceByPaymentHash: Invoice;
  /** A list of all invoices associated with walletIds optionally passed. */
  readonly invoices?: Maybe<InvoiceConnection>;
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars['SignedAmount']['output'];
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  readonly pendingIncomingTransactionsByAddress: ReadonlyArray<Transaction>;
  readonly transactionById: Transaction;
  /** A list of BTC transactions associated with this wallet. */
  readonly transactions?: Maybe<TransactionConnection>;
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  readonly transactionsByPaymentHash: ReadonlyArray<Transaction>;
  readonly transactionsByPaymentRequest: ReadonlyArray<Transaction>;
  readonly walletCurrency: WalletCurrency;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletInvoiceByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash']['input'];
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletPendingIncomingTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionByIdArgs = {
  transactionId: Scalars['ID']['input'];
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash']['input'];
};


/** A wallet belonging to an account which contains a BTC balance and a list of transactions. */
export type BtcWalletTransactionsByPaymentRequestArgs = {
  paymentRequest: Scalars['LnPaymentRequest']['input'];
};

export type BuildInformation = {
  readonly __typename: 'BuildInformation';
  readonly commitHash?: Maybe<Scalars['String']['output']>;
  readonly helmRevision?: Maybe<Scalars['Int']['output']>;
};

export type CallbackEndpoint = {
  readonly __typename: 'CallbackEndpoint';
  readonly id: Scalars['EndpointId']['output'];
  readonly url: Scalars['EndpointUrl']['output'];
};

export type CallbackEndpointAddInput = {
  /** callback endpoint to be called */
  readonly url: Scalars['EndpointUrl']['input'];
};

export type CallbackEndpointAddPayload = {
  readonly __typename: 'CallbackEndpointAddPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly id?: Maybe<Scalars['EndpointId']['output']>;
};

export type CallbackEndpointDeleteInput = {
  readonly id: Scalars['EndpointId']['input'];
};

export type CaptchaCreateChallengePayload = {
  readonly __typename: 'CaptchaCreateChallengePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly result?: Maybe<CaptchaCreateChallengeResult>;
};

export type CaptchaCreateChallengeResult = {
  readonly __typename: 'CaptchaCreateChallengeResult';
  readonly challengeCode: Scalars['String']['output'];
  readonly failbackMode: Scalars['Boolean']['output'];
  readonly id: Scalars['String']['output'];
  readonly newCaptcha: Scalars['Boolean']['output'];
};

export type CaptchaRequestAuthCodeInput = {
  readonly challengeCode: Scalars['String']['input'];
  readonly channel?: InputMaybe<PhoneCodeChannelType>;
  readonly phone: Scalars['Phone']['input'];
  readonly secCode: Scalars['String']['input'];
  readonly validationCode: Scalars['String']['input'];
};

export type CentAmountPayload = {
  readonly __typename: 'CentAmountPayload';
  readonly amount?: Maybe<Scalars['CentAmount']['output']>;
  readonly errors: ReadonlyArray<Error>;
};

export type ConsumerAccount = Account & {
  readonly __typename: 'ConsumerAccount';
  readonly btcWallet?: Maybe<BtcWallet>;
  readonly callbackEndpoints: ReadonlyArray<CallbackEndpoint>;
  readonly callbackPortalUrl: Scalars['String']['output'];
  /** return CSV stream, base64 encoded, of the list of transactions in the wallet */
  readonly csvTransactions: Scalars['String']['output'];
  readonly defaultWallet: PublicWallet;
  readonly defaultWalletId: Scalars['WalletId']['output'];
  readonly displayCurrency: Scalars['DisplayCurrency']['output'];
  readonly firstName?: Maybe<Scalars['String']['output']>;
  readonly id: Scalars['ID']['output'];
  /** A list of all invoices associated with walletIds optionally passed. */
  readonly invoices?: Maybe<InvoiceConnection>;
  readonly lastName?: Maybe<Scalars['String']['output']>;
  readonly level: AccountLevel;
  readonly limits: AccountLimits;
  readonly notificationSettings: NotificationSettings;
  readonly onboardingStatus?: Maybe<OnboardingStatus>;
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  /** List the quiz questions of the consumer account */
  readonly quiz: ReadonlyArray<Quiz>;
  readonly realtimePrice: RealtimePrice;
  /** A list of all transactions associated with walletIds optionally passed. */
  readonly transactions?: Maybe<TransactionConnection>;
  readonly usdWallet?: Maybe<UsdWallet>;
  readonly walletById: Wallet;
  readonly wallets: ReadonlyArray<Wallet>;
  readonly welcomeProfile?: Maybe<WelcomeProfile>;
};


export type ConsumerAccountCsvTransactionsArgs = {
  walletIds: ReadonlyArray<Scalars['WalletId']['input']>;
};


export type ConsumerAccountInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']['input']>>>;
};


export type ConsumerAccountPendingIncomingTransactionsArgs = {
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']['input']>>>;
};


export type ConsumerAccountTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  walletIds?: InputMaybe<ReadonlyArray<InputMaybe<Scalars['WalletId']['input']>>>;
};


export type ConsumerAccountWalletByIdArgs = {
  walletId: Scalars['WalletId']['input'];
};

export type Contact = {
  readonly __typename: 'Contact';
  readonly prettyName: Scalars['String']['output'];
};

export type Coordinates = {
  readonly __typename: 'Coordinates';
  readonly latitude: Scalars['Float']['output'];
  readonly longitude: Scalars['Float']['output'];
};

export type Country = {
  readonly __typename: 'Country';
  readonly id: Scalars['CountryCode']['output'];
  readonly supportedAuthChannels: ReadonlyArray<PhoneCodeChannelType>;
};

export type Currency = {
  readonly __typename: 'Currency';
  readonly flag: Scalars['String']['output'];
  readonly fractionDigits: Scalars['Int']['output'];
  readonly id: Scalars['ID']['output'];
  readonly name: Scalars['String']['output'];
  readonly symbol: Scalars['String']['output'];
};

export type CurrencyConversionEstimation = {
  readonly __typename: 'CurrencyConversionEstimation';
  /** Amount in satoshis. */
  readonly btcSatAmount: Scalars['SatAmount']['output'];
  readonly id: Scalars['ID']['output'];
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars['Timestamp']['output'];
  /** Amount in USD cents. */
  readonly usdCentAmount: Scalars['CentAmount']['output'];
};

export type DepositFeesInformation = {
  readonly __typename: 'DepositFeesInformation';
  readonly minBankFee: Scalars['String']['output'];
  /** below this amount minBankFee will be charged */
  readonly minBankFeeThreshold: Scalars['String']['output'];
  /** ratio to charge as basis points above minBankFeeThreshold amount */
  readonly ratio: Scalars['String']['output'];
};

export type DeviceNotificationTokenCreateInput = {
  readonly deviceToken: Scalars['String']['input'];
};

export type Email = {
  readonly __typename: 'Email';
  readonly address?: Maybe<Scalars['EmailAddress']['output']>;
  readonly verified?: Maybe<Scalars['Boolean']['output']>;
};

export type Error = {
  readonly code?: Maybe<Scalars['String']['output']>;
  readonly message: Scalars['String']['output'];
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
};

export const ExchangeCurrencyUnit = {
  Btcsat: 'BTCSAT',
  Usdcent: 'USDCENT'
} as const;

export type ExchangeCurrencyUnit = typeof ExchangeCurrencyUnit[keyof typeof ExchangeCurrencyUnit];
export type FeedbackSubmitInput = {
  readonly feedback: Scalars['Feedback']['input'];
};

export type FeesInformation = {
  readonly __typename: 'FeesInformation';
  readonly deposit: DepositFeesInformation;
};

/** Provides global settings for the application which might have an impact for the user. */
export type Globals = {
  readonly __typename: 'Globals';
  readonly buildInformation: BuildInformation;
  readonly feesInformation: FeesInformation;
  /** The domain name for lightning addresses accepted by this Galoy instance */
  readonly lightningAddressDomain: Scalars['String']['output'];
  readonly lightningAddressDomainAliases: ReadonlyArray<Scalars['String']['output']>;
  /** Which network (mainnet, testnet, regtest, signet) this instance is running on. */
  readonly network: Network;
  /**
   * A list of public keys for the running lightning nodes.
   * This can be used to know if an invoice belongs to one of our nodes.
   */
  readonly nodesIds: ReadonlyArray<Scalars['String']['output']>;
  /** A list of countries and their supported auth channels */
  readonly supportedCountries: ReadonlyArray<Country>;
};

export type GraphQlApplicationError = Error & {
  readonly __typename: 'GraphQLApplicationError';
  readonly code?: Maybe<Scalars['String']['output']>;
  readonly message: Scalars['String']['output'];
  readonly path?: Maybe<ReadonlyArray<Maybe<Scalars['String']['output']>>>;
};

export const Icon = {
  ArrowLeft: 'ARROW_LEFT',
  ArrowRight: 'ARROW_RIGHT',
  BackSpace: 'BACK_SPACE',
  Bank: 'BANK',
  Bell: 'BELL',
  Bitcoin: 'BITCOIN',
  Book: 'BOOK',
  BtcBook: 'BTC_BOOK',
  CaretDown: 'CARET_DOWN',
  CaretLeft: 'CARET_LEFT',
  CaretRight: 'CARET_RIGHT',
  CaretUp: 'CARET_UP',
  Check: 'CHECK',
  CheckCircle: 'CHECK_CIRCLE',
  Close: 'CLOSE',
  CloseCrossWithBackground: 'CLOSE_CROSS_WITH_BACKGROUND',
  Coins: 'COINS',
  CopyPaste: 'COPY_PASTE',
  Dollar: 'DOLLAR',
  Eye: 'EYE',
  EyeSlash: 'EYE_SLASH',
  Filter: 'FILTER',
  Globe: 'GLOBE',
  Graph: 'GRAPH',
  Image: 'IMAGE',
  Info: 'INFO',
  Lightning: 'LIGHTNING',
  Link: 'LINK',
  Loading: 'LOADING',
  MagnifyingGlass: 'MAGNIFYING_GLASS',
  Map: 'MAP',
  Menu: 'MENU',
  Note: 'NOTE',
  PaymentError: 'PAYMENT_ERROR',
  PaymentPending: 'PAYMENT_PENDING',
  PaymentSuccess: 'PAYMENT_SUCCESS',
  Pencil: 'PENCIL',
  People: 'PEOPLE',
  QrCode: 'QR_CODE',
  Question: 'QUESTION',
  Rank: 'RANK',
  Receive: 'RECEIVE',
  Refresh: 'REFRESH',
  Send: 'SEND',
  Settings: 'SETTINGS',
  Share: 'SHARE',
  Transfer: 'TRANSFER',
  User: 'USER',
  Video: 'VIDEO',
  Warning: 'WARNING',
  WarningWithBackground: 'WARNING_WITH_BACKGROUND'
} as const;

export type Icon = typeof Icon[keyof typeof Icon];
export type InitiationVia = InitiationViaIntraLedger | InitiationViaLn | InitiationViaOnChain;

export type InitiationViaIntraLedger = {
  readonly __typename: 'InitiationViaIntraLedger';
  readonly counterPartyUsername?: Maybe<Scalars['Username']['output']>;
  readonly counterPartyWalletId?: Maybe<Scalars['WalletId']['output']>;
};

export type InitiationViaLn = {
  readonly __typename: 'InitiationViaLn';
  readonly paymentHash: Scalars['PaymentHash']['output'];
  /** Bolt11 invoice */
  readonly paymentRequest: Scalars['LnPaymentRequest']['output'];
};

export type InitiationViaOnChain = {
  readonly __typename: 'InitiationViaOnChain';
  readonly address: Scalars['OnChainAddress']['output'];
};

export type IntraLedgerPaymentSendInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount']['input'];
  /** Optional memo to be attached to the payment. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  readonly recipientWalletId: Scalars['WalletId']['input'];
  /** The wallet ID of the sender. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type IntraLedgerUpdate = {
  readonly __typename: 'IntraLedgerUpdate';
  /** @deprecated Deprecated in favor of transaction */
  readonly amount: Scalars['SatAmount']['output'];
  /** @deprecated Deprecated in favor of transaction */
  readonly displayCurrencyPerSat: Scalars['Float']['output'];
  readonly transaction: Transaction;
  readonly txNotificationType: TxNotificationType;
  /** @deprecated updated over displayCurrencyPerSat */
  readonly usdPerSat: Scalars['Float']['output'];
  /** @deprecated Deprecated in favor of transaction */
  readonly walletId: Scalars['WalletId']['output'];
};

export type IntraLedgerUsdPaymentSendInput = {
  /** Amount in cents. */
  readonly amount: Scalars['CentAmount']['input'];
  /** Optional memo to be attached to the payment. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  readonly recipientWalletId: Scalars['WalletId']['input'];
  /** The wallet ID of the sender. */
  readonly walletId: Scalars['WalletId']['input'];
};

/** A lightning invoice. */
export type Invoice = {
  readonly createdAt: Scalars['Timestamp']['output'];
  /** The unique external id set for the invoice. */
  readonly externalId: Scalars['TxExternalId']['output'];
  /** The payment hash of the lightning invoice. */
  readonly paymentHash: Scalars['PaymentHash']['output'];
  /** The bolt11 invoice to be paid. */
  readonly paymentRequest: Scalars['LnPaymentRequest']['output'];
  /** The payment secret of the lightning invoice. This is not the preimage of the payment hash. */
  readonly paymentSecret: Scalars['LnPaymentSecret']['output'];
  /** The payment status of the invoice. */
  readonly paymentStatus: InvoicePaymentStatus;
};

/** A connection to a list of items. */
export type InvoiceConnection = {
  readonly __typename: 'InvoiceConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<InvoiceEdge>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
};

/** An edge in a connection. */
export type InvoiceEdge = {
  readonly __typename: 'InvoiceEdge';
  /** A cursor for use in pagination */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  readonly node: Invoice;
};

export const InvoicePaymentStatus = {
  Expired: 'EXPIRED',
  Paid: 'PAID',
  Pending: 'PENDING'
} as const;

export type InvoicePaymentStatus = typeof InvoicePaymentStatus[keyof typeof InvoicePaymentStatus];
export type Leader = {
  readonly __typename: 'Leader';
  readonly name?: Maybe<Scalars['LeaderboardName']['output']>;
  readonly points: Scalars['Int']['output'];
  readonly rank: Scalars['Int']['output'];
};

export type Leaderboard = {
  readonly __typename: 'Leaderboard';
  readonly leaders: ReadonlyArray<Leader>;
  readonly range: WelcomeRange;
};

export type LnAddressPaymentSendInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount']['input'];
  /** Lightning address to send to. */
  readonly lnAddress: Scalars['String']['input'];
  /** Wallet ID to send bitcoin from. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnInvoice = Invoice & {
  readonly __typename: 'LnInvoice';
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly externalId: Scalars['TxExternalId']['output'];
  readonly paymentHash: Scalars['PaymentHash']['output'];
  readonly paymentRequest: Scalars['LnPaymentRequest']['output'];
  readonly paymentSecret: Scalars['LnPaymentSecret']['output'];
  readonly paymentStatus: InvoicePaymentStatus;
  readonly satoshis: Scalars['SatAmount']['output'];
};

export type LnInvoiceCancelInput = {
  readonly paymentHash: Scalars['PaymentHash']['input'];
  /** Wallet ID for a wallet associated with the current account. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnInvoiceCreateInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount']['input'];
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']['input']>;
  readonly externalId?: InputMaybe<Scalars['TxExternalId']['input']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** Wallet ID for a BTC wallet belonging to the current account. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnInvoiceCreateOnBehalfOfRecipientInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount']['input'];
  readonly descriptionHash?: InputMaybe<Scalars['Hex32Bytes']['input']>;
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']['input']>;
  readonly externalId?: InputMaybe<Scalars['TxExternalId']['input']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** Wallet ID for a BTC wallet which belongs to any account. */
  readonly recipientWalletId: Scalars['WalletId']['input'];
};

export type LnInvoiceFeeProbeInput = {
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnInvoicePayload = {
  readonly __typename: 'LnInvoicePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly invoice?: Maybe<LnInvoice>;
};

export type LnInvoicePaymentInput = {
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
  /** Wallet ID with sufficient balance to cover amount of invoice.  Must belong to the account of the current user. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnInvoicePaymentStatus = {
  readonly __typename: 'LnInvoicePaymentStatus';
  readonly paymentHash?: Maybe<Scalars['PaymentHash']['output']>;
  readonly paymentRequest?: Maybe<Scalars['LnPaymentRequest']['output']>;
  readonly status?: Maybe<InvoicePaymentStatus>;
};

export type LnInvoicePaymentStatusByHashInput = {
  readonly paymentHash: Scalars['PaymentHash']['input'];
};

export type LnInvoicePaymentStatusByPaymentRequestInput = {
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
};

export type LnInvoicePaymentStatusInput = {
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
};

export type LnInvoicePaymentStatusPayload = {
  readonly __typename: 'LnInvoicePaymentStatusPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly paymentHash?: Maybe<Scalars['PaymentHash']['output']>;
  readonly paymentRequest?: Maybe<Scalars['LnPaymentRequest']['output']>;
  readonly status?: Maybe<InvoicePaymentStatus>;
};

export type LnNoAmountInvoice = Invoice & {
  readonly __typename: 'LnNoAmountInvoice';
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly externalId: Scalars['TxExternalId']['output'];
  readonly paymentHash: Scalars['PaymentHash']['output'];
  readonly paymentRequest: Scalars['LnPaymentRequest']['output'];
  readonly paymentSecret: Scalars['LnPaymentSecret']['output'];
  readonly paymentStatus: InvoicePaymentStatus;
};

export type LnNoAmountInvoiceCreateInput = {
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']['input']>;
  readonly externalId?: InputMaybe<Scalars['TxExternalId']['input']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** ID for either a USD or BTC wallet belonging to the account of the current user. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnNoAmountInvoiceCreateOnBehalfOfRecipientInput = {
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']['input']>;
  readonly externalId?: InputMaybe<Scalars['TxExternalId']['input']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** ID for either a USD or BTC wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars['WalletId']['input'];
};

export type LnNoAmountInvoiceFeeProbeInput = {
  readonly amount: Scalars['SatAmount']['input'];
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnNoAmountInvoicePayload = {
  readonly __typename: 'LnNoAmountInvoicePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly invoice?: Maybe<LnNoAmountInvoice>;
};

export type LnNoAmountInvoicePaymentInput = {
  /** Amount to pay in satoshis. */
  readonly amount: Scalars['SatAmount']['input'];
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
  /** Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnNoAmountUsdInvoiceFeeProbeInput = {
  readonly amount: Scalars['CentAmount']['input'];
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnNoAmountUsdInvoicePaymentInput = {
  /** Amount to pay in USD cents. */
  readonly amount: Scalars['CentAmount']['input'];
  /** Optional memo to associate with the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** Payment request representing the invoice which is being paid. */
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
  /** Wallet ID with sufficient balance to cover amount defined in mutation request.  Must belong to the account of the current user. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnUpdate = {
  readonly __typename: 'LnUpdate';
  /** @deprecated Deprecated in favor of transaction */
  readonly paymentHash: Scalars['PaymentHash']['output'];
  readonly status: InvoicePaymentStatus;
  readonly transaction: Transaction;
  /** @deprecated Deprecated in favor of transaction */
  readonly walletId: Scalars['WalletId']['output'];
};

export type LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount']['input'];
  readonly descriptionHash?: InputMaybe<Scalars['Hex32Bytes']['input']>;
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']['input']>;
  readonly externalId?: InputMaybe<Scalars['TxExternalId']['input']>;
  /** Optional memo for the lightning invoice. Acts as a note to the recipient. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** Wallet ID for a USD wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars['WalletId']['input'];
};

export type LnUsdInvoiceCreateInput = {
  /** Amount in USD cents. */
  readonly amount: Scalars['CentAmount']['input'];
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']['input']>;
  readonly externalId?: InputMaybe<Scalars['TxExternalId']['input']>;
  /** Optional memo for the lightning invoice. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** Wallet ID for a USD wallet belonging to the current user. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnUsdInvoiceCreateOnBehalfOfRecipientInput = {
  /** Amount in USD cents. */
  readonly amount: Scalars['CentAmount']['input'];
  readonly descriptionHash?: InputMaybe<Scalars['Hex32Bytes']['input']>;
  /** Optional invoice expiration time in minutes. */
  readonly expiresIn?: InputMaybe<Scalars['Minutes']['input']>;
  readonly externalId?: InputMaybe<Scalars['TxExternalId']['input']>;
  /** Optional memo for the lightning invoice. Acts as a note to the recipient. */
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  /** Wallet ID for a USD wallet which belongs to the account of any user. */
  readonly recipientWalletId: Scalars['WalletId']['input'];
};

export type LnUsdInvoiceFeeProbeInput = {
  readonly paymentRequest: Scalars['LnPaymentRequest']['input'];
  readonly walletId: Scalars['WalletId']['input'];
};

export type LnurlPaymentSendInput = {
  /** Amount in satoshis. */
  readonly amount: Scalars['SatAmount']['input'];
  /** Lnurl string to send to. */
  readonly lnurl: Scalars['String']['input'];
  /** Wallet ID to send bitcoin from. */
  readonly walletId: Scalars['WalletId']['input'];
};

export type MapInfo = {
  readonly __typename: 'MapInfo';
  readonly coordinates: Coordinates;
  readonly title: Scalars['String']['output'];
};

export type MapMarker = {
  readonly __typename: 'MapMarker';
  readonly mapInfo: MapInfo;
  readonly username: Scalars['Username']['output'];
};

export type Merchant = {
  readonly __typename: 'Merchant';
  /** GPS coordinates for the merchant that can be used to place the related business on a map */
  readonly coordinates: Coordinates;
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly id: Scalars['ID']['output'];
  readonly title: Scalars['String']['output'];
  /** The username of the merchant */
  readonly username: Scalars['Username']['output'];
  /** Whether the merchant has been validated */
  readonly validated: Scalars['Boolean']['output'];
};

export type MerchantMapSuggestInput = {
  readonly latitude: Scalars['Float']['input'];
  readonly longitude: Scalars['Float']['input'];
  readonly title: Scalars['String']['input'];
  readonly username: Scalars['Username']['input'];
};

export type MerchantPayload = {
  readonly __typename: 'MerchantPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly merchant?: Maybe<Merchant>;
};

export type MobileVersions = {
  readonly __typename: 'MobileVersions';
  readonly currentSupported: Scalars['Int']['output'];
  readonly minSupported: Scalars['Int']['output'];
  readonly platform: Scalars['String']['output'];
};

export type Mutation = {
  readonly __typename: 'Mutation';
  readonly accountDelete: AccountDeletePayload;
  readonly accountDisableNotificationCategory: AccountUpdateNotificationSettingsPayload;
  readonly accountDisableNotificationChannel: AccountUpdateNotificationSettingsPayload;
  readonly accountEnableNotificationCategory: AccountUpdateNotificationSettingsPayload;
  readonly accountEnableNotificationChannel: AccountUpdateNotificationSettingsPayload;
  readonly accountUpdateDefaultWalletId: AccountUpdateDefaultWalletIdPayload;
  readonly accountUpdateDisplayCurrency: AccountUpdateDisplayCurrencyPayload;
  readonly apiKeyCreate: ApiKeyCreatePayload;
  readonly apiKeyRevoke: ApiKeyRevokePayload;
  readonly callbackEndpointAdd: CallbackEndpointAddPayload;
  readonly callbackEndpointDelete: SuccessPayload;
  readonly captchaCreateChallenge: CaptchaCreateChallengePayload;
  readonly captchaRequestAuthCode: SuccessPayload;
  readonly deviceNotificationTokenCreate: SuccessPayload;
  readonly feedbackSubmit: SuccessPayload;
  /**
   * Actions a payment which is internal to the ledger e.g. it does
   * not use onchain/lightning. Returns payment status (success,
   * failed, pending, already_paid).
   */
  readonly intraLedgerPaymentSend: PaymentSendPayload;
  /**
   * Actions a payment which is internal to the ledger e.g. it does
   * not use onchain/lightning. Returns payment status (success,
   * failed, pending, already_paid).
   */
  readonly intraLedgerUsdPaymentSend: PaymentSendPayload;
  /** Sends a payment to a lightning address. */
  readonly lnAddressPaymentSend: PaymentSendPayload;
  /** Cancel an unpaid lightning invoice for an associated wallet. */
  readonly lnInvoiceCancel: SuccessPayload;
  /**
   * Returns a lightning invoice for an associated wallet.
   * When invoice is paid the value will be credited to a BTC wallet.
   * Expires after 'expiresIn' or 24 hours.
   */
  readonly lnInvoiceCreate: LnInvoicePayload;
  /**
   * Returns a lightning invoice for an associated wallet.
   * When invoice is paid the value will be credited to a BTC wallet.
   * Expires after 'expiresIn' or 24 hours.
   */
  readonly lnInvoiceCreateOnBehalfOfRecipient: LnInvoicePayload;
  readonly lnInvoiceFeeProbe: SatAmountPayload;
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet can be USD or BTC and must have sufficient balance to cover amount in lightning invoice.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnInvoicePaymentSend: PaymentSendPayload;
  /**
   * Returns a lightning invoice for an associated wallet.
   * Can be used to receive any supported currency value (currently USD or BTC).
   * Expires after 'expiresIn' or 24 hours for BTC invoices or 5 minutes for USD invoices.
   */
  readonly lnNoAmountInvoiceCreate: LnNoAmountInvoicePayload;
  /**
   * Returns a lightning invoice for an associated wallet.
   * Can be used to receive any supported currency value (currently USD or BTC).
   * Expires after 'expiresIn' or 24 hours for BTC invoices or 5 minutes for USD invoices.
   */
  readonly lnNoAmountInvoiceCreateOnBehalfOfRecipient: LnNoAmountInvoicePayload;
  readonly lnNoAmountInvoiceFeeProbe: SatAmountPayload;
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet must be BTC and must have sufficient balance to cover amount specified in mutation request.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnNoAmountInvoicePaymentSend: PaymentSendPayload;
  readonly lnNoAmountUsdInvoiceFeeProbe: CentAmountPayload;
  /**
   * Pay a lightning invoice using a balance from a wallet which is owned by the account of the current user.
   * Provided wallet must be USD and have sufficient balance to cover amount specified in mutation request.
   * Returns payment status (success, failed, pending, already_paid).
   */
  readonly lnNoAmountUsdInvoicePaymentSend: PaymentSendPayload;
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   *   associated with the amount).
   */
  readonly lnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipient: LnInvoicePayload;
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   * associated with the amount).
   */
  readonly lnUsdInvoiceCreate: LnInvoicePayload;
  /**
   * Returns a lightning invoice denominated in satoshis for an associated wallet.
   * When invoice is paid the equivalent value at invoice creation will be credited to a USD wallet.
   * Expires after 'expiresIn' or 5 minutes (short expiry time because there is a USD/BTC exchange rate
   *   associated with the amount).
   */
  readonly lnUsdInvoiceCreateOnBehalfOfRecipient: LnInvoicePayload;
  readonly lnUsdInvoiceFeeProbe: SatAmountPayload;
  /** Sends a payment to a lightning address. */
  readonly lnurlPaymentSend: PaymentSendPayload;
  readonly merchantMapSuggest: MerchantPayload;
  readonly onChainAddressCreate: OnChainAddressPayload;
  readonly onChainAddressCurrent: OnChainAddressPayload;
  readonly onChainPaymentSend: PaymentSendPayload;
  readonly onChainPaymentSendAll: PaymentSendPayload;
  readonly onChainUsdPaymentSend: PaymentSendPayload;
  readonly onChainUsdPaymentSendAsBtcDenominated: PaymentSendPayload;
  readonly onboardingFlowStart: OnboardingFlowStartResult;
  readonly quizClaim: QuizClaimPayload;
  readonly statefulNotificationAcknowledge: StatefulNotificationAcknowledgePayload;
  readonly supportChatMessageAdd: SupportChatMessageAddPayload;
  readonly supportChatReset: SuccessPayload;
  /** @deprecated will be moved to AccountContact */
  readonly userContactUpdateAlias: UserContactUpdateAliasPayload;
  readonly userEmailDelete: UserEmailDeletePayload;
  readonly userEmailRegistrationInitiate: UserEmailRegistrationInitiatePayload;
  readonly userEmailRegistrationValidate: UserEmailRegistrationValidatePayload;
  readonly userLogin: AuthTokenPayload;
  readonly userLoginUpgrade: UpgradePayload;
  readonly userLogout: SuccessPayload;
  readonly userPhoneDelete: UserPhoneDeletePayload;
  readonly userPhoneRegistrationInitiate: SuccessPayload;
  readonly userPhoneRegistrationValidate: UserPhoneRegistrationValidatePayload;
  readonly userTotpDelete: UserTotpDeletePayload;
  readonly userTotpRegistrationInitiate: UserTotpRegistrationInitiatePayload;
  readonly userTotpRegistrationValidate: UserTotpRegistrationValidatePayload;
  readonly userUpdateLanguage: UserUpdateLanguagePayload;
  /** @deprecated Username will be moved to @Handle in Accounts. Also SetUsername naming should be used instead of UpdateUsername to reflect the idempotency of Handles */
  readonly userUpdateUsername: UserUpdateUsernamePayload;
};


export type MutationAccountDisableNotificationCategoryArgs = {
  input: AccountDisableNotificationCategoryInput;
};


export type MutationAccountDisableNotificationChannelArgs = {
  input: AccountDisableNotificationChannelInput;
};


export type MutationAccountEnableNotificationCategoryArgs = {
  input: AccountEnableNotificationCategoryInput;
};


export type MutationAccountEnableNotificationChannelArgs = {
  input: AccountEnableNotificationChannelInput;
};


export type MutationAccountUpdateDefaultWalletIdArgs = {
  input: AccountUpdateDefaultWalletIdInput;
};


export type MutationAccountUpdateDisplayCurrencyArgs = {
  input: AccountUpdateDisplayCurrencyInput;
};


export type MutationApiKeyCreateArgs = {
  input: ApiKeyCreateInput;
};


export type MutationApiKeyRevokeArgs = {
  input: ApiKeyRevokeInput;
};


export type MutationCallbackEndpointAddArgs = {
  input: CallbackEndpointAddInput;
};


export type MutationCallbackEndpointDeleteArgs = {
  input: CallbackEndpointDeleteInput;
};


export type MutationCaptchaRequestAuthCodeArgs = {
  input: CaptchaRequestAuthCodeInput;
};


export type MutationDeviceNotificationTokenCreateArgs = {
  input: DeviceNotificationTokenCreateInput;
};


export type MutationFeedbackSubmitArgs = {
  input: FeedbackSubmitInput;
};


export type MutationIntraLedgerPaymentSendArgs = {
  input: IntraLedgerPaymentSendInput;
};


export type MutationIntraLedgerUsdPaymentSendArgs = {
  input: IntraLedgerUsdPaymentSendInput;
};


export type MutationLnAddressPaymentSendArgs = {
  input: LnAddressPaymentSendInput;
};


export type MutationLnInvoiceCancelArgs = {
  input: LnInvoiceCancelInput;
};


export type MutationLnInvoiceCreateArgs = {
  input: LnInvoiceCreateInput;
};


export type MutationLnInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnInvoiceCreateOnBehalfOfRecipientInput;
};


export type MutationLnInvoiceFeeProbeArgs = {
  input: LnInvoiceFeeProbeInput;
};


export type MutationLnInvoicePaymentSendArgs = {
  input: LnInvoicePaymentInput;
};


export type MutationLnNoAmountInvoiceCreateArgs = {
  input: LnNoAmountInvoiceCreateInput;
};


export type MutationLnNoAmountInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput;
};


export type MutationLnNoAmountInvoiceFeeProbeArgs = {
  input: LnNoAmountInvoiceFeeProbeInput;
};


export type MutationLnNoAmountInvoicePaymentSendArgs = {
  input: LnNoAmountInvoicePaymentInput;
};


export type MutationLnNoAmountUsdInvoiceFeeProbeArgs = {
  input: LnNoAmountUsdInvoiceFeeProbeInput;
};


export type MutationLnNoAmountUsdInvoicePaymentSendArgs = {
  input: LnNoAmountUsdInvoicePaymentInput;
};


export type MutationLnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientArgs = {
  input: LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput;
};


export type MutationLnUsdInvoiceCreateArgs = {
  input: LnUsdInvoiceCreateInput;
};


export type MutationLnUsdInvoiceCreateOnBehalfOfRecipientArgs = {
  input: LnUsdInvoiceCreateOnBehalfOfRecipientInput;
};


export type MutationLnUsdInvoiceFeeProbeArgs = {
  input: LnUsdInvoiceFeeProbeInput;
};


export type MutationLnurlPaymentSendArgs = {
  input: LnurlPaymentSendInput;
};


export type MutationMerchantMapSuggestArgs = {
  input: MerchantMapSuggestInput;
};


export type MutationOnChainAddressCreateArgs = {
  input: OnChainAddressCreateInput;
};


export type MutationOnChainAddressCurrentArgs = {
  input: OnChainAddressCurrentInput;
};


export type MutationOnChainPaymentSendArgs = {
  input: OnChainPaymentSendInput;
};


export type MutationOnChainPaymentSendAllArgs = {
  input: OnChainPaymentSendAllInput;
};


export type MutationOnChainUsdPaymentSendArgs = {
  input: OnChainUsdPaymentSendInput;
};


export type MutationOnChainUsdPaymentSendAsBtcDenominatedArgs = {
  input: OnChainUsdPaymentSendAsBtcDenominatedInput;
};


export type MutationOnboardingFlowStartArgs = {
  input: OnboardingFlowStartInput;
};


export type MutationQuizClaimArgs = {
  input: QuizClaimInput;
};


export type MutationStatefulNotificationAcknowledgeArgs = {
  input: StatefulNotificationAcknowledgeInput;
};


export type MutationSupportChatMessageAddArgs = {
  input: SupportChatMessageAddInput;
};


export type MutationUserContactUpdateAliasArgs = {
  input: UserContactUpdateAliasInput;
};


export type MutationUserEmailRegistrationInitiateArgs = {
  input: UserEmailRegistrationInitiateInput;
};


export type MutationUserEmailRegistrationValidateArgs = {
  input: UserEmailRegistrationValidateInput;
};


export type MutationUserLoginArgs = {
  input: UserLoginInput;
};


export type MutationUserLoginUpgradeArgs = {
  input: UserLoginUpgradeInput;
};


export type MutationUserLogoutArgs = {
  input?: InputMaybe<UserLogoutInput>;
};


export type MutationUserPhoneRegistrationInitiateArgs = {
  input: UserPhoneRegistrationInitiateInput;
};


export type MutationUserPhoneRegistrationValidateArgs = {
  input: UserPhoneRegistrationValidateInput;
};


export type MutationUserTotpRegistrationValidateArgs = {
  input: UserTotpRegistrationValidateInput;
};


export type MutationUserUpdateLanguageArgs = {
  input: UserUpdateLanguageInput;
};


export type MutationUserUpdateUsernameArgs = {
  input: UserUpdateUsernameInput;
};

export type MyUpdatesPayload = {
  readonly __typename: 'MyUpdatesPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
  readonly update?: Maybe<UserUpdate>;
};

export const Network = {
  Mainnet: 'mainnet',
  Regtest: 'regtest',
  Signet: 'signet',
  Testnet: 'testnet'
} as const;

export type Network = typeof Network[keyof typeof Network];
export type NotificationAction = OpenDeepLinkAction | OpenExternalLinkAction;

export const NotificationChannel = {
  Push: 'PUSH'
} as const;

export type NotificationChannel = typeof NotificationChannel[keyof typeof NotificationChannel];
export type NotificationChannelSettings = {
  readonly __typename: 'NotificationChannelSettings';
  readonly disabledCategories: ReadonlyArray<Scalars['NotificationCategory']['output']>;
  readonly enabled: Scalars['Boolean']['output'];
};

export type NotificationSettings = {
  readonly __typename: 'NotificationSettings';
  readonly push: NotificationChannelSettings;
};

export type OnChainAddressCreateInput = {
  readonly walletId: Scalars['WalletId']['input'];
};

export type OnChainAddressCurrentInput = {
  readonly walletId: Scalars['WalletId']['input'];
};

export type OnChainAddressPayload = {
  readonly __typename: 'OnChainAddressPayload';
  readonly address?: Maybe<Scalars['OnChainAddress']['output']>;
  readonly errors: ReadonlyArray<Error>;
};

export type OnChainPaymentSendAllInput = {
  readonly address: Scalars['OnChainAddress']['input'];
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  readonly speed?: PayoutSpeed;
  readonly walletId: Scalars['WalletId']['input'];
};

export type OnChainPaymentSendInput = {
  readonly address: Scalars['OnChainAddress']['input'];
  readonly amount: Scalars['SatAmount']['input'];
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  readonly speed?: PayoutSpeed;
  readonly walletId: Scalars['WalletId']['input'];
};

export type OnChainTxFee = {
  readonly __typename: 'OnChainTxFee';
  readonly amount: Scalars['SatAmount']['output'];
};

export type OnChainUpdate = {
  readonly __typename: 'OnChainUpdate';
  /** @deprecated Deprecated in favor of transaction */
  readonly amount: Scalars['SatAmount']['output'];
  /** @deprecated Deprecated in favor of transaction */
  readonly displayCurrencyPerSat: Scalars['Float']['output'];
  readonly transaction: Transaction;
  /** @deprecated Deprecated in favor of transaction */
  readonly txHash: Scalars['OnChainTxHash']['output'];
  readonly txNotificationType: TxNotificationType;
  /** @deprecated updated over displayCurrencyPerSat */
  readonly usdPerSat: Scalars['Float']['output'];
  /** @deprecated Deprecated in favor of transaction */
  readonly walletId: Scalars['WalletId']['output'];
};

export type OnChainUsdPaymentSendAsBtcDenominatedInput = {
  readonly address: Scalars['OnChainAddress']['input'];
  readonly amount: Scalars['SatAmount']['input'];
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  readonly speed?: PayoutSpeed;
  readonly walletId: Scalars['WalletId']['input'];
};

export type OnChainUsdPaymentSendInput = {
  readonly address: Scalars['OnChainAddress']['input'];
  readonly amount: Scalars['CentAmount']['input'];
  readonly memo?: InputMaybe<Scalars['Memo']['input']>;
  readonly speed?: PayoutSpeed;
  readonly walletId: Scalars['WalletId']['input'];
};

export type OnChainUsdTxFee = {
  readonly __typename: 'OnChainUsdTxFee';
  readonly amount: Scalars['CentAmount']['output'];
};

export type OnboardingFlowStartInput = {
  readonly firstName: Scalars['String']['input'];
  readonly lastName: Scalars['String']['input'];
};

export type OnboardingFlowStartResult = {
  readonly __typename: 'OnboardingFlowStartResult';
  readonly tokenAndroid: Scalars['String']['output'];
  readonly tokenIos: Scalars['String']['output'];
  readonly tokenWeb: Scalars['String']['output'];
  readonly workflowRunId: Scalars['String']['output'];
};

export const OnboardingStatus = {
  Abandoned: 'ABANDONED',
  Approved: 'APPROVED',
  AwaitingInput: 'AWAITING_INPUT',
  Declined: 'DECLINED',
  Error: 'ERROR',
  NotStarted: 'NOT_STARTED',
  Processing: 'PROCESSING',
  Review: 'REVIEW'
} as const;

export type OnboardingStatus = typeof OnboardingStatus[keyof typeof OnboardingStatus];
export type OneDayAccountLimit = AccountLimit & {
  readonly __typename: 'OneDayAccountLimit';
  /** The rolling time interval value in seconds for the current 24 hour period. */
  readonly interval?: Maybe<Scalars['Seconds']['output']>;
  /** The amount of cents remaining below the limit for the current 24 hour period. */
  readonly remainingLimit?: Maybe<Scalars['CentAmount']['output']>;
  /** The current maximum limit for a given 24 hour period. */
  readonly totalLimit: Scalars['CentAmount']['output'];
};

export type OpenDeepLinkAction = {
  readonly __typename: 'OpenDeepLinkAction';
  readonly deepLink: Scalars['String']['output'];
};

export type OpenExternalLinkAction = {
  readonly __typename: 'OpenExternalLinkAction';
  readonly url: Scalars['String']['output'];
};

/** Information about pagination in a connection. */
export type PageInfo = {
  readonly __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  readonly endCursor?: Maybe<Scalars['String']['output']>;
  /** When paginating forwards, are there more items? */
  readonly hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  readonly hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  readonly startCursor?: Maybe<Scalars['String']['output']>;
};

export type PaymentSendPayload = {
  readonly __typename: 'PaymentSendPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly status?: Maybe<PaymentSendResult>;
  readonly transaction?: Maybe<Transaction>;
};

export const PaymentSendResult = {
  AlreadyPaid: 'ALREADY_PAID',
  Failure: 'FAILURE',
  Pending: 'PENDING',
  Success: 'SUCCESS'
} as const;

export type PaymentSendResult = typeof PaymentSendResult[keyof typeof PaymentSendResult];
export const PayoutSpeed = {
  Fast: 'FAST'
} as const;

export type PayoutSpeed = typeof PayoutSpeed[keyof typeof PayoutSpeed];
export const PhoneCodeChannelType = {
  Sms: 'SMS',
  Whatsapp: 'WHATSAPP'
} as const;

export type PhoneCodeChannelType = typeof PhoneCodeChannelType[keyof typeof PhoneCodeChannelType];
/** Price amount expressed in base/offset. To calculate, use: `base / 10^offset` */
export type Price = {
  readonly __typename: 'Price';
  readonly base: Scalars['SafeInt']['output'];
  readonly currencyUnit: Scalars['String']['output'];
  readonly formattedAmount: Scalars['String']['output'];
  readonly offset: Scalars['Int']['output'];
};

/** The range for the X axis in the BTC price graph */
export const PriceGraphRange = {
  FiveYears: 'FIVE_YEARS',
  OneDay: 'ONE_DAY',
  OneMonth: 'ONE_MONTH',
  OneWeek: 'ONE_WEEK',
  OneYear: 'ONE_YEAR'
} as const;

export type PriceGraphRange = typeof PriceGraphRange[keyof typeof PriceGraphRange];
export type PriceInput = {
  readonly amount: Scalars['SatAmount']['input'];
  readonly amountCurrencyUnit: ExchangeCurrencyUnit;
  readonly priceCurrencyUnit: ExchangeCurrencyUnit;
};

export type PriceInterface = {
  readonly base: Scalars['SafeInt']['output'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String']['output'];
  readonly offset: Scalars['Int']['output'];
};

/** Price of 1 sat in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSatInMinorUnit = PriceInterface & {
  readonly __typename: 'PriceOfOneSatInMinorUnit';
  readonly base: Scalars['SafeInt']['output'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String']['output'];
  readonly offset: Scalars['Int']['output'];
};

/** Price of 1 sat or 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneSettlementMinorUnitInDisplayMinorUnit = PriceInterface & {
  readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit';
  readonly base: Scalars['SafeInt']['output'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String']['output'];
  /** @deprecated Deprecated please use `base / 10^offset` */
  readonly formattedAmount: Scalars['String']['output'];
  readonly offset: Scalars['Int']['output'];
};

/** Price of 1 usd cent in base/offset. To calculate, use: `base / 10^offset` */
export type PriceOfOneUsdCentInMinorUnit = PriceInterface & {
  readonly __typename: 'PriceOfOneUsdCentInMinorUnit';
  readonly base: Scalars['SafeInt']['output'];
  /** @deprecated Deprecated due to type renaming */
  readonly currencyUnit: Scalars['String']['output'];
  readonly offset: Scalars['Int']['output'];
};

export type PricePayload = {
  readonly __typename: 'PricePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly price?: Maybe<Price>;
};

export type PricePoint = {
  readonly __typename: 'PricePoint';
  readonly price: Price;
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars['Timestamp']['output'];
};

/** A public view of a generic wallet which stores value in one of our supported currencies. */
export type PublicWallet = {
  readonly __typename: 'PublicWallet';
  readonly currency: WalletCurrency;
  readonly id: Scalars['ID']['output'];
  /** @deprecated Shifting property to 'currency' */
  readonly walletCurrency: WalletCurrency;
};

export type Query = {
  readonly __typename: 'Query';
  readonly accountDefaultWallet: PublicWallet;
  /** Retrieve the list of scopes permitted for the user's token or API key */
  readonly authorization: Authorization;
  readonly beta: Scalars['Boolean']['output'];
  readonly btcPriceList?: Maybe<ReadonlyArray<Maybe<PricePoint>>>;
  readonly businessMapMarkers: ReadonlyArray<MapMarker>;
  readonly colorScheme: Scalars['String']['output'];
  readonly countryCode: Scalars['String']['output'];
  /** Returns an estimated conversion rate for the given amount and currency */
  readonly currencyConversionEstimation: CurrencyConversionEstimation;
  readonly currencyList: ReadonlyArray<Currency>;
  readonly feedbackModalShown: Scalars['Boolean']['output'];
  readonly globals?: Maybe<Globals>;
  readonly hasPromptedSetDefaultAccount: Scalars['Boolean']['output'];
  readonly hiddenBalanceToolTip: Scalars['Boolean']['output'];
  readonly hideBalance: Scalars['Boolean']['output'];
  readonly innerCircleValue: Scalars['Int']['output'];
  readonly introducingCirclesModalShown: Scalars['Boolean']['output'];
  /** @deprecated Deprecated in favor of lnInvoicePaymentStatusByPaymentRequest */
  readonly lnInvoicePaymentStatus: LnInvoicePaymentStatusPayload;
  readonly lnInvoicePaymentStatusByHash: LnInvoicePaymentStatus;
  readonly lnInvoicePaymentStatusByPaymentRequest: LnInvoicePaymentStatus;
  readonly me?: Maybe<User>;
  readonly mobileVersions?: Maybe<ReadonlyArray<Maybe<MobileVersions>>>;
  readonly onChainTxFee: OnChainTxFee;
  readonly onChainUsdTxFee: OnChainUsdTxFee;
  readonly onChainUsdTxFeeAsBtcDenominated: OnChainUsdTxFee;
  readonly price?: Maybe<Scalars['String']['output']>;
  /** Returns 1 Sat and 1 Usd Cent price for the given currency in minor unit */
  readonly realtimePrice: RealtimePrice;
  readonly region?: Maybe<Region>;
  /** @deprecated will be migrated to AccountDefaultWalletId */
  readonly userDefaultWalletId: Scalars['WalletId']['output'];
  readonly usernameAvailable?: Maybe<Scalars['Boolean']['output']>;
  readonly welcomeLeaderboard: Leaderboard;
};


export type QueryAccountDefaultWalletArgs = {
  username: Scalars['Username']['input'];
  walletCurrency?: InputMaybe<WalletCurrency>;
};


export type QueryBtcPriceListArgs = {
  range: PriceGraphRange;
};


export type QueryCurrencyConversionEstimationArgs = {
  amount: Scalars['Float']['input'];
  currency: Scalars['DisplayCurrency']['input'];
};


export type QueryLnInvoicePaymentStatusArgs = {
  input: LnInvoicePaymentStatusInput;
};


export type QueryLnInvoicePaymentStatusByHashArgs = {
  input: LnInvoicePaymentStatusByHashInput;
};


export type QueryLnInvoicePaymentStatusByPaymentRequestArgs = {
  input: LnInvoicePaymentStatusByPaymentRequestInput;
};


export type QueryOnChainTxFeeArgs = {
  address: Scalars['OnChainAddress']['input'];
  amount: Scalars['SatAmount']['input'];
  speed?: PayoutSpeed;
  walletId: Scalars['WalletId']['input'];
};


export type QueryOnChainUsdTxFeeArgs = {
  address: Scalars['OnChainAddress']['input'];
  amount: Scalars['CentAmount']['input'];
  speed?: PayoutSpeed;
  walletId: Scalars['WalletId']['input'];
};


export type QueryOnChainUsdTxFeeAsBtcDenominatedArgs = {
  address: Scalars['OnChainAddress']['input'];
  amount: Scalars['SatAmount']['input'];
  speed?: PayoutSpeed;
  walletId: Scalars['WalletId']['input'];
};


export type QueryRealtimePriceArgs = {
  currency?: InputMaybe<Scalars['DisplayCurrency']['input']>;
};


export type QueryUserDefaultWalletIdArgs = {
  username: Scalars['Username']['input'];
};


export type QueryUsernameAvailableArgs = {
  username: Scalars['Username']['input'];
};


export type QueryWelcomeLeaderboardArgs = {
  input: WelcomeLeaderboardInput;
};

export type Quiz = {
  readonly __typename: 'Quiz';
  /** The reward in Satoshis for the quiz question */
  readonly amount: Scalars['SatAmount']['output'];
  readonly completed: Scalars['Boolean']['output'];
  readonly id: Scalars['ID']['output'];
  readonly notBefore?: Maybe<Scalars['Timestamp']['output']>;
};

export type QuizClaimInput = {
  readonly id: Scalars['ID']['input'];
};

export type QuizClaimPayload = {
  readonly __typename: 'QuizClaimPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly quizzes: ReadonlyArray<Quiz>;
};

export type RealtimePrice = {
  readonly __typename: 'RealtimePrice';
  readonly btcSatPrice: PriceOfOneSatInMinorUnit;
  /** @deprecated Deprecated in favor of denominatorCurrencyDetails */
  readonly denominatorCurrency: Scalars['DisplayCurrency']['output'];
  readonly denominatorCurrencyDetails: Currency;
  readonly id: Scalars['ID']['output'];
  /** Unix timestamp (number of seconds elapsed since January 1, 1970 00:00:00 UTC) */
  readonly timestamp: Scalars['Timestamp']['output'];
  readonly usdCentPrice: PriceOfOneUsdCentInMinorUnit;
};

export type RealtimePriceInput = {
  readonly currency?: InputMaybe<Scalars['DisplayCurrency']['input']>;
};

export type RealtimePricePayload = {
  readonly __typename: 'RealtimePricePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly realtimePrice?: Maybe<RealtimePrice>;
};

export type Region = {
  readonly __typename: 'Region';
  readonly latitude: Scalars['Float']['output'];
  readonly latitudeDelta: Scalars['Float']['output'];
  readonly longitude: Scalars['Float']['output'];
  readonly longitudeDelta: Scalars['Float']['output'];
};

export type SatAmountPayload = {
  readonly __typename: 'SatAmountPayload';
  readonly amount?: Maybe<Scalars['SatAmount']['output']>;
  readonly errors: ReadonlyArray<Error>;
};

export const Scope = {
  Read: 'READ',
  Receive: 'RECEIVE',
  Write: 'WRITE'
} as const;

export type Scope = typeof Scope[keyof typeof Scope];
export type SettlementVia = SettlementViaIntraLedger | SettlementViaLn | SettlementViaOnChain;

export type SettlementViaIntraLedger = {
  readonly __typename: 'SettlementViaIntraLedger';
  /** Settlement destination: Could be null if the payee does not have a username */
  readonly counterPartyUsername?: Maybe<Scalars['Username']['output']>;
  readonly counterPartyWalletId?: Maybe<Scalars['WalletId']['output']>;
  readonly preImage?: Maybe<Scalars['LnPaymentPreImage']['output']>;
};

export type SettlementViaLn = {
  readonly __typename: 'SettlementViaLn';
  /** @deprecated Shifting property to 'preImage' to improve granularity of the LnPaymentSecret type */
  readonly paymentSecret?: Maybe<Scalars['LnPaymentSecret']['output']>;
  readonly preImage?: Maybe<Scalars['LnPaymentPreImage']['output']>;
};

export type SettlementViaOnChain = {
  readonly __typename: 'SettlementViaOnChain';
  readonly arrivalInMempoolEstimatedAt?: Maybe<Scalars['Timestamp']['output']>;
  readonly transactionHash?: Maybe<Scalars['OnChainTxHash']['output']>;
  readonly vout?: Maybe<Scalars['Int']['output']>;
};

export type StatefulNotification = {
  readonly __typename: 'StatefulNotification';
  readonly acknowledgedAt?: Maybe<Scalars['Timestamp']['output']>;
  readonly action?: Maybe<NotificationAction>;
  readonly body: Scalars['String']['output'];
  readonly bulletinEnabled: Scalars['Boolean']['output'];
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly deepLink?: Maybe<Scalars['String']['output']>;
  readonly icon?: Maybe<Icon>;
  readonly id: Scalars['ID']['output'];
  readonly title: Scalars['String']['output'];
};

export type StatefulNotificationAcknowledgeInput = {
  readonly notificationId: Scalars['ID']['input'];
};

export type StatefulNotificationAcknowledgePayload = {
  readonly __typename: 'StatefulNotificationAcknowledgePayload';
  readonly notification: StatefulNotification;
};

export type StatefulNotificationConnection = {
  readonly __typename: 'StatefulNotificationConnection';
  /** A list of edges. */
  readonly edges: ReadonlyArray<StatefulNotificationEdge>;
  /** A list of nodes. */
  readonly nodes: ReadonlyArray<StatefulNotification>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
};

/** An edge in a connection. */
export type StatefulNotificationEdge = {
  readonly __typename: 'StatefulNotificationEdge';
  /** A cursor for use in pagination */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  readonly node: StatefulNotification;
};

export type Subscription = {
  readonly __typename: 'Subscription';
  /** @deprecated Deprecated in favor of lnInvoicePaymentStatusByPaymentRequest */
  readonly lnInvoicePaymentStatus: LnInvoicePaymentStatusPayload;
  readonly lnInvoicePaymentStatusByHash: LnInvoicePaymentStatusPayload;
  readonly lnInvoicePaymentStatusByPaymentRequest: LnInvoicePaymentStatusPayload;
  readonly myUpdates: MyUpdatesPayload;
  readonly price: PricePayload;
  /** Returns the price of 1 satoshi */
  readonly realtimePrice: RealtimePricePayload;
};


export type SubscriptionLnInvoicePaymentStatusArgs = {
  input: LnInvoicePaymentStatusInput;
};


export type SubscriptionLnInvoicePaymentStatusByHashArgs = {
  input: LnInvoicePaymentStatusByHashInput;
};


export type SubscriptionLnInvoicePaymentStatusByPaymentRequestArgs = {
  input: LnInvoicePaymentStatusByPaymentRequestInput;
};


export type SubscriptionPriceArgs = {
  input: PriceInput;
};


export type SubscriptionRealtimePriceArgs = {
  input: RealtimePriceInput;
};

export type SuccessPayload = {
  readonly __typename: 'SuccessPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly success?: Maybe<Scalars['Boolean']['output']>;
};

export type SupportChatMessageAddInput = {
  readonly message: Scalars['String']['input'];
};

export type SupportChatMessageAddPayload = {
  readonly __typename: 'SupportChatMessageAddPayload';
  readonly errors: ReadonlyArray<Error>;
  readonly supportMessage?: Maybe<ReadonlyArray<Maybe<SupportMessage>>>;
};

export type SupportMessage = {
  readonly __typename: 'SupportMessage';
  readonly id: Scalars['ID']['output'];
  readonly message: Scalars['String']['output'];
  readonly role: SupportRole;
  readonly timestamp: Scalars['Timestamp']['output'];
};

export const SupportRole = {
  Assistant: 'ASSISTANT',
  User: 'USER'
} as const;

export type SupportRole = typeof SupportRole[keyof typeof SupportRole];
/**
 * Give details about an individual transaction.
 * Galoy have a smart routing system which is automatically
 * settling intraledger when both the payer and payee use the same wallet
 * therefore it's possible the transactions is being initiated onchain
 * or with lightning but settled intraledger.
 */
export type Transaction = {
  readonly __typename: 'Transaction';
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly direction: TxDirection;
  readonly externalId?: Maybe<Scalars['TxExternalId']['output']>;
  readonly id: Scalars['ID']['output'];
  /** From which protocol the payment has been initiated. */
  readonly initiationVia: InitiationVia;
  readonly memo?: Maybe<Scalars['Memo']['output']>;
  /** Amount of the settlement currency sent or received. */
  readonly settlementAmount: Scalars['SignedAmount']['output'];
  /** Wallet currency for transaction. */
  readonly settlementCurrency: WalletCurrency;
  readonly settlementDisplayAmount: Scalars['SignedDisplayMajorAmount']['output'];
  readonly settlementDisplayCurrency: Scalars['DisplayCurrency']['output'];
  readonly settlementDisplayFee: Scalars['SignedDisplayMajorAmount']['output'];
  readonly settlementFee: Scalars['SignedAmount']['output'];
  /** Price in WALLETCURRENCY/SETTLEMENTUNIT at time of settlement. */
  readonly settlementPrice: PriceOfOneSettlementMinorUnitInDisplayMinorUnit;
  /** To which protocol the payment has settled on. */
  readonly settlementVia: SettlementVia;
  readonly status: TxStatus;
};

/** A connection to a list of items. */
export type TransactionConnection = {
  readonly __typename: 'TransactionConnection';
  /** A list of edges. */
  readonly edges?: Maybe<ReadonlyArray<TransactionEdge>>;
  /** Information to aid in pagination. */
  readonly pageInfo: PageInfo;
};

/** An edge in a connection. */
export type TransactionEdge = {
  readonly __typename: 'TransactionEdge';
  /** A cursor for use in pagination */
  readonly cursor: Scalars['String']['output'];
  /** The item at the end of the edge */
  readonly node: Transaction;
};

export const TxDirection = {
  Receive: 'RECEIVE',
  Send: 'SEND'
} as const;

export type TxDirection = typeof TxDirection[keyof typeof TxDirection];
export const TxNotificationType = {
  IntraLedgerPayment: 'IntraLedgerPayment',
  IntraLedgerReceipt: 'IntraLedgerReceipt',
  LigtningReceipt: 'LigtningReceipt',
  OnchainPayment: 'OnchainPayment',
  OnchainReceipt: 'OnchainReceipt',
  OnchainReceiptPending: 'OnchainReceiptPending'
} as const;

export type TxNotificationType = typeof TxNotificationType[keyof typeof TxNotificationType];
export const TxStatus = {
  Failure: 'FAILURE',
  Pending: 'PENDING',
  Success: 'SUCCESS'
} as const;

export type TxStatus = typeof TxStatus[keyof typeof TxStatus];
export type UpgradePayload = {
  readonly __typename: 'UpgradePayload';
  readonly authToken?: Maybe<Scalars['AuthToken']['output']>;
  readonly errors: ReadonlyArray<Error>;
  readonly success: Scalars['Boolean']['output'];
};

/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWallet = Wallet & {
  readonly __typename: 'UsdWallet';
  readonly accountId: Scalars['ID']['output'];
  readonly balance: Scalars['SignedAmount']['output'];
  readonly id: Scalars['ID']['output'];
  readonly invoiceByPaymentHash: Invoice;
  /** A list of all invoices associated with walletIds optionally passed. */
  readonly invoices?: Maybe<InvoiceConnection>;
  /** An unconfirmed incoming onchain balance. */
  readonly pendingIncomingBalance: Scalars['SignedAmount']['output'];
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  readonly pendingIncomingTransactionsByAddress: ReadonlyArray<Transaction>;
  readonly transactionById: Transaction;
  readonly transactions?: Maybe<TransactionConnection>;
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  readonly transactionsByPaymentHash: ReadonlyArray<Transaction>;
  readonly transactionsByPaymentRequest: ReadonlyArray<Transaction>;
  readonly walletCurrency: WalletCurrency;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletInvoiceByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash']['input'];
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletPendingIncomingTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionByIdArgs = {
  transactionId: Scalars['ID']['input'];
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash']['input'];
};


/** A wallet belonging to an account which contains a USD balance and a list of transactions. */
export type UsdWalletTransactionsByPaymentRequestArgs = {
  paymentRequest: Scalars['LnPaymentRequest']['input'];
};

export type User = {
  readonly __typename: 'User';
  readonly apiKeys: ReadonlyArray<ApiKey>;
  /**
   * Get single contact details.
   * Can include the transactions associated with the contact.
   * @deprecated will be moved to Accounts
   */
  readonly contactByUsername: UserContact;
  /**
   * Get full list of contacts.
   * Can include the transactions associated with each contact.
   * @deprecated will be moved to account
   */
  readonly contacts: ReadonlyArray<UserContact>;
  readonly createdAt: Scalars['Timestamp']['output'];
  readonly defaultAccount: Account;
  /** Email address */
  readonly email?: Maybe<Email>;
  readonly id: Scalars['ID']['output'];
  /**
   * Preferred language for user.
   * When value is 'default' the intent is to use preferred language from OS settings.
   */
  readonly language: Scalars['Language']['output'];
  /** Phone number with international calling code. */
  readonly phone?: Maybe<Scalars['Phone']['output']>;
  readonly statefulNotifications: StatefulNotificationConnection;
  readonly statefulNotificationsWithoutBulletinEnabled: StatefulNotificationConnection;
  readonly supportChat: ReadonlyArray<SupportMessage>;
  /** Whether TOTP is enabled for this user. */
  readonly totpEnabled: Scalars['Boolean']['output'];
  readonly unacknowledgedStatefulNotificationsWithBulletinEnabled: StatefulNotificationConnection;
  readonly unacknowledgedStatefulNotificationsWithoutBulletinEnabledCount: Scalars['Int']['output'];
  /**
   * Optional immutable user friendly identifier.
   * @deprecated will be moved to @Handle in Account and Wallet
   */
  readonly username?: Maybe<Scalars['Username']['output']>;
};


export type UserContactByUsernameArgs = {
  username: Scalars['Username']['input'];
};


export type UserStatefulNotificationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


export type UserStatefulNotificationsWithoutBulletinEnabledArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};


export type UserUnacknowledgedStatefulNotificationsWithBulletinEnabledArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  first: Scalars['Int']['input'];
};

export type UserContact = {
  readonly __typename: 'UserContact';
  /**
   * Alias the user can set for this contact.
   * Only the user can see the alias attached to their contact.
   */
  readonly alias?: Maybe<Scalars['ContactAlias']['output']>;
  readonly id: Scalars['Username']['output'];
  /** Paginated list of transactions sent to/from this contact. */
  readonly transactions?: Maybe<TransactionConnection>;
  readonly transactionsCount: Scalars['Int']['output'];
  /** Actual identifier of the contact. */
  readonly username: Scalars['Username']['output'];
};


export type UserContactTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};

export type UserContactUpdateAliasInput = {
  readonly alias: Scalars['ContactAlias']['input'];
  readonly username: Scalars['Username']['input'];
};

export type UserContactUpdateAliasPayload = {
  readonly __typename: 'UserContactUpdateAliasPayload';
  readonly contact?: Maybe<UserContact>;
  readonly errors: ReadonlyArray<Error>;
};

export type UserEmailDeletePayload = {
  readonly __typename: 'UserEmailDeletePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserEmailRegistrationInitiateInput = {
  readonly email: Scalars['EmailAddress']['input'];
};

export type UserEmailRegistrationInitiatePayload = {
  readonly __typename: 'UserEmailRegistrationInitiatePayload';
  readonly emailRegistrationId?: Maybe<Scalars['EmailRegistrationId']['output']>;
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserEmailRegistrationValidateInput = {
  readonly code: Scalars['OneTimeAuthCode']['input'];
  readonly emailRegistrationId: Scalars['EmailRegistrationId']['input'];
};

export type UserEmailRegistrationValidatePayload = {
  readonly __typename: 'UserEmailRegistrationValidatePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserLoginInput = {
  readonly code: Scalars['OneTimeAuthCode']['input'];
  readonly phone: Scalars['Phone']['input'];
};

export type UserLoginUpgradeInput = {
  readonly code: Scalars['OneTimeAuthCode']['input'];
  readonly phone: Scalars['Phone']['input'];
};

export type UserLogoutInput = {
  readonly deviceToken: Scalars['String']['input'];
};

export type UserPhoneDeletePayload = {
  readonly __typename: 'UserPhoneDeletePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserPhoneRegistrationInitiateInput = {
  readonly channel?: InputMaybe<PhoneCodeChannelType>;
  readonly phone: Scalars['Phone']['input'];
};

export type UserPhoneRegistrationValidateInput = {
  readonly code: Scalars['OneTimeAuthCode']['input'];
  readonly phone: Scalars['Phone']['input'];
};

export type UserPhoneRegistrationValidatePayload = {
  readonly __typename: 'UserPhoneRegistrationValidatePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserTotpDeletePayload = {
  readonly __typename: 'UserTotpDeletePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserTotpRegistrationInitiatePayload = {
  readonly __typename: 'UserTotpRegistrationInitiatePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly totpRegistrationId?: Maybe<Scalars['TotpRegistrationId']['output']>;
  readonly totpSecret?: Maybe<Scalars['TotpSecret']['output']>;
};

export type UserTotpRegistrationValidateInput = {
  readonly authToken?: InputMaybe<Scalars['AuthToken']['input']>;
  readonly totpCode: Scalars['TotpCode']['input'];
  readonly totpRegistrationId: Scalars['TotpRegistrationId']['input'];
};

export type UserTotpRegistrationValidatePayload = {
  readonly __typename: 'UserTotpRegistrationValidatePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly me?: Maybe<User>;
};

export type UserUpdate = IntraLedgerUpdate | LnUpdate | OnChainUpdate | Price | RealtimePrice;

export type UserUpdateLanguageInput = {
  readonly language: Scalars['Language']['input'];
};

export type UserUpdateLanguagePayload = {
  readonly __typename: 'UserUpdateLanguagePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly user?: Maybe<User>;
};

export type UserUpdateUsernameInput = {
  readonly username: Scalars['Username']['input'];
};

export type UserUpdateUsernamePayload = {
  readonly __typename: 'UserUpdateUsernamePayload';
  readonly errors: ReadonlyArray<Error>;
  readonly user?: Maybe<User>;
};

/** A generic wallet which stores value in one of our supported currencies. */
export type Wallet = {
  readonly accountId: Scalars['ID']['output'];
  readonly balance: Scalars['SignedAmount']['output'];
  readonly id: Scalars['ID']['output'];
  readonly invoiceByPaymentHash: Invoice;
  readonly invoices?: Maybe<InvoiceConnection>;
  readonly pendingIncomingBalance: Scalars['SignedAmount']['output'];
  /**
   * Pending incoming OnChain transactions. When transactions
   * are confirmed they will receive a new id and be found in the transactions
   * list. Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly pendingIncomingTransactions: ReadonlyArray<Transaction>;
  /**
   * Pending incoming OnChain transactions. When transactions
   * are confirmed they will receive a new id and be found in the transactions
   * list. Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly pendingIncomingTransactionsByAddress: ReadonlyArray<Transaction>;
  readonly transactionById: Transaction;
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactions?: Maybe<TransactionConnection>;
  /**
   * Transactions are ordered anti-chronologically,
   * ie: the newest transaction will be first
   */
  readonly transactionsByAddress?: Maybe<TransactionConnection>;
  /** Returns the transactions that include this paymentHash. This should be a list of size one for a received lightning payment. This can be more that one transaction for a sent lightning payment. */
  readonly transactionsByPaymentHash: ReadonlyArray<Transaction>;
  /** Returns the transactions that include this paymentRequest. */
  readonly transactionsByPaymentRequest: ReadonlyArray<Transaction>;
  readonly walletCurrency: WalletCurrency;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletInvoiceByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash']['input'];
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletInvoicesArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletPendingIncomingTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionByIdArgs = {
  transactionId: Scalars['ID']['input'];
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsArgs = {
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByAddressArgs = {
  address: Scalars['OnChainAddress']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByPaymentHashArgs = {
  paymentHash: Scalars['PaymentHash']['input'];
};


/** A generic wallet which stores value in one of our supported currencies. */
export type WalletTransactionsByPaymentRequestArgs = {
  paymentRequest: Scalars['LnPaymentRequest']['input'];
};

export const WalletCurrency = {
  Btc: 'BTC',
  Usd: 'USD'
} as const;

export type WalletCurrency = typeof WalletCurrency[keyof typeof WalletCurrency];
export type WelcomeLeaderboardInput = {
  readonly range: WelcomeRange;
};

export type WelcomeProfile = {
  readonly __typename: 'WelcomeProfile';
  readonly allTimePoints: Scalars['Int']['output'];
  readonly allTimeRank: Scalars['Int']['output'];
  readonly innerCircleAllTimeCount: Scalars['Int']['output'];
  readonly innerCircleThisMonthCount: Scalars['Int']['output'];
  readonly leaderboardName?: Maybe<Scalars['LeaderboardName']['output']>;
  readonly outerCircleAllTimeCount: Scalars['Int']['output'];
  readonly outerCircleThisMonthCount: Scalars['Int']['output'];
  readonly thisMonthPoints: Scalars['Int']['output'];
  readonly thisMonthRank: Scalars['Int']['output'];
};

export const WelcomeRange = {
  AllTime: 'AllTime',
  ThisMonth: 'ThisMonth'
} as const;

export type WelcomeRange = typeof WelcomeRange[keyof typeof WelcomeRange];
export type MobileUpdateQueryVariables = Exact<{ [key: string]: never; }>;


export type MobileUpdateQuery = { readonly __typename: 'Query', readonly mobileVersions?: ReadonlyArray<{ readonly __typename: 'MobileVersions', readonly platform: string, readonly currentSupported: number, readonly minSupported: number } | null> | null };

export type BalanceHeaderQueryVariables = Exact<{ [key: string]: never; }>;


export type BalanceHeaderQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type InviteQueryVariables = Exact<{ [key: string]: never; }>;


export type InviteQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly username?: string | null } | null };

export type BtcPriceListQueryVariables = Exact<{
  range: PriceGraphRange;
}>;


export type BtcPriceListQuery = { readonly __typename: 'Query', readonly btcPriceList?: ReadonlyArray<{ readonly __typename: 'PricePoint', readonly timestamp: number, readonly price: { readonly __typename: 'Price', readonly base: number, readonly offset: number, readonly currencyUnit: string } } | null> | null };

export type SetDefaultAccountModalQueryVariables = Exact<{ [key: string]: never; }>;


export type SetDefaultAccountModalQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly defaultWalletId: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type UserUpdateUsernameMutationVariables = Exact<{
  input: UserUpdateUsernameInput;
}>;


export type UserUpdateUsernameMutation = { readonly __typename: 'Mutation', readonly userUpdateUsername: { readonly __typename: 'UserUpdateUsernamePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly code?: string | null }>, readonly user?: { readonly __typename: 'User', readonly id: string, readonly username?: string | null } | null } };

export type MyUserIdQueryVariables = Exact<{ [key: string]: never; }>;


export type MyUserIdQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string } | null };

export type WalletOverviewScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type WalletOverviewScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type AnalyticsQueryVariables = Exact<{ [key: string]: never; }>;


export type AnalyticsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly username?: string | null, readonly id: string } | null, readonly globals?: { readonly __typename: 'Globals', readonly network: Network } | null };

export type RealtimePriceQueryVariables = Exact<{ [key: string]: never; }>;


export type RealtimePriceQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly realtimePrice: { readonly __typename: 'RealtimePrice', readonly denominatorCurrency: string, readonly id: string, readonly timestamp: number, readonly btcSatPrice: { readonly __typename: 'PriceOfOneSatInMinorUnit', readonly base: number, readonly offset: number }, readonly usdCentPrice: { readonly __typename: 'PriceOfOneUsdCentInMinorUnit', readonly base: number, readonly offset: number } } } } | null };

export type HideBalanceQueryVariables = Exact<{ [key: string]: never; }>;


export type HideBalanceQuery = { readonly __typename: 'Query', readonly hideBalance: boolean };

export type HiddenBalanceToolTipQueryVariables = Exact<{ [key: string]: never; }>;


export type HiddenBalanceToolTipQuery = { readonly __typename: 'Query', readonly hiddenBalanceToolTip: boolean };

export type BetaQueryVariables = Exact<{ [key: string]: never; }>;


export type BetaQuery = { readonly __typename: 'Query', readonly beta: boolean };

export type ColorSchemeQueryVariables = Exact<{ [key: string]: never; }>;


export type ColorSchemeQuery = { readonly __typename: 'Query', readonly colorScheme: string };

export type CountryCodeQueryVariables = Exact<{ [key: string]: never; }>;


export type CountryCodeQuery = { readonly __typename: 'Query', readonly countryCode: string };

export type RegionQueryVariables = Exact<{ [key: string]: never; }>;


export type RegionQuery = { readonly __typename: 'Query', readonly region?: { readonly __typename: 'Region', readonly latitude: number, readonly longitude: number, readonly latitudeDelta: number, readonly longitudeDelta: number } | null };

export type FeedbackModalShownQueryVariables = Exact<{ [key: string]: never; }>;


export type FeedbackModalShownQuery = { readonly __typename: 'Query', readonly feedbackModalShown: boolean };

export type HasPromptedSetDefaultAccountQueryVariables = Exact<{ [key: string]: never; }>;


export type HasPromptedSetDefaultAccountQuery = { readonly __typename: 'Query', readonly hasPromptedSetDefaultAccount: boolean };

export type IntroducingCirclesModalShownQueryVariables = Exact<{ [key: string]: never; }>;


export type IntroducingCirclesModalShownQuery = { readonly __typename: 'Query', readonly introducingCirclesModalShown: boolean };

export type InnerCircleValueQueryVariables = Exact<{ [key: string]: never; }>;


export type InnerCircleValueQuery = { readonly __typename: 'Query', readonly innerCircleValue: number };

export type TransactionFragment = { readonly __typename: 'Transaction', readonly id: string, readonly status: TxStatus, readonly direction: TxDirection, readonly memo?: string | null, readonly createdAt: number, readonly settlementAmount: number, readonly settlementFee: number, readonly settlementDisplayFee: string, readonly settlementCurrency: WalletCurrency, readonly settlementDisplayAmount: string, readonly settlementDisplayCurrency: string, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string }, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string, readonly paymentRequest: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null, readonly preImage?: string | null } | { readonly __typename: 'SettlementViaLn', readonly preImage?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null, readonly arrivalInMempoolEstimatedAt?: number | null } };

export type TransactionListFragment = { readonly __typename: 'TransactionConnection', readonly pageInfo: { readonly __typename: 'PageInfo', readonly hasNextPage: boolean, readonly hasPreviousPage: boolean, readonly startCursor?: string | null, readonly endCursor?: string | null }, readonly edges?: ReadonlyArray<{ readonly __typename: 'TransactionEdge', readonly cursor: string, readonly node: { readonly __typename: 'Transaction', readonly id: string, readonly status: TxStatus, readonly direction: TxDirection, readonly memo?: string | null, readonly createdAt: number, readonly settlementAmount: number, readonly settlementFee: number, readonly settlementDisplayFee: string, readonly settlementCurrency: WalletCurrency, readonly settlementDisplayAmount: string, readonly settlementDisplayCurrency: string, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string }, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string, readonly paymentRequest: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null, readonly preImage?: string | null } | { readonly __typename: 'SettlementViaLn', readonly preImage?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null, readonly arrivalInMempoolEstimatedAt?: number | null } } }> | null };

export type NetworkQueryVariables = Exact<{ [key: string]: never; }>;


export type NetworkQuery = { readonly __typename: 'Query', readonly globals?: { readonly __typename: 'Globals', readonly network: Network } | null };

export type LevelQueryVariables = Exact<{ [key: string]: never; }>;


export type LevelQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly level: AccountLevel } } | null };

export type DisplayCurrencyQueryVariables = Exact<{ [key: string]: never; }>;


export type DisplayCurrencyQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly displayCurrency: string } } | null };

export type CurrencyListQueryVariables = Exact<{ [key: string]: never; }>;


export type CurrencyListQuery = { readonly __typename: 'Query', readonly currencyList: ReadonlyArray<{ readonly __typename: 'Currency', readonly id: string, readonly flag: string, readonly name: string, readonly symbol: string, readonly fractionDigits: number }> };

export type CaptchaCreateChallengeMutationVariables = Exact<{ [key: string]: never; }>;


export type CaptchaCreateChallengeMutation = { readonly __typename: 'Mutation', readonly captchaCreateChallenge: { readonly __typename: 'CaptchaCreateChallengePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly result?: { readonly __typename: 'CaptchaCreateChallengeResult', readonly id: string, readonly challengeCode: string, readonly newCaptcha: boolean, readonly failbackMode: boolean } | null } };

export type UserLogoutMutationVariables = Exact<{
  input: UserLogoutInput;
}>;


export type UserLogoutMutation = { readonly __typename: 'Mutation', readonly userLogout: { readonly __typename: 'SuccessPayload', readonly success?: boolean | null } };

export type ConversionScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type ConversionScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type DebugScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type DebugScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string } } | null };

export type MyQuizQuestionsQueryVariables = Exact<{ [key: string]: never; }>;


export type MyQuizQuestionsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly quiz: ReadonlyArray<{ readonly __typename: 'Quiz', readonly id: string, readonly amount: number, readonly completed: boolean, readonly notBefore?: number | null }> } } | null };

export type QuizClaimMutationVariables = Exact<{
  input: QuizClaimInput;
}>;


export type QuizClaimMutation = { readonly __typename: 'Mutation', readonly quizClaim: { readonly __typename: 'QuizClaimPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly quizzes: ReadonlyArray<{ readonly __typename: 'Quiz', readonly id: string, readonly amount: number, readonly completed: boolean, readonly notBefore?: number | null }> } };

export type UserEmailRegistrationInitiateMutationVariables = Exact<{
  input: UserEmailRegistrationInitiateInput;
}>;


export type UserEmailRegistrationInitiateMutation = { readonly __typename: 'Mutation', readonly userEmailRegistrationInitiate: { readonly __typename: 'UserEmailRegistrationInitiatePayload', readonly emailRegistrationId?: string | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly me?: { readonly __typename: 'User', readonly id: string, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null } | null } };

export type UserEmailRegistrationValidateMutationVariables = Exact<{
  input: UserEmailRegistrationValidateInput;
}>;


export type UserEmailRegistrationValidateMutation = { readonly __typename: 'Mutation', readonly userEmailRegistrationValidate: { readonly __typename: 'UserEmailRegistrationValidatePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly me?: { readonly __typename: 'User', readonly id: string, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null } | null } };

export type OnboardingFlowStartMutationVariables = Exact<{
  input: OnboardingFlowStartInput;
}>;


export type OnboardingFlowStartMutation = { readonly __typename: 'Mutation', readonly onboardingFlowStart: { readonly __typename: 'OnboardingFlowStartResult', readonly workflowRunId: string, readonly tokenWeb: string } };

export type FullOnboardingScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type FullOnboardingScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly onboardingStatus?: OnboardingStatus | null } } | null };

export type AddressScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type AddressScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly username?: string | null } | null };

export type HomeAuthedQueryVariables = Exact<{ [key: string]: never; }>;


export type HomeAuthedQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly language: string, readonly username?: string | null, readonly phone?: string | null, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly level: AccountLevel, readonly defaultWalletId: string, readonly pendingIncomingTransactions: ReadonlyArray<{ readonly __typename: 'Transaction', readonly id: string, readonly status: TxStatus, readonly direction: TxDirection, readonly memo?: string | null, readonly createdAt: number, readonly settlementAmount: number, readonly settlementFee: number, readonly settlementDisplayFee: string, readonly settlementCurrency: WalletCurrency, readonly settlementDisplayAmount: string, readonly settlementDisplayCurrency: string, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string }, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string, readonly paymentRequest: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null, readonly preImage?: string | null } | { readonly __typename: 'SettlementViaLn', readonly preImage?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null, readonly arrivalInMempoolEstimatedAt?: number | null } }>, readonly transactions?: { readonly __typename: 'TransactionConnection', readonly pageInfo: { readonly __typename: 'PageInfo', readonly hasNextPage: boolean, readonly hasPreviousPage: boolean, readonly startCursor?: string | null, readonly endCursor?: string | null }, readonly edges?: ReadonlyArray<{ readonly __typename: 'TransactionEdge', readonly cursor: string, readonly node: { readonly __typename: 'Transaction', readonly id: string, readonly status: TxStatus, readonly direction: TxDirection, readonly memo?: string | null, readonly createdAt: number, readonly settlementAmount: number, readonly settlementFee: number, readonly settlementDisplayFee: string, readonly settlementCurrency: WalletCurrency, readonly settlementDisplayAmount: string, readonly settlementDisplayCurrency: string, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string }, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string, readonly paymentRequest: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null, readonly preImage?: string | null } | { readonly __typename: 'SettlementViaLn', readonly preImage?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null, readonly arrivalInMempoolEstimatedAt?: number | null } } }> | null } | null, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type HomeUnauthedQueryVariables = Exact<{ [key: string]: never; }>;


export type HomeUnauthedQuery = { readonly __typename: 'Query', readonly globals?: { readonly __typename: 'Globals', readonly network: Network } | null, readonly currencyList: ReadonlyArray<{ readonly __typename: 'Currency', readonly id: string, readonly flag: string, readonly name: string, readonly symbol: string, readonly fractionDigits: number }> };

export type BulletinsQueryVariables = Exact<{
  first: Scalars['Int']['input'];
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type BulletinsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly unacknowledgedStatefulNotificationsWithBulletinEnabled: { readonly __typename: 'StatefulNotificationConnection', readonly pageInfo: { readonly __typename: 'PageInfo', readonly endCursor?: string | null, readonly hasNextPage: boolean, readonly hasPreviousPage: boolean, readonly startCursor?: string | null }, readonly edges: ReadonlyArray<{ readonly __typename: 'StatefulNotificationEdge', readonly cursor: string, readonly node: { readonly __typename: 'StatefulNotification', readonly id: string, readonly title: string, readonly body: string, readonly createdAt: number, readonly acknowledgedAt?: number | null, readonly bulletinEnabled: boolean, readonly icon?: Icon | null, readonly action?: { readonly __typename: 'OpenDeepLinkAction', readonly deepLink: string } | { readonly __typename: 'OpenExternalLinkAction', readonly url: string } | null } }> } } | null };

export type BusinessMapMarkersQueryVariables = Exact<{ [key: string]: never; }>;


export type BusinessMapMarkersQuery = { readonly __typename: 'Query', readonly businessMapMarkers: ReadonlyArray<{ readonly __typename: 'MapMarker', readonly username: string, readonly mapInfo: { readonly __typename: 'MapInfo', readonly title: string, readonly coordinates: { readonly __typename: 'Coordinates', readonly longitude: number, readonly latitude: number } } }> };

export type StatefulNotificationsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['String']['input']>;
}>;


export type StatefulNotificationsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly statefulNotificationsWithoutBulletinEnabled: { readonly __typename: 'StatefulNotificationConnection', readonly nodes: ReadonlyArray<{ readonly __typename: 'StatefulNotification', readonly id: string, readonly title: string, readonly body: string, readonly createdAt: number, readonly acknowledgedAt?: number | null, readonly bulletinEnabled: boolean, readonly icon?: Icon | null, readonly action?: { readonly __typename: 'OpenDeepLinkAction', readonly deepLink: string } | { readonly __typename: 'OpenExternalLinkAction', readonly url: string } | null }>, readonly pageInfo: { readonly __typename: 'PageInfo', readonly endCursor?: string | null, readonly hasNextPage: boolean, readonly hasPreviousPage: boolean, readonly startCursor?: string | null } } } | null };

export type StatefulNotificationAcknowledgeMutationVariables = Exact<{
  input: StatefulNotificationAcknowledgeInput;
}>;


export type StatefulNotificationAcknowledgeMutation = { readonly __typename: 'Mutation', readonly statefulNotificationAcknowledge: { readonly __typename: 'StatefulNotificationAcknowledgePayload', readonly notification: { readonly __typename: 'StatefulNotification', readonly acknowledgedAt?: number | null } } };

export type CirclesQueryVariables = Exact<{ [key: string]: never; }>;


export type CirclesQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly username?: string | null, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly welcomeProfile?: { readonly __typename: 'WelcomeProfile', readonly allTimePoints: number, readonly allTimeRank: number, readonly innerCircleAllTimeCount: number, readonly innerCircleThisMonthCount: number, readonly outerCircleAllTimeCount: number, readonly outerCircleThisMonthCount: number, readonly thisMonthPoints: number, readonly thisMonthRank: number } | null } } | null };

export type ContactsQueryVariables = Exact<{ [key: string]: never; }>;


export type ContactsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly contacts: ReadonlyArray<{ readonly __typename: 'UserContact', readonly id: string, readonly username: string, readonly alias?: string | null, readonly transactionsCount: number }> } | null };

export type TransactionListForContactQueryVariables = Exact<{
  username: Scalars['Username']['input'];
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
}>;


export type TransactionListForContactQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly contactByUsername: { readonly __typename: 'UserContact', readonly transactions?: { readonly __typename: 'TransactionConnection', readonly pageInfo: { readonly __typename: 'PageInfo', readonly hasNextPage: boolean, readonly hasPreviousPage: boolean, readonly startCursor?: string | null, readonly endCursor?: string | null }, readonly edges?: ReadonlyArray<{ readonly __typename: 'TransactionEdge', readonly cursor: string, readonly node: { readonly __typename: 'Transaction', readonly id: string, readonly status: TxStatus, readonly direction: TxDirection, readonly memo?: string | null, readonly createdAt: number, readonly settlementAmount: number, readonly settlementFee: number, readonly settlementDisplayFee: string, readonly settlementCurrency: WalletCurrency, readonly settlementDisplayAmount: string, readonly settlementDisplayCurrency: string, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string }, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string, readonly paymentRequest: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null, readonly preImage?: string | null } | { readonly __typename: 'SettlementViaLn', readonly preImage?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null, readonly arrivalInMempoolEstimatedAt?: number | null } } }> | null } | null } } | null };

export type ContactsCardQueryVariables = Exact<{ [key: string]: never; }>;


export type ContactsCardQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly contacts: ReadonlyArray<{ readonly __typename: 'UserContact', readonly id: string, readonly username: string, readonly alias?: string | null, readonly transactionsCount: number }> } | null };

export type UserContactUpdateAliasMutationVariables = Exact<{
  input: UserContactUpdateAliasInput;
}>;


export type UserContactUpdateAliasMutation = { readonly __typename: 'Mutation', readonly userContactUpdateAlias: { readonly __typename: 'UserContactUpdateAliasPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly contact?: { readonly __typename: 'UserContact', readonly alias?: string | null, readonly id: string } | null } };

export type UserLoginMutationVariables = Exact<{
  input: UserLoginInput;
}>;


export type UserLoginMutation = { readonly __typename: 'Mutation', readonly userLogin: { readonly __typename: 'AuthTokenPayload', readonly authToken?: string | null, readonly totpRequired?: boolean | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string, readonly code?: string | null }> } };

export type UserLoginUpgradeMutationVariables = Exact<{
  input: UserLoginUpgradeInput;
}>;


export type UserLoginUpgradeMutation = { readonly __typename: 'Mutation', readonly userLoginUpgrade: { readonly __typename: 'UpgradePayload', readonly success: boolean, readonly authToken?: string | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string, readonly code?: string | null }> } };

export type UserPhoneRegistrationValidateMutationVariables = Exact<{
  input: UserPhoneRegistrationValidateInput;
}>;


export type UserPhoneRegistrationValidateMutation = { readonly __typename: 'Mutation', readonly userPhoneRegistrationValidate: { readonly __typename: 'UserPhoneRegistrationValidatePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string, readonly code?: string | null }>, readonly me?: { readonly __typename: 'User', readonly id: string, readonly phone?: string | null, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null } | null } };

export type CaptchaRequestAuthCodeMutationVariables = Exact<{
  input: CaptchaRequestAuthCodeInput;
}>;


export type CaptchaRequestAuthCodeMutation = { readonly __typename: 'Mutation', readonly captchaRequestAuthCode: { readonly __typename: 'SuccessPayload', readonly success?: boolean | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string, readonly code?: string | null }> } };

export type SupportedCountriesQueryVariables = Exact<{ [key: string]: never; }>;


export type SupportedCountriesQuery = { readonly __typename: 'Query', readonly globals?: { readonly __typename: 'Globals', readonly supportedCountries: ReadonlyArray<{ readonly __typename: 'Country', readonly id: string, readonly supportedAuthChannels: ReadonlyArray<PhoneCodeChannelType> }> } | null };

export type UserPhoneRegistrationInitiateMutationVariables = Exact<{
  input: UserPhoneRegistrationInitiateInput;
}>;


export type UserPhoneRegistrationInitiateMutation = { readonly __typename: 'Mutation', readonly userPhoneRegistrationInitiate: { readonly __typename: 'SuccessPayload', readonly success?: boolean | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type PriceHistoryScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type PriceHistoryScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string } } | null };

export type MyLnUpdatesSubscriptionVariables = Exact<{ [key: string]: never; }>;


export type MyLnUpdatesSubscription = { readonly __typename: 'Subscription', readonly myUpdates: { readonly __typename: 'MyUpdatesPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly update?: { readonly __typename: 'IntraLedgerUpdate' } | { readonly __typename: 'LnUpdate', readonly paymentHash: string, readonly status: InvoicePaymentStatus } | { readonly __typename: 'OnChainUpdate' } | { readonly __typename: 'Price' } | { readonly __typename: 'RealtimePrice' } | null } };

export type PaymentRequestQueryVariables = Exact<{ [key: string]: never; }>;


export type PaymentRequestQuery = { readonly __typename: 'Query', readonly globals?: { readonly __typename: 'Globals', readonly network: Network, readonly feesInformation: { readonly __typename: 'FeesInformation', readonly deposit: { readonly __typename: 'DepositFeesInformation', readonly minBankFee: string, readonly minBankFeeThreshold: string } } } | null, readonly me?: { readonly __typename: 'User', readonly id: string, readonly username?: string | null, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly defaultWalletId: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type LnNoAmountInvoiceCreateMutationVariables = Exact<{
  input: LnNoAmountInvoiceCreateInput;
}>;


export type LnNoAmountInvoiceCreateMutation = { readonly __typename: 'Mutation', readonly lnNoAmountInvoiceCreate: { readonly __typename: 'LnNoAmountInvoicePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly invoice?: { readonly __typename: 'LnNoAmountInvoice', readonly createdAt: number, readonly paymentHash: string, readonly paymentRequest: string, readonly paymentStatus: InvoicePaymentStatus, readonly externalId: string } | null } };

export type LnInvoiceCreateMutationVariables = Exact<{
  input: LnInvoiceCreateInput;
}>;


export type LnInvoiceCreateMutation = { readonly __typename: 'Mutation', readonly lnInvoiceCreate: { readonly __typename: 'LnInvoicePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly invoice?: { readonly __typename: 'LnInvoice', readonly createdAt: number, readonly paymentHash: string, readonly paymentRequest: string, readonly paymentStatus: InvoicePaymentStatus, readonly externalId: string, readonly satoshis: number } | null } };

export type OnChainAddressCurrentMutationVariables = Exact<{
  input: OnChainAddressCurrentInput;
}>;


export type OnChainAddressCurrentMutation = { readonly __typename: 'Mutation', readonly onChainAddressCurrent: { readonly __typename: 'OnChainAddressPayload', readonly address?: string | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnUsdInvoiceCreateMutationVariables = Exact<{
  input: LnUsdInvoiceCreateInput;
}>;


export type LnUsdInvoiceCreateMutation = { readonly __typename: 'Mutation', readonly lnUsdInvoiceCreate: { readonly __typename: 'LnInvoicePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly invoice?: { readonly __typename: 'LnInvoice', readonly createdAt: number, readonly paymentHash: string, readonly paymentRequest: string, readonly paymentStatus: InvoicePaymentStatus, readonly externalId: string, readonly satoshis: number } | null } };

export type ScanningQrCodeScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type ScanningQrCodeScreenQuery = { readonly __typename: 'Query', readonly globals?: { readonly __typename: 'Globals', readonly network: Network } | null, readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string } | { readonly __typename: 'UsdWallet', readonly id: string }> }, readonly contacts: ReadonlyArray<{ readonly __typename: 'UserContact', readonly id: string, readonly username: string }> } | null };

export type SendBitcoinConfirmationScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type SendBitcoinConfirmationScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type SendBitcoinDestinationQueryVariables = Exact<{ [key: string]: never; }>;


export type SendBitcoinDestinationQuery = { readonly __typename: 'Query', readonly globals?: { readonly __typename: 'Globals', readonly network: Network } | null, readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string } | { readonly __typename: 'UsdWallet', readonly id: string }> }, readonly contacts: ReadonlyArray<{ readonly __typename: 'UserContact', readonly id: string, readonly username: string, readonly alias?: string | null, readonly transactionsCount: number }> } | null };

export type AccountDefaultWalletQueryVariables = Exact<{
  walletCurrency?: InputMaybe<WalletCurrency>;
  username: Scalars['Username']['input'];
}>;


export type AccountDefaultWalletQuery = { readonly __typename: 'Query', readonly accountDefaultWallet: { readonly __typename: 'PublicWallet', readonly id: string } };

export type SendBitcoinDetailsScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type SendBitcoinDetailsScreenQuery = { readonly __typename: 'Query', readonly globals?: { readonly __typename: 'Globals', readonly network: Network } | null, readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly defaultWalletId: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly balance: number } | { readonly __typename: 'UsdWallet', readonly id: string, readonly walletCurrency: WalletCurrency, readonly balance: number }> } } | null };

export type SendBitcoinWithdrawalLimitsQueryVariables = Exact<{ [key: string]: never; }>;


export type SendBitcoinWithdrawalLimitsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly limits: { readonly __typename: 'AccountLimits', readonly withdrawal: ReadonlyArray<{ readonly __typename: 'OneDayAccountLimit', readonly totalLimit: number, readonly remainingLimit?: number | null, readonly interval?: number | null }> } } } | null };

export type SendBitcoinInternalLimitsQueryVariables = Exact<{ [key: string]: never; }>;


export type SendBitcoinInternalLimitsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly limits: { readonly __typename: 'AccountLimits', readonly internalSend: ReadonlyArray<{ readonly __typename: 'OneDayAccountLimit', readonly totalLimit: number, readonly remainingLimit?: number | null, readonly interval?: number | null }> } } } | null };

export type FeedbackSubmitMutationVariables = Exact<{
  input: FeedbackSubmitInput;
}>;


export type FeedbackSubmitMutation = { readonly __typename: 'Mutation', readonly feedbackSubmit: { readonly __typename: 'SuccessPayload', readonly success?: boolean | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnNoAmountInvoiceFeeProbeMutationVariables = Exact<{
  input: LnNoAmountInvoiceFeeProbeInput;
}>;


export type LnNoAmountInvoiceFeeProbeMutation = { readonly __typename: 'Mutation', readonly lnNoAmountInvoiceFeeProbe: { readonly __typename: 'SatAmountPayload', readonly amount?: number | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnInvoiceFeeProbeMutationVariables = Exact<{
  input: LnInvoiceFeeProbeInput;
}>;


export type LnInvoiceFeeProbeMutation = { readonly __typename: 'Mutation', readonly lnInvoiceFeeProbe: { readonly __typename: 'SatAmountPayload', readonly amount?: number | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnUsdInvoiceFeeProbeMutationVariables = Exact<{
  input: LnUsdInvoiceFeeProbeInput;
}>;


export type LnUsdInvoiceFeeProbeMutation = { readonly __typename: 'Mutation', readonly lnUsdInvoiceFeeProbe: { readonly __typename: 'SatAmountPayload', readonly amount?: number | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnNoAmountUsdInvoiceFeeProbeMutationVariables = Exact<{
  input: LnNoAmountUsdInvoiceFeeProbeInput;
}>;


export type LnNoAmountUsdInvoiceFeeProbeMutation = { readonly __typename: 'Mutation', readonly lnNoAmountUsdInvoiceFeeProbe: { readonly __typename: 'CentAmountPayload', readonly amount?: number | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type OnChainTxFeeQueryVariables = Exact<{
  walletId: Scalars['WalletId']['input'];
  address: Scalars['OnChainAddress']['input'];
  amount: Scalars['SatAmount']['input'];
}>;


export type OnChainTxFeeQuery = { readonly __typename: 'Query', readonly onChainTxFee: { readonly __typename: 'OnChainTxFee', readonly amount: number } };

export type OnChainUsdTxFeeQueryVariables = Exact<{
  walletId: Scalars['WalletId']['input'];
  address: Scalars['OnChainAddress']['input'];
  amount: Scalars['CentAmount']['input'];
}>;


export type OnChainUsdTxFeeQuery = { readonly __typename: 'Query', readonly onChainUsdTxFee: { readonly __typename: 'OnChainUsdTxFee', readonly amount: number } };

export type OnChainUsdTxFeeAsBtcDenominatedQueryVariables = Exact<{
  walletId: Scalars['WalletId']['input'];
  address: Scalars['OnChainAddress']['input'];
  amount: Scalars['SatAmount']['input'];
}>;


export type OnChainUsdTxFeeAsBtcDenominatedQuery = { readonly __typename: 'Query', readonly onChainUsdTxFeeAsBtcDenominated: { readonly __typename: 'OnChainUsdTxFee', readonly amount: number } };

export type IntraLedgerPaymentSendMutationVariables = Exact<{
  input: IntraLedgerPaymentSendInput;
}>;


export type IntraLedgerPaymentSendMutation = { readonly __typename: 'Mutation', readonly intraLedgerPaymentSend: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type IntraLedgerUsdPaymentSendMutationVariables = Exact<{
  input: IntraLedgerUsdPaymentSendInput;
}>;


export type IntraLedgerUsdPaymentSendMutation = { readonly __typename: 'Mutation', readonly intraLedgerUsdPaymentSend: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnNoAmountInvoicePaymentSendMutationVariables = Exact<{
  input: LnNoAmountInvoicePaymentInput;
}>;


export type LnNoAmountInvoicePaymentSendMutation = { readonly __typename: 'Mutation', readonly lnNoAmountInvoicePaymentSend: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnInvoicePaymentSendMutationVariables = Exact<{
  input: LnInvoicePaymentInput;
}>;


export type LnInvoicePaymentSendMutation = { readonly __typename: 'Mutation', readonly lnInvoicePaymentSend: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type LnNoAmountUsdInvoicePaymentSendMutationVariables = Exact<{
  input: LnNoAmountUsdInvoicePaymentInput;
}>;


export type LnNoAmountUsdInvoicePaymentSendMutation = { readonly __typename: 'Mutation', readonly lnNoAmountUsdInvoicePaymentSend: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type OnChainPaymentSendMutationVariables = Exact<{
  input: OnChainPaymentSendInput;
}>;


export type OnChainPaymentSendMutation = { readonly __typename: 'Mutation', readonly onChainPaymentSend: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly transaction?: { readonly __typename: 'Transaction', readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger' } | { readonly __typename: 'SettlementViaLn' } | { readonly __typename: 'SettlementViaOnChain', readonly arrivalInMempoolEstimatedAt?: number | null } } | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type OnChainPaymentSendAllMutationVariables = Exact<{
  input: OnChainPaymentSendAllInput;
}>;


export type OnChainPaymentSendAllMutation = { readonly __typename: 'Mutation', readonly onChainPaymentSendAll: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type OnChainUsdPaymentSendMutationVariables = Exact<{
  input: OnChainUsdPaymentSendInput;
}>;


export type OnChainUsdPaymentSendMutation = { readonly __typename: 'Mutation', readonly onChainUsdPaymentSend: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type OnChainUsdPaymentSendAsBtcDenominatedMutationVariables = Exact<{
  input: OnChainUsdPaymentSendAsBtcDenominatedInput;
}>;


export type OnChainUsdPaymentSendAsBtcDenominatedMutation = { readonly __typename: 'Mutation', readonly onChainUsdPaymentSendAsBtcDenominated: { readonly __typename: 'PaymentSendPayload', readonly status?: PaymentSendResult | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type AccountDeleteMutationVariables = Exact<{ [key: string]: never; }>;


export type AccountDeleteMutation = { readonly __typename: 'Mutation', readonly accountDelete: { readonly __typename: 'AccountDeletePayload', readonly success: boolean, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type UserEmailDeleteMutationVariables = Exact<{ [key: string]: never; }>;


export type UserEmailDeleteMutation = { readonly __typename: 'Mutation', readonly userEmailDelete: { readonly __typename: 'UserEmailDeletePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly me?: { readonly __typename: 'User', readonly id: string, readonly phone?: string | null, readonly totpEnabled: boolean, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null } | null } };

export type UserPhoneDeleteMutationVariables = Exact<{ [key: string]: never; }>;


export type UserPhoneDeleteMutation = { readonly __typename: 'Mutation', readonly userPhoneDelete: { readonly __typename: 'UserPhoneDeletePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly me?: { readonly __typename: 'User', readonly id: string, readonly phone?: string | null, readonly totpEnabled: boolean, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null } | null } };

export type WarningSecureAccountQueryVariables = Exact<{ [key: string]: never; }>;


export type WarningSecureAccountQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly level: AccountLevel, readonly id: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type AccountUpdateDefaultWalletIdMutationVariables = Exact<{
  input: AccountUpdateDefaultWalletIdInput;
}>;


export type AccountUpdateDefaultWalletIdMutation = { readonly __typename: 'Mutation', readonly accountUpdateDefaultWalletId: { readonly __typename: 'AccountUpdateDefaultWalletIdPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly account?: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly defaultWalletId: string } | null } };

export type SetDefaultWalletScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type SetDefaultWalletScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly defaultWalletId: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> } } | null };

export type AccountUpdateDisplayCurrencyMutationVariables = Exact<{
  input: AccountUpdateDisplayCurrencyInput;
}>;


export type AccountUpdateDisplayCurrencyMutation = { readonly __typename: 'Mutation', readonly accountUpdateDisplayCurrency: { readonly __typename: 'AccountUpdateDisplayCurrencyPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly account?: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly displayCurrency: string } | null } };

export type LanguageQueryVariables = Exact<{ [key: string]: never; }>;


export type LanguageQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly language: string } | null };

export type UserUpdateLanguageMutationVariables = Exact<{
  input: UserUpdateLanguageInput;
}>;


export type UserUpdateLanguageMutation = { readonly __typename: 'Mutation', readonly userUpdateLanguage: { readonly __typename: 'UserUpdateLanguagePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly user?: { readonly __typename: 'User', readonly id: string, readonly language: string } | null } };

export type NotificationSettingsQueryVariables = Exact<{ [key: string]: never; }>;


export type NotificationSettingsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly notificationSettings: { readonly __typename: 'NotificationSettings', readonly push: { readonly __typename: 'NotificationChannelSettings', readonly enabled: boolean, readonly disabledCategories: ReadonlyArray<string> } } } } | null };

export type AccountEnableNotificationChannelMutationVariables = Exact<{
  input: AccountEnableNotificationChannelInput;
}>;


export type AccountEnableNotificationChannelMutation = { readonly __typename: 'Mutation', readonly accountEnableNotificationChannel: { readonly __typename: 'AccountUpdateNotificationSettingsPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly account?: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly notificationSettings: { readonly __typename: 'NotificationSettings', readonly push: { readonly __typename: 'NotificationChannelSettings', readonly enabled: boolean, readonly disabledCategories: ReadonlyArray<string> } } } | null } };

export type AccountDisableNotificationChannelMutationVariables = Exact<{
  input: AccountDisableNotificationChannelInput;
}>;


export type AccountDisableNotificationChannelMutation = { readonly __typename: 'Mutation', readonly accountDisableNotificationChannel: { readonly __typename: 'AccountUpdateNotificationSettingsPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly account?: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly notificationSettings: { readonly __typename: 'NotificationSettings', readonly push: { readonly __typename: 'NotificationChannelSettings', readonly enabled: boolean, readonly disabledCategories: ReadonlyArray<string> } } } | null } };

export type AccountEnableNotificationCategoryMutationVariables = Exact<{
  input: AccountEnableNotificationCategoryInput;
}>;


export type AccountEnableNotificationCategoryMutation = { readonly __typename: 'Mutation', readonly accountEnableNotificationCategory: { readonly __typename: 'AccountUpdateNotificationSettingsPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly account?: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly notificationSettings: { readonly __typename: 'NotificationSettings', readonly push: { readonly __typename: 'NotificationChannelSettings', readonly enabled: boolean, readonly disabledCategories: ReadonlyArray<string> } } } | null } };

export type AccountDisableNotificationCategoryMutationVariables = Exact<{
  input: AccountDisableNotificationCategoryInput;
}>;


export type AccountDisableNotificationCategoryMutation = { readonly __typename: 'Mutation', readonly accountDisableNotificationCategory: { readonly __typename: 'AccountUpdateNotificationSettingsPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly account?: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly notificationSettings: { readonly __typename: 'NotificationSettings', readonly push: { readonly __typename: 'NotificationChannelSettings', readonly enabled: boolean, readonly disabledCategories: ReadonlyArray<string> } } } | null } };

export type UnacknowledgedNotificationCountQueryVariables = Exact<{ [key: string]: never; }>;


export type UnacknowledgedNotificationCountQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly unacknowledgedStatefulNotificationsWithoutBulletinEnabledCount: number } | null };

export type SettingsScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type SettingsScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly username?: string | null, readonly language: string, readonly totpEnabled: boolean, readonly phone?: string | null, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly defaultWalletId: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency } | { readonly __typename: 'UsdWallet', readonly id: string, readonly balance: number, readonly walletCurrency: WalletCurrency }> }, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null } | null };

export type ExportCsvSettingQueryVariables = Exact<{
  walletIds: ReadonlyArray<Scalars['WalletId']['input']> | Scalars['WalletId']['input'];
}>;


export type ExportCsvSettingQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly csvTransactions: string } } | null };

export type UserTotpDeleteMutationVariables = Exact<{ [key: string]: never; }>;


export type UserTotpDeleteMutation = { readonly __typename: 'Mutation', readonly userTotpDelete: { readonly __typename: 'UserTotpDeletePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly me?: { readonly __typename: 'User', readonly id: string, readonly phone?: string | null, readonly totpEnabled: boolean, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null } | null } };

export type AccountLimitsQueryVariables = Exact<{ [key: string]: never; }>;


export type AccountLimitsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly limits: { readonly __typename: 'AccountLimits', readonly withdrawal: ReadonlyArray<{ readonly __typename: 'OneDayAccountLimit', readonly totalLimit: number, readonly remainingLimit?: number | null, readonly interval?: number | null }>, readonly internalSend: ReadonlyArray<{ readonly __typename: 'OneDayAccountLimit', readonly totalLimit: number, readonly remainingLimit?: number | null, readonly interval?: number | null }>, readonly convert: ReadonlyArray<{ readonly __typename: 'OneDayAccountLimit', readonly totalLimit: number, readonly remainingLimit?: number | null, readonly interval?: number | null }> } } } | null };

export type SupportChatQueryVariables = Exact<{ [key: string]: never; }>;


export type SupportChatQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly supportChat: ReadonlyArray<{ readonly __typename: 'SupportMessage', readonly id: string, readonly message: string, readonly role: SupportRole, readonly timestamp: number }> } | null };

export type SupportChatMessageAddMutationVariables = Exact<{
  input: SupportChatMessageAddInput;
}>;


export type SupportChatMessageAddMutation = { readonly __typename: 'Mutation', readonly supportChatMessageAdd: { readonly __typename: 'SupportChatMessageAddPayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly supportMessage?: ReadonlyArray<{ readonly __typename: 'SupportMessage', readonly id: string, readonly message: string, readonly role: SupportRole, readonly timestamp: number } | null> | null } };

export type SupportChatResetMutationVariables = Exact<{ [key: string]: never; }>;


export type SupportChatResetMutation = { readonly __typename: 'Mutation', readonly supportChatReset: { readonly __typename: 'SuccessPayload', readonly success?: boolean | null } };

export type TotpRegistrationScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type TotpRegistrationScreenQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly username?: string | null } | null };

export type UserTotpRegistrationInitiateMutationVariables = Exact<{ [key: string]: never; }>;


export type UserTotpRegistrationInitiateMutation = { readonly __typename: 'Mutation', readonly userTotpRegistrationInitiate: { readonly __typename: 'UserTotpRegistrationInitiatePayload', readonly totpRegistrationId?: string | null, readonly totpSecret?: string | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type UserTotpRegistrationValidateMutationVariables = Exact<{
  input: UserTotpRegistrationValidateInput;
}>;


export type UserTotpRegistrationValidateMutation = { readonly __typename: 'Mutation', readonly userTotpRegistrationValidate: { readonly __typename: 'UserTotpRegistrationValidatePayload', readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }>, readonly me?: { readonly __typename: 'User', readonly id: string, readonly totpEnabled: boolean, readonly phone?: string | null, readonly email?: { readonly __typename: 'Email', readonly address?: string | null, readonly verified?: boolean | null } | null } | null } };

export type TransactionListForDefaultAccountQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['String']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['String']['input']>;
}>;


export type TransactionListForDefaultAccountQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly pendingIncomingTransactions: ReadonlyArray<{ readonly __typename: 'Transaction', readonly id: string, readonly status: TxStatus, readonly direction: TxDirection, readonly memo?: string | null, readonly createdAt: number, readonly settlementAmount: number, readonly settlementFee: number, readonly settlementDisplayFee: string, readonly settlementCurrency: WalletCurrency, readonly settlementDisplayAmount: string, readonly settlementDisplayCurrency: string, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string }, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string, readonly paymentRequest: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null, readonly preImage?: string | null } | { readonly __typename: 'SettlementViaLn', readonly preImage?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null, readonly arrivalInMempoolEstimatedAt?: number | null } }>, readonly transactions?: { readonly __typename: 'TransactionConnection', readonly pageInfo: { readonly __typename: 'PageInfo', readonly hasNextPage: boolean, readonly hasPreviousPage: boolean, readonly startCursor?: string | null, readonly endCursor?: string | null }, readonly edges?: ReadonlyArray<{ readonly __typename: 'TransactionEdge', readonly cursor: string, readonly node: { readonly __typename: 'Transaction', readonly id: string, readonly status: TxStatus, readonly direction: TxDirection, readonly memo?: string | null, readonly createdAt: number, readonly settlementAmount: number, readonly settlementFee: number, readonly settlementDisplayFee: string, readonly settlementCurrency: WalletCurrency, readonly settlementDisplayAmount: string, readonly settlementDisplayCurrency: string, readonly settlementPrice: { readonly __typename: 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit', readonly base: number, readonly offset: number, readonly currencyUnit: string, readonly formattedAmount: string }, readonly initiationVia: { readonly __typename: 'InitiationViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null } | { readonly __typename: 'InitiationViaLn', readonly paymentHash: string, readonly paymentRequest: string } | { readonly __typename: 'InitiationViaOnChain', readonly address: string }, readonly settlementVia: { readonly __typename: 'SettlementViaIntraLedger', readonly counterPartyWalletId?: string | null, readonly counterPartyUsername?: string | null, readonly preImage?: string | null } | { readonly __typename: 'SettlementViaLn', readonly preImage?: string | null } | { readonly __typename: 'SettlementViaOnChain', readonly transactionHash?: string | null, readonly arrivalInMempoolEstimatedAt?: number | null } } }> | null } | null } } | null };

export type DeviceNotificationTokenCreateMutationVariables = Exact<{
  input: DeviceNotificationTokenCreateInput;
}>;


export type DeviceNotificationTokenCreateMutation = { readonly __typename: 'Mutation', readonly deviceNotificationTokenCreate: { readonly __typename: 'SuccessPayload', readonly success?: boolean | null, readonly errors: ReadonlyArray<{ readonly __typename: 'GraphQLApplicationError', readonly message: string }> } };

export type WalletsQueryVariables = Exact<{ [key: string]: never; }>;


export type WalletsQuery = { readonly __typename: 'Query', readonly me?: { readonly __typename: 'User', readonly id: string, readonly defaultAccount: { readonly __typename: 'ConsumerAccount', readonly id: string, readonly wallets: ReadonlyArray<{ readonly __typename: 'BTCWallet', readonly walletCurrency: WalletCurrency, readonly id: string } | { readonly __typename: 'UsdWallet', readonly walletCurrency: WalletCurrency, readonly id: string }> } } | null };

export const TransactionFragmentDoc = gql`
    fragment Transaction on Transaction {
  __typename
  id
  status
  direction
  memo
  createdAt
  settlementAmount
  settlementFee
  settlementDisplayFee
  settlementCurrency
  settlementDisplayAmount
  settlementDisplayCurrency
  settlementPrice {
    base
    offset
    currencyUnit
    formattedAmount
  }
  initiationVia {
    ... on InitiationViaIntraLedger {
      counterPartyWalletId
      counterPartyUsername
    }
    ... on InitiationViaLn {
      paymentHash
      paymentRequest
    }
    ... on InitiationViaOnChain {
      address
    }
  }
  settlementVia {
    ... on SettlementViaIntraLedger {
      counterPartyWalletId
      counterPartyUsername
      preImage
    }
    ... on SettlementViaLn {
      preImage
    }
    ... on SettlementViaOnChain {
      transactionHash
      arrivalInMempoolEstimatedAt
    }
  }
}
    `;
export const TransactionListFragmentDoc = gql`
    fragment TransactionList on TransactionConnection {
  pageInfo {
    hasNextPage
    hasPreviousPage
    startCursor
    endCursor
  }
  edges {
    cursor
    node {
      ...Transaction
    }
  }
}
    ${TransactionFragmentDoc}`;
export const MobileUpdateDocument = gql`
    query mobileUpdate {
  mobileVersions {
    platform
    currentSupported
    minSupported
  }
}
    `;

/**
 * __useMobileUpdateQuery__
 *
 * To run a query within a React component, call `useMobileUpdateQuery` and pass it any options that fit your needs.
 * When your component renders, `useMobileUpdateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMobileUpdateQuery({
 *   variables: {
 *   },
 * });
 */
export function useMobileUpdateQuery(baseOptions?: Apollo.QueryHookOptions<MobileUpdateQuery, MobileUpdateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MobileUpdateQuery, MobileUpdateQueryVariables>(MobileUpdateDocument, options);
      }
export function useMobileUpdateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MobileUpdateQuery, MobileUpdateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MobileUpdateQuery, MobileUpdateQueryVariables>(MobileUpdateDocument, options);
        }
export function useMobileUpdateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MobileUpdateQuery, MobileUpdateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MobileUpdateQuery, MobileUpdateQueryVariables>(MobileUpdateDocument, options);
        }
export type MobileUpdateQueryHookResult = ReturnType<typeof useMobileUpdateQuery>;
export type MobileUpdateLazyQueryHookResult = ReturnType<typeof useMobileUpdateLazyQuery>;
export type MobileUpdateSuspenseQueryHookResult = ReturnType<typeof useMobileUpdateSuspenseQuery>;
export type MobileUpdateQueryResult = Apollo.QueryResult<MobileUpdateQuery, MobileUpdateQueryVariables>;
export const BalanceHeaderDocument = gql`
    query balanceHeader {
  me {
    id
    defaultAccount {
      id
      wallets {
        id
        balance
        walletCurrency
      }
    }
  }
}
    `;

/**
 * __useBalanceHeaderQuery__
 *
 * To run a query within a React component, call `useBalanceHeaderQuery` and pass it any options that fit your needs.
 * When your component renders, `useBalanceHeaderQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBalanceHeaderQuery({
 *   variables: {
 *   },
 * });
 */
export function useBalanceHeaderQuery(baseOptions?: Apollo.QueryHookOptions<BalanceHeaderQuery, BalanceHeaderQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BalanceHeaderQuery, BalanceHeaderQueryVariables>(BalanceHeaderDocument, options);
      }
export function useBalanceHeaderLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BalanceHeaderQuery, BalanceHeaderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BalanceHeaderQuery, BalanceHeaderQueryVariables>(BalanceHeaderDocument, options);
        }
export function useBalanceHeaderSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<BalanceHeaderQuery, BalanceHeaderQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BalanceHeaderQuery, BalanceHeaderQueryVariables>(BalanceHeaderDocument, options);
        }
export type BalanceHeaderQueryHookResult = ReturnType<typeof useBalanceHeaderQuery>;
export type BalanceHeaderLazyQueryHookResult = ReturnType<typeof useBalanceHeaderLazyQuery>;
export type BalanceHeaderSuspenseQueryHookResult = ReturnType<typeof useBalanceHeaderSuspenseQuery>;
export type BalanceHeaderQueryResult = Apollo.QueryResult<BalanceHeaderQuery, BalanceHeaderQueryVariables>;
export const InviteDocument = gql`
    query invite {
  me {
    id
    username
  }
}
    `;

/**
 * __useInviteQuery__
 *
 * To run a query within a React component, call `useInviteQuery` and pass it any options that fit your needs.
 * When your component renders, `useInviteQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInviteQuery({
 *   variables: {
 *   },
 * });
 */
export function useInviteQuery(baseOptions?: Apollo.QueryHookOptions<InviteQuery, InviteQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InviteQuery, InviteQueryVariables>(InviteDocument, options);
      }
export function useInviteLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InviteQuery, InviteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InviteQuery, InviteQueryVariables>(InviteDocument, options);
        }
export function useInviteSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<InviteQuery, InviteQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InviteQuery, InviteQueryVariables>(InviteDocument, options);
        }
export type InviteQueryHookResult = ReturnType<typeof useInviteQuery>;
export type InviteLazyQueryHookResult = ReturnType<typeof useInviteLazyQuery>;
export type InviteSuspenseQueryHookResult = ReturnType<typeof useInviteSuspenseQuery>;
export type InviteQueryResult = Apollo.QueryResult<InviteQuery, InviteQueryVariables>;
export const BtcPriceListDocument = gql`
    query btcPriceList($range: PriceGraphRange!) {
  btcPriceList(range: $range) {
    timestamp
    price {
      base
      offset
      currencyUnit
    }
  }
}
    `;

/**
 * __useBtcPriceListQuery__
 *
 * To run a query within a React component, call `useBtcPriceListQuery` and pass it any options that fit your needs.
 * When your component renders, `useBtcPriceListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBtcPriceListQuery({
 *   variables: {
 *      range: // value for 'range'
 *   },
 * });
 */
export function useBtcPriceListQuery(baseOptions: Apollo.QueryHookOptions<BtcPriceListQuery, BtcPriceListQueryVariables> & ({ variables: BtcPriceListQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BtcPriceListQuery, BtcPriceListQueryVariables>(BtcPriceListDocument, options);
      }
export function useBtcPriceListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BtcPriceListQuery, BtcPriceListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BtcPriceListQuery, BtcPriceListQueryVariables>(BtcPriceListDocument, options);
        }
export function useBtcPriceListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<BtcPriceListQuery, BtcPriceListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BtcPriceListQuery, BtcPriceListQueryVariables>(BtcPriceListDocument, options);
        }
export type BtcPriceListQueryHookResult = ReturnType<typeof useBtcPriceListQuery>;
export type BtcPriceListLazyQueryHookResult = ReturnType<typeof useBtcPriceListLazyQuery>;
export type BtcPriceListSuspenseQueryHookResult = ReturnType<typeof useBtcPriceListSuspenseQuery>;
export type BtcPriceListQueryResult = Apollo.QueryResult<BtcPriceListQuery, BtcPriceListQueryVariables>;
export const SetDefaultAccountModalDocument = gql`
    query setDefaultAccountModal {
  me {
    id
    defaultAccount {
      id
      defaultWalletId
      wallets {
        id
        balance
        walletCurrency
      }
    }
  }
}
    `;

/**
 * __useSetDefaultAccountModalQuery__
 *
 * To run a query within a React component, call `useSetDefaultAccountModalQuery` and pass it any options that fit your needs.
 * When your component renders, `useSetDefaultAccountModalQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSetDefaultAccountModalQuery({
 *   variables: {
 *   },
 * });
 */
export function useSetDefaultAccountModalQuery(baseOptions?: Apollo.QueryHookOptions<SetDefaultAccountModalQuery, SetDefaultAccountModalQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SetDefaultAccountModalQuery, SetDefaultAccountModalQueryVariables>(SetDefaultAccountModalDocument, options);
      }
export function useSetDefaultAccountModalLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SetDefaultAccountModalQuery, SetDefaultAccountModalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SetDefaultAccountModalQuery, SetDefaultAccountModalQueryVariables>(SetDefaultAccountModalDocument, options);
        }
export function useSetDefaultAccountModalSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SetDefaultAccountModalQuery, SetDefaultAccountModalQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SetDefaultAccountModalQuery, SetDefaultAccountModalQueryVariables>(SetDefaultAccountModalDocument, options);
        }
export type SetDefaultAccountModalQueryHookResult = ReturnType<typeof useSetDefaultAccountModalQuery>;
export type SetDefaultAccountModalLazyQueryHookResult = ReturnType<typeof useSetDefaultAccountModalLazyQuery>;
export type SetDefaultAccountModalSuspenseQueryHookResult = ReturnType<typeof useSetDefaultAccountModalSuspenseQuery>;
export type SetDefaultAccountModalQueryResult = Apollo.QueryResult<SetDefaultAccountModalQuery, SetDefaultAccountModalQueryVariables>;
export const UserUpdateUsernameDocument = gql`
    mutation userUpdateUsername($input: UserUpdateUsernameInput!) {
  userUpdateUsername(input: $input) {
    errors {
      code
    }
    user {
      id
      username
    }
  }
}
    `;
export type UserUpdateUsernameMutationFn = Apollo.MutationFunction<UserUpdateUsernameMutation, UserUpdateUsernameMutationVariables>;

/**
 * __useUserUpdateUsernameMutation__
 *
 * To run a mutation, you first call `useUserUpdateUsernameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserUpdateUsernameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userUpdateUsernameMutation, { data, loading, error }] = useUserUpdateUsernameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserUpdateUsernameMutation(baseOptions?: Apollo.MutationHookOptions<UserUpdateUsernameMutation, UserUpdateUsernameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserUpdateUsernameMutation, UserUpdateUsernameMutationVariables>(UserUpdateUsernameDocument, options);
      }
export type UserUpdateUsernameMutationHookResult = ReturnType<typeof useUserUpdateUsernameMutation>;
export type UserUpdateUsernameMutationResult = Apollo.MutationResult<UserUpdateUsernameMutation>;
export type UserUpdateUsernameMutationOptions = Apollo.BaseMutationOptions<UserUpdateUsernameMutation, UserUpdateUsernameMutationVariables>;
export const MyUserIdDocument = gql`
    query myUserId {
  me {
    id
  }
}
    `;

/**
 * __useMyUserIdQuery__
 *
 * To run a query within a React component, call `useMyUserIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyUserIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyUserIdQuery({
 *   variables: {
 *   },
 * });
 */
export function useMyUserIdQuery(baseOptions?: Apollo.QueryHookOptions<MyUserIdQuery, MyUserIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyUserIdQuery, MyUserIdQueryVariables>(MyUserIdDocument, options);
      }
export function useMyUserIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyUserIdQuery, MyUserIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyUserIdQuery, MyUserIdQueryVariables>(MyUserIdDocument, options);
        }
export function useMyUserIdSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MyUserIdQuery, MyUserIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyUserIdQuery, MyUserIdQueryVariables>(MyUserIdDocument, options);
        }
export type MyUserIdQueryHookResult = ReturnType<typeof useMyUserIdQuery>;
export type MyUserIdLazyQueryHookResult = ReturnType<typeof useMyUserIdLazyQuery>;
export type MyUserIdSuspenseQueryHookResult = ReturnType<typeof useMyUserIdSuspenseQuery>;
export type MyUserIdQueryResult = Apollo.QueryResult<MyUserIdQuery, MyUserIdQueryVariables>;
export const WalletOverviewScreenDocument = gql`
    query walletOverviewScreen {
  me {
    id
    defaultAccount {
      id
      wallets {
        id
        balance
        walletCurrency
      }
    }
  }
}
    `;

/**
 * __useWalletOverviewScreenQuery__
 *
 * To run a query within a React component, call `useWalletOverviewScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useWalletOverviewScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWalletOverviewScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useWalletOverviewScreenQuery(baseOptions?: Apollo.QueryHookOptions<WalletOverviewScreenQuery, WalletOverviewScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<WalletOverviewScreenQuery, WalletOverviewScreenQueryVariables>(WalletOverviewScreenDocument, options);
      }
export function useWalletOverviewScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<WalletOverviewScreenQuery, WalletOverviewScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<WalletOverviewScreenQuery, WalletOverviewScreenQueryVariables>(WalletOverviewScreenDocument, options);
        }
export function useWalletOverviewScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<WalletOverviewScreenQuery, WalletOverviewScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<WalletOverviewScreenQuery, WalletOverviewScreenQueryVariables>(WalletOverviewScreenDocument, options);
        }
export type WalletOverviewScreenQueryHookResult = ReturnType<typeof useWalletOverviewScreenQuery>;
export type WalletOverviewScreenLazyQueryHookResult = ReturnType<typeof useWalletOverviewScreenLazyQuery>;
export type WalletOverviewScreenSuspenseQueryHookResult = ReturnType<typeof useWalletOverviewScreenSuspenseQuery>;
export type WalletOverviewScreenQueryResult = Apollo.QueryResult<WalletOverviewScreenQuery, WalletOverviewScreenQueryVariables>;
export const AnalyticsDocument = gql`
    query analytics {
  me {
    username
    id
  }
  globals {
    network
  }
}
    `;

/**
 * __useAnalyticsQuery__
 *
 * To run a query within a React component, call `useAnalyticsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAnalyticsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAnalyticsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAnalyticsQuery(baseOptions?: Apollo.QueryHookOptions<AnalyticsQuery, AnalyticsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AnalyticsQuery, AnalyticsQueryVariables>(AnalyticsDocument, options);
      }
export function useAnalyticsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AnalyticsQuery, AnalyticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AnalyticsQuery, AnalyticsQueryVariables>(AnalyticsDocument, options);
        }
export function useAnalyticsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AnalyticsQuery, AnalyticsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AnalyticsQuery, AnalyticsQueryVariables>(AnalyticsDocument, options);
        }
export type AnalyticsQueryHookResult = ReturnType<typeof useAnalyticsQuery>;
export type AnalyticsLazyQueryHookResult = ReturnType<typeof useAnalyticsLazyQuery>;
export type AnalyticsSuspenseQueryHookResult = ReturnType<typeof useAnalyticsSuspenseQuery>;
export type AnalyticsQueryResult = Apollo.QueryResult<AnalyticsQuery, AnalyticsQueryVariables>;
export const RealtimePriceDocument = gql`
    query realtimePrice {
  me {
    id
    defaultAccount {
      id
      realtimePrice {
        btcSatPrice {
          base
          offset
        }
        denominatorCurrency
        id
        timestamp
        usdCentPrice {
          base
          offset
        }
      }
    }
  }
}
    `;

/**
 * __useRealtimePriceQuery__
 *
 * To run a query within a React component, call `useRealtimePriceQuery` and pass it any options that fit your needs.
 * When your component renders, `useRealtimePriceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRealtimePriceQuery({
 *   variables: {
 *   },
 * });
 */
export function useRealtimePriceQuery(baseOptions?: Apollo.QueryHookOptions<RealtimePriceQuery, RealtimePriceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RealtimePriceQuery, RealtimePriceQueryVariables>(RealtimePriceDocument, options);
      }
export function useRealtimePriceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RealtimePriceQuery, RealtimePriceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RealtimePriceQuery, RealtimePriceQueryVariables>(RealtimePriceDocument, options);
        }
export function useRealtimePriceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RealtimePriceQuery, RealtimePriceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RealtimePriceQuery, RealtimePriceQueryVariables>(RealtimePriceDocument, options);
        }
export type RealtimePriceQueryHookResult = ReturnType<typeof useRealtimePriceQuery>;
export type RealtimePriceLazyQueryHookResult = ReturnType<typeof useRealtimePriceLazyQuery>;
export type RealtimePriceSuspenseQueryHookResult = ReturnType<typeof useRealtimePriceSuspenseQuery>;
export type RealtimePriceQueryResult = Apollo.QueryResult<RealtimePriceQuery, RealtimePriceQueryVariables>;
export const HideBalanceDocument = gql`
    query hideBalance {
  hideBalance @client
}
    `;

/**
 * __useHideBalanceQuery__
 *
 * To run a query within a React component, call `useHideBalanceQuery` and pass it any options that fit your needs.
 * When your component renders, `useHideBalanceQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHideBalanceQuery({
 *   variables: {
 *   },
 * });
 */
export function useHideBalanceQuery(baseOptions?: Apollo.QueryHookOptions<HideBalanceQuery, HideBalanceQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HideBalanceQuery, HideBalanceQueryVariables>(HideBalanceDocument, options);
      }
export function useHideBalanceLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HideBalanceQuery, HideBalanceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HideBalanceQuery, HideBalanceQueryVariables>(HideBalanceDocument, options);
        }
export function useHideBalanceSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HideBalanceQuery, HideBalanceQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HideBalanceQuery, HideBalanceQueryVariables>(HideBalanceDocument, options);
        }
export type HideBalanceQueryHookResult = ReturnType<typeof useHideBalanceQuery>;
export type HideBalanceLazyQueryHookResult = ReturnType<typeof useHideBalanceLazyQuery>;
export type HideBalanceSuspenseQueryHookResult = ReturnType<typeof useHideBalanceSuspenseQuery>;
export type HideBalanceQueryResult = Apollo.QueryResult<HideBalanceQuery, HideBalanceQueryVariables>;
export const HiddenBalanceToolTipDocument = gql`
    query hiddenBalanceToolTip {
  hiddenBalanceToolTip @client
}
    `;

/**
 * __useHiddenBalanceToolTipQuery__
 *
 * To run a query within a React component, call `useHiddenBalanceToolTipQuery` and pass it any options that fit your needs.
 * When your component renders, `useHiddenBalanceToolTipQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHiddenBalanceToolTipQuery({
 *   variables: {
 *   },
 * });
 */
export function useHiddenBalanceToolTipQuery(baseOptions?: Apollo.QueryHookOptions<HiddenBalanceToolTipQuery, HiddenBalanceToolTipQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HiddenBalanceToolTipQuery, HiddenBalanceToolTipQueryVariables>(HiddenBalanceToolTipDocument, options);
      }
export function useHiddenBalanceToolTipLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HiddenBalanceToolTipQuery, HiddenBalanceToolTipQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HiddenBalanceToolTipQuery, HiddenBalanceToolTipQueryVariables>(HiddenBalanceToolTipDocument, options);
        }
export function useHiddenBalanceToolTipSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HiddenBalanceToolTipQuery, HiddenBalanceToolTipQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HiddenBalanceToolTipQuery, HiddenBalanceToolTipQueryVariables>(HiddenBalanceToolTipDocument, options);
        }
export type HiddenBalanceToolTipQueryHookResult = ReturnType<typeof useHiddenBalanceToolTipQuery>;
export type HiddenBalanceToolTipLazyQueryHookResult = ReturnType<typeof useHiddenBalanceToolTipLazyQuery>;
export type HiddenBalanceToolTipSuspenseQueryHookResult = ReturnType<typeof useHiddenBalanceToolTipSuspenseQuery>;
export type HiddenBalanceToolTipQueryResult = Apollo.QueryResult<HiddenBalanceToolTipQuery, HiddenBalanceToolTipQueryVariables>;
export const BetaDocument = gql`
    query beta {
  beta @client
}
    `;

/**
 * __useBetaQuery__
 *
 * To run a query within a React component, call `useBetaQuery` and pass it any options that fit your needs.
 * When your component renders, `useBetaQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBetaQuery({
 *   variables: {
 *   },
 * });
 */
export function useBetaQuery(baseOptions?: Apollo.QueryHookOptions<BetaQuery, BetaQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BetaQuery, BetaQueryVariables>(BetaDocument, options);
      }
export function useBetaLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BetaQuery, BetaQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BetaQuery, BetaQueryVariables>(BetaDocument, options);
        }
export function useBetaSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<BetaQuery, BetaQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BetaQuery, BetaQueryVariables>(BetaDocument, options);
        }
export type BetaQueryHookResult = ReturnType<typeof useBetaQuery>;
export type BetaLazyQueryHookResult = ReturnType<typeof useBetaLazyQuery>;
export type BetaSuspenseQueryHookResult = ReturnType<typeof useBetaSuspenseQuery>;
export type BetaQueryResult = Apollo.QueryResult<BetaQuery, BetaQueryVariables>;
export const ColorSchemeDocument = gql`
    query colorScheme {
  colorScheme @client
}
    `;

/**
 * __useColorSchemeQuery__
 *
 * To run a query within a React component, call `useColorSchemeQuery` and pass it any options that fit your needs.
 * When your component renders, `useColorSchemeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useColorSchemeQuery({
 *   variables: {
 *   },
 * });
 */
export function useColorSchemeQuery(baseOptions?: Apollo.QueryHookOptions<ColorSchemeQuery, ColorSchemeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ColorSchemeQuery, ColorSchemeQueryVariables>(ColorSchemeDocument, options);
      }
export function useColorSchemeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ColorSchemeQuery, ColorSchemeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ColorSchemeQuery, ColorSchemeQueryVariables>(ColorSchemeDocument, options);
        }
export function useColorSchemeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ColorSchemeQuery, ColorSchemeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ColorSchemeQuery, ColorSchemeQueryVariables>(ColorSchemeDocument, options);
        }
export type ColorSchemeQueryHookResult = ReturnType<typeof useColorSchemeQuery>;
export type ColorSchemeLazyQueryHookResult = ReturnType<typeof useColorSchemeLazyQuery>;
export type ColorSchemeSuspenseQueryHookResult = ReturnType<typeof useColorSchemeSuspenseQuery>;
export type ColorSchemeQueryResult = Apollo.QueryResult<ColorSchemeQuery, ColorSchemeQueryVariables>;
export const CountryCodeDocument = gql`
    query countryCode {
  countryCode @client
}
    `;

/**
 * __useCountryCodeQuery__
 *
 * To run a query within a React component, call `useCountryCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useCountryCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCountryCodeQuery({
 *   variables: {
 *   },
 * });
 */
export function useCountryCodeQuery(baseOptions?: Apollo.QueryHookOptions<CountryCodeQuery, CountryCodeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CountryCodeQuery, CountryCodeQueryVariables>(CountryCodeDocument, options);
      }
export function useCountryCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CountryCodeQuery, CountryCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CountryCodeQuery, CountryCodeQueryVariables>(CountryCodeDocument, options);
        }
export function useCountryCodeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CountryCodeQuery, CountryCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CountryCodeQuery, CountryCodeQueryVariables>(CountryCodeDocument, options);
        }
export type CountryCodeQueryHookResult = ReturnType<typeof useCountryCodeQuery>;
export type CountryCodeLazyQueryHookResult = ReturnType<typeof useCountryCodeLazyQuery>;
export type CountryCodeSuspenseQueryHookResult = ReturnType<typeof useCountryCodeSuspenseQuery>;
export type CountryCodeQueryResult = Apollo.QueryResult<CountryCodeQuery, CountryCodeQueryVariables>;
export const RegionDocument = gql`
    query region {
  region @client {
    latitude
    longitude
    latitudeDelta
    longitudeDelta
  }
}
    `;

/**
 * __useRegionQuery__
 *
 * To run a query within a React component, call `useRegionQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegionQuery({
 *   variables: {
 *   },
 * });
 */
export function useRegionQuery(baseOptions?: Apollo.QueryHookOptions<RegionQuery, RegionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegionQuery, RegionQueryVariables>(RegionDocument, options);
      }
export function useRegionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegionQuery, RegionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegionQuery, RegionQueryVariables>(RegionDocument, options);
        }
export function useRegionSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<RegionQuery, RegionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<RegionQuery, RegionQueryVariables>(RegionDocument, options);
        }
export type RegionQueryHookResult = ReturnType<typeof useRegionQuery>;
export type RegionLazyQueryHookResult = ReturnType<typeof useRegionLazyQuery>;
export type RegionSuspenseQueryHookResult = ReturnType<typeof useRegionSuspenseQuery>;
export type RegionQueryResult = Apollo.QueryResult<RegionQuery, RegionQueryVariables>;
export const FeedbackModalShownDocument = gql`
    query feedbackModalShown {
  feedbackModalShown @client
}
    `;

/**
 * __useFeedbackModalShownQuery__
 *
 * To run a query within a React component, call `useFeedbackModalShownQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeedbackModalShownQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeedbackModalShownQuery({
 *   variables: {
 *   },
 * });
 */
export function useFeedbackModalShownQuery(baseOptions?: Apollo.QueryHookOptions<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>(FeedbackModalShownDocument, options);
      }
export function useFeedbackModalShownLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>(FeedbackModalShownDocument, options);
        }
export function useFeedbackModalShownSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>(FeedbackModalShownDocument, options);
        }
export type FeedbackModalShownQueryHookResult = ReturnType<typeof useFeedbackModalShownQuery>;
export type FeedbackModalShownLazyQueryHookResult = ReturnType<typeof useFeedbackModalShownLazyQuery>;
export type FeedbackModalShownSuspenseQueryHookResult = ReturnType<typeof useFeedbackModalShownSuspenseQuery>;
export type FeedbackModalShownQueryResult = Apollo.QueryResult<FeedbackModalShownQuery, FeedbackModalShownQueryVariables>;
export const HasPromptedSetDefaultAccountDocument = gql`
    query hasPromptedSetDefaultAccount {
  hasPromptedSetDefaultAccount @client
}
    `;

/**
 * __useHasPromptedSetDefaultAccountQuery__
 *
 * To run a query within a React component, call `useHasPromptedSetDefaultAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useHasPromptedSetDefaultAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHasPromptedSetDefaultAccountQuery({
 *   variables: {
 *   },
 * });
 */
export function useHasPromptedSetDefaultAccountQuery(baseOptions?: Apollo.QueryHookOptions<HasPromptedSetDefaultAccountQuery, HasPromptedSetDefaultAccountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HasPromptedSetDefaultAccountQuery, HasPromptedSetDefaultAccountQueryVariables>(HasPromptedSetDefaultAccountDocument, options);
      }
export function useHasPromptedSetDefaultAccountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HasPromptedSetDefaultAccountQuery, HasPromptedSetDefaultAccountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HasPromptedSetDefaultAccountQuery, HasPromptedSetDefaultAccountQueryVariables>(HasPromptedSetDefaultAccountDocument, options);
        }
export function useHasPromptedSetDefaultAccountSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HasPromptedSetDefaultAccountQuery, HasPromptedSetDefaultAccountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HasPromptedSetDefaultAccountQuery, HasPromptedSetDefaultAccountQueryVariables>(HasPromptedSetDefaultAccountDocument, options);
        }
export type HasPromptedSetDefaultAccountQueryHookResult = ReturnType<typeof useHasPromptedSetDefaultAccountQuery>;
export type HasPromptedSetDefaultAccountLazyQueryHookResult = ReturnType<typeof useHasPromptedSetDefaultAccountLazyQuery>;
export type HasPromptedSetDefaultAccountSuspenseQueryHookResult = ReturnType<typeof useHasPromptedSetDefaultAccountSuspenseQuery>;
export type HasPromptedSetDefaultAccountQueryResult = Apollo.QueryResult<HasPromptedSetDefaultAccountQuery, HasPromptedSetDefaultAccountQueryVariables>;
export const IntroducingCirclesModalShownDocument = gql`
    query introducingCirclesModalShown {
  introducingCirclesModalShown @client
}
    `;

/**
 * __useIntroducingCirclesModalShownQuery__
 *
 * To run a query within a React component, call `useIntroducingCirclesModalShownQuery` and pass it any options that fit your needs.
 * When your component renders, `useIntroducingCirclesModalShownQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useIntroducingCirclesModalShownQuery({
 *   variables: {
 *   },
 * });
 */
export function useIntroducingCirclesModalShownQuery(baseOptions?: Apollo.QueryHookOptions<IntroducingCirclesModalShownQuery, IntroducingCirclesModalShownQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<IntroducingCirclesModalShownQuery, IntroducingCirclesModalShownQueryVariables>(IntroducingCirclesModalShownDocument, options);
      }
export function useIntroducingCirclesModalShownLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<IntroducingCirclesModalShownQuery, IntroducingCirclesModalShownQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<IntroducingCirclesModalShownQuery, IntroducingCirclesModalShownQueryVariables>(IntroducingCirclesModalShownDocument, options);
        }
export function useIntroducingCirclesModalShownSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<IntroducingCirclesModalShownQuery, IntroducingCirclesModalShownQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<IntroducingCirclesModalShownQuery, IntroducingCirclesModalShownQueryVariables>(IntroducingCirclesModalShownDocument, options);
        }
export type IntroducingCirclesModalShownQueryHookResult = ReturnType<typeof useIntroducingCirclesModalShownQuery>;
export type IntroducingCirclesModalShownLazyQueryHookResult = ReturnType<typeof useIntroducingCirclesModalShownLazyQuery>;
export type IntroducingCirclesModalShownSuspenseQueryHookResult = ReturnType<typeof useIntroducingCirclesModalShownSuspenseQuery>;
export type IntroducingCirclesModalShownQueryResult = Apollo.QueryResult<IntroducingCirclesModalShownQuery, IntroducingCirclesModalShownQueryVariables>;
export const InnerCircleValueDocument = gql`
    query innerCircleValue {
  innerCircleValue @client
}
    `;

/**
 * __useInnerCircleValueQuery__
 *
 * To run a query within a React component, call `useInnerCircleValueQuery` and pass it any options that fit your needs.
 * When your component renders, `useInnerCircleValueQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInnerCircleValueQuery({
 *   variables: {
 *   },
 * });
 */
export function useInnerCircleValueQuery(baseOptions?: Apollo.QueryHookOptions<InnerCircleValueQuery, InnerCircleValueQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InnerCircleValueQuery, InnerCircleValueQueryVariables>(InnerCircleValueDocument, options);
      }
export function useInnerCircleValueLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InnerCircleValueQuery, InnerCircleValueQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InnerCircleValueQuery, InnerCircleValueQueryVariables>(InnerCircleValueDocument, options);
        }
export function useInnerCircleValueSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<InnerCircleValueQuery, InnerCircleValueQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<InnerCircleValueQuery, InnerCircleValueQueryVariables>(InnerCircleValueDocument, options);
        }
export type InnerCircleValueQueryHookResult = ReturnType<typeof useInnerCircleValueQuery>;
export type InnerCircleValueLazyQueryHookResult = ReturnType<typeof useInnerCircleValueLazyQuery>;
export type InnerCircleValueSuspenseQueryHookResult = ReturnType<typeof useInnerCircleValueSuspenseQuery>;
export type InnerCircleValueQueryResult = Apollo.QueryResult<InnerCircleValueQuery, InnerCircleValueQueryVariables>;
export const NetworkDocument = gql`
    query network {
  globals {
    network
  }
}
    `;

/**
 * __useNetworkQuery__
 *
 * To run a query within a React component, call `useNetworkQuery` and pass it any options that fit your needs.
 * When your component renders, `useNetworkQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNetworkQuery({
 *   variables: {
 *   },
 * });
 */
export function useNetworkQuery(baseOptions?: Apollo.QueryHookOptions<NetworkQuery, NetworkQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NetworkQuery, NetworkQueryVariables>(NetworkDocument, options);
      }
export function useNetworkLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NetworkQuery, NetworkQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NetworkQuery, NetworkQueryVariables>(NetworkDocument, options);
        }
export function useNetworkSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<NetworkQuery, NetworkQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NetworkQuery, NetworkQueryVariables>(NetworkDocument, options);
        }
export type NetworkQueryHookResult = ReturnType<typeof useNetworkQuery>;
export type NetworkLazyQueryHookResult = ReturnType<typeof useNetworkLazyQuery>;
export type NetworkSuspenseQueryHookResult = ReturnType<typeof useNetworkSuspenseQuery>;
export type NetworkQueryResult = Apollo.QueryResult<NetworkQuery, NetworkQueryVariables>;
export const LevelDocument = gql`
    query level {
  me {
    id
    defaultAccount {
      id
      level
    }
  }
}
    `;

/**
 * __useLevelQuery__
 *
 * To run a query within a React component, call `useLevelQuery` and pass it any options that fit your needs.
 * When your component renders, `useLevelQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLevelQuery({
 *   variables: {
 *   },
 * });
 */
export function useLevelQuery(baseOptions?: Apollo.QueryHookOptions<LevelQuery, LevelQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LevelQuery, LevelQueryVariables>(LevelDocument, options);
      }
export function useLevelLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LevelQuery, LevelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LevelQuery, LevelQueryVariables>(LevelDocument, options);
        }
export function useLevelSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LevelQuery, LevelQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LevelQuery, LevelQueryVariables>(LevelDocument, options);
        }
export type LevelQueryHookResult = ReturnType<typeof useLevelQuery>;
export type LevelLazyQueryHookResult = ReturnType<typeof useLevelLazyQuery>;
export type LevelSuspenseQueryHookResult = ReturnType<typeof useLevelSuspenseQuery>;
export type LevelQueryResult = Apollo.QueryResult<LevelQuery, LevelQueryVariables>;
export const DisplayCurrencyDocument = gql`
    query displayCurrency {
  me {
    id
    defaultAccount {
      id
      displayCurrency
    }
  }
}
    `;

/**
 * __useDisplayCurrencyQuery__
 *
 * To run a query within a React component, call `useDisplayCurrencyQuery` and pass it any options that fit your needs.
 * When your component renders, `useDisplayCurrencyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDisplayCurrencyQuery({
 *   variables: {
 *   },
 * });
 */
export function useDisplayCurrencyQuery(baseOptions?: Apollo.QueryHookOptions<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>(DisplayCurrencyDocument, options);
      }
export function useDisplayCurrencyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>(DisplayCurrencyDocument, options);
        }
export function useDisplayCurrencySuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>(DisplayCurrencyDocument, options);
        }
export type DisplayCurrencyQueryHookResult = ReturnType<typeof useDisplayCurrencyQuery>;
export type DisplayCurrencyLazyQueryHookResult = ReturnType<typeof useDisplayCurrencyLazyQuery>;
export type DisplayCurrencySuspenseQueryHookResult = ReturnType<typeof useDisplayCurrencySuspenseQuery>;
export type DisplayCurrencyQueryResult = Apollo.QueryResult<DisplayCurrencyQuery, DisplayCurrencyQueryVariables>;
export const CurrencyListDocument = gql`
    query currencyList {
  currencyList {
    __typename
    id
    flag
    name
    symbol
    fractionDigits
  }
}
    `;

/**
 * __useCurrencyListQuery__
 *
 * To run a query within a React component, call `useCurrencyListQuery` and pass it any options that fit your needs.
 * When your component renders, `useCurrencyListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCurrencyListQuery({
 *   variables: {
 *   },
 * });
 */
export function useCurrencyListQuery(baseOptions?: Apollo.QueryHookOptions<CurrencyListQuery, CurrencyListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CurrencyListQuery, CurrencyListQueryVariables>(CurrencyListDocument, options);
      }
export function useCurrencyListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CurrencyListQuery, CurrencyListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CurrencyListQuery, CurrencyListQueryVariables>(CurrencyListDocument, options);
        }
export function useCurrencyListSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CurrencyListQuery, CurrencyListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CurrencyListQuery, CurrencyListQueryVariables>(CurrencyListDocument, options);
        }
export type CurrencyListQueryHookResult = ReturnType<typeof useCurrencyListQuery>;
export type CurrencyListLazyQueryHookResult = ReturnType<typeof useCurrencyListLazyQuery>;
export type CurrencyListSuspenseQueryHookResult = ReturnType<typeof useCurrencyListSuspenseQuery>;
export type CurrencyListQueryResult = Apollo.QueryResult<CurrencyListQuery, CurrencyListQueryVariables>;
export const CaptchaCreateChallengeDocument = gql`
    mutation captchaCreateChallenge {
  captchaCreateChallenge {
    errors {
      message
    }
    result {
      id
      challengeCode
      newCaptcha
      failbackMode
    }
  }
}
    `;
export type CaptchaCreateChallengeMutationFn = Apollo.MutationFunction<CaptchaCreateChallengeMutation, CaptchaCreateChallengeMutationVariables>;

/**
 * __useCaptchaCreateChallengeMutation__
 *
 * To run a mutation, you first call `useCaptchaCreateChallengeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCaptchaCreateChallengeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [captchaCreateChallengeMutation, { data, loading, error }] = useCaptchaCreateChallengeMutation({
 *   variables: {
 *   },
 * });
 */
export function useCaptchaCreateChallengeMutation(baseOptions?: Apollo.MutationHookOptions<CaptchaCreateChallengeMutation, CaptchaCreateChallengeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CaptchaCreateChallengeMutation, CaptchaCreateChallengeMutationVariables>(CaptchaCreateChallengeDocument, options);
      }
export type CaptchaCreateChallengeMutationHookResult = ReturnType<typeof useCaptchaCreateChallengeMutation>;
export type CaptchaCreateChallengeMutationResult = Apollo.MutationResult<CaptchaCreateChallengeMutation>;
export type CaptchaCreateChallengeMutationOptions = Apollo.BaseMutationOptions<CaptchaCreateChallengeMutation, CaptchaCreateChallengeMutationVariables>;
export const UserLogoutDocument = gql`
    mutation userLogout($input: UserLogoutInput!) {
  userLogout(input: $input) {
    success
  }
}
    `;
export type UserLogoutMutationFn = Apollo.MutationFunction<UserLogoutMutation, UserLogoutMutationVariables>;

/**
 * __useUserLogoutMutation__
 *
 * To run a mutation, you first call `useUserLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userLogoutMutation, { data, loading, error }] = useUserLogoutMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserLogoutMutation(baseOptions?: Apollo.MutationHookOptions<UserLogoutMutation, UserLogoutMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserLogoutMutation, UserLogoutMutationVariables>(UserLogoutDocument, options);
      }
export type UserLogoutMutationHookResult = ReturnType<typeof useUserLogoutMutation>;
export type UserLogoutMutationResult = Apollo.MutationResult<UserLogoutMutation>;
export type UserLogoutMutationOptions = Apollo.BaseMutationOptions<UserLogoutMutation, UserLogoutMutationVariables>;
export const ConversionScreenDocument = gql`
    query conversionScreen {
  me {
    id
    defaultAccount {
      id
      wallets {
        id
        balance
        walletCurrency
      }
    }
  }
}
    `;

/**
 * __useConversionScreenQuery__
 *
 * To run a query within a React component, call `useConversionScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useConversionScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConversionScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useConversionScreenQuery(baseOptions?: Apollo.QueryHookOptions<ConversionScreenQuery, ConversionScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConversionScreenQuery, ConversionScreenQueryVariables>(ConversionScreenDocument, options);
      }
export function useConversionScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConversionScreenQuery, ConversionScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConversionScreenQuery, ConversionScreenQueryVariables>(ConversionScreenDocument, options);
        }
export function useConversionScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ConversionScreenQuery, ConversionScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ConversionScreenQuery, ConversionScreenQueryVariables>(ConversionScreenDocument, options);
        }
export type ConversionScreenQueryHookResult = ReturnType<typeof useConversionScreenQuery>;
export type ConversionScreenLazyQueryHookResult = ReturnType<typeof useConversionScreenLazyQuery>;
export type ConversionScreenSuspenseQueryHookResult = ReturnType<typeof useConversionScreenSuspenseQuery>;
export type ConversionScreenQueryResult = Apollo.QueryResult<ConversionScreenQuery, ConversionScreenQueryVariables>;
export const DebugScreenDocument = gql`
    query debugScreen {
  me {
    id
    defaultAccount {
      id
    }
  }
}
    `;

/**
 * __useDebugScreenQuery__
 *
 * To run a query within a React component, call `useDebugScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useDebugScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useDebugScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useDebugScreenQuery(baseOptions?: Apollo.QueryHookOptions<DebugScreenQuery, DebugScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<DebugScreenQuery, DebugScreenQueryVariables>(DebugScreenDocument, options);
      }
export function useDebugScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<DebugScreenQuery, DebugScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<DebugScreenQuery, DebugScreenQueryVariables>(DebugScreenDocument, options);
        }
export function useDebugScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<DebugScreenQuery, DebugScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<DebugScreenQuery, DebugScreenQueryVariables>(DebugScreenDocument, options);
        }
export type DebugScreenQueryHookResult = ReturnType<typeof useDebugScreenQuery>;
export type DebugScreenLazyQueryHookResult = ReturnType<typeof useDebugScreenLazyQuery>;
export type DebugScreenSuspenseQueryHookResult = ReturnType<typeof useDebugScreenSuspenseQuery>;
export type DebugScreenQueryResult = Apollo.QueryResult<DebugScreenQuery, DebugScreenQueryVariables>;
export const MyQuizQuestionsDocument = gql`
    query myQuizQuestions {
  me {
    id
    defaultAccount {
      id
      ... on ConsumerAccount {
        quiz {
          id
          amount
          completed
          notBefore
        }
      }
    }
  }
}
    `;

/**
 * __useMyQuizQuestionsQuery__
 *
 * To run a query within a React component, call `useMyQuizQuestionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyQuizQuestionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyQuizQuestionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useMyQuizQuestionsQuery(baseOptions?: Apollo.QueryHookOptions<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>(MyQuizQuestionsDocument, options);
      }
export function useMyQuizQuestionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>(MyQuizQuestionsDocument, options);
        }
export function useMyQuizQuestionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>(MyQuizQuestionsDocument, options);
        }
export type MyQuizQuestionsQueryHookResult = ReturnType<typeof useMyQuizQuestionsQuery>;
export type MyQuizQuestionsLazyQueryHookResult = ReturnType<typeof useMyQuizQuestionsLazyQuery>;
export type MyQuizQuestionsSuspenseQueryHookResult = ReturnType<typeof useMyQuizQuestionsSuspenseQuery>;
export type MyQuizQuestionsQueryResult = Apollo.QueryResult<MyQuizQuestionsQuery, MyQuizQuestionsQueryVariables>;
export const QuizClaimDocument = gql`
    mutation quizClaim($input: QuizClaimInput!) {
  quizClaim(input: $input) {
    errors {
      message
    }
    quizzes {
      id
      amount
      completed
      notBefore
    }
  }
}
    `;
export type QuizClaimMutationFn = Apollo.MutationFunction<QuizClaimMutation, QuizClaimMutationVariables>;

/**
 * __useQuizClaimMutation__
 *
 * To run a mutation, you first call `useQuizClaimMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useQuizClaimMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [quizClaimMutation, { data, loading, error }] = useQuizClaimMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useQuizClaimMutation(baseOptions?: Apollo.MutationHookOptions<QuizClaimMutation, QuizClaimMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<QuizClaimMutation, QuizClaimMutationVariables>(QuizClaimDocument, options);
      }
export type QuizClaimMutationHookResult = ReturnType<typeof useQuizClaimMutation>;
export type QuizClaimMutationResult = Apollo.MutationResult<QuizClaimMutation>;
export type QuizClaimMutationOptions = Apollo.BaseMutationOptions<QuizClaimMutation, QuizClaimMutationVariables>;
export const UserEmailRegistrationInitiateDocument = gql`
    mutation userEmailRegistrationInitiate($input: UserEmailRegistrationInitiateInput!) {
  userEmailRegistrationInitiate(input: $input) {
    errors {
      message
    }
    emailRegistrationId
    me {
      id
      email {
        address
        verified
      }
    }
  }
}
    `;
export type UserEmailRegistrationInitiateMutationFn = Apollo.MutationFunction<UserEmailRegistrationInitiateMutation, UserEmailRegistrationInitiateMutationVariables>;

/**
 * __useUserEmailRegistrationInitiateMutation__
 *
 * To run a mutation, you first call `useUserEmailRegistrationInitiateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailRegistrationInitiateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailRegistrationInitiateMutation, { data, loading, error }] = useUserEmailRegistrationInitiateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserEmailRegistrationInitiateMutation(baseOptions?: Apollo.MutationHookOptions<UserEmailRegistrationInitiateMutation, UserEmailRegistrationInitiateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserEmailRegistrationInitiateMutation, UserEmailRegistrationInitiateMutationVariables>(UserEmailRegistrationInitiateDocument, options);
      }
export type UserEmailRegistrationInitiateMutationHookResult = ReturnType<typeof useUserEmailRegistrationInitiateMutation>;
export type UserEmailRegistrationInitiateMutationResult = Apollo.MutationResult<UserEmailRegistrationInitiateMutation>;
export type UserEmailRegistrationInitiateMutationOptions = Apollo.BaseMutationOptions<UserEmailRegistrationInitiateMutation, UserEmailRegistrationInitiateMutationVariables>;
export const UserEmailRegistrationValidateDocument = gql`
    mutation userEmailRegistrationValidate($input: UserEmailRegistrationValidateInput!) {
  userEmailRegistrationValidate(input: $input) {
    errors {
      message
    }
    me {
      id
      email {
        address
        verified
      }
    }
  }
}
    `;
export type UserEmailRegistrationValidateMutationFn = Apollo.MutationFunction<UserEmailRegistrationValidateMutation, UserEmailRegistrationValidateMutationVariables>;

/**
 * __useUserEmailRegistrationValidateMutation__
 *
 * To run a mutation, you first call `useUserEmailRegistrationValidateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailRegistrationValidateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailRegistrationValidateMutation, { data, loading, error }] = useUserEmailRegistrationValidateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserEmailRegistrationValidateMutation(baseOptions?: Apollo.MutationHookOptions<UserEmailRegistrationValidateMutation, UserEmailRegistrationValidateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserEmailRegistrationValidateMutation, UserEmailRegistrationValidateMutationVariables>(UserEmailRegistrationValidateDocument, options);
      }
export type UserEmailRegistrationValidateMutationHookResult = ReturnType<typeof useUserEmailRegistrationValidateMutation>;
export type UserEmailRegistrationValidateMutationResult = Apollo.MutationResult<UserEmailRegistrationValidateMutation>;
export type UserEmailRegistrationValidateMutationOptions = Apollo.BaseMutationOptions<UserEmailRegistrationValidateMutation, UserEmailRegistrationValidateMutationVariables>;
export const OnboardingFlowStartDocument = gql`
    mutation onboardingFlowStart($input: OnboardingFlowStartInput!) {
  onboardingFlowStart(input: $input) {
    workflowRunId
    tokenWeb
  }
}
    `;
export type OnboardingFlowStartMutationFn = Apollo.MutationFunction<OnboardingFlowStartMutation, OnboardingFlowStartMutationVariables>;

/**
 * __useOnboardingFlowStartMutation__
 *
 * To run a mutation, you first call `useOnboardingFlowStartMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnboardingFlowStartMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onboardingFlowStartMutation, { data, loading, error }] = useOnboardingFlowStartMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnboardingFlowStartMutation(baseOptions?: Apollo.MutationHookOptions<OnboardingFlowStartMutation, OnboardingFlowStartMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OnboardingFlowStartMutation, OnboardingFlowStartMutationVariables>(OnboardingFlowStartDocument, options);
      }
export type OnboardingFlowStartMutationHookResult = ReturnType<typeof useOnboardingFlowStartMutation>;
export type OnboardingFlowStartMutationResult = Apollo.MutationResult<OnboardingFlowStartMutation>;
export type OnboardingFlowStartMutationOptions = Apollo.BaseMutationOptions<OnboardingFlowStartMutation, OnboardingFlowStartMutationVariables>;
export const FullOnboardingScreenDocument = gql`
    query fullOnboardingScreen {
  me {
    id
    defaultAccount {
      ... on ConsumerAccount {
        id
        onboardingStatus
      }
    }
  }
}
    `;

/**
 * __useFullOnboardingScreenQuery__
 *
 * To run a query within a React component, call `useFullOnboardingScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useFullOnboardingScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFullOnboardingScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useFullOnboardingScreenQuery(baseOptions?: Apollo.QueryHookOptions<FullOnboardingScreenQuery, FullOnboardingScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FullOnboardingScreenQuery, FullOnboardingScreenQueryVariables>(FullOnboardingScreenDocument, options);
      }
export function useFullOnboardingScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FullOnboardingScreenQuery, FullOnboardingScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FullOnboardingScreenQuery, FullOnboardingScreenQueryVariables>(FullOnboardingScreenDocument, options);
        }
export function useFullOnboardingScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FullOnboardingScreenQuery, FullOnboardingScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FullOnboardingScreenQuery, FullOnboardingScreenQueryVariables>(FullOnboardingScreenDocument, options);
        }
export type FullOnboardingScreenQueryHookResult = ReturnType<typeof useFullOnboardingScreenQuery>;
export type FullOnboardingScreenLazyQueryHookResult = ReturnType<typeof useFullOnboardingScreenLazyQuery>;
export type FullOnboardingScreenSuspenseQueryHookResult = ReturnType<typeof useFullOnboardingScreenSuspenseQuery>;
export type FullOnboardingScreenQueryResult = Apollo.QueryResult<FullOnboardingScreenQuery, FullOnboardingScreenQueryVariables>;
export const AddressScreenDocument = gql`
    query addressScreen {
  me {
    id
    username
  }
}
    `;

/**
 * __useAddressScreenQuery__
 *
 * To run a query within a React component, call `useAddressScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddressScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddressScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useAddressScreenQuery(baseOptions?: Apollo.QueryHookOptions<AddressScreenQuery, AddressScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddressScreenQuery, AddressScreenQueryVariables>(AddressScreenDocument, options);
      }
export function useAddressScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddressScreenQuery, AddressScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddressScreenQuery, AddressScreenQueryVariables>(AddressScreenDocument, options);
        }
export function useAddressScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AddressScreenQuery, AddressScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AddressScreenQuery, AddressScreenQueryVariables>(AddressScreenDocument, options);
        }
export type AddressScreenQueryHookResult = ReturnType<typeof useAddressScreenQuery>;
export type AddressScreenLazyQueryHookResult = ReturnType<typeof useAddressScreenLazyQuery>;
export type AddressScreenSuspenseQueryHookResult = ReturnType<typeof useAddressScreenSuspenseQuery>;
export type AddressScreenQueryResult = Apollo.QueryResult<AddressScreenQuery, AddressScreenQueryVariables>;
export const HomeAuthedDocument = gql`
    query homeAuthed {
  me {
    id
    language
    username
    phone
    email {
      address
      verified
    }
    defaultAccount {
      id
      level
      defaultWalletId
      pendingIncomingTransactions {
        ...Transaction
      }
      transactions(first: 20) {
        ...TransactionList
      }
      wallets {
        id
        balance
        walletCurrency
      }
    }
  }
}
    ${TransactionFragmentDoc}
${TransactionListFragmentDoc}`;

/**
 * __useHomeAuthedQuery__
 *
 * To run a query within a React component, call `useHomeAuthedQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeAuthedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeAuthedQuery({
 *   variables: {
 *   },
 * });
 */
export function useHomeAuthedQuery(baseOptions?: Apollo.QueryHookOptions<HomeAuthedQuery, HomeAuthedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HomeAuthedQuery, HomeAuthedQueryVariables>(HomeAuthedDocument, options);
      }
export function useHomeAuthedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomeAuthedQuery, HomeAuthedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HomeAuthedQuery, HomeAuthedQueryVariables>(HomeAuthedDocument, options);
        }
export function useHomeAuthedSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HomeAuthedQuery, HomeAuthedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HomeAuthedQuery, HomeAuthedQueryVariables>(HomeAuthedDocument, options);
        }
export type HomeAuthedQueryHookResult = ReturnType<typeof useHomeAuthedQuery>;
export type HomeAuthedLazyQueryHookResult = ReturnType<typeof useHomeAuthedLazyQuery>;
export type HomeAuthedSuspenseQueryHookResult = ReturnType<typeof useHomeAuthedSuspenseQuery>;
export type HomeAuthedQueryResult = Apollo.QueryResult<HomeAuthedQuery, HomeAuthedQueryVariables>;
export const HomeUnauthedDocument = gql`
    query homeUnauthed {
  globals {
    network
  }
  currencyList {
    id
    flag
    name
    symbol
    fractionDigits
  }
}
    `;

/**
 * __useHomeUnauthedQuery__
 *
 * To run a query within a React component, call `useHomeUnauthedQuery` and pass it any options that fit your needs.
 * When your component renders, `useHomeUnauthedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHomeUnauthedQuery({
 *   variables: {
 *   },
 * });
 */
export function useHomeUnauthedQuery(baseOptions?: Apollo.QueryHookOptions<HomeUnauthedQuery, HomeUnauthedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HomeUnauthedQuery, HomeUnauthedQueryVariables>(HomeUnauthedDocument, options);
      }
export function useHomeUnauthedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HomeUnauthedQuery, HomeUnauthedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HomeUnauthedQuery, HomeUnauthedQueryVariables>(HomeUnauthedDocument, options);
        }
export function useHomeUnauthedSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<HomeUnauthedQuery, HomeUnauthedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<HomeUnauthedQuery, HomeUnauthedQueryVariables>(HomeUnauthedDocument, options);
        }
export type HomeUnauthedQueryHookResult = ReturnType<typeof useHomeUnauthedQuery>;
export type HomeUnauthedLazyQueryHookResult = ReturnType<typeof useHomeUnauthedLazyQuery>;
export type HomeUnauthedSuspenseQueryHookResult = ReturnType<typeof useHomeUnauthedSuspenseQuery>;
export type HomeUnauthedQueryResult = Apollo.QueryResult<HomeUnauthedQuery, HomeUnauthedQueryVariables>;
export const BulletinsDocument = gql`
    query Bulletins($first: Int!, $after: String) {
  me {
    id
    unacknowledgedStatefulNotificationsWithBulletinEnabled(
      first: $first
      after: $after
    ) {
      pageInfo {
        endCursor
        hasNextPage
        hasPreviousPage
        startCursor
      }
      edges {
        node {
          id
          title
          body
          createdAt
          acknowledgedAt
          bulletinEnabled
          icon
          action {
            ... on OpenDeepLinkAction {
              deepLink
            }
            ... on OpenExternalLinkAction {
              url
            }
          }
        }
        cursor
      }
    }
  }
}
    `;

/**
 * __useBulletinsQuery__
 *
 * To run a query within a React component, call `useBulletinsQuery` and pass it any options that fit your needs.
 * When your component renders, `useBulletinsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBulletinsQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *   },
 * });
 */
export function useBulletinsQuery(baseOptions: Apollo.QueryHookOptions<BulletinsQuery, BulletinsQueryVariables> & ({ variables: BulletinsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BulletinsQuery, BulletinsQueryVariables>(BulletinsDocument, options);
      }
export function useBulletinsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BulletinsQuery, BulletinsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BulletinsQuery, BulletinsQueryVariables>(BulletinsDocument, options);
        }
export function useBulletinsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<BulletinsQuery, BulletinsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BulletinsQuery, BulletinsQueryVariables>(BulletinsDocument, options);
        }
export type BulletinsQueryHookResult = ReturnType<typeof useBulletinsQuery>;
export type BulletinsLazyQueryHookResult = ReturnType<typeof useBulletinsLazyQuery>;
export type BulletinsSuspenseQueryHookResult = ReturnType<typeof useBulletinsSuspenseQuery>;
export type BulletinsQueryResult = Apollo.QueryResult<BulletinsQuery, BulletinsQueryVariables>;
export const BusinessMapMarkersDocument = gql`
    query businessMapMarkers {
  businessMapMarkers {
    username
    mapInfo {
      title
      coordinates {
        longitude
        latitude
      }
    }
  }
}
    `;

/**
 * __useBusinessMapMarkersQuery__
 *
 * To run a query within a React component, call `useBusinessMapMarkersQuery` and pass it any options that fit your needs.
 * When your component renders, `useBusinessMapMarkersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBusinessMapMarkersQuery({
 *   variables: {
 *   },
 * });
 */
export function useBusinessMapMarkersQuery(baseOptions?: Apollo.QueryHookOptions<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>(BusinessMapMarkersDocument, options);
      }
export function useBusinessMapMarkersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>(BusinessMapMarkersDocument, options);
        }
export function useBusinessMapMarkersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>(BusinessMapMarkersDocument, options);
        }
export type BusinessMapMarkersQueryHookResult = ReturnType<typeof useBusinessMapMarkersQuery>;
export type BusinessMapMarkersLazyQueryHookResult = ReturnType<typeof useBusinessMapMarkersLazyQuery>;
export type BusinessMapMarkersSuspenseQueryHookResult = ReturnType<typeof useBusinessMapMarkersSuspenseQuery>;
export type BusinessMapMarkersQueryResult = Apollo.QueryResult<BusinessMapMarkersQuery, BusinessMapMarkersQueryVariables>;
export const StatefulNotificationsDocument = gql`
    query StatefulNotifications($after: String) {
  me {
    statefulNotificationsWithoutBulletinEnabled(first: 20, after: $after) {
      nodes {
        id
        title
        body
        createdAt
        acknowledgedAt
        bulletinEnabled
        icon
        action {
          ... on OpenDeepLinkAction {
            deepLink
          }
          ... on OpenExternalLinkAction {
            url
          }
        }
      }
      pageInfo {
        endCursor
        hasNextPage
        hasPreviousPage
        startCursor
      }
    }
  }
}
    `;

/**
 * __useStatefulNotificationsQuery__
 *
 * To run a query within a React component, call `useStatefulNotificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStatefulNotificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStatefulNotificationsQuery({
 *   variables: {
 *      after: // value for 'after'
 *   },
 * });
 */
export function useStatefulNotificationsQuery(baseOptions?: Apollo.QueryHookOptions<StatefulNotificationsQuery, StatefulNotificationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StatefulNotificationsQuery, StatefulNotificationsQueryVariables>(StatefulNotificationsDocument, options);
      }
export function useStatefulNotificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StatefulNotificationsQuery, StatefulNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StatefulNotificationsQuery, StatefulNotificationsQueryVariables>(StatefulNotificationsDocument, options);
        }
export function useStatefulNotificationsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<StatefulNotificationsQuery, StatefulNotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<StatefulNotificationsQuery, StatefulNotificationsQueryVariables>(StatefulNotificationsDocument, options);
        }
export type StatefulNotificationsQueryHookResult = ReturnType<typeof useStatefulNotificationsQuery>;
export type StatefulNotificationsLazyQueryHookResult = ReturnType<typeof useStatefulNotificationsLazyQuery>;
export type StatefulNotificationsSuspenseQueryHookResult = ReturnType<typeof useStatefulNotificationsSuspenseQuery>;
export type StatefulNotificationsQueryResult = Apollo.QueryResult<StatefulNotificationsQuery, StatefulNotificationsQueryVariables>;
export const StatefulNotificationAcknowledgeDocument = gql`
    mutation StatefulNotificationAcknowledge($input: StatefulNotificationAcknowledgeInput!) {
  statefulNotificationAcknowledge(input: $input) {
    notification {
      acknowledgedAt
    }
  }
}
    `;
export type StatefulNotificationAcknowledgeMutationFn = Apollo.MutationFunction<StatefulNotificationAcknowledgeMutation, StatefulNotificationAcknowledgeMutationVariables>;

/**
 * __useStatefulNotificationAcknowledgeMutation__
 *
 * To run a mutation, you first call `useStatefulNotificationAcknowledgeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStatefulNotificationAcknowledgeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [statefulNotificationAcknowledgeMutation, { data, loading, error }] = useStatefulNotificationAcknowledgeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useStatefulNotificationAcknowledgeMutation(baseOptions?: Apollo.MutationHookOptions<StatefulNotificationAcknowledgeMutation, StatefulNotificationAcknowledgeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StatefulNotificationAcknowledgeMutation, StatefulNotificationAcknowledgeMutationVariables>(StatefulNotificationAcknowledgeDocument, options);
      }
export type StatefulNotificationAcknowledgeMutationHookResult = ReturnType<typeof useStatefulNotificationAcknowledgeMutation>;
export type StatefulNotificationAcknowledgeMutationResult = Apollo.MutationResult<StatefulNotificationAcknowledgeMutation>;
export type StatefulNotificationAcknowledgeMutationOptions = Apollo.BaseMutationOptions<StatefulNotificationAcknowledgeMutation, StatefulNotificationAcknowledgeMutationVariables>;
export const CirclesDocument = gql`
    query Circles {
  me {
    id
    username
    defaultAccount {
      id
      ... on ConsumerAccount {
        welcomeProfile {
          allTimePoints
          allTimeRank
          innerCircleAllTimeCount
          innerCircleThisMonthCount
          outerCircleAllTimeCount
          outerCircleThisMonthCount
          thisMonthPoints
          thisMonthRank
        }
      }
    }
  }
}
    `;

/**
 * __useCirclesQuery__
 *
 * To run a query within a React component, call `useCirclesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCirclesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCirclesQuery({
 *   variables: {
 *   },
 * });
 */
export function useCirclesQuery(baseOptions?: Apollo.QueryHookOptions<CirclesQuery, CirclesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CirclesQuery, CirclesQueryVariables>(CirclesDocument, options);
      }
export function useCirclesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CirclesQuery, CirclesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CirclesQuery, CirclesQueryVariables>(CirclesDocument, options);
        }
export function useCirclesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CirclesQuery, CirclesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CirclesQuery, CirclesQueryVariables>(CirclesDocument, options);
        }
export type CirclesQueryHookResult = ReturnType<typeof useCirclesQuery>;
export type CirclesLazyQueryHookResult = ReturnType<typeof useCirclesLazyQuery>;
export type CirclesSuspenseQueryHookResult = ReturnType<typeof useCirclesSuspenseQuery>;
export type CirclesQueryResult = Apollo.QueryResult<CirclesQuery, CirclesQueryVariables>;
export const ContactsDocument = gql`
    query contacts {
  me {
    id
    contacts {
      id
      username
      alias
      transactionsCount
    }
  }
}
    `;

/**
 * __useContactsQuery__
 *
 * To run a query within a React component, call `useContactsQuery` and pass it any options that fit your needs.
 * When your component renders, `useContactsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContactsQuery({
 *   variables: {
 *   },
 * });
 */
export function useContactsQuery(baseOptions?: Apollo.QueryHookOptions<ContactsQuery, ContactsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContactsQuery, ContactsQueryVariables>(ContactsDocument, options);
      }
export function useContactsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContactsQuery, ContactsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContactsQuery, ContactsQueryVariables>(ContactsDocument, options);
        }
export function useContactsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ContactsQuery, ContactsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ContactsQuery, ContactsQueryVariables>(ContactsDocument, options);
        }
export type ContactsQueryHookResult = ReturnType<typeof useContactsQuery>;
export type ContactsLazyQueryHookResult = ReturnType<typeof useContactsLazyQuery>;
export type ContactsSuspenseQueryHookResult = ReturnType<typeof useContactsSuspenseQuery>;
export type ContactsQueryResult = Apollo.QueryResult<ContactsQuery, ContactsQueryVariables>;
export const TransactionListForContactDocument = gql`
    query transactionListForContact($username: Username!, $first: Int, $after: String, $last: Int, $before: String) {
  me {
    id
    contactByUsername(username: $username) {
      transactions(first: $first, after: $after, last: $last, before: $before) {
        ...TransactionList
      }
    }
  }
}
    ${TransactionListFragmentDoc}`;

/**
 * __useTransactionListForContactQuery__
 *
 * To run a query within a React component, call `useTransactionListForContactQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionListForContactQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionListForContactQuery({
 *   variables: {
 *      username: // value for 'username'
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      last: // value for 'last'
 *      before: // value for 'before'
 *   },
 * });
 */
export function useTransactionListForContactQuery(baseOptions: Apollo.QueryHookOptions<TransactionListForContactQuery, TransactionListForContactQueryVariables> & ({ variables: TransactionListForContactQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TransactionListForContactQuery, TransactionListForContactQueryVariables>(TransactionListForContactDocument, options);
      }
export function useTransactionListForContactLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TransactionListForContactQuery, TransactionListForContactQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TransactionListForContactQuery, TransactionListForContactQueryVariables>(TransactionListForContactDocument, options);
        }
export function useTransactionListForContactSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TransactionListForContactQuery, TransactionListForContactQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TransactionListForContactQuery, TransactionListForContactQueryVariables>(TransactionListForContactDocument, options);
        }
export type TransactionListForContactQueryHookResult = ReturnType<typeof useTransactionListForContactQuery>;
export type TransactionListForContactLazyQueryHookResult = ReturnType<typeof useTransactionListForContactLazyQuery>;
export type TransactionListForContactSuspenseQueryHookResult = ReturnType<typeof useTransactionListForContactSuspenseQuery>;
export type TransactionListForContactQueryResult = Apollo.QueryResult<TransactionListForContactQuery, TransactionListForContactQueryVariables>;
export const ContactsCardDocument = gql`
    query ContactsCard {
  me {
    id
    contacts {
      id
      username
      alias
      transactionsCount
    }
  }
}
    `;

/**
 * __useContactsCardQuery__
 *
 * To run a query within a React component, call `useContactsCardQuery` and pass it any options that fit your needs.
 * When your component renders, `useContactsCardQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContactsCardQuery({
 *   variables: {
 *   },
 * });
 */
export function useContactsCardQuery(baseOptions?: Apollo.QueryHookOptions<ContactsCardQuery, ContactsCardQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContactsCardQuery, ContactsCardQueryVariables>(ContactsCardDocument, options);
      }
export function useContactsCardLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContactsCardQuery, ContactsCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContactsCardQuery, ContactsCardQueryVariables>(ContactsCardDocument, options);
        }
export function useContactsCardSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ContactsCardQuery, ContactsCardQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ContactsCardQuery, ContactsCardQueryVariables>(ContactsCardDocument, options);
        }
export type ContactsCardQueryHookResult = ReturnType<typeof useContactsCardQuery>;
export type ContactsCardLazyQueryHookResult = ReturnType<typeof useContactsCardLazyQuery>;
export type ContactsCardSuspenseQueryHookResult = ReturnType<typeof useContactsCardSuspenseQuery>;
export type ContactsCardQueryResult = Apollo.QueryResult<ContactsCardQuery, ContactsCardQueryVariables>;
export const UserContactUpdateAliasDocument = gql`
    mutation userContactUpdateAlias($input: UserContactUpdateAliasInput!) {
  userContactUpdateAlias(input: $input) {
    errors {
      message
    }
    contact {
      alias
      id
    }
  }
}
    `;
export type UserContactUpdateAliasMutationFn = Apollo.MutationFunction<UserContactUpdateAliasMutation, UserContactUpdateAliasMutationVariables>;

/**
 * __useUserContactUpdateAliasMutation__
 *
 * To run a mutation, you first call `useUserContactUpdateAliasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserContactUpdateAliasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userContactUpdateAliasMutation, { data, loading, error }] = useUserContactUpdateAliasMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserContactUpdateAliasMutation(baseOptions?: Apollo.MutationHookOptions<UserContactUpdateAliasMutation, UserContactUpdateAliasMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserContactUpdateAliasMutation, UserContactUpdateAliasMutationVariables>(UserContactUpdateAliasDocument, options);
      }
export type UserContactUpdateAliasMutationHookResult = ReturnType<typeof useUserContactUpdateAliasMutation>;
export type UserContactUpdateAliasMutationResult = Apollo.MutationResult<UserContactUpdateAliasMutation>;
export type UserContactUpdateAliasMutationOptions = Apollo.BaseMutationOptions<UserContactUpdateAliasMutation, UserContactUpdateAliasMutationVariables>;
export const UserLoginDocument = gql`
    mutation userLogin($input: UserLoginInput!) {
  userLogin(input: $input) {
    errors {
      message
      code
    }
    authToken
    totpRequired
  }
}
    `;
export type UserLoginMutationFn = Apollo.MutationFunction<UserLoginMutation, UserLoginMutationVariables>;

/**
 * __useUserLoginMutation__
 *
 * To run a mutation, you first call `useUserLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userLoginMutation, { data, loading, error }] = useUserLoginMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserLoginMutation(baseOptions?: Apollo.MutationHookOptions<UserLoginMutation, UserLoginMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserLoginMutation, UserLoginMutationVariables>(UserLoginDocument, options);
      }
export type UserLoginMutationHookResult = ReturnType<typeof useUserLoginMutation>;
export type UserLoginMutationResult = Apollo.MutationResult<UserLoginMutation>;
export type UserLoginMutationOptions = Apollo.BaseMutationOptions<UserLoginMutation, UserLoginMutationVariables>;
export const UserLoginUpgradeDocument = gql`
    mutation userLoginUpgrade($input: UserLoginUpgradeInput!) {
  userLoginUpgrade(input: $input) {
    errors {
      message
      code
    }
    success
    authToken
  }
}
    `;
export type UserLoginUpgradeMutationFn = Apollo.MutationFunction<UserLoginUpgradeMutation, UserLoginUpgradeMutationVariables>;

/**
 * __useUserLoginUpgradeMutation__
 *
 * To run a mutation, you first call `useUserLoginUpgradeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserLoginUpgradeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userLoginUpgradeMutation, { data, loading, error }] = useUserLoginUpgradeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserLoginUpgradeMutation(baseOptions?: Apollo.MutationHookOptions<UserLoginUpgradeMutation, UserLoginUpgradeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserLoginUpgradeMutation, UserLoginUpgradeMutationVariables>(UserLoginUpgradeDocument, options);
      }
export type UserLoginUpgradeMutationHookResult = ReturnType<typeof useUserLoginUpgradeMutation>;
export type UserLoginUpgradeMutationResult = Apollo.MutationResult<UserLoginUpgradeMutation>;
export type UserLoginUpgradeMutationOptions = Apollo.BaseMutationOptions<UserLoginUpgradeMutation, UserLoginUpgradeMutationVariables>;
export const UserPhoneRegistrationValidateDocument = gql`
    mutation userPhoneRegistrationValidate($input: UserPhoneRegistrationValidateInput!) {
  userPhoneRegistrationValidate(input: $input) {
    errors {
      message
      code
    }
    me {
      id
      phone
      email {
        address
        verified
      }
    }
  }
}
    `;
export type UserPhoneRegistrationValidateMutationFn = Apollo.MutationFunction<UserPhoneRegistrationValidateMutation, UserPhoneRegistrationValidateMutationVariables>;

/**
 * __useUserPhoneRegistrationValidateMutation__
 *
 * To run a mutation, you first call `useUserPhoneRegistrationValidateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPhoneRegistrationValidateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPhoneRegistrationValidateMutation, { data, loading, error }] = useUserPhoneRegistrationValidateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserPhoneRegistrationValidateMutation(baseOptions?: Apollo.MutationHookOptions<UserPhoneRegistrationValidateMutation, UserPhoneRegistrationValidateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserPhoneRegistrationValidateMutation, UserPhoneRegistrationValidateMutationVariables>(UserPhoneRegistrationValidateDocument, options);
      }
export type UserPhoneRegistrationValidateMutationHookResult = ReturnType<typeof useUserPhoneRegistrationValidateMutation>;
export type UserPhoneRegistrationValidateMutationResult = Apollo.MutationResult<UserPhoneRegistrationValidateMutation>;
export type UserPhoneRegistrationValidateMutationOptions = Apollo.BaseMutationOptions<UserPhoneRegistrationValidateMutation, UserPhoneRegistrationValidateMutationVariables>;
export const CaptchaRequestAuthCodeDocument = gql`
    mutation captchaRequestAuthCode($input: CaptchaRequestAuthCodeInput!) {
  captchaRequestAuthCode(input: $input) {
    errors {
      message
      code
    }
    success
  }
}
    `;
export type CaptchaRequestAuthCodeMutationFn = Apollo.MutationFunction<CaptchaRequestAuthCodeMutation, CaptchaRequestAuthCodeMutationVariables>;

/**
 * __useCaptchaRequestAuthCodeMutation__
 *
 * To run a mutation, you first call `useCaptchaRequestAuthCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCaptchaRequestAuthCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [captchaRequestAuthCodeMutation, { data, loading, error }] = useCaptchaRequestAuthCodeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCaptchaRequestAuthCodeMutation(baseOptions?: Apollo.MutationHookOptions<CaptchaRequestAuthCodeMutation, CaptchaRequestAuthCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CaptchaRequestAuthCodeMutation, CaptchaRequestAuthCodeMutationVariables>(CaptchaRequestAuthCodeDocument, options);
      }
export type CaptchaRequestAuthCodeMutationHookResult = ReturnType<typeof useCaptchaRequestAuthCodeMutation>;
export type CaptchaRequestAuthCodeMutationResult = Apollo.MutationResult<CaptchaRequestAuthCodeMutation>;
export type CaptchaRequestAuthCodeMutationOptions = Apollo.BaseMutationOptions<CaptchaRequestAuthCodeMutation, CaptchaRequestAuthCodeMutationVariables>;
export const SupportedCountriesDocument = gql`
    query supportedCountries {
  globals {
    supportedCountries {
      id
      supportedAuthChannels
    }
  }
}
    `;

/**
 * __useSupportedCountriesQuery__
 *
 * To run a query within a React component, call `useSupportedCountriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSupportedCountriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSupportedCountriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useSupportedCountriesQuery(baseOptions?: Apollo.QueryHookOptions<SupportedCountriesQuery, SupportedCountriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SupportedCountriesQuery, SupportedCountriesQueryVariables>(SupportedCountriesDocument, options);
      }
export function useSupportedCountriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SupportedCountriesQuery, SupportedCountriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SupportedCountriesQuery, SupportedCountriesQueryVariables>(SupportedCountriesDocument, options);
        }
export function useSupportedCountriesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SupportedCountriesQuery, SupportedCountriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SupportedCountriesQuery, SupportedCountriesQueryVariables>(SupportedCountriesDocument, options);
        }
export type SupportedCountriesQueryHookResult = ReturnType<typeof useSupportedCountriesQuery>;
export type SupportedCountriesLazyQueryHookResult = ReturnType<typeof useSupportedCountriesLazyQuery>;
export type SupportedCountriesSuspenseQueryHookResult = ReturnType<typeof useSupportedCountriesSuspenseQuery>;
export type SupportedCountriesQueryResult = Apollo.QueryResult<SupportedCountriesQuery, SupportedCountriesQueryVariables>;
export const UserPhoneRegistrationInitiateDocument = gql`
    mutation userPhoneRegistrationInitiate($input: UserPhoneRegistrationInitiateInput!) {
  userPhoneRegistrationInitiate(input: $input) {
    errors {
      message
    }
    success
  }
}
    `;
export type UserPhoneRegistrationInitiateMutationFn = Apollo.MutationFunction<UserPhoneRegistrationInitiateMutation, UserPhoneRegistrationInitiateMutationVariables>;

/**
 * __useUserPhoneRegistrationInitiateMutation__
 *
 * To run a mutation, you first call `useUserPhoneRegistrationInitiateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPhoneRegistrationInitiateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPhoneRegistrationInitiateMutation, { data, loading, error }] = useUserPhoneRegistrationInitiateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserPhoneRegistrationInitiateMutation(baseOptions?: Apollo.MutationHookOptions<UserPhoneRegistrationInitiateMutation, UserPhoneRegistrationInitiateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserPhoneRegistrationInitiateMutation, UserPhoneRegistrationInitiateMutationVariables>(UserPhoneRegistrationInitiateDocument, options);
      }
export type UserPhoneRegistrationInitiateMutationHookResult = ReturnType<typeof useUserPhoneRegistrationInitiateMutation>;
export type UserPhoneRegistrationInitiateMutationResult = Apollo.MutationResult<UserPhoneRegistrationInitiateMutation>;
export type UserPhoneRegistrationInitiateMutationOptions = Apollo.BaseMutationOptions<UserPhoneRegistrationInitiateMutation, UserPhoneRegistrationInitiateMutationVariables>;
export const PriceHistoryScreenDocument = gql`
    query priceHistoryScreen {
  me {
    id
    defaultAccount {
      id
    }
  }
}
    `;

/**
 * __usePriceHistoryScreenQuery__
 *
 * To run a query within a React component, call `usePriceHistoryScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `usePriceHistoryScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePriceHistoryScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function usePriceHistoryScreenQuery(baseOptions?: Apollo.QueryHookOptions<PriceHistoryScreenQuery, PriceHistoryScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PriceHistoryScreenQuery, PriceHistoryScreenQueryVariables>(PriceHistoryScreenDocument, options);
      }
export function usePriceHistoryScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PriceHistoryScreenQuery, PriceHistoryScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PriceHistoryScreenQuery, PriceHistoryScreenQueryVariables>(PriceHistoryScreenDocument, options);
        }
export function usePriceHistoryScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PriceHistoryScreenQuery, PriceHistoryScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PriceHistoryScreenQuery, PriceHistoryScreenQueryVariables>(PriceHistoryScreenDocument, options);
        }
export type PriceHistoryScreenQueryHookResult = ReturnType<typeof usePriceHistoryScreenQuery>;
export type PriceHistoryScreenLazyQueryHookResult = ReturnType<typeof usePriceHistoryScreenLazyQuery>;
export type PriceHistoryScreenSuspenseQueryHookResult = ReturnType<typeof usePriceHistoryScreenSuspenseQuery>;
export type PriceHistoryScreenQueryResult = Apollo.QueryResult<PriceHistoryScreenQuery, PriceHistoryScreenQueryVariables>;
export const MyLnUpdatesDocument = gql`
    subscription myLnUpdates {
  myUpdates {
    errors {
      message
    }
    update {
      ... on LnUpdate {
        paymentHash
        status
      }
    }
  }
}
    `;

/**
 * __useMyLnUpdatesSubscription__
 *
 * To run a query within a React component, call `useMyLnUpdatesSubscription` and pass it any options that fit your needs.
 * When your component renders, `useMyLnUpdatesSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyLnUpdatesSubscription({
 *   variables: {
 *   },
 * });
 */
export function useMyLnUpdatesSubscription(baseOptions?: Apollo.SubscriptionHookOptions<MyLnUpdatesSubscription, MyLnUpdatesSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<MyLnUpdatesSubscription, MyLnUpdatesSubscriptionVariables>(MyLnUpdatesDocument, options);
      }
export type MyLnUpdatesSubscriptionHookResult = ReturnType<typeof useMyLnUpdatesSubscription>;
export type MyLnUpdatesSubscriptionResult = Apollo.SubscriptionResult<MyLnUpdatesSubscription>;
export const PaymentRequestDocument = gql`
    query paymentRequest {
  globals {
    network
    feesInformation {
      deposit {
        minBankFee
        minBankFeeThreshold
      }
    }
  }
  me {
    id
    username
    defaultAccount {
      id
      wallets {
        id
        balance
        walletCurrency
      }
      defaultWalletId
    }
  }
}
    `;

/**
 * __usePaymentRequestQuery__
 *
 * To run a query within a React component, call `usePaymentRequestQuery` and pass it any options that fit your needs.
 * When your component renders, `usePaymentRequestQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePaymentRequestQuery({
 *   variables: {
 *   },
 * });
 */
export function usePaymentRequestQuery(baseOptions?: Apollo.QueryHookOptions<PaymentRequestQuery, PaymentRequestQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PaymentRequestQuery, PaymentRequestQueryVariables>(PaymentRequestDocument, options);
      }
export function usePaymentRequestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PaymentRequestQuery, PaymentRequestQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PaymentRequestQuery, PaymentRequestQueryVariables>(PaymentRequestDocument, options);
        }
export function usePaymentRequestSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<PaymentRequestQuery, PaymentRequestQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<PaymentRequestQuery, PaymentRequestQueryVariables>(PaymentRequestDocument, options);
        }
export type PaymentRequestQueryHookResult = ReturnType<typeof usePaymentRequestQuery>;
export type PaymentRequestLazyQueryHookResult = ReturnType<typeof usePaymentRequestLazyQuery>;
export type PaymentRequestSuspenseQueryHookResult = ReturnType<typeof usePaymentRequestSuspenseQuery>;
export type PaymentRequestQueryResult = Apollo.QueryResult<PaymentRequestQuery, PaymentRequestQueryVariables>;
export const LnNoAmountInvoiceCreateDocument = gql`
    mutation lnNoAmountInvoiceCreate($input: LnNoAmountInvoiceCreateInput!) {
  lnNoAmountInvoiceCreate(input: $input) {
    errors {
      message
    }
    invoice {
      createdAt
      paymentHash
      paymentRequest
      paymentStatus
      externalId
    }
  }
}
    `;
export type LnNoAmountInvoiceCreateMutationFn = Apollo.MutationFunction<LnNoAmountInvoiceCreateMutation, LnNoAmountInvoiceCreateMutationVariables>;

/**
 * __useLnNoAmountInvoiceCreateMutation__
 *
 * To run a mutation, you first call `useLnNoAmountInvoiceCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountInvoiceCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountInvoiceCreateMutation, { data, loading, error }] = useLnNoAmountInvoiceCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountInvoiceCreateMutation(baseOptions?: Apollo.MutationHookOptions<LnNoAmountInvoiceCreateMutation, LnNoAmountInvoiceCreateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnNoAmountInvoiceCreateMutation, LnNoAmountInvoiceCreateMutationVariables>(LnNoAmountInvoiceCreateDocument, options);
      }
export type LnNoAmountInvoiceCreateMutationHookResult = ReturnType<typeof useLnNoAmountInvoiceCreateMutation>;
export type LnNoAmountInvoiceCreateMutationResult = Apollo.MutationResult<LnNoAmountInvoiceCreateMutation>;
export type LnNoAmountInvoiceCreateMutationOptions = Apollo.BaseMutationOptions<LnNoAmountInvoiceCreateMutation, LnNoAmountInvoiceCreateMutationVariables>;
export const LnInvoiceCreateDocument = gql`
    mutation lnInvoiceCreate($input: LnInvoiceCreateInput!) {
  lnInvoiceCreate(input: $input) {
    errors {
      message
    }
    invoice {
      createdAt
      paymentHash
      paymentRequest
      paymentStatus
      externalId
      satoshis
    }
  }
}
    `;
export type LnInvoiceCreateMutationFn = Apollo.MutationFunction<LnInvoiceCreateMutation, LnInvoiceCreateMutationVariables>;

/**
 * __useLnInvoiceCreateMutation__
 *
 * To run a mutation, you first call `useLnInvoiceCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoiceCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoiceCreateMutation, { data, loading, error }] = useLnInvoiceCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoiceCreateMutation(baseOptions?: Apollo.MutationHookOptions<LnInvoiceCreateMutation, LnInvoiceCreateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnInvoiceCreateMutation, LnInvoiceCreateMutationVariables>(LnInvoiceCreateDocument, options);
      }
export type LnInvoiceCreateMutationHookResult = ReturnType<typeof useLnInvoiceCreateMutation>;
export type LnInvoiceCreateMutationResult = Apollo.MutationResult<LnInvoiceCreateMutation>;
export type LnInvoiceCreateMutationOptions = Apollo.BaseMutationOptions<LnInvoiceCreateMutation, LnInvoiceCreateMutationVariables>;
export const OnChainAddressCurrentDocument = gql`
    mutation onChainAddressCurrent($input: OnChainAddressCurrentInput!) {
  onChainAddressCurrent(input: $input) {
    errors {
      message
    }
    address
  }
}
    `;
export type OnChainAddressCurrentMutationFn = Apollo.MutationFunction<OnChainAddressCurrentMutation, OnChainAddressCurrentMutationVariables>;

/**
 * __useOnChainAddressCurrentMutation__
 *
 * To run a mutation, you first call `useOnChainAddressCurrentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainAddressCurrentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainAddressCurrentMutation, { data, loading, error }] = useOnChainAddressCurrentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainAddressCurrentMutation(baseOptions?: Apollo.MutationHookOptions<OnChainAddressCurrentMutation, OnChainAddressCurrentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OnChainAddressCurrentMutation, OnChainAddressCurrentMutationVariables>(OnChainAddressCurrentDocument, options);
      }
export type OnChainAddressCurrentMutationHookResult = ReturnType<typeof useOnChainAddressCurrentMutation>;
export type OnChainAddressCurrentMutationResult = Apollo.MutationResult<OnChainAddressCurrentMutation>;
export type OnChainAddressCurrentMutationOptions = Apollo.BaseMutationOptions<OnChainAddressCurrentMutation, OnChainAddressCurrentMutationVariables>;
export const LnUsdInvoiceCreateDocument = gql`
    mutation lnUsdInvoiceCreate($input: LnUsdInvoiceCreateInput!) {
  lnUsdInvoiceCreate(input: $input) {
    errors {
      message
    }
    invoice {
      createdAt
      paymentHash
      paymentRequest
      paymentStatus
      externalId
      satoshis
    }
  }
}
    `;
export type LnUsdInvoiceCreateMutationFn = Apollo.MutationFunction<LnUsdInvoiceCreateMutation, LnUsdInvoiceCreateMutationVariables>;

/**
 * __useLnUsdInvoiceCreateMutation__
 *
 * To run a mutation, you first call `useLnUsdInvoiceCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnUsdInvoiceCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnUsdInvoiceCreateMutation, { data, loading, error }] = useLnUsdInvoiceCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnUsdInvoiceCreateMutation(baseOptions?: Apollo.MutationHookOptions<LnUsdInvoiceCreateMutation, LnUsdInvoiceCreateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnUsdInvoiceCreateMutation, LnUsdInvoiceCreateMutationVariables>(LnUsdInvoiceCreateDocument, options);
      }
export type LnUsdInvoiceCreateMutationHookResult = ReturnType<typeof useLnUsdInvoiceCreateMutation>;
export type LnUsdInvoiceCreateMutationResult = Apollo.MutationResult<LnUsdInvoiceCreateMutation>;
export type LnUsdInvoiceCreateMutationOptions = Apollo.BaseMutationOptions<LnUsdInvoiceCreateMutation, LnUsdInvoiceCreateMutationVariables>;
export const ScanningQrCodeScreenDocument = gql`
    query scanningQRCodeScreen {
  globals {
    network
  }
  me {
    id
    defaultAccount {
      id
      wallets {
        id
      }
    }
    contacts {
      id
      username
    }
  }
}
    `;

/**
 * __useScanningQrCodeScreenQuery__
 *
 * To run a query within a React component, call `useScanningQrCodeScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useScanningQrCodeScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScanningQrCodeScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useScanningQrCodeScreenQuery(baseOptions?: Apollo.QueryHookOptions<ScanningQrCodeScreenQuery, ScanningQrCodeScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScanningQrCodeScreenQuery, ScanningQrCodeScreenQueryVariables>(ScanningQrCodeScreenDocument, options);
      }
export function useScanningQrCodeScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScanningQrCodeScreenQuery, ScanningQrCodeScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScanningQrCodeScreenQuery, ScanningQrCodeScreenQueryVariables>(ScanningQrCodeScreenDocument, options);
        }
export function useScanningQrCodeScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ScanningQrCodeScreenQuery, ScanningQrCodeScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ScanningQrCodeScreenQuery, ScanningQrCodeScreenQueryVariables>(ScanningQrCodeScreenDocument, options);
        }
export type ScanningQrCodeScreenQueryHookResult = ReturnType<typeof useScanningQrCodeScreenQuery>;
export type ScanningQrCodeScreenLazyQueryHookResult = ReturnType<typeof useScanningQrCodeScreenLazyQuery>;
export type ScanningQrCodeScreenSuspenseQueryHookResult = ReturnType<typeof useScanningQrCodeScreenSuspenseQuery>;
export type ScanningQrCodeScreenQueryResult = Apollo.QueryResult<ScanningQrCodeScreenQuery, ScanningQrCodeScreenQueryVariables>;
export const SendBitcoinConfirmationScreenDocument = gql`
    query sendBitcoinConfirmationScreen {
  me {
    id
    defaultAccount {
      id
      wallets {
        id
        balance
        walletCurrency
      }
    }
  }
}
    `;

/**
 * __useSendBitcoinConfirmationScreenQuery__
 *
 * To run a query within a React component, call `useSendBitcoinConfirmationScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinConfirmationScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinConfirmationScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinConfirmationScreenQuery(baseOptions?: Apollo.QueryHookOptions<SendBitcoinConfirmationScreenQuery, SendBitcoinConfirmationScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendBitcoinConfirmationScreenQuery, SendBitcoinConfirmationScreenQueryVariables>(SendBitcoinConfirmationScreenDocument, options);
      }
export function useSendBitcoinConfirmationScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendBitcoinConfirmationScreenQuery, SendBitcoinConfirmationScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendBitcoinConfirmationScreenQuery, SendBitcoinConfirmationScreenQueryVariables>(SendBitcoinConfirmationScreenDocument, options);
        }
export function useSendBitcoinConfirmationScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SendBitcoinConfirmationScreenQuery, SendBitcoinConfirmationScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SendBitcoinConfirmationScreenQuery, SendBitcoinConfirmationScreenQueryVariables>(SendBitcoinConfirmationScreenDocument, options);
        }
export type SendBitcoinConfirmationScreenQueryHookResult = ReturnType<typeof useSendBitcoinConfirmationScreenQuery>;
export type SendBitcoinConfirmationScreenLazyQueryHookResult = ReturnType<typeof useSendBitcoinConfirmationScreenLazyQuery>;
export type SendBitcoinConfirmationScreenSuspenseQueryHookResult = ReturnType<typeof useSendBitcoinConfirmationScreenSuspenseQuery>;
export type SendBitcoinConfirmationScreenQueryResult = Apollo.QueryResult<SendBitcoinConfirmationScreenQuery, SendBitcoinConfirmationScreenQueryVariables>;
export const SendBitcoinDestinationDocument = gql`
    query sendBitcoinDestination {
  globals {
    network
  }
  me {
    id
    defaultAccount {
      id
      wallets {
        id
      }
    }
    contacts {
      id
      username
      alias
      transactionsCount
    }
  }
}
    `;

/**
 * __useSendBitcoinDestinationQuery__
 *
 * To run a query within a React component, call `useSendBitcoinDestinationQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinDestinationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinDestinationQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinDestinationQuery(baseOptions?: Apollo.QueryHookOptions<SendBitcoinDestinationQuery, SendBitcoinDestinationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendBitcoinDestinationQuery, SendBitcoinDestinationQueryVariables>(SendBitcoinDestinationDocument, options);
      }
export function useSendBitcoinDestinationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendBitcoinDestinationQuery, SendBitcoinDestinationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendBitcoinDestinationQuery, SendBitcoinDestinationQueryVariables>(SendBitcoinDestinationDocument, options);
        }
export function useSendBitcoinDestinationSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SendBitcoinDestinationQuery, SendBitcoinDestinationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SendBitcoinDestinationQuery, SendBitcoinDestinationQueryVariables>(SendBitcoinDestinationDocument, options);
        }
export type SendBitcoinDestinationQueryHookResult = ReturnType<typeof useSendBitcoinDestinationQuery>;
export type SendBitcoinDestinationLazyQueryHookResult = ReturnType<typeof useSendBitcoinDestinationLazyQuery>;
export type SendBitcoinDestinationSuspenseQueryHookResult = ReturnType<typeof useSendBitcoinDestinationSuspenseQuery>;
export type SendBitcoinDestinationQueryResult = Apollo.QueryResult<SendBitcoinDestinationQuery, SendBitcoinDestinationQueryVariables>;
export const AccountDefaultWalletDocument = gql`
    query accountDefaultWallet($walletCurrency: WalletCurrency, $username: Username!) {
  accountDefaultWallet(walletCurrency: $walletCurrency, username: $username) {
    id
  }
}
    `;

/**
 * __useAccountDefaultWalletQuery__
 *
 * To run a query within a React component, call `useAccountDefaultWalletQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountDefaultWalletQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountDefaultWalletQuery({
 *   variables: {
 *      walletCurrency: // value for 'walletCurrency'
 *      username: // value for 'username'
 *   },
 * });
 */
export function useAccountDefaultWalletQuery(baseOptions: Apollo.QueryHookOptions<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables> & ({ variables: AccountDefaultWalletQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>(AccountDefaultWalletDocument, options);
      }
export function useAccountDefaultWalletLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>(AccountDefaultWalletDocument, options);
        }
export function useAccountDefaultWalletSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>(AccountDefaultWalletDocument, options);
        }
export type AccountDefaultWalletQueryHookResult = ReturnType<typeof useAccountDefaultWalletQuery>;
export type AccountDefaultWalletLazyQueryHookResult = ReturnType<typeof useAccountDefaultWalletLazyQuery>;
export type AccountDefaultWalletSuspenseQueryHookResult = ReturnType<typeof useAccountDefaultWalletSuspenseQuery>;
export type AccountDefaultWalletQueryResult = Apollo.QueryResult<AccountDefaultWalletQuery, AccountDefaultWalletQueryVariables>;
export const SendBitcoinDetailsScreenDocument = gql`
    query sendBitcoinDetailsScreen {
  globals {
    network
  }
  me {
    id
    defaultAccount {
      id
      defaultWalletId
      wallets {
        id
        walletCurrency
        balance
      }
    }
  }
}
    `;

/**
 * __useSendBitcoinDetailsScreenQuery__
 *
 * To run a query within a React component, call `useSendBitcoinDetailsScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinDetailsScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinDetailsScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinDetailsScreenQuery(baseOptions?: Apollo.QueryHookOptions<SendBitcoinDetailsScreenQuery, SendBitcoinDetailsScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendBitcoinDetailsScreenQuery, SendBitcoinDetailsScreenQueryVariables>(SendBitcoinDetailsScreenDocument, options);
      }
export function useSendBitcoinDetailsScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendBitcoinDetailsScreenQuery, SendBitcoinDetailsScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendBitcoinDetailsScreenQuery, SendBitcoinDetailsScreenQueryVariables>(SendBitcoinDetailsScreenDocument, options);
        }
export function useSendBitcoinDetailsScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SendBitcoinDetailsScreenQuery, SendBitcoinDetailsScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SendBitcoinDetailsScreenQuery, SendBitcoinDetailsScreenQueryVariables>(SendBitcoinDetailsScreenDocument, options);
        }
export type SendBitcoinDetailsScreenQueryHookResult = ReturnType<typeof useSendBitcoinDetailsScreenQuery>;
export type SendBitcoinDetailsScreenLazyQueryHookResult = ReturnType<typeof useSendBitcoinDetailsScreenLazyQuery>;
export type SendBitcoinDetailsScreenSuspenseQueryHookResult = ReturnType<typeof useSendBitcoinDetailsScreenSuspenseQuery>;
export type SendBitcoinDetailsScreenQueryResult = Apollo.QueryResult<SendBitcoinDetailsScreenQuery, SendBitcoinDetailsScreenQueryVariables>;
export const SendBitcoinWithdrawalLimitsDocument = gql`
    query sendBitcoinWithdrawalLimits {
  me {
    id
    defaultAccount {
      id
      limits {
        withdrawal {
          totalLimit
          remainingLimit
          interval
        }
      }
    }
  }
}
    `;

/**
 * __useSendBitcoinWithdrawalLimitsQuery__
 *
 * To run a query within a React component, call `useSendBitcoinWithdrawalLimitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinWithdrawalLimitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinWithdrawalLimitsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinWithdrawalLimitsQuery(baseOptions?: Apollo.QueryHookOptions<SendBitcoinWithdrawalLimitsQuery, SendBitcoinWithdrawalLimitsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendBitcoinWithdrawalLimitsQuery, SendBitcoinWithdrawalLimitsQueryVariables>(SendBitcoinWithdrawalLimitsDocument, options);
      }
export function useSendBitcoinWithdrawalLimitsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendBitcoinWithdrawalLimitsQuery, SendBitcoinWithdrawalLimitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendBitcoinWithdrawalLimitsQuery, SendBitcoinWithdrawalLimitsQueryVariables>(SendBitcoinWithdrawalLimitsDocument, options);
        }
export function useSendBitcoinWithdrawalLimitsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SendBitcoinWithdrawalLimitsQuery, SendBitcoinWithdrawalLimitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SendBitcoinWithdrawalLimitsQuery, SendBitcoinWithdrawalLimitsQueryVariables>(SendBitcoinWithdrawalLimitsDocument, options);
        }
export type SendBitcoinWithdrawalLimitsQueryHookResult = ReturnType<typeof useSendBitcoinWithdrawalLimitsQuery>;
export type SendBitcoinWithdrawalLimitsLazyQueryHookResult = ReturnType<typeof useSendBitcoinWithdrawalLimitsLazyQuery>;
export type SendBitcoinWithdrawalLimitsSuspenseQueryHookResult = ReturnType<typeof useSendBitcoinWithdrawalLimitsSuspenseQuery>;
export type SendBitcoinWithdrawalLimitsQueryResult = Apollo.QueryResult<SendBitcoinWithdrawalLimitsQuery, SendBitcoinWithdrawalLimitsQueryVariables>;
export const SendBitcoinInternalLimitsDocument = gql`
    query sendBitcoinInternalLimits {
  me {
    id
    defaultAccount {
      id
      limits {
        internalSend {
          totalLimit
          remainingLimit
          interval
        }
      }
    }
  }
}
    `;

/**
 * __useSendBitcoinInternalLimitsQuery__
 *
 * To run a query within a React component, call `useSendBitcoinInternalLimitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendBitcoinInternalLimitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendBitcoinInternalLimitsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSendBitcoinInternalLimitsQuery(baseOptions?: Apollo.QueryHookOptions<SendBitcoinInternalLimitsQuery, SendBitcoinInternalLimitsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendBitcoinInternalLimitsQuery, SendBitcoinInternalLimitsQueryVariables>(SendBitcoinInternalLimitsDocument, options);
      }
export function useSendBitcoinInternalLimitsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendBitcoinInternalLimitsQuery, SendBitcoinInternalLimitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendBitcoinInternalLimitsQuery, SendBitcoinInternalLimitsQueryVariables>(SendBitcoinInternalLimitsDocument, options);
        }
export function useSendBitcoinInternalLimitsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SendBitcoinInternalLimitsQuery, SendBitcoinInternalLimitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SendBitcoinInternalLimitsQuery, SendBitcoinInternalLimitsQueryVariables>(SendBitcoinInternalLimitsDocument, options);
        }
export type SendBitcoinInternalLimitsQueryHookResult = ReturnType<typeof useSendBitcoinInternalLimitsQuery>;
export type SendBitcoinInternalLimitsLazyQueryHookResult = ReturnType<typeof useSendBitcoinInternalLimitsLazyQuery>;
export type SendBitcoinInternalLimitsSuspenseQueryHookResult = ReturnType<typeof useSendBitcoinInternalLimitsSuspenseQuery>;
export type SendBitcoinInternalLimitsQueryResult = Apollo.QueryResult<SendBitcoinInternalLimitsQuery, SendBitcoinInternalLimitsQueryVariables>;
export const FeedbackSubmitDocument = gql`
    mutation feedbackSubmit($input: FeedbackSubmitInput!) {
  feedbackSubmit(input: $input) {
    errors {
      message
      __typename
    }
    success
    __typename
  }
}
    `;
export type FeedbackSubmitMutationFn = Apollo.MutationFunction<FeedbackSubmitMutation, FeedbackSubmitMutationVariables>;

/**
 * __useFeedbackSubmitMutation__
 *
 * To run a mutation, you first call `useFeedbackSubmitMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useFeedbackSubmitMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [feedbackSubmitMutation, { data, loading, error }] = useFeedbackSubmitMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useFeedbackSubmitMutation(baseOptions?: Apollo.MutationHookOptions<FeedbackSubmitMutation, FeedbackSubmitMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<FeedbackSubmitMutation, FeedbackSubmitMutationVariables>(FeedbackSubmitDocument, options);
      }
export type FeedbackSubmitMutationHookResult = ReturnType<typeof useFeedbackSubmitMutation>;
export type FeedbackSubmitMutationResult = Apollo.MutationResult<FeedbackSubmitMutation>;
export type FeedbackSubmitMutationOptions = Apollo.BaseMutationOptions<FeedbackSubmitMutation, FeedbackSubmitMutationVariables>;
export const LnNoAmountInvoiceFeeProbeDocument = gql`
    mutation lnNoAmountInvoiceFeeProbe($input: LnNoAmountInvoiceFeeProbeInput!) {
  lnNoAmountInvoiceFeeProbe(input: $input) {
    errors {
      message
    }
    amount
  }
}
    `;
export type LnNoAmountInvoiceFeeProbeMutationFn = Apollo.MutationFunction<LnNoAmountInvoiceFeeProbeMutation, LnNoAmountInvoiceFeeProbeMutationVariables>;

/**
 * __useLnNoAmountInvoiceFeeProbeMutation__
 *
 * To run a mutation, you first call `useLnNoAmountInvoiceFeeProbeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountInvoiceFeeProbeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountInvoiceFeeProbeMutation, { data, loading, error }] = useLnNoAmountInvoiceFeeProbeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountInvoiceFeeProbeMutation(baseOptions?: Apollo.MutationHookOptions<LnNoAmountInvoiceFeeProbeMutation, LnNoAmountInvoiceFeeProbeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnNoAmountInvoiceFeeProbeMutation, LnNoAmountInvoiceFeeProbeMutationVariables>(LnNoAmountInvoiceFeeProbeDocument, options);
      }
export type LnNoAmountInvoiceFeeProbeMutationHookResult = ReturnType<typeof useLnNoAmountInvoiceFeeProbeMutation>;
export type LnNoAmountInvoiceFeeProbeMutationResult = Apollo.MutationResult<LnNoAmountInvoiceFeeProbeMutation>;
export type LnNoAmountInvoiceFeeProbeMutationOptions = Apollo.BaseMutationOptions<LnNoAmountInvoiceFeeProbeMutation, LnNoAmountInvoiceFeeProbeMutationVariables>;
export const LnInvoiceFeeProbeDocument = gql`
    mutation lnInvoiceFeeProbe($input: LnInvoiceFeeProbeInput!) {
  lnInvoiceFeeProbe(input: $input) {
    errors {
      message
    }
    amount
  }
}
    `;
export type LnInvoiceFeeProbeMutationFn = Apollo.MutationFunction<LnInvoiceFeeProbeMutation, LnInvoiceFeeProbeMutationVariables>;

/**
 * __useLnInvoiceFeeProbeMutation__
 *
 * To run a mutation, you first call `useLnInvoiceFeeProbeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoiceFeeProbeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoiceFeeProbeMutation, { data, loading, error }] = useLnInvoiceFeeProbeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoiceFeeProbeMutation(baseOptions?: Apollo.MutationHookOptions<LnInvoiceFeeProbeMutation, LnInvoiceFeeProbeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnInvoiceFeeProbeMutation, LnInvoiceFeeProbeMutationVariables>(LnInvoiceFeeProbeDocument, options);
      }
export type LnInvoiceFeeProbeMutationHookResult = ReturnType<typeof useLnInvoiceFeeProbeMutation>;
export type LnInvoiceFeeProbeMutationResult = Apollo.MutationResult<LnInvoiceFeeProbeMutation>;
export type LnInvoiceFeeProbeMutationOptions = Apollo.BaseMutationOptions<LnInvoiceFeeProbeMutation, LnInvoiceFeeProbeMutationVariables>;
export const LnUsdInvoiceFeeProbeDocument = gql`
    mutation lnUsdInvoiceFeeProbe($input: LnUsdInvoiceFeeProbeInput!) {
  lnUsdInvoiceFeeProbe(input: $input) {
    errors {
      message
    }
    amount
  }
}
    `;
export type LnUsdInvoiceFeeProbeMutationFn = Apollo.MutationFunction<LnUsdInvoiceFeeProbeMutation, LnUsdInvoiceFeeProbeMutationVariables>;

/**
 * __useLnUsdInvoiceFeeProbeMutation__
 *
 * To run a mutation, you first call `useLnUsdInvoiceFeeProbeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnUsdInvoiceFeeProbeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnUsdInvoiceFeeProbeMutation, { data, loading, error }] = useLnUsdInvoiceFeeProbeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnUsdInvoiceFeeProbeMutation(baseOptions?: Apollo.MutationHookOptions<LnUsdInvoiceFeeProbeMutation, LnUsdInvoiceFeeProbeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnUsdInvoiceFeeProbeMutation, LnUsdInvoiceFeeProbeMutationVariables>(LnUsdInvoiceFeeProbeDocument, options);
      }
export type LnUsdInvoiceFeeProbeMutationHookResult = ReturnType<typeof useLnUsdInvoiceFeeProbeMutation>;
export type LnUsdInvoiceFeeProbeMutationResult = Apollo.MutationResult<LnUsdInvoiceFeeProbeMutation>;
export type LnUsdInvoiceFeeProbeMutationOptions = Apollo.BaseMutationOptions<LnUsdInvoiceFeeProbeMutation, LnUsdInvoiceFeeProbeMutationVariables>;
export const LnNoAmountUsdInvoiceFeeProbeDocument = gql`
    mutation lnNoAmountUsdInvoiceFeeProbe($input: LnNoAmountUsdInvoiceFeeProbeInput!) {
  lnNoAmountUsdInvoiceFeeProbe(input: $input) {
    errors {
      message
    }
    amount
  }
}
    `;
export type LnNoAmountUsdInvoiceFeeProbeMutationFn = Apollo.MutationFunction<LnNoAmountUsdInvoiceFeeProbeMutation, LnNoAmountUsdInvoiceFeeProbeMutationVariables>;

/**
 * __useLnNoAmountUsdInvoiceFeeProbeMutation__
 *
 * To run a mutation, you first call `useLnNoAmountUsdInvoiceFeeProbeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountUsdInvoiceFeeProbeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountUsdInvoiceFeeProbeMutation, { data, loading, error }] = useLnNoAmountUsdInvoiceFeeProbeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountUsdInvoiceFeeProbeMutation(baseOptions?: Apollo.MutationHookOptions<LnNoAmountUsdInvoiceFeeProbeMutation, LnNoAmountUsdInvoiceFeeProbeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnNoAmountUsdInvoiceFeeProbeMutation, LnNoAmountUsdInvoiceFeeProbeMutationVariables>(LnNoAmountUsdInvoiceFeeProbeDocument, options);
      }
export type LnNoAmountUsdInvoiceFeeProbeMutationHookResult = ReturnType<typeof useLnNoAmountUsdInvoiceFeeProbeMutation>;
export type LnNoAmountUsdInvoiceFeeProbeMutationResult = Apollo.MutationResult<LnNoAmountUsdInvoiceFeeProbeMutation>;
export type LnNoAmountUsdInvoiceFeeProbeMutationOptions = Apollo.BaseMutationOptions<LnNoAmountUsdInvoiceFeeProbeMutation, LnNoAmountUsdInvoiceFeeProbeMutationVariables>;
export const OnChainTxFeeDocument = gql`
    query onChainTxFee($walletId: WalletId!, $address: OnChainAddress!, $amount: SatAmount!) {
  onChainTxFee(walletId: $walletId, address: $address, amount: $amount) {
    amount
  }
}
    `;

/**
 * __useOnChainTxFeeQuery__
 *
 * To run a query within a React component, call `useOnChainTxFeeQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnChainTxFeeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnChainTxFeeQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      address: // value for 'address'
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useOnChainTxFeeQuery(baseOptions: Apollo.QueryHookOptions<OnChainTxFeeQuery, OnChainTxFeeQueryVariables> & ({ variables: OnChainTxFeeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>(OnChainTxFeeDocument, options);
      }
export function useOnChainTxFeeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>(OnChainTxFeeDocument, options);
        }
export function useOnChainTxFeeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>(OnChainTxFeeDocument, options);
        }
export type OnChainTxFeeQueryHookResult = ReturnType<typeof useOnChainTxFeeQuery>;
export type OnChainTxFeeLazyQueryHookResult = ReturnType<typeof useOnChainTxFeeLazyQuery>;
export type OnChainTxFeeSuspenseQueryHookResult = ReturnType<typeof useOnChainTxFeeSuspenseQuery>;
export type OnChainTxFeeQueryResult = Apollo.QueryResult<OnChainTxFeeQuery, OnChainTxFeeQueryVariables>;
export const OnChainUsdTxFeeDocument = gql`
    query onChainUsdTxFee($walletId: WalletId!, $address: OnChainAddress!, $amount: CentAmount!) {
  onChainUsdTxFee(walletId: $walletId, address: $address, amount: $amount) {
    amount
  }
}
    `;

/**
 * __useOnChainUsdTxFeeQuery__
 *
 * To run a query within a React component, call `useOnChainUsdTxFeeQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnChainUsdTxFeeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnChainUsdTxFeeQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      address: // value for 'address'
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useOnChainUsdTxFeeQuery(baseOptions: Apollo.QueryHookOptions<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables> & ({ variables: OnChainUsdTxFeeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables>(OnChainUsdTxFeeDocument, options);
      }
export function useOnChainUsdTxFeeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables>(OnChainUsdTxFeeDocument, options);
        }
export function useOnChainUsdTxFeeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables>(OnChainUsdTxFeeDocument, options);
        }
export type OnChainUsdTxFeeQueryHookResult = ReturnType<typeof useOnChainUsdTxFeeQuery>;
export type OnChainUsdTxFeeLazyQueryHookResult = ReturnType<typeof useOnChainUsdTxFeeLazyQuery>;
export type OnChainUsdTxFeeSuspenseQueryHookResult = ReturnType<typeof useOnChainUsdTxFeeSuspenseQuery>;
export type OnChainUsdTxFeeQueryResult = Apollo.QueryResult<OnChainUsdTxFeeQuery, OnChainUsdTxFeeQueryVariables>;
export const OnChainUsdTxFeeAsBtcDenominatedDocument = gql`
    query onChainUsdTxFeeAsBtcDenominated($walletId: WalletId!, $address: OnChainAddress!, $amount: SatAmount!) {
  onChainUsdTxFeeAsBtcDenominated(
    walletId: $walletId
    address: $address
    amount: $amount
  ) {
    amount
  }
}
    `;

/**
 * __useOnChainUsdTxFeeAsBtcDenominatedQuery__
 *
 * To run a query within a React component, call `useOnChainUsdTxFeeAsBtcDenominatedQuery` and pass it any options that fit your needs.
 * When your component renders, `useOnChainUsdTxFeeAsBtcDenominatedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOnChainUsdTxFeeAsBtcDenominatedQuery({
 *   variables: {
 *      walletId: // value for 'walletId'
 *      address: // value for 'address'
 *      amount: // value for 'amount'
 *   },
 * });
 */
export function useOnChainUsdTxFeeAsBtcDenominatedQuery(baseOptions: Apollo.QueryHookOptions<OnChainUsdTxFeeAsBtcDenominatedQuery, OnChainUsdTxFeeAsBtcDenominatedQueryVariables> & ({ variables: OnChainUsdTxFeeAsBtcDenominatedQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OnChainUsdTxFeeAsBtcDenominatedQuery, OnChainUsdTxFeeAsBtcDenominatedQueryVariables>(OnChainUsdTxFeeAsBtcDenominatedDocument, options);
      }
export function useOnChainUsdTxFeeAsBtcDenominatedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OnChainUsdTxFeeAsBtcDenominatedQuery, OnChainUsdTxFeeAsBtcDenominatedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OnChainUsdTxFeeAsBtcDenominatedQuery, OnChainUsdTxFeeAsBtcDenominatedQueryVariables>(OnChainUsdTxFeeAsBtcDenominatedDocument, options);
        }
export function useOnChainUsdTxFeeAsBtcDenominatedSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<OnChainUsdTxFeeAsBtcDenominatedQuery, OnChainUsdTxFeeAsBtcDenominatedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OnChainUsdTxFeeAsBtcDenominatedQuery, OnChainUsdTxFeeAsBtcDenominatedQueryVariables>(OnChainUsdTxFeeAsBtcDenominatedDocument, options);
        }
export type OnChainUsdTxFeeAsBtcDenominatedQueryHookResult = ReturnType<typeof useOnChainUsdTxFeeAsBtcDenominatedQuery>;
export type OnChainUsdTxFeeAsBtcDenominatedLazyQueryHookResult = ReturnType<typeof useOnChainUsdTxFeeAsBtcDenominatedLazyQuery>;
export type OnChainUsdTxFeeAsBtcDenominatedSuspenseQueryHookResult = ReturnType<typeof useOnChainUsdTxFeeAsBtcDenominatedSuspenseQuery>;
export type OnChainUsdTxFeeAsBtcDenominatedQueryResult = Apollo.QueryResult<OnChainUsdTxFeeAsBtcDenominatedQuery, OnChainUsdTxFeeAsBtcDenominatedQueryVariables>;
export const IntraLedgerPaymentSendDocument = gql`
    mutation intraLedgerPaymentSend($input: IntraLedgerPaymentSendInput!) {
  intraLedgerPaymentSend(input: $input) {
    errors {
      message
    }
    status
  }
}
    `;
export type IntraLedgerPaymentSendMutationFn = Apollo.MutationFunction<IntraLedgerPaymentSendMutation, IntraLedgerPaymentSendMutationVariables>;

/**
 * __useIntraLedgerPaymentSendMutation__
 *
 * To run a mutation, you first call `useIntraLedgerPaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useIntraLedgerPaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [intraLedgerPaymentSendMutation, { data, loading, error }] = useIntraLedgerPaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useIntraLedgerPaymentSendMutation(baseOptions?: Apollo.MutationHookOptions<IntraLedgerPaymentSendMutation, IntraLedgerPaymentSendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<IntraLedgerPaymentSendMutation, IntraLedgerPaymentSendMutationVariables>(IntraLedgerPaymentSendDocument, options);
      }
export type IntraLedgerPaymentSendMutationHookResult = ReturnType<typeof useIntraLedgerPaymentSendMutation>;
export type IntraLedgerPaymentSendMutationResult = Apollo.MutationResult<IntraLedgerPaymentSendMutation>;
export type IntraLedgerPaymentSendMutationOptions = Apollo.BaseMutationOptions<IntraLedgerPaymentSendMutation, IntraLedgerPaymentSendMutationVariables>;
export const IntraLedgerUsdPaymentSendDocument = gql`
    mutation intraLedgerUsdPaymentSend($input: IntraLedgerUsdPaymentSendInput!) {
  intraLedgerUsdPaymentSend(input: $input) {
    errors {
      message
    }
    status
  }
}
    `;
export type IntraLedgerUsdPaymentSendMutationFn = Apollo.MutationFunction<IntraLedgerUsdPaymentSendMutation, IntraLedgerUsdPaymentSendMutationVariables>;

/**
 * __useIntraLedgerUsdPaymentSendMutation__
 *
 * To run a mutation, you first call `useIntraLedgerUsdPaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useIntraLedgerUsdPaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [intraLedgerUsdPaymentSendMutation, { data, loading, error }] = useIntraLedgerUsdPaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useIntraLedgerUsdPaymentSendMutation(baseOptions?: Apollo.MutationHookOptions<IntraLedgerUsdPaymentSendMutation, IntraLedgerUsdPaymentSendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<IntraLedgerUsdPaymentSendMutation, IntraLedgerUsdPaymentSendMutationVariables>(IntraLedgerUsdPaymentSendDocument, options);
      }
export type IntraLedgerUsdPaymentSendMutationHookResult = ReturnType<typeof useIntraLedgerUsdPaymentSendMutation>;
export type IntraLedgerUsdPaymentSendMutationResult = Apollo.MutationResult<IntraLedgerUsdPaymentSendMutation>;
export type IntraLedgerUsdPaymentSendMutationOptions = Apollo.BaseMutationOptions<IntraLedgerUsdPaymentSendMutation, IntraLedgerUsdPaymentSendMutationVariables>;
export const LnNoAmountInvoicePaymentSendDocument = gql`
    mutation lnNoAmountInvoicePaymentSend($input: LnNoAmountInvoicePaymentInput!) {
  lnNoAmountInvoicePaymentSend(input: $input) {
    errors {
      message
    }
    status
  }
}
    `;
export type LnNoAmountInvoicePaymentSendMutationFn = Apollo.MutationFunction<LnNoAmountInvoicePaymentSendMutation, LnNoAmountInvoicePaymentSendMutationVariables>;

/**
 * __useLnNoAmountInvoicePaymentSendMutation__
 *
 * To run a mutation, you first call `useLnNoAmountInvoicePaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountInvoicePaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountInvoicePaymentSendMutation, { data, loading, error }] = useLnNoAmountInvoicePaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountInvoicePaymentSendMutation(baseOptions?: Apollo.MutationHookOptions<LnNoAmountInvoicePaymentSendMutation, LnNoAmountInvoicePaymentSendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnNoAmountInvoicePaymentSendMutation, LnNoAmountInvoicePaymentSendMutationVariables>(LnNoAmountInvoicePaymentSendDocument, options);
      }
export type LnNoAmountInvoicePaymentSendMutationHookResult = ReturnType<typeof useLnNoAmountInvoicePaymentSendMutation>;
export type LnNoAmountInvoicePaymentSendMutationResult = Apollo.MutationResult<LnNoAmountInvoicePaymentSendMutation>;
export type LnNoAmountInvoicePaymentSendMutationOptions = Apollo.BaseMutationOptions<LnNoAmountInvoicePaymentSendMutation, LnNoAmountInvoicePaymentSendMutationVariables>;
export const LnInvoicePaymentSendDocument = gql`
    mutation lnInvoicePaymentSend($input: LnInvoicePaymentInput!) {
  lnInvoicePaymentSend(input: $input) {
    errors {
      message
    }
    status
  }
}
    `;
export type LnInvoicePaymentSendMutationFn = Apollo.MutationFunction<LnInvoicePaymentSendMutation, LnInvoicePaymentSendMutationVariables>;

/**
 * __useLnInvoicePaymentSendMutation__
 *
 * To run a mutation, you first call `useLnInvoicePaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnInvoicePaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnInvoicePaymentSendMutation, { data, loading, error }] = useLnInvoicePaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnInvoicePaymentSendMutation(baseOptions?: Apollo.MutationHookOptions<LnInvoicePaymentSendMutation, LnInvoicePaymentSendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnInvoicePaymentSendMutation, LnInvoicePaymentSendMutationVariables>(LnInvoicePaymentSendDocument, options);
      }
export type LnInvoicePaymentSendMutationHookResult = ReturnType<typeof useLnInvoicePaymentSendMutation>;
export type LnInvoicePaymentSendMutationResult = Apollo.MutationResult<LnInvoicePaymentSendMutation>;
export type LnInvoicePaymentSendMutationOptions = Apollo.BaseMutationOptions<LnInvoicePaymentSendMutation, LnInvoicePaymentSendMutationVariables>;
export const LnNoAmountUsdInvoicePaymentSendDocument = gql`
    mutation lnNoAmountUsdInvoicePaymentSend($input: LnNoAmountUsdInvoicePaymentInput!) {
  lnNoAmountUsdInvoicePaymentSend(input: $input) {
    errors {
      message
    }
    status
  }
}
    `;
export type LnNoAmountUsdInvoicePaymentSendMutationFn = Apollo.MutationFunction<LnNoAmountUsdInvoicePaymentSendMutation, LnNoAmountUsdInvoicePaymentSendMutationVariables>;

/**
 * __useLnNoAmountUsdInvoicePaymentSendMutation__
 *
 * To run a mutation, you first call `useLnNoAmountUsdInvoicePaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLnNoAmountUsdInvoicePaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [lnNoAmountUsdInvoicePaymentSendMutation, { data, loading, error }] = useLnNoAmountUsdInvoicePaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLnNoAmountUsdInvoicePaymentSendMutation(baseOptions?: Apollo.MutationHookOptions<LnNoAmountUsdInvoicePaymentSendMutation, LnNoAmountUsdInvoicePaymentSendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<LnNoAmountUsdInvoicePaymentSendMutation, LnNoAmountUsdInvoicePaymentSendMutationVariables>(LnNoAmountUsdInvoicePaymentSendDocument, options);
      }
export type LnNoAmountUsdInvoicePaymentSendMutationHookResult = ReturnType<typeof useLnNoAmountUsdInvoicePaymentSendMutation>;
export type LnNoAmountUsdInvoicePaymentSendMutationResult = Apollo.MutationResult<LnNoAmountUsdInvoicePaymentSendMutation>;
export type LnNoAmountUsdInvoicePaymentSendMutationOptions = Apollo.BaseMutationOptions<LnNoAmountUsdInvoicePaymentSendMutation, LnNoAmountUsdInvoicePaymentSendMutationVariables>;
export const OnChainPaymentSendDocument = gql`
    mutation onChainPaymentSend($input: OnChainPaymentSendInput!) {
  onChainPaymentSend(input: $input) {
    transaction {
      settlementVia {
        ... on SettlementViaOnChain {
          arrivalInMempoolEstimatedAt
        }
      }
    }
    errors {
      message
    }
    status
  }
}
    `;
export type OnChainPaymentSendMutationFn = Apollo.MutationFunction<OnChainPaymentSendMutation, OnChainPaymentSendMutationVariables>;

/**
 * __useOnChainPaymentSendMutation__
 *
 * To run a mutation, you first call `useOnChainPaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainPaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainPaymentSendMutation, { data, loading, error }] = useOnChainPaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainPaymentSendMutation(baseOptions?: Apollo.MutationHookOptions<OnChainPaymentSendMutation, OnChainPaymentSendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OnChainPaymentSendMutation, OnChainPaymentSendMutationVariables>(OnChainPaymentSendDocument, options);
      }
export type OnChainPaymentSendMutationHookResult = ReturnType<typeof useOnChainPaymentSendMutation>;
export type OnChainPaymentSendMutationResult = Apollo.MutationResult<OnChainPaymentSendMutation>;
export type OnChainPaymentSendMutationOptions = Apollo.BaseMutationOptions<OnChainPaymentSendMutation, OnChainPaymentSendMutationVariables>;
export const OnChainPaymentSendAllDocument = gql`
    mutation onChainPaymentSendAll($input: OnChainPaymentSendAllInput!) {
  onChainPaymentSendAll(input: $input) {
    errors {
      message
    }
    status
  }
}
    `;
export type OnChainPaymentSendAllMutationFn = Apollo.MutationFunction<OnChainPaymentSendAllMutation, OnChainPaymentSendAllMutationVariables>;

/**
 * __useOnChainPaymentSendAllMutation__
 *
 * To run a mutation, you first call `useOnChainPaymentSendAllMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainPaymentSendAllMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainPaymentSendAllMutation, { data, loading, error }] = useOnChainPaymentSendAllMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainPaymentSendAllMutation(baseOptions?: Apollo.MutationHookOptions<OnChainPaymentSendAllMutation, OnChainPaymentSendAllMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OnChainPaymentSendAllMutation, OnChainPaymentSendAllMutationVariables>(OnChainPaymentSendAllDocument, options);
      }
export type OnChainPaymentSendAllMutationHookResult = ReturnType<typeof useOnChainPaymentSendAllMutation>;
export type OnChainPaymentSendAllMutationResult = Apollo.MutationResult<OnChainPaymentSendAllMutation>;
export type OnChainPaymentSendAllMutationOptions = Apollo.BaseMutationOptions<OnChainPaymentSendAllMutation, OnChainPaymentSendAllMutationVariables>;
export const OnChainUsdPaymentSendDocument = gql`
    mutation onChainUsdPaymentSend($input: OnChainUsdPaymentSendInput!) {
  onChainUsdPaymentSend(input: $input) {
    errors {
      message
    }
    status
  }
}
    `;
export type OnChainUsdPaymentSendMutationFn = Apollo.MutationFunction<OnChainUsdPaymentSendMutation, OnChainUsdPaymentSendMutationVariables>;

/**
 * __useOnChainUsdPaymentSendMutation__
 *
 * To run a mutation, you first call `useOnChainUsdPaymentSendMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainUsdPaymentSendMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainUsdPaymentSendMutation, { data, loading, error }] = useOnChainUsdPaymentSendMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainUsdPaymentSendMutation(baseOptions?: Apollo.MutationHookOptions<OnChainUsdPaymentSendMutation, OnChainUsdPaymentSendMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OnChainUsdPaymentSendMutation, OnChainUsdPaymentSendMutationVariables>(OnChainUsdPaymentSendDocument, options);
      }
export type OnChainUsdPaymentSendMutationHookResult = ReturnType<typeof useOnChainUsdPaymentSendMutation>;
export type OnChainUsdPaymentSendMutationResult = Apollo.MutationResult<OnChainUsdPaymentSendMutation>;
export type OnChainUsdPaymentSendMutationOptions = Apollo.BaseMutationOptions<OnChainUsdPaymentSendMutation, OnChainUsdPaymentSendMutationVariables>;
export const OnChainUsdPaymentSendAsBtcDenominatedDocument = gql`
    mutation onChainUsdPaymentSendAsBtcDenominated($input: OnChainUsdPaymentSendAsBtcDenominatedInput!) {
  onChainUsdPaymentSendAsBtcDenominated(input: $input) {
    errors {
      message
    }
    status
  }
}
    `;
export type OnChainUsdPaymentSendAsBtcDenominatedMutationFn = Apollo.MutationFunction<OnChainUsdPaymentSendAsBtcDenominatedMutation, OnChainUsdPaymentSendAsBtcDenominatedMutationVariables>;

/**
 * __useOnChainUsdPaymentSendAsBtcDenominatedMutation__
 *
 * To run a mutation, you first call `useOnChainUsdPaymentSendAsBtcDenominatedMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useOnChainUsdPaymentSendAsBtcDenominatedMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [onChainUsdPaymentSendAsBtcDenominatedMutation, { data, loading, error }] = useOnChainUsdPaymentSendAsBtcDenominatedMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useOnChainUsdPaymentSendAsBtcDenominatedMutation(baseOptions?: Apollo.MutationHookOptions<OnChainUsdPaymentSendAsBtcDenominatedMutation, OnChainUsdPaymentSendAsBtcDenominatedMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<OnChainUsdPaymentSendAsBtcDenominatedMutation, OnChainUsdPaymentSendAsBtcDenominatedMutationVariables>(OnChainUsdPaymentSendAsBtcDenominatedDocument, options);
      }
export type OnChainUsdPaymentSendAsBtcDenominatedMutationHookResult = ReturnType<typeof useOnChainUsdPaymentSendAsBtcDenominatedMutation>;
export type OnChainUsdPaymentSendAsBtcDenominatedMutationResult = Apollo.MutationResult<OnChainUsdPaymentSendAsBtcDenominatedMutation>;
export type OnChainUsdPaymentSendAsBtcDenominatedMutationOptions = Apollo.BaseMutationOptions<OnChainUsdPaymentSendAsBtcDenominatedMutation, OnChainUsdPaymentSendAsBtcDenominatedMutationVariables>;
export const AccountDeleteDocument = gql`
    mutation accountDelete {
  accountDelete {
    errors {
      message
    }
    success
  }
}
    `;
export type AccountDeleteMutationFn = Apollo.MutationFunction<AccountDeleteMutation, AccountDeleteMutationVariables>;

/**
 * __useAccountDeleteMutation__
 *
 * To run a mutation, you first call `useAccountDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountDeleteMutation, { data, loading, error }] = useAccountDeleteMutation({
 *   variables: {
 *   },
 * });
 */
export function useAccountDeleteMutation(baseOptions?: Apollo.MutationHookOptions<AccountDeleteMutation, AccountDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountDeleteMutation, AccountDeleteMutationVariables>(AccountDeleteDocument, options);
      }
export type AccountDeleteMutationHookResult = ReturnType<typeof useAccountDeleteMutation>;
export type AccountDeleteMutationResult = Apollo.MutationResult<AccountDeleteMutation>;
export type AccountDeleteMutationOptions = Apollo.BaseMutationOptions<AccountDeleteMutation, AccountDeleteMutationVariables>;
export const UserEmailDeleteDocument = gql`
    mutation userEmailDelete {
  userEmailDelete {
    errors {
      message
    }
    me {
      id
      phone
      totpEnabled
      email {
        address
        verified
      }
    }
  }
}
    `;
export type UserEmailDeleteMutationFn = Apollo.MutationFunction<UserEmailDeleteMutation, UserEmailDeleteMutationVariables>;

/**
 * __useUserEmailDeleteMutation__
 *
 * To run a mutation, you first call `useUserEmailDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserEmailDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userEmailDeleteMutation, { data, loading, error }] = useUserEmailDeleteMutation({
 *   variables: {
 *   },
 * });
 */
export function useUserEmailDeleteMutation(baseOptions?: Apollo.MutationHookOptions<UserEmailDeleteMutation, UserEmailDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserEmailDeleteMutation, UserEmailDeleteMutationVariables>(UserEmailDeleteDocument, options);
      }
export type UserEmailDeleteMutationHookResult = ReturnType<typeof useUserEmailDeleteMutation>;
export type UserEmailDeleteMutationResult = Apollo.MutationResult<UserEmailDeleteMutation>;
export type UserEmailDeleteMutationOptions = Apollo.BaseMutationOptions<UserEmailDeleteMutation, UserEmailDeleteMutationVariables>;
export const UserPhoneDeleteDocument = gql`
    mutation userPhoneDelete {
  userPhoneDelete {
    errors {
      message
    }
    me {
      id
      phone
      totpEnabled
      email {
        address
        verified
      }
    }
  }
}
    `;
export type UserPhoneDeleteMutationFn = Apollo.MutationFunction<UserPhoneDeleteMutation, UserPhoneDeleteMutationVariables>;

/**
 * __useUserPhoneDeleteMutation__
 *
 * To run a mutation, you first call `useUserPhoneDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserPhoneDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userPhoneDeleteMutation, { data, loading, error }] = useUserPhoneDeleteMutation({
 *   variables: {
 *   },
 * });
 */
export function useUserPhoneDeleteMutation(baseOptions?: Apollo.MutationHookOptions<UserPhoneDeleteMutation, UserPhoneDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserPhoneDeleteMutation, UserPhoneDeleteMutationVariables>(UserPhoneDeleteDocument, options);
      }
export type UserPhoneDeleteMutationHookResult = ReturnType<typeof useUserPhoneDeleteMutation>;
export type UserPhoneDeleteMutationResult = Apollo.MutationResult<UserPhoneDeleteMutation>;
export type UserPhoneDeleteMutationOptions = Apollo.BaseMutationOptions<UserPhoneDeleteMutation, UserPhoneDeleteMutationVariables>;
export const WarningSecureAccountDocument = gql`
    query warningSecureAccount {
  me {
    id
    defaultAccount {
      level
      id
      wallets {
        id
        balance
        walletCurrency
      }
    }
  }
}
    `;

/**
 * __useWarningSecureAccountQuery__
 *
 * To run a query within a React component, call `useWarningSecureAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useWarningSecureAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWarningSecureAccountQuery({
 *   variables: {
 *   },
 * });
 */
export function useWarningSecureAccountQuery(baseOptions?: Apollo.QueryHookOptions<WarningSecureAccountQuery, WarningSecureAccountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<WarningSecureAccountQuery, WarningSecureAccountQueryVariables>(WarningSecureAccountDocument, options);
      }
export function useWarningSecureAccountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<WarningSecureAccountQuery, WarningSecureAccountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<WarningSecureAccountQuery, WarningSecureAccountQueryVariables>(WarningSecureAccountDocument, options);
        }
export function useWarningSecureAccountSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<WarningSecureAccountQuery, WarningSecureAccountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<WarningSecureAccountQuery, WarningSecureAccountQueryVariables>(WarningSecureAccountDocument, options);
        }
export type WarningSecureAccountQueryHookResult = ReturnType<typeof useWarningSecureAccountQuery>;
export type WarningSecureAccountLazyQueryHookResult = ReturnType<typeof useWarningSecureAccountLazyQuery>;
export type WarningSecureAccountSuspenseQueryHookResult = ReturnType<typeof useWarningSecureAccountSuspenseQuery>;
export type WarningSecureAccountQueryResult = Apollo.QueryResult<WarningSecureAccountQuery, WarningSecureAccountQueryVariables>;
export const AccountUpdateDefaultWalletIdDocument = gql`
    mutation accountUpdateDefaultWalletId($input: AccountUpdateDefaultWalletIdInput!) {
  accountUpdateDefaultWalletId(input: $input) {
    errors {
      message
    }
    account {
      id
      defaultWalletId
    }
  }
}
    `;
export type AccountUpdateDefaultWalletIdMutationFn = Apollo.MutationFunction<AccountUpdateDefaultWalletIdMutation, AccountUpdateDefaultWalletIdMutationVariables>;

/**
 * __useAccountUpdateDefaultWalletIdMutation__
 *
 * To run a mutation, you first call `useAccountUpdateDefaultWalletIdMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountUpdateDefaultWalletIdMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountUpdateDefaultWalletIdMutation, { data, loading, error }] = useAccountUpdateDefaultWalletIdMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountUpdateDefaultWalletIdMutation(baseOptions?: Apollo.MutationHookOptions<AccountUpdateDefaultWalletIdMutation, AccountUpdateDefaultWalletIdMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountUpdateDefaultWalletIdMutation, AccountUpdateDefaultWalletIdMutationVariables>(AccountUpdateDefaultWalletIdDocument, options);
      }
export type AccountUpdateDefaultWalletIdMutationHookResult = ReturnType<typeof useAccountUpdateDefaultWalletIdMutation>;
export type AccountUpdateDefaultWalletIdMutationResult = Apollo.MutationResult<AccountUpdateDefaultWalletIdMutation>;
export type AccountUpdateDefaultWalletIdMutationOptions = Apollo.BaseMutationOptions<AccountUpdateDefaultWalletIdMutation, AccountUpdateDefaultWalletIdMutationVariables>;
export const SetDefaultWalletScreenDocument = gql`
    query setDefaultWalletScreen {
  me {
    id
    defaultAccount {
      id
      defaultWalletId
      wallets {
        id
        balance
        walletCurrency
      }
    }
  }
}
    `;

/**
 * __useSetDefaultWalletScreenQuery__
 *
 * To run a query within a React component, call `useSetDefaultWalletScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSetDefaultWalletScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSetDefaultWalletScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useSetDefaultWalletScreenQuery(baseOptions?: Apollo.QueryHookOptions<SetDefaultWalletScreenQuery, SetDefaultWalletScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SetDefaultWalletScreenQuery, SetDefaultWalletScreenQueryVariables>(SetDefaultWalletScreenDocument, options);
      }
export function useSetDefaultWalletScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SetDefaultWalletScreenQuery, SetDefaultWalletScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SetDefaultWalletScreenQuery, SetDefaultWalletScreenQueryVariables>(SetDefaultWalletScreenDocument, options);
        }
export function useSetDefaultWalletScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SetDefaultWalletScreenQuery, SetDefaultWalletScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SetDefaultWalletScreenQuery, SetDefaultWalletScreenQueryVariables>(SetDefaultWalletScreenDocument, options);
        }
export type SetDefaultWalletScreenQueryHookResult = ReturnType<typeof useSetDefaultWalletScreenQuery>;
export type SetDefaultWalletScreenLazyQueryHookResult = ReturnType<typeof useSetDefaultWalletScreenLazyQuery>;
export type SetDefaultWalletScreenSuspenseQueryHookResult = ReturnType<typeof useSetDefaultWalletScreenSuspenseQuery>;
export type SetDefaultWalletScreenQueryResult = Apollo.QueryResult<SetDefaultWalletScreenQuery, SetDefaultWalletScreenQueryVariables>;
export const AccountUpdateDisplayCurrencyDocument = gql`
    mutation accountUpdateDisplayCurrency($input: AccountUpdateDisplayCurrencyInput!) {
  accountUpdateDisplayCurrency(input: $input) {
    errors {
      message
    }
    account {
      id
      displayCurrency
    }
  }
}
    `;
export type AccountUpdateDisplayCurrencyMutationFn = Apollo.MutationFunction<AccountUpdateDisplayCurrencyMutation, AccountUpdateDisplayCurrencyMutationVariables>;

/**
 * __useAccountUpdateDisplayCurrencyMutation__
 *
 * To run a mutation, you first call `useAccountUpdateDisplayCurrencyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountUpdateDisplayCurrencyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountUpdateDisplayCurrencyMutation, { data, loading, error }] = useAccountUpdateDisplayCurrencyMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountUpdateDisplayCurrencyMutation(baseOptions?: Apollo.MutationHookOptions<AccountUpdateDisplayCurrencyMutation, AccountUpdateDisplayCurrencyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountUpdateDisplayCurrencyMutation, AccountUpdateDisplayCurrencyMutationVariables>(AccountUpdateDisplayCurrencyDocument, options);
      }
export type AccountUpdateDisplayCurrencyMutationHookResult = ReturnType<typeof useAccountUpdateDisplayCurrencyMutation>;
export type AccountUpdateDisplayCurrencyMutationResult = Apollo.MutationResult<AccountUpdateDisplayCurrencyMutation>;
export type AccountUpdateDisplayCurrencyMutationOptions = Apollo.BaseMutationOptions<AccountUpdateDisplayCurrencyMutation, AccountUpdateDisplayCurrencyMutationVariables>;
export const LanguageDocument = gql`
    query language {
  me {
    id
    language
  }
}
    `;

/**
 * __useLanguageQuery__
 *
 * To run a query within a React component, call `useLanguageQuery` and pass it any options that fit your needs.
 * When your component renders, `useLanguageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLanguageQuery({
 *   variables: {
 *   },
 * });
 */
export function useLanguageQuery(baseOptions?: Apollo.QueryHookOptions<LanguageQuery, LanguageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LanguageQuery, LanguageQueryVariables>(LanguageDocument, options);
      }
export function useLanguageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LanguageQuery, LanguageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LanguageQuery, LanguageQueryVariables>(LanguageDocument, options);
        }
export function useLanguageSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LanguageQuery, LanguageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LanguageQuery, LanguageQueryVariables>(LanguageDocument, options);
        }
export type LanguageQueryHookResult = ReturnType<typeof useLanguageQuery>;
export type LanguageLazyQueryHookResult = ReturnType<typeof useLanguageLazyQuery>;
export type LanguageSuspenseQueryHookResult = ReturnType<typeof useLanguageSuspenseQuery>;
export type LanguageQueryResult = Apollo.QueryResult<LanguageQuery, LanguageQueryVariables>;
export const UserUpdateLanguageDocument = gql`
    mutation userUpdateLanguage($input: UserUpdateLanguageInput!) {
  userUpdateLanguage(input: $input) {
    errors {
      message
    }
    user {
      id
      language
    }
  }
}
    `;
export type UserUpdateLanguageMutationFn = Apollo.MutationFunction<UserUpdateLanguageMutation, UserUpdateLanguageMutationVariables>;

/**
 * __useUserUpdateLanguageMutation__
 *
 * To run a mutation, you first call `useUserUpdateLanguageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserUpdateLanguageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userUpdateLanguageMutation, { data, loading, error }] = useUserUpdateLanguageMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserUpdateLanguageMutation(baseOptions?: Apollo.MutationHookOptions<UserUpdateLanguageMutation, UserUpdateLanguageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserUpdateLanguageMutation, UserUpdateLanguageMutationVariables>(UserUpdateLanguageDocument, options);
      }
export type UserUpdateLanguageMutationHookResult = ReturnType<typeof useUserUpdateLanguageMutation>;
export type UserUpdateLanguageMutationResult = Apollo.MutationResult<UserUpdateLanguageMutation>;
export type UserUpdateLanguageMutationOptions = Apollo.BaseMutationOptions<UserUpdateLanguageMutation, UserUpdateLanguageMutationVariables>;
export const NotificationSettingsDocument = gql`
    query notificationSettings {
  me {
    id
    defaultAccount {
      id
      notificationSettings {
        push {
          enabled
          disabledCategories
        }
      }
    }
  }
}
    `;

/**
 * __useNotificationSettingsQuery__
 *
 * To run a query within a React component, call `useNotificationSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationSettingsQuery({
 *   variables: {
 *   },
 * });
 */
export function useNotificationSettingsQuery(baseOptions?: Apollo.QueryHookOptions<NotificationSettingsQuery, NotificationSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationSettingsQuery, NotificationSettingsQueryVariables>(NotificationSettingsDocument, options);
      }
export function useNotificationSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationSettingsQuery, NotificationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationSettingsQuery, NotificationSettingsQueryVariables>(NotificationSettingsDocument, options);
        }
export function useNotificationSettingsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<NotificationSettingsQuery, NotificationSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<NotificationSettingsQuery, NotificationSettingsQueryVariables>(NotificationSettingsDocument, options);
        }
export type NotificationSettingsQueryHookResult = ReturnType<typeof useNotificationSettingsQuery>;
export type NotificationSettingsLazyQueryHookResult = ReturnType<typeof useNotificationSettingsLazyQuery>;
export type NotificationSettingsSuspenseQueryHookResult = ReturnType<typeof useNotificationSettingsSuspenseQuery>;
export type NotificationSettingsQueryResult = Apollo.QueryResult<NotificationSettingsQuery, NotificationSettingsQueryVariables>;
export const AccountEnableNotificationChannelDocument = gql`
    mutation accountEnableNotificationChannel($input: AccountEnableNotificationChannelInput!) {
  accountEnableNotificationChannel(input: $input) {
    errors {
      message
    }
    account {
      id
      notificationSettings {
        push {
          enabled
          disabledCategories
        }
      }
    }
  }
}
    `;
export type AccountEnableNotificationChannelMutationFn = Apollo.MutationFunction<AccountEnableNotificationChannelMutation, AccountEnableNotificationChannelMutationVariables>;

/**
 * __useAccountEnableNotificationChannelMutation__
 *
 * To run a mutation, you first call `useAccountEnableNotificationChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountEnableNotificationChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountEnableNotificationChannelMutation, { data, loading, error }] = useAccountEnableNotificationChannelMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountEnableNotificationChannelMutation(baseOptions?: Apollo.MutationHookOptions<AccountEnableNotificationChannelMutation, AccountEnableNotificationChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountEnableNotificationChannelMutation, AccountEnableNotificationChannelMutationVariables>(AccountEnableNotificationChannelDocument, options);
      }
export type AccountEnableNotificationChannelMutationHookResult = ReturnType<typeof useAccountEnableNotificationChannelMutation>;
export type AccountEnableNotificationChannelMutationResult = Apollo.MutationResult<AccountEnableNotificationChannelMutation>;
export type AccountEnableNotificationChannelMutationOptions = Apollo.BaseMutationOptions<AccountEnableNotificationChannelMutation, AccountEnableNotificationChannelMutationVariables>;
export const AccountDisableNotificationChannelDocument = gql`
    mutation accountDisableNotificationChannel($input: AccountDisableNotificationChannelInput!) {
  accountDisableNotificationChannel(input: $input) {
    errors {
      message
    }
    account {
      id
      notificationSettings {
        push {
          enabled
          disabledCategories
        }
      }
    }
  }
}
    `;
export type AccountDisableNotificationChannelMutationFn = Apollo.MutationFunction<AccountDisableNotificationChannelMutation, AccountDisableNotificationChannelMutationVariables>;

/**
 * __useAccountDisableNotificationChannelMutation__
 *
 * To run a mutation, you first call `useAccountDisableNotificationChannelMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountDisableNotificationChannelMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountDisableNotificationChannelMutation, { data, loading, error }] = useAccountDisableNotificationChannelMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountDisableNotificationChannelMutation(baseOptions?: Apollo.MutationHookOptions<AccountDisableNotificationChannelMutation, AccountDisableNotificationChannelMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountDisableNotificationChannelMutation, AccountDisableNotificationChannelMutationVariables>(AccountDisableNotificationChannelDocument, options);
      }
export type AccountDisableNotificationChannelMutationHookResult = ReturnType<typeof useAccountDisableNotificationChannelMutation>;
export type AccountDisableNotificationChannelMutationResult = Apollo.MutationResult<AccountDisableNotificationChannelMutation>;
export type AccountDisableNotificationChannelMutationOptions = Apollo.BaseMutationOptions<AccountDisableNotificationChannelMutation, AccountDisableNotificationChannelMutationVariables>;
export const AccountEnableNotificationCategoryDocument = gql`
    mutation accountEnableNotificationCategory($input: AccountEnableNotificationCategoryInput!) {
  accountEnableNotificationCategory(input: $input) {
    errors {
      message
    }
    account {
      id
      notificationSettings {
        push {
          enabled
          disabledCategories
        }
      }
    }
  }
}
    `;
export type AccountEnableNotificationCategoryMutationFn = Apollo.MutationFunction<AccountEnableNotificationCategoryMutation, AccountEnableNotificationCategoryMutationVariables>;

/**
 * __useAccountEnableNotificationCategoryMutation__
 *
 * To run a mutation, you first call `useAccountEnableNotificationCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountEnableNotificationCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountEnableNotificationCategoryMutation, { data, loading, error }] = useAccountEnableNotificationCategoryMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountEnableNotificationCategoryMutation(baseOptions?: Apollo.MutationHookOptions<AccountEnableNotificationCategoryMutation, AccountEnableNotificationCategoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountEnableNotificationCategoryMutation, AccountEnableNotificationCategoryMutationVariables>(AccountEnableNotificationCategoryDocument, options);
      }
export type AccountEnableNotificationCategoryMutationHookResult = ReturnType<typeof useAccountEnableNotificationCategoryMutation>;
export type AccountEnableNotificationCategoryMutationResult = Apollo.MutationResult<AccountEnableNotificationCategoryMutation>;
export type AccountEnableNotificationCategoryMutationOptions = Apollo.BaseMutationOptions<AccountEnableNotificationCategoryMutation, AccountEnableNotificationCategoryMutationVariables>;
export const AccountDisableNotificationCategoryDocument = gql`
    mutation accountDisableNotificationCategory($input: AccountDisableNotificationCategoryInput!) {
  accountDisableNotificationCategory(input: $input) {
    errors {
      message
    }
    account {
      id
      notificationSettings {
        push {
          enabled
          disabledCategories
        }
      }
    }
  }
}
    `;
export type AccountDisableNotificationCategoryMutationFn = Apollo.MutationFunction<AccountDisableNotificationCategoryMutation, AccountDisableNotificationCategoryMutationVariables>;

/**
 * __useAccountDisableNotificationCategoryMutation__
 *
 * To run a mutation, you first call `useAccountDisableNotificationCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAccountDisableNotificationCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [accountDisableNotificationCategoryMutation, { data, loading, error }] = useAccountDisableNotificationCategoryMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAccountDisableNotificationCategoryMutation(baseOptions?: Apollo.MutationHookOptions<AccountDisableNotificationCategoryMutation, AccountDisableNotificationCategoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AccountDisableNotificationCategoryMutation, AccountDisableNotificationCategoryMutationVariables>(AccountDisableNotificationCategoryDocument, options);
      }
export type AccountDisableNotificationCategoryMutationHookResult = ReturnType<typeof useAccountDisableNotificationCategoryMutation>;
export type AccountDisableNotificationCategoryMutationResult = Apollo.MutationResult<AccountDisableNotificationCategoryMutation>;
export type AccountDisableNotificationCategoryMutationOptions = Apollo.BaseMutationOptions<AccountDisableNotificationCategoryMutation, AccountDisableNotificationCategoryMutationVariables>;
export const UnacknowledgedNotificationCountDocument = gql`
    query UnacknowledgedNotificationCount {
  me {
    id
    unacknowledgedStatefulNotificationsWithoutBulletinEnabledCount
  }
}
    `;

/**
 * __useUnacknowledgedNotificationCountQuery__
 *
 * To run a query within a React component, call `useUnacknowledgedNotificationCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useUnacknowledgedNotificationCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUnacknowledgedNotificationCountQuery({
 *   variables: {
 *   },
 * });
 */
export function useUnacknowledgedNotificationCountQuery(baseOptions?: Apollo.QueryHookOptions<UnacknowledgedNotificationCountQuery, UnacknowledgedNotificationCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UnacknowledgedNotificationCountQuery, UnacknowledgedNotificationCountQueryVariables>(UnacknowledgedNotificationCountDocument, options);
      }
export function useUnacknowledgedNotificationCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UnacknowledgedNotificationCountQuery, UnacknowledgedNotificationCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UnacknowledgedNotificationCountQuery, UnacknowledgedNotificationCountQueryVariables>(UnacknowledgedNotificationCountDocument, options);
        }
export function useUnacknowledgedNotificationCountSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UnacknowledgedNotificationCountQuery, UnacknowledgedNotificationCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UnacknowledgedNotificationCountQuery, UnacknowledgedNotificationCountQueryVariables>(UnacknowledgedNotificationCountDocument, options);
        }
export type UnacknowledgedNotificationCountQueryHookResult = ReturnType<typeof useUnacknowledgedNotificationCountQuery>;
export type UnacknowledgedNotificationCountLazyQueryHookResult = ReturnType<typeof useUnacknowledgedNotificationCountLazyQuery>;
export type UnacknowledgedNotificationCountSuspenseQueryHookResult = ReturnType<typeof useUnacknowledgedNotificationCountSuspenseQuery>;
export type UnacknowledgedNotificationCountQueryResult = Apollo.QueryResult<UnacknowledgedNotificationCountQuery, UnacknowledgedNotificationCountQueryVariables>;
export const SettingsScreenDocument = gql`
    query SettingsScreen {
  me {
    id
    username
    language
    defaultAccount {
      id
      defaultWalletId
      wallets {
        id
        balance
        walletCurrency
      }
    }
    totpEnabled
    phone
    email {
      address
      verified
    }
  }
}
    `;

/**
 * __useSettingsScreenQuery__
 *
 * To run a query within a React component, call `useSettingsScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSettingsScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSettingsScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useSettingsScreenQuery(baseOptions?: Apollo.QueryHookOptions<SettingsScreenQuery, SettingsScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SettingsScreenQuery, SettingsScreenQueryVariables>(SettingsScreenDocument, options);
      }
export function useSettingsScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SettingsScreenQuery, SettingsScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SettingsScreenQuery, SettingsScreenQueryVariables>(SettingsScreenDocument, options);
        }
export function useSettingsScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SettingsScreenQuery, SettingsScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SettingsScreenQuery, SettingsScreenQueryVariables>(SettingsScreenDocument, options);
        }
export type SettingsScreenQueryHookResult = ReturnType<typeof useSettingsScreenQuery>;
export type SettingsScreenLazyQueryHookResult = ReturnType<typeof useSettingsScreenLazyQuery>;
export type SettingsScreenSuspenseQueryHookResult = ReturnType<typeof useSettingsScreenSuspenseQuery>;
export type SettingsScreenQueryResult = Apollo.QueryResult<SettingsScreenQuery, SettingsScreenQueryVariables>;
export const ExportCsvSettingDocument = gql`
    query ExportCsvSetting($walletIds: [WalletId!]!) {
  me {
    id
    defaultAccount {
      id
      csvTransactions(walletIds: $walletIds)
    }
  }
}
    `;

/**
 * __useExportCsvSettingQuery__
 *
 * To run a query within a React component, call `useExportCsvSettingQuery` and pass it any options that fit your needs.
 * When your component renders, `useExportCsvSettingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useExportCsvSettingQuery({
 *   variables: {
 *      walletIds: // value for 'walletIds'
 *   },
 * });
 */
export function useExportCsvSettingQuery(baseOptions: Apollo.QueryHookOptions<ExportCsvSettingQuery, ExportCsvSettingQueryVariables> & ({ variables: ExportCsvSettingQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ExportCsvSettingQuery, ExportCsvSettingQueryVariables>(ExportCsvSettingDocument, options);
      }
export function useExportCsvSettingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ExportCsvSettingQuery, ExportCsvSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ExportCsvSettingQuery, ExportCsvSettingQueryVariables>(ExportCsvSettingDocument, options);
        }
export function useExportCsvSettingSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ExportCsvSettingQuery, ExportCsvSettingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ExportCsvSettingQuery, ExportCsvSettingQueryVariables>(ExportCsvSettingDocument, options);
        }
export type ExportCsvSettingQueryHookResult = ReturnType<typeof useExportCsvSettingQuery>;
export type ExportCsvSettingLazyQueryHookResult = ReturnType<typeof useExportCsvSettingLazyQuery>;
export type ExportCsvSettingSuspenseQueryHookResult = ReturnType<typeof useExportCsvSettingSuspenseQuery>;
export type ExportCsvSettingQueryResult = Apollo.QueryResult<ExportCsvSettingQuery, ExportCsvSettingQueryVariables>;
export const UserTotpDeleteDocument = gql`
    mutation userTotpDelete {
  userTotpDelete {
    errors {
      message
    }
    me {
      id
      phone
      totpEnabled
      email {
        address
        verified
      }
    }
  }
}
    `;
export type UserTotpDeleteMutationFn = Apollo.MutationFunction<UserTotpDeleteMutation, UserTotpDeleteMutationVariables>;

/**
 * __useUserTotpDeleteMutation__
 *
 * To run a mutation, you first call `useUserTotpDeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserTotpDeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userTotpDeleteMutation, { data, loading, error }] = useUserTotpDeleteMutation({
 *   variables: {
 *   },
 * });
 */
export function useUserTotpDeleteMutation(baseOptions?: Apollo.MutationHookOptions<UserTotpDeleteMutation, UserTotpDeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserTotpDeleteMutation, UserTotpDeleteMutationVariables>(UserTotpDeleteDocument, options);
      }
export type UserTotpDeleteMutationHookResult = ReturnType<typeof useUserTotpDeleteMutation>;
export type UserTotpDeleteMutationResult = Apollo.MutationResult<UserTotpDeleteMutation>;
export type UserTotpDeleteMutationOptions = Apollo.BaseMutationOptions<UserTotpDeleteMutation, UserTotpDeleteMutationVariables>;
export const AccountLimitsDocument = gql`
    query accountLimits {
  me {
    id
    defaultAccount {
      id
      limits {
        withdrawal {
          totalLimit
          remainingLimit
          interval
        }
        internalSend {
          totalLimit
          remainingLimit
          interval
        }
        convert {
          totalLimit
          remainingLimit
          interval
        }
      }
    }
  }
}
    `;

/**
 * __useAccountLimitsQuery__
 *
 * To run a query within a React component, call `useAccountLimitsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAccountLimitsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAccountLimitsQuery({
 *   variables: {
 *   },
 * });
 */
export function useAccountLimitsQuery(baseOptions?: Apollo.QueryHookOptions<AccountLimitsQuery, AccountLimitsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AccountLimitsQuery, AccountLimitsQueryVariables>(AccountLimitsDocument, options);
      }
export function useAccountLimitsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AccountLimitsQuery, AccountLimitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AccountLimitsQuery, AccountLimitsQueryVariables>(AccountLimitsDocument, options);
        }
export function useAccountLimitsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<AccountLimitsQuery, AccountLimitsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<AccountLimitsQuery, AccountLimitsQueryVariables>(AccountLimitsDocument, options);
        }
export type AccountLimitsQueryHookResult = ReturnType<typeof useAccountLimitsQuery>;
export type AccountLimitsLazyQueryHookResult = ReturnType<typeof useAccountLimitsLazyQuery>;
export type AccountLimitsSuspenseQueryHookResult = ReturnType<typeof useAccountLimitsSuspenseQuery>;
export type AccountLimitsQueryResult = Apollo.QueryResult<AccountLimitsQuery, AccountLimitsQueryVariables>;
export const SupportChatDocument = gql`
    query supportChat {
  me {
    id
    supportChat {
      id
      message
      role
      timestamp
    }
  }
}
    `;

/**
 * __useSupportChatQuery__
 *
 * To run a query within a React component, call `useSupportChatQuery` and pass it any options that fit your needs.
 * When your component renders, `useSupportChatQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSupportChatQuery({
 *   variables: {
 *   },
 * });
 */
export function useSupportChatQuery(baseOptions?: Apollo.QueryHookOptions<SupportChatQuery, SupportChatQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SupportChatQuery, SupportChatQueryVariables>(SupportChatDocument, options);
      }
export function useSupportChatLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SupportChatQuery, SupportChatQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SupportChatQuery, SupportChatQueryVariables>(SupportChatDocument, options);
        }
export function useSupportChatSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SupportChatQuery, SupportChatQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SupportChatQuery, SupportChatQueryVariables>(SupportChatDocument, options);
        }
export type SupportChatQueryHookResult = ReturnType<typeof useSupportChatQuery>;
export type SupportChatLazyQueryHookResult = ReturnType<typeof useSupportChatLazyQuery>;
export type SupportChatSuspenseQueryHookResult = ReturnType<typeof useSupportChatSuspenseQuery>;
export type SupportChatQueryResult = Apollo.QueryResult<SupportChatQuery, SupportChatQueryVariables>;
export const SupportChatMessageAddDocument = gql`
    mutation supportChatMessageAdd($input: SupportChatMessageAddInput!) {
  supportChatMessageAdd(input: $input) {
    errors {
      message
    }
    supportMessage {
      id
      message
      role
      timestamp
    }
  }
}
    `;
export type SupportChatMessageAddMutationFn = Apollo.MutationFunction<SupportChatMessageAddMutation, SupportChatMessageAddMutationVariables>;

/**
 * __useSupportChatMessageAddMutation__
 *
 * To run a mutation, you first call `useSupportChatMessageAddMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSupportChatMessageAddMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [supportChatMessageAddMutation, { data, loading, error }] = useSupportChatMessageAddMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSupportChatMessageAddMutation(baseOptions?: Apollo.MutationHookOptions<SupportChatMessageAddMutation, SupportChatMessageAddMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SupportChatMessageAddMutation, SupportChatMessageAddMutationVariables>(SupportChatMessageAddDocument, options);
      }
export type SupportChatMessageAddMutationHookResult = ReturnType<typeof useSupportChatMessageAddMutation>;
export type SupportChatMessageAddMutationResult = Apollo.MutationResult<SupportChatMessageAddMutation>;
export type SupportChatMessageAddMutationOptions = Apollo.BaseMutationOptions<SupportChatMessageAddMutation, SupportChatMessageAddMutationVariables>;
export const SupportChatResetDocument = gql`
    mutation supportChatReset {
  supportChatReset {
    success
  }
}
    `;
export type SupportChatResetMutationFn = Apollo.MutationFunction<SupportChatResetMutation, SupportChatResetMutationVariables>;

/**
 * __useSupportChatResetMutation__
 *
 * To run a mutation, you first call `useSupportChatResetMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSupportChatResetMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [supportChatResetMutation, { data, loading, error }] = useSupportChatResetMutation({
 *   variables: {
 *   },
 * });
 */
export function useSupportChatResetMutation(baseOptions?: Apollo.MutationHookOptions<SupportChatResetMutation, SupportChatResetMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SupportChatResetMutation, SupportChatResetMutationVariables>(SupportChatResetDocument, options);
      }
export type SupportChatResetMutationHookResult = ReturnType<typeof useSupportChatResetMutation>;
export type SupportChatResetMutationResult = Apollo.MutationResult<SupportChatResetMutation>;
export type SupportChatResetMutationOptions = Apollo.BaseMutationOptions<SupportChatResetMutation, SupportChatResetMutationVariables>;
export const TotpRegistrationScreenDocument = gql`
    query totpRegistrationScreen {
  me {
    id
    username
  }
}
    `;

/**
 * __useTotpRegistrationScreenQuery__
 *
 * To run a query within a React component, call `useTotpRegistrationScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useTotpRegistrationScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTotpRegistrationScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useTotpRegistrationScreenQuery(baseOptions?: Apollo.QueryHookOptions<TotpRegistrationScreenQuery, TotpRegistrationScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TotpRegistrationScreenQuery, TotpRegistrationScreenQueryVariables>(TotpRegistrationScreenDocument, options);
      }
export function useTotpRegistrationScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TotpRegistrationScreenQuery, TotpRegistrationScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TotpRegistrationScreenQuery, TotpRegistrationScreenQueryVariables>(TotpRegistrationScreenDocument, options);
        }
export function useTotpRegistrationScreenSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TotpRegistrationScreenQuery, TotpRegistrationScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TotpRegistrationScreenQuery, TotpRegistrationScreenQueryVariables>(TotpRegistrationScreenDocument, options);
        }
export type TotpRegistrationScreenQueryHookResult = ReturnType<typeof useTotpRegistrationScreenQuery>;
export type TotpRegistrationScreenLazyQueryHookResult = ReturnType<typeof useTotpRegistrationScreenLazyQuery>;
export type TotpRegistrationScreenSuspenseQueryHookResult = ReturnType<typeof useTotpRegistrationScreenSuspenseQuery>;
export type TotpRegistrationScreenQueryResult = Apollo.QueryResult<TotpRegistrationScreenQuery, TotpRegistrationScreenQueryVariables>;
export const UserTotpRegistrationInitiateDocument = gql`
    mutation userTotpRegistrationInitiate {
  userTotpRegistrationInitiate {
    errors {
      message
    }
    totpRegistrationId
    totpSecret
  }
}
    `;
export type UserTotpRegistrationInitiateMutationFn = Apollo.MutationFunction<UserTotpRegistrationInitiateMutation, UserTotpRegistrationInitiateMutationVariables>;

/**
 * __useUserTotpRegistrationInitiateMutation__
 *
 * To run a mutation, you first call `useUserTotpRegistrationInitiateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserTotpRegistrationInitiateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userTotpRegistrationInitiateMutation, { data, loading, error }] = useUserTotpRegistrationInitiateMutation({
 *   variables: {
 *   },
 * });
 */
export function useUserTotpRegistrationInitiateMutation(baseOptions?: Apollo.MutationHookOptions<UserTotpRegistrationInitiateMutation, UserTotpRegistrationInitiateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserTotpRegistrationInitiateMutation, UserTotpRegistrationInitiateMutationVariables>(UserTotpRegistrationInitiateDocument, options);
      }
export type UserTotpRegistrationInitiateMutationHookResult = ReturnType<typeof useUserTotpRegistrationInitiateMutation>;
export type UserTotpRegistrationInitiateMutationResult = Apollo.MutationResult<UserTotpRegistrationInitiateMutation>;
export type UserTotpRegistrationInitiateMutationOptions = Apollo.BaseMutationOptions<UserTotpRegistrationInitiateMutation, UserTotpRegistrationInitiateMutationVariables>;
export const UserTotpRegistrationValidateDocument = gql`
    mutation userTotpRegistrationValidate($input: UserTotpRegistrationValidateInput!) {
  userTotpRegistrationValidate(input: $input) {
    errors {
      message
    }
    me {
      id
      totpEnabled
      phone
      email {
        address
        verified
      }
    }
  }
}
    `;
export type UserTotpRegistrationValidateMutationFn = Apollo.MutationFunction<UserTotpRegistrationValidateMutation, UserTotpRegistrationValidateMutationVariables>;

/**
 * __useUserTotpRegistrationValidateMutation__
 *
 * To run a mutation, you first call `useUserTotpRegistrationValidateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUserTotpRegistrationValidateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [userTotpRegistrationValidateMutation, { data, loading, error }] = useUserTotpRegistrationValidateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUserTotpRegistrationValidateMutation(baseOptions?: Apollo.MutationHookOptions<UserTotpRegistrationValidateMutation, UserTotpRegistrationValidateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UserTotpRegistrationValidateMutation, UserTotpRegistrationValidateMutationVariables>(UserTotpRegistrationValidateDocument, options);
      }
export type UserTotpRegistrationValidateMutationHookResult = ReturnType<typeof useUserTotpRegistrationValidateMutation>;
export type UserTotpRegistrationValidateMutationResult = Apollo.MutationResult<UserTotpRegistrationValidateMutation>;
export type UserTotpRegistrationValidateMutationOptions = Apollo.BaseMutationOptions<UserTotpRegistrationValidateMutation, UserTotpRegistrationValidateMutationVariables>;
export const TransactionListForDefaultAccountDocument = gql`
    query transactionListForDefaultAccount($first: Int, $after: String, $last: Int, $before: String) {
  me {
    id
    defaultAccount {
      id
      pendingIncomingTransactions {
        ...Transaction
      }
      transactions(first: $first, after: $after, last: $last, before: $before) {
        ...TransactionList
      }
    }
  }
}
    ${TransactionFragmentDoc}
${TransactionListFragmentDoc}`;

/**
 * __useTransactionListForDefaultAccountQuery__
 *
 * To run a query within a React component, call `useTransactionListForDefaultAccountQuery` and pass it any options that fit your needs.
 * When your component renders, `useTransactionListForDefaultAccountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTransactionListForDefaultAccountQuery({
 *   variables: {
 *      first: // value for 'first'
 *      after: // value for 'after'
 *      last: // value for 'last'
 *      before: // value for 'before'
 *   },
 * });
 */
export function useTransactionListForDefaultAccountQuery(baseOptions?: Apollo.QueryHookOptions<TransactionListForDefaultAccountQuery, TransactionListForDefaultAccountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TransactionListForDefaultAccountQuery, TransactionListForDefaultAccountQueryVariables>(TransactionListForDefaultAccountDocument, options);
      }
export function useTransactionListForDefaultAccountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TransactionListForDefaultAccountQuery, TransactionListForDefaultAccountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TransactionListForDefaultAccountQuery, TransactionListForDefaultAccountQueryVariables>(TransactionListForDefaultAccountDocument, options);
        }
export function useTransactionListForDefaultAccountSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<TransactionListForDefaultAccountQuery, TransactionListForDefaultAccountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<TransactionListForDefaultAccountQuery, TransactionListForDefaultAccountQueryVariables>(TransactionListForDefaultAccountDocument, options);
        }
export type TransactionListForDefaultAccountQueryHookResult = ReturnType<typeof useTransactionListForDefaultAccountQuery>;
export type TransactionListForDefaultAccountLazyQueryHookResult = ReturnType<typeof useTransactionListForDefaultAccountLazyQuery>;
export type TransactionListForDefaultAccountSuspenseQueryHookResult = ReturnType<typeof useTransactionListForDefaultAccountSuspenseQuery>;
export type TransactionListForDefaultAccountQueryResult = Apollo.QueryResult<TransactionListForDefaultAccountQuery, TransactionListForDefaultAccountQueryVariables>;
export const DeviceNotificationTokenCreateDocument = gql`
    mutation deviceNotificationTokenCreate($input: DeviceNotificationTokenCreateInput!) {
  deviceNotificationTokenCreate(input: $input) {
    errors {
      message
    }
    success
  }
}
    `;
export type DeviceNotificationTokenCreateMutationFn = Apollo.MutationFunction<DeviceNotificationTokenCreateMutation, DeviceNotificationTokenCreateMutationVariables>;

/**
 * __useDeviceNotificationTokenCreateMutation__
 *
 * To run a mutation, you first call `useDeviceNotificationTokenCreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeviceNotificationTokenCreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deviceNotificationTokenCreateMutation, { data, loading, error }] = useDeviceNotificationTokenCreateMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useDeviceNotificationTokenCreateMutation(baseOptions?: Apollo.MutationHookOptions<DeviceNotificationTokenCreateMutation, DeviceNotificationTokenCreateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeviceNotificationTokenCreateMutation, DeviceNotificationTokenCreateMutationVariables>(DeviceNotificationTokenCreateDocument, options);
      }
export type DeviceNotificationTokenCreateMutationHookResult = ReturnType<typeof useDeviceNotificationTokenCreateMutation>;
export type DeviceNotificationTokenCreateMutationResult = Apollo.MutationResult<DeviceNotificationTokenCreateMutation>;
export type DeviceNotificationTokenCreateMutationOptions = Apollo.BaseMutationOptions<DeviceNotificationTokenCreateMutation, DeviceNotificationTokenCreateMutationVariables>;
export const WalletsDocument = gql`
    query wallets {
  me {
    id
    defaultAccount {
      id
      wallets {
        walletCurrency
        id
      }
    }
  }
}
    `;

/**
 * __useWalletsQuery__
 *
 * To run a query within a React component, call `useWalletsQuery` and pass it any options that fit your needs.
 * When your component renders, `useWalletsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useWalletsQuery({
 *   variables: {
 *   },
 * });
 */
export function useWalletsQuery(baseOptions?: Apollo.QueryHookOptions<WalletsQuery, WalletsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<WalletsQuery, WalletsQueryVariables>(WalletsDocument, options);
      }
export function useWalletsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<WalletsQuery, WalletsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<WalletsQuery, WalletsQueryVariables>(WalletsDocument, options);
        }
export function useWalletsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<WalletsQuery, WalletsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<WalletsQuery, WalletsQueryVariables>(WalletsDocument, options);
        }
export type WalletsQueryHookResult = ReturnType<typeof useWalletsQuery>;
export type WalletsLazyQueryHookResult = ReturnType<typeof useWalletsLazyQuery>;
export type WalletsSuspenseQueryHookResult = ReturnType<typeof useWalletsSuspenseQuery>;
export type WalletsQueryResult = Apollo.QueryResult<WalletsQuery, WalletsQueryVariables>;


export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping of union types */
export type ResolversUnionTypes<RefType extends Record<string, unknown>> = {
  InitiationVia: ( InitiationViaIntraLedger ) | ( InitiationViaLn ) | ( InitiationViaOnChain );
  NotificationAction: ( OpenDeepLinkAction ) | ( OpenExternalLinkAction );
  SettlementVia: ( SettlementViaIntraLedger ) | ( SettlementViaLn ) | ( SettlementViaOnChain );
  UserUpdate: ( IntraLedgerUpdate ) | ( LnUpdate ) | ( OnChainUpdate ) | ( Price ) | ( RealtimePrice );
};

/** Mapping of interface types */
export type ResolversInterfaceTypes<RefType extends Record<string, unknown>> = {
  Account: ( ConsumerAccount );
  AccountLimit: ( OneDayAccountLimit );
  Error: ( GraphQlApplicationError );
  Invoice: ( LnInvoice ) | ( LnNoAmountInvoice );
  PriceInterface: ( PriceOfOneSatInMinorUnit ) | ( PriceOfOneSettlementMinorUnitInDisplayMinorUnit ) | ( PriceOfOneUsdCentInMinorUnit );
  Wallet: ( BtcWallet ) | ( UsdWallet );
};

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  Account: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Account']>;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  AccountDeletePayload: ResolverTypeWrapper<AccountDeletePayload>;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  AccountDisableNotificationCategoryInput: AccountDisableNotificationCategoryInput;
  AccountDisableNotificationChannelInput: AccountDisableNotificationChannelInput;
  AccountEnableNotificationCategoryInput: AccountEnableNotificationCategoryInput;
  AccountEnableNotificationChannelInput: AccountEnableNotificationChannelInput;
  AccountLevel: AccountLevel;
  AccountLimit: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['AccountLimit']>;
  AccountLimits: ResolverTypeWrapper<AccountLimits>;
  AccountUpdateDefaultWalletIdInput: AccountUpdateDefaultWalletIdInput;
  AccountUpdateDefaultWalletIdPayload: ResolverTypeWrapper<AccountUpdateDefaultWalletIdPayload>;
  AccountUpdateDisplayCurrencyInput: AccountUpdateDisplayCurrencyInput;
  AccountUpdateDisplayCurrencyPayload: ResolverTypeWrapper<AccountUpdateDisplayCurrencyPayload>;
  AccountUpdateNotificationSettingsPayload: ResolverTypeWrapper<AccountUpdateNotificationSettingsPayload>;
  ApiKey: ResolverTypeWrapper<ApiKey>;
  ApiKeyCreateInput: ApiKeyCreateInput;
  ApiKeyCreatePayload: ResolverTypeWrapper<ApiKeyCreatePayload>;
  ApiKeyRevokeInput: ApiKeyRevokeInput;
  ApiKeyRevokePayload: ResolverTypeWrapper<ApiKeyRevokePayload>;
  AuthToken: ResolverTypeWrapper<Scalars['AuthToken']['output']>;
  AuthTokenPayload: ResolverTypeWrapper<AuthTokenPayload>;
  Authorization: ResolverTypeWrapper<Authorization>;
  BTCWallet: ResolverTypeWrapper<BtcWallet>;
  BuildInformation: ResolverTypeWrapper<BuildInformation>;
  CallbackEndpoint: ResolverTypeWrapper<CallbackEndpoint>;
  CallbackEndpointAddInput: CallbackEndpointAddInput;
  CallbackEndpointAddPayload: ResolverTypeWrapper<CallbackEndpointAddPayload>;
  CallbackEndpointDeleteInput: CallbackEndpointDeleteInput;
  CaptchaCreateChallengePayload: ResolverTypeWrapper<CaptchaCreateChallengePayload>;
  CaptchaCreateChallengeResult: ResolverTypeWrapper<CaptchaCreateChallengeResult>;
  CaptchaRequestAuthCodeInput: CaptchaRequestAuthCodeInput;
  CentAmount: ResolverTypeWrapper<Scalars['CentAmount']['output']>;
  CentAmountPayload: ResolverTypeWrapper<CentAmountPayload>;
  ConsumerAccount: ResolverTypeWrapper<ConsumerAccount>;
  Contact: ResolverTypeWrapper<Contact>;
  ContactAlias: ResolverTypeWrapper<Scalars['ContactAlias']['output']>;
  Coordinates: ResolverTypeWrapper<Coordinates>;
  Float: ResolverTypeWrapper<Scalars['Float']['output']>;
  Country: ResolverTypeWrapper<Country>;
  CountryCode: ResolverTypeWrapper<Scalars['CountryCode']['output']>;
  Currency: ResolverTypeWrapper<Currency>;
  CurrencyConversionEstimation: ResolverTypeWrapper<CurrencyConversionEstimation>;
  DepositFeesInformation: ResolverTypeWrapper<DepositFeesInformation>;
  DeviceNotificationTokenCreateInput: DeviceNotificationTokenCreateInput;
  DisplayCurrency: ResolverTypeWrapper<Scalars['DisplayCurrency']['output']>;
  Email: ResolverTypeWrapper<Email>;
  EmailAddress: ResolverTypeWrapper<Scalars['EmailAddress']['output']>;
  EmailRegistrationId: ResolverTypeWrapper<Scalars['EmailRegistrationId']['output']>;
  EndpointId: ResolverTypeWrapper<Scalars['EndpointId']['output']>;
  EndpointUrl: ResolverTypeWrapper<Scalars['EndpointUrl']['output']>;
  Error: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Error']>;
  ExchangeCurrencyUnit: ExchangeCurrencyUnit;
  Feedback: ResolverTypeWrapper<Scalars['Feedback']['output']>;
  FeedbackSubmitInput: FeedbackSubmitInput;
  FeesInformation: ResolverTypeWrapper<FeesInformation>;
  Globals: ResolverTypeWrapper<Globals>;
  GraphQLApplicationError: ResolverTypeWrapper<GraphQlApplicationError>;
  Hex32Bytes: ResolverTypeWrapper<Scalars['Hex32Bytes']['output']>;
  Icon: Icon;
  InitiationVia: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['InitiationVia']>;
  InitiationViaIntraLedger: ResolverTypeWrapper<InitiationViaIntraLedger>;
  InitiationViaLn: ResolverTypeWrapper<InitiationViaLn>;
  InitiationViaOnChain: ResolverTypeWrapper<InitiationViaOnChain>;
  IntraLedgerPaymentSendInput: IntraLedgerPaymentSendInput;
  IntraLedgerUpdate: ResolverTypeWrapper<IntraLedgerUpdate>;
  IntraLedgerUsdPaymentSendInput: IntraLedgerUsdPaymentSendInput;
  Invoice: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Invoice']>;
  InvoiceConnection: ResolverTypeWrapper<InvoiceConnection>;
  InvoiceEdge: ResolverTypeWrapper<InvoiceEdge>;
  InvoicePaymentStatus: InvoicePaymentStatus;
  Language: ResolverTypeWrapper<Scalars['Language']['output']>;
  Leader: ResolverTypeWrapper<Leader>;
  Leaderboard: ResolverTypeWrapper<Leaderboard>;
  LeaderboardName: ResolverTypeWrapper<Scalars['LeaderboardName']['output']>;
  LnAddressPaymentSendInput: LnAddressPaymentSendInput;
  LnInvoice: ResolverTypeWrapper<LnInvoice>;
  LnInvoiceCancelInput: LnInvoiceCancelInput;
  LnInvoiceCreateInput: LnInvoiceCreateInput;
  LnInvoiceCreateOnBehalfOfRecipientInput: LnInvoiceCreateOnBehalfOfRecipientInput;
  LnInvoiceFeeProbeInput: LnInvoiceFeeProbeInput;
  LnInvoicePayload: ResolverTypeWrapper<LnInvoicePayload>;
  LnInvoicePaymentInput: LnInvoicePaymentInput;
  LnInvoicePaymentStatus: ResolverTypeWrapper<LnInvoicePaymentStatus>;
  LnInvoicePaymentStatusByHashInput: LnInvoicePaymentStatusByHashInput;
  LnInvoicePaymentStatusByPaymentRequestInput: LnInvoicePaymentStatusByPaymentRequestInput;
  LnInvoicePaymentStatusInput: LnInvoicePaymentStatusInput;
  LnInvoicePaymentStatusPayload: ResolverTypeWrapper<LnInvoicePaymentStatusPayload>;
  LnNoAmountInvoice: ResolverTypeWrapper<LnNoAmountInvoice>;
  LnNoAmountInvoiceCreateInput: LnNoAmountInvoiceCreateInput;
  LnNoAmountInvoiceCreateOnBehalfOfRecipientInput: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput;
  LnNoAmountInvoiceFeeProbeInput: LnNoAmountInvoiceFeeProbeInput;
  LnNoAmountInvoicePayload: ResolverTypeWrapper<LnNoAmountInvoicePayload>;
  LnNoAmountInvoicePaymentInput: LnNoAmountInvoicePaymentInput;
  LnNoAmountUsdInvoiceFeeProbeInput: LnNoAmountUsdInvoiceFeeProbeInput;
  LnNoAmountUsdInvoicePaymentInput: LnNoAmountUsdInvoicePaymentInput;
  LnPaymentPreImage: ResolverTypeWrapper<Scalars['LnPaymentPreImage']['output']>;
  LnPaymentRequest: ResolverTypeWrapper<Scalars['LnPaymentRequest']['output']>;
  LnPaymentSecret: ResolverTypeWrapper<Scalars['LnPaymentSecret']['output']>;
  LnUpdate: ResolverTypeWrapper<LnUpdate>;
  LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput: LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput;
  LnUsdInvoiceCreateInput: LnUsdInvoiceCreateInput;
  LnUsdInvoiceCreateOnBehalfOfRecipientInput: LnUsdInvoiceCreateOnBehalfOfRecipientInput;
  LnUsdInvoiceFeeProbeInput: LnUsdInvoiceFeeProbeInput;
  LnurlPaymentSendInput: LnurlPaymentSendInput;
  MapInfo: ResolverTypeWrapper<MapInfo>;
  MapMarker: ResolverTypeWrapper<MapMarker>;
  Memo: ResolverTypeWrapper<Scalars['Memo']['output']>;
  Merchant: ResolverTypeWrapper<Merchant>;
  MerchantMapSuggestInput: MerchantMapSuggestInput;
  MerchantPayload: ResolverTypeWrapper<MerchantPayload>;
  Minutes: ResolverTypeWrapper<Scalars['Minutes']['output']>;
  MobileVersions: ResolverTypeWrapper<MobileVersions>;
  Mutation: ResolverTypeWrapper<{}>;
  MyUpdatesPayload: ResolverTypeWrapper<Omit<MyUpdatesPayload, 'update'> & { update?: Maybe<ResolversTypes['UserUpdate']> }>;
  Network: Network;
  NotificationAction: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['NotificationAction']>;
  NotificationCategory: ResolverTypeWrapper<Scalars['NotificationCategory']['output']>;
  NotificationChannel: NotificationChannel;
  NotificationChannelSettings: ResolverTypeWrapper<NotificationChannelSettings>;
  NotificationSettings: ResolverTypeWrapper<NotificationSettings>;
  OnChainAddress: ResolverTypeWrapper<Scalars['OnChainAddress']['output']>;
  OnChainAddressCreateInput: OnChainAddressCreateInput;
  OnChainAddressCurrentInput: OnChainAddressCurrentInput;
  OnChainAddressPayload: ResolverTypeWrapper<OnChainAddressPayload>;
  OnChainPaymentSendAllInput: OnChainPaymentSendAllInput;
  OnChainPaymentSendInput: OnChainPaymentSendInput;
  OnChainTxFee: ResolverTypeWrapper<OnChainTxFee>;
  OnChainTxHash: ResolverTypeWrapper<Scalars['OnChainTxHash']['output']>;
  OnChainUpdate: ResolverTypeWrapper<OnChainUpdate>;
  OnChainUsdPaymentSendAsBtcDenominatedInput: OnChainUsdPaymentSendAsBtcDenominatedInput;
  OnChainUsdPaymentSendInput: OnChainUsdPaymentSendInput;
  OnChainUsdTxFee: ResolverTypeWrapper<OnChainUsdTxFee>;
  OnboardingFlowStartInput: OnboardingFlowStartInput;
  OnboardingFlowStartResult: ResolverTypeWrapper<OnboardingFlowStartResult>;
  OnboardingStatus: OnboardingStatus;
  OneDayAccountLimit: ResolverTypeWrapper<OneDayAccountLimit>;
  OneTimeAuthCode: ResolverTypeWrapper<Scalars['OneTimeAuthCode']['output']>;
  OpenDeepLinkAction: ResolverTypeWrapper<OpenDeepLinkAction>;
  OpenExternalLinkAction: ResolverTypeWrapper<OpenExternalLinkAction>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PaymentHash: ResolverTypeWrapper<Scalars['PaymentHash']['output']>;
  PaymentSendPayload: ResolverTypeWrapper<PaymentSendPayload>;
  PaymentSendResult: PaymentSendResult;
  PayoutSpeed: PayoutSpeed;
  Phone: ResolverTypeWrapper<Scalars['Phone']['output']>;
  PhoneCodeChannelType: PhoneCodeChannelType;
  Price: ResolverTypeWrapper<Price>;
  PriceGraphRange: PriceGraphRange;
  PriceInput: PriceInput;
  PriceInterface: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['PriceInterface']>;
  PriceOfOneSatInMinorUnit: ResolverTypeWrapper<PriceOfOneSatInMinorUnit>;
  PriceOfOneSettlementMinorUnitInDisplayMinorUnit: ResolverTypeWrapper<PriceOfOneSettlementMinorUnitInDisplayMinorUnit>;
  PriceOfOneUsdCentInMinorUnit: ResolverTypeWrapper<PriceOfOneUsdCentInMinorUnit>;
  PricePayload: ResolverTypeWrapper<PricePayload>;
  PricePoint: ResolverTypeWrapper<PricePoint>;
  PublicWallet: ResolverTypeWrapper<PublicWallet>;
  Query: ResolverTypeWrapper<{}>;
  Quiz: ResolverTypeWrapper<Quiz>;
  QuizClaimInput: QuizClaimInput;
  QuizClaimPayload: ResolverTypeWrapper<QuizClaimPayload>;
  RealtimePrice: ResolverTypeWrapper<RealtimePrice>;
  RealtimePriceInput: RealtimePriceInput;
  RealtimePricePayload: ResolverTypeWrapper<RealtimePricePayload>;
  Region: ResolverTypeWrapper<Region>;
  SafeInt: ResolverTypeWrapper<Scalars['SafeInt']['output']>;
  SatAmount: ResolverTypeWrapper<Scalars['SatAmount']['output']>;
  SatAmountPayload: ResolverTypeWrapper<SatAmountPayload>;
  Scope: Scope;
  Seconds: ResolverTypeWrapper<Scalars['Seconds']['output']>;
  SettlementVia: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['SettlementVia']>;
  SettlementViaIntraLedger: ResolverTypeWrapper<SettlementViaIntraLedger>;
  SettlementViaLn: ResolverTypeWrapper<SettlementViaLn>;
  SettlementViaOnChain: ResolverTypeWrapper<SettlementViaOnChain>;
  SignedAmount: ResolverTypeWrapper<Scalars['SignedAmount']['output']>;
  SignedDisplayMajorAmount: ResolverTypeWrapper<Scalars['SignedDisplayMajorAmount']['output']>;
  StatefulNotification: ResolverTypeWrapper<Omit<StatefulNotification, 'action'> & { action?: Maybe<ResolversTypes['NotificationAction']> }>;
  StatefulNotificationAcknowledgeInput: StatefulNotificationAcknowledgeInput;
  StatefulNotificationAcknowledgePayload: ResolverTypeWrapper<StatefulNotificationAcknowledgePayload>;
  StatefulNotificationConnection: ResolverTypeWrapper<StatefulNotificationConnection>;
  StatefulNotificationEdge: ResolverTypeWrapper<StatefulNotificationEdge>;
  Subscription: ResolverTypeWrapper<{}>;
  SuccessPayload: ResolverTypeWrapper<SuccessPayload>;
  SupportChatMessageAddInput: SupportChatMessageAddInput;
  SupportChatMessageAddPayload: ResolverTypeWrapper<SupportChatMessageAddPayload>;
  SupportMessage: ResolverTypeWrapper<SupportMessage>;
  SupportRole: SupportRole;
  Timestamp: ResolverTypeWrapper<Scalars['Timestamp']['output']>;
  TotpCode: ResolverTypeWrapper<Scalars['TotpCode']['output']>;
  TotpRegistrationId: ResolverTypeWrapper<Scalars['TotpRegistrationId']['output']>;
  TotpSecret: ResolverTypeWrapper<Scalars['TotpSecret']['output']>;
  Transaction: ResolverTypeWrapper<Omit<Transaction, 'initiationVia' | 'settlementVia'> & { initiationVia: ResolversTypes['InitiationVia'], settlementVia: ResolversTypes['SettlementVia'] }>;
  TransactionConnection: ResolverTypeWrapper<TransactionConnection>;
  TransactionEdge: ResolverTypeWrapper<TransactionEdge>;
  TxDirection: TxDirection;
  TxExternalId: ResolverTypeWrapper<Scalars['TxExternalId']['output']>;
  TxNotificationType: TxNotificationType;
  TxStatus: TxStatus;
  UpgradePayload: ResolverTypeWrapper<UpgradePayload>;
  UsdWallet: ResolverTypeWrapper<UsdWallet>;
  User: ResolverTypeWrapper<User>;
  UserContact: ResolverTypeWrapper<UserContact>;
  UserContactUpdateAliasInput: UserContactUpdateAliasInput;
  UserContactUpdateAliasPayload: ResolverTypeWrapper<UserContactUpdateAliasPayload>;
  UserEmailDeletePayload: ResolverTypeWrapper<UserEmailDeletePayload>;
  UserEmailRegistrationInitiateInput: UserEmailRegistrationInitiateInput;
  UserEmailRegistrationInitiatePayload: ResolverTypeWrapper<UserEmailRegistrationInitiatePayload>;
  UserEmailRegistrationValidateInput: UserEmailRegistrationValidateInput;
  UserEmailRegistrationValidatePayload: ResolverTypeWrapper<UserEmailRegistrationValidatePayload>;
  UserLoginInput: UserLoginInput;
  UserLoginUpgradeInput: UserLoginUpgradeInput;
  UserLogoutInput: UserLogoutInput;
  UserPhoneDeletePayload: ResolverTypeWrapper<UserPhoneDeletePayload>;
  UserPhoneRegistrationInitiateInput: UserPhoneRegistrationInitiateInput;
  UserPhoneRegistrationValidateInput: UserPhoneRegistrationValidateInput;
  UserPhoneRegistrationValidatePayload: ResolverTypeWrapper<UserPhoneRegistrationValidatePayload>;
  UserTotpDeletePayload: ResolverTypeWrapper<UserTotpDeletePayload>;
  UserTotpRegistrationInitiatePayload: ResolverTypeWrapper<UserTotpRegistrationInitiatePayload>;
  UserTotpRegistrationValidateInput: UserTotpRegistrationValidateInput;
  UserTotpRegistrationValidatePayload: ResolverTypeWrapper<UserTotpRegistrationValidatePayload>;
  UserUpdate: ResolverTypeWrapper<ResolversUnionTypes<ResolversTypes>['UserUpdate']>;
  UserUpdateLanguageInput: UserUpdateLanguageInput;
  UserUpdateLanguagePayload: ResolverTypeWrapper<UserUpdateLanguagePayload>;
  UserUpdateUsernameInput: UserUpdateUsernameInput;
  UserUpdateUsernamePayload: ResolverTypeWrapper<UserUpdateUsernamePayload>;
  Username: ResolverTypeWrapper<Scalars['Username']['output']>;
  Wallet: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Wallet']>;
  WalletCurrency: WalletCurrency;
  WalletId: ResolverTypeWrapper<Scalars['WalletId']['output']>;
  WelcomeLeaderboardInput: WelcomeLeaderboardInput;
  WelcomeProfile: ResolverTypeWrapper<WelcomeProfile>;
  WelcomeRange: WelcomeRange;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  Account: ResolversInterfaceTypes<ResolversParentTypes>['Account'];
  String: Scalars['String']['output'];
  ID: Scalars['ID']['output'];
  Int: Scalars['Int']['output'];
  AccountDeletePayload: AccountDeletePayload;
  Boolean: Scalars['Boolean']['output'];
  AccountDisableNotificationCategoryInput: AccountDisableNotificationCategoryInput;
  AccountDisableNotificationChannelInput: AccountDisableNotificationChannelInput;
  AccountEnableNotificationCategoryInput: AccountEnableNotificationCategoryInput;
  AccountEnableNotificationChannelInput: AccountEnableNotificationChannelInput;
  AccountLimit: ResolversInterfaceTypes<ResolversParentTypes>['AccountLimit'];
  AccountLimits: AccountLimits;
  AccountUpdateDefaultWalletIdInput: AccountUpdateDefaultWalletIdInput;
  AccountUpdateDefaultWalletIdPayload: AccountUpdateDefaultWalletIdPayload;
  AccountUpdateDisplayCurrencyInput: AccountUpdateDisplayCurrencyInput;
  AccountUpdateDisplayCurrencyPayload: AccountUpdateDisplayCurrencyPayload;
  AccountUpdateNotificationSettingsPayload: AccountUpdateNotificationSettingsPayload;
  ApiKey: ApiKey;
  ApiKeyCreateInput: ApiKeyCreateInput;
  ApiKeyCreatePayload: ApiKeyCreatePayload;
  ApiKeyRevokeInput: ApiKeyRevokeInput;
  ApiKeyRevokePayload: ApiKeyRevokePayload;
  AuthToken: Scalars['AuthToken']['output'];
  AuthTokenPayload: AuthTokenPayload;
  Authorization: Authorization;
  BTCWallet: BtcWallet;
  BuildInformation: BuildInformation;
  CallbackEndpoint: CallbackEndpoint;
  CallbackEndpointAddInput: CallbackEndpointAddInput;
  CallbackEndpointAddPayload: CallbackEndpointAddPayload;
  CallbackEndpointDeleteInput: CallbackEndpointDeleteInput;
  CaptchaCreateChallengePayload: CaptchaCreateChallengePayload;
  CaptchaCreateChallengeResult: CaptchaCreateChallengeResult;
  CaptchaRequestAuthCodeInput: CaptchaRequestAuthCodeInput;
  CentAmount: Scalars['CentAmount']['output'];
  CentAmountPayload: CentAmountPayload;
  ConsumerAccount: ConsumerAccount;
  Contact: Contact;
  ContactAlias: Scalars['ContactAlias']['output'];
  Coordinates: Coordinates;
  Float: Scalars['Float']['output'];
  Country: Country;
  CountryCode: Scalars['CountryCode']['output'];
  Currency: Currency;
  CurrencyConversionEstimation: CurrencyConversionEstimation;
  DepositFeesInformation: DepositFeesInformation;
  DeviceNotificationTokenCreateInput: DeviceNotificationTokenCreateInput;
  DisplayCurrency: Scalars['DisplayCurrency']['output'];
  Email: Email;
  EmailAddress: Scalars['EmailAddress']['output'];
  EmailRegistrationId: Scalars['EmailRegistrationId']['output'];
  EndpointId: Scalars['EndpointId']['output'];
  EndpointUrl: Scalars['EndpointUrl']['output'];
  Error: ResolversInterfaceTypes<ResolversParentTypes>['Error'];
  Feedback: Scalars['Feedback']['output'];
  FeedbackSubmitInput: FeedbackSubmitInput;
  FeesInformation: FeesInformation;
  Globals: Globals;
  GraphQLApplicationError: GraphQlApplicationError;
  Hex32Bytes: Scalars['Hex32Bytes']['output'];
  InitiationVia: ResolversUnionTypes<ResolversParentTypes>['InitiationVia'];
  InitiationViaIntraLedger: InitiationViaIntraLedger;
  InitiationViaLn: InitiationViaLn;
  InitiationViaOnChain: InitiationViaOnChain;
  IntraLedgerPaymentSendInput: IntraLedgerPaymentSendInput;
  IntraLedgerUpdate: IntraLedgerUpdate;
  IntraLedgerUsdPaymentSendInput: IntraLedgerUsdPaymentSendInput;
  Invoice: ResolversInterfaceTypes<ResolversParentTypes>['Invoice'];
  InvoiceConnection: InvoiceConnection;
  InvoiceEdge: InvoiceEdge;
  Language: Scalars['Language']['output'];
  Leader: Leader;
  Leaderboard: Leaderboard;
  LeaderboardName: Scalars['LeaderboardName']['output'];
  LnAddressPaymentSendInput: LnAddressPaymentSendInput;
  LnInvoice: LnInvoice;
  LnInvoiceCancelInput: LnInvoiceCancelInput;
  LnInvoiceCreateInput: LnInvoiceCreateInput;
  LnInvoiceCreateOnBehalfOfRecipientInput: LnInvoiceCreateOnBehalfOfRecipientInput;
  LnInvoiceFeeProbeInput: LnInvoiceFeeProbeInput;
  LnInvoicePayload: LnInvoicePayload;
  LnInvoicePaymentInput: LnInvoicePaymentInput;
  LnInvoicePaymentStatus: LnInvoicePaymentStatus;
  LnInvoicePaymentStatusByHashInput: LnInvoicePaymentStatusByHashInput;
  LnInvoicePaymentStatusByPaymentRequestInput: LnInvoicePaymentStatusByPaymentRequestInput;
  LnInvoicePaymentStatusInput: LnInvoicePaymentStatusInput;
  LnInvoicePaymentStatusPayload: LnInvoicePaymentStatusPayload;
  LnNoAmountInvoice: LnNoAmountInvoice;
  LnNoAmountInvoiceCreateInput: LnNoAmountInvoiceCreateInput;
  LnNoAmountInvoiceCreateOnBehalfOfRecipientInput: LnNoAmountInvoiceCreateOnBehalfOfRecipientInput;
  LnNoAmountInvoiceFeeProbeInput: LnNoAmountInvoiceFeeProbeInput;
  LnNoAmountInvoicePayload: LnNoAmountInvoicePayload;
  LnNoAmountInvoicePaymentInput: LnNoAmountInvoicePaymentInput;
  LnNoAmountUsdInvoiceFeeProbeInput: LnNoAmountUsdInvoiceFeeProbeInput;
  LnNoAmountUsdInvoicePaymentInput: LnNoAmountUsdInvoicePaymentInput;
  LnPaymentPreImage: Scalars['LnPaymentPreImage']['output'];
  LnPaymentRequest: Scalars['LnPaymentRequest']['output'];
  LnPaymentSecret: Scalars['LnPaymentSecret']['output'];
  LnUpdate: LnUpdate;
  LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput: LnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientInput;
  LnUsdInvoiceCreateInput: LnUsdInvoiceCreateInput;
  LnUsdInvoiceCreateOnBehalfOfRecipientInput: LnUsdInvoiceCreateOnBehalfOfRecipientInput;
  LnUsdInvoiceFeeProbeInput: LnUsdInvoiceFeeProbeInput;
  LnurlPaymentSendInput: LnurlPaymentSendInput;
  MapInfo: MapInfo;
  MapMarker: MapMarker;
  Memo: Scalars['Memo']['output'];
  Merchant: Merchant;
  MerchantMapSuggestInput: MerchantMapSuggestInput;
  MerchantPayload: MerchantPayload;
  Minutes: Scalars['Minutes']['output'];
  MobileVersions: MobileVersions;
  Mutation: {};
  MyUpdatesPayload: Omit<MyUpdatesPayload, 'update'> & { update?: Maybe<ResolversParentTypes['UserUpdate']> };
  NotificationAction: ResolversUnionTypes<ResolversParentTypes>['NotificationAction'];
  NotificationCategory: Scalars['NotificationCategory']['output'];
  NotificationChannelSettings: NotificationChannelSettings;
  NotificationSettings: NotificationSettings;
  OnChainAddress: Scalars['OnChainAddress']['output'];
  OnChainAddressCreateInput: OnChainAddressCreateInput;
  OnChainAddressCurrentInput: OnChainAddressCurrentInput;
  OnChainAddressPayload: OnChainAddressPayload;
  OnChainPaymentSendAllInput: OnChainPaymentSendAllInput;
  OnChainPaymentSendInput: OnChainPaymentSendInput;
  OnChainTxFee: OnChainTxFee;
  OnChainTxHash: Scalars['OnChainTxHash']['output'];
  OnChainUpdate: OnChainUpdate;
  OnChainUsdPaymentSendAsBtcDenominatedInput: OnChainUsdPaymentSendAsBtcDenominatedInput;
  OnChainUsdPaymentSendInput: OnChainUsdPaymentSendInput;
  OnChainUsdTxFee: OnChainUsdTxFee;
  OnboardingFlowStartInput: OnboardingFlowStartInput;
  OnboardingFlowStartResult: OnboardingFlowStartResult;
  OneDayAccountLimit: OneDayAccountLimit;
  OneTimeAuthCode: Scalars['OneTimeAuthCode']['output'];
  OpenDeepLinkAction: OpenDeepLinkAction;
  OpenExternalLinkAction: OpenExternalLinkAction;
  PageInfo: PageInfo;
  PaymentHash: Scalars['PaymentHash']['output'];
  PaymentSendPayload: PaymentSendPayload;
  Phone: Scalars['Phone']['output'];
  Price: Price;
  PriceInput: PriceInput;
  PriceInterface: ResolversInterfaceTypes<ResolversParentTypes>['PriceInterface'];
  PriceOfOneSatInMinorUnit: PriceOfOneSatInMinorUnit;
  PriceOfOneSettlementMinorUnitInDisplayMinorUnit: PriceOfOneSettlementMinorUnitInDisplayMinorUnit;
  PriceOfOneUsdCentInMinorUnit: PriceOfOneUsdCentInMinorUnit;
  PricePayload: PricePayload;
  PricePoint: PricePoint;
  PublicWallet: PublicWallet;
  Query: {};
  Quiz: Quiz;
  QuizClaimInput: QuizClaimInput;
  QuizClaimPayload: QuizClaimPayload;
  RealtimePrice: RealtimePrice;
  RealtimePriceInput: RealtimePriceInput;
  RealtimePricePayload: RealtimePricePayload;
  Region: Region;
  SafeInt: Scalars['SafeInt']['output'];
  SatAmount: Scalars['SatAmount']['output'];
  SatAmountPayload: SatAmountPayload;
  Seconds: Scalars['Seconds']['output'];
  SettlementVia: ResolversUnionTypes<ResolversParentTypes>['SettlementVia'];
  SettlementViaIntraLedger: SettlementViaIntraLedger;
  SettlementViaLn: SettlementViaLn;
  SettlementViaOnChain: SettlementViaOnChain;
  SignedAmount: Scalars['SignedAmount']['output'];
  SignedDisplayMajorAmount: Scalars['SignedDisplayMajorAmount']['output'];
  StatefulNotification: Omit<StatefulNotification, 'action'> & { action?: Maybe<ResolversParentTypes['NotificationAction']> };
  StatefulNotificationAcknowledgeInput: StatefulNotificationAcknowledgeInput;
  StatefulNotificationAcknowledgePayload: StatefulNotificationAcknowledgePayload;
  StatefulNotificationConnection: StatefulNotificationConnection;
  StatefulNotificationEdge: StatefulNotificationEdge;
  Subscription: {};
  SuccessPayload: SuccessPayload;
  SupportChatMessageAddInput: SupportChatMessageAddInput;
  SupportChatMessageAddPayload: SupportChatMessageAddPayload;
  SupportMessage: SupportMessage;
  Timestamp: Scalars['Timestamp']['output'];
  TotpCode: Scalars['TotpCode']['output'];
  TotpRegistrationId: Scalars['TotpRegistrationId']['output'];
  TotpSecret: Scalars['TotpSecret']['output'];
  Transaction: Omit<Transaction, 'initiationVia' | 'settlementVia'> & { initiationVia: ResolversParentTypes['InitiationVia'], settlementVia: ResolversParentTypes['SettlementVia'] };
  TransactionConnection: TransactionConnection;
  TransactionEdge: TransactionEdge;
  TxExternalId: Scalars['TxExternalId']['output'];
  UpgradePayload: UpgradePayload;
  UsdWallet: UsdWallet;
  User: User;
  UserContact: UserContact;
  UserContactUpdateAliasInput: UserContactUpdateAliasInput;
  UserContactUpdateAliasPayload: UserContactUpdateAliasPayload;
  UserEmailDeletePayload: UserEmailDeletePayload;
  UserEmailRegistrationInitiateInput: UserEmailRegistrationInitiateInput;
  UserEmailRegistrationInitiatePayload: UserEmailRegistrationInitiatePayload;
  UserEmailRegistrationValidateInput: UserEmailRegistrationValidateInput;
  UserEmailRegistrationValidatePayload: UserEmailRegistrationValidatePayload;
  UserLoginInput: UserLoginInput;
  UserLoginUpgradeInput: UserLoginUpgradeInput;
  UserLogoutInput: UserLogoutInput;
  UserPhoneDeletePayload: UserPhoneDeletePayload;
  UserPhoneRegistrationInitiateInput: UserPhoneRegistrationInitiateInput;
  UserPhoneRegistrationValidateInput: UserPhoneRegistrationValidateInput;
  UserPhoneRegistrationValidatePayload: UserPhoneRegistrationValidatePayload;
  UserTotpDeletePayload: UserTotpDeletePayload;
  UserTotpRegistrationInitiatePayload: UserTotpRegistrationInitiatePayload;
  UserTotpRegistrationValidateInput: UserTotpRegistrationValidateInput;
  UserTotpRegistrationValidatePayload: UserTotpRegistrationValidatePayload;
  UserUpdate: ResolversUnionTypes<ResolversParentTypes>['UserUpdate'];
  UserUpdateLanguageInput: UserUpdateLanguageInput;
  UserUpdateLanguagePayload: UserUpdateLanguagePayload;
  UserUpdateUsernameInput: UserUpdateUsernameInput;
  UserUpdateUsernamePayload: UserUpdateUsernamePayload;
  Username: Scalars['Username']['output'];
  Wallet: ResolversInterfaceTypes<ResolversParentTypes>['Wallet'];
  WalletId: Scalars['WalletId']['output'];
  WelcomeLeaderboardInput: WelcomeLeaderboardInput;
  WelcomeProfile: WelcomeProfile;
};

export type DeferDirectiveArgs = {
  if?: Scalars['Boolean']['input'];
  label?: Maybe<Scalars['String']['input']>;
};

export type DeferDirectiveResolver<Result, Parent, ContextType = any, Args = DeferDirectiveArgs> = DirectiveResolverFn<Result, Parent, ContextType, Args>;

export type AccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['Account'] = ResolversParentTypes['Account']> = {
  __resolveType: TypeResolveFn<'ConsumerAccount', ParentType, ContextType>;
  btcWallet?: Resolver<Maybe<ResolversTypes['BTCWallet']>, ParentType, ContextType>;
  callbackEndpoints?: Resolver<ReadonlyArray<ResolversTypes['CallbackEndpoint']>, ParentType, ContextType>;
  callbackPortalUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  csvTransactions?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<AccountCsvTransactionsArgs, 'walletIds'>>;
  defaultWallet?: Resolver<ResolversTypes['PublicWallet'], ParentType, ContextType>;
  defaultWalletId?: Resolver<ResolversTypes['WalletId'], ParentType, ContextType>;
  displayCurrency?: Resolver<ResolversTypes['DisplayCurrency'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoices?: Resolver<Maybe<ResolversTypes['InvoiceConnection']>, ParentType, ContextType, Partial<AccountInvoicesArgs>>;
  level?: Resolver<ResolversTypes['AccountLevel'], ParentType, ContextType>;
  limits?: Resolver<ResolversTypes['AccountLimits'], ParentType, ContextType>;
  notificationSettings?: Resolver<ResolversTypes['NotificationSettings'], ParentType, ContextType>;
  pendingIncomingTransactions?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, Partial<AccountPendingIncomingTransactionsArgs>>;
  realtimePrice?: Resolver<ResolversTypes['RealtimePrice'], ParentType, ContextType>;
  transactions?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, Partial<AccountTransactionsArgs>>;
  usdWallet?: Resolver<Maybe<ResolversTypes['UsdWallet']>, ParentType, ContextType>;
  walletById?: Resolver<ResolversTypes['Wallet'], ParentType, ContextType, RequireFields<AccountWalletByIdArgs, 'walletId'>>;
  wallets?: Resolver<ReadonlyArray<ResolversTypes['Wallet']>, ParentType, ContextType>;
};

export type AccountDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountDeletePayload'] = ResolversParentTypes['AccountDeletePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountLimitResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountLimit'] = ResolversParentTypes['AccountLimit']> = {
  __resolveType: TypeResolveFn<'OneDayAccountLimit', ParentType, ContextType>;
  interval?: Resolver<Maybe<ResolversTypes['Seconds']>, ParentType, ContextType>;
  remainingLimit?: Resolver<Maybe<ResolversTypes['CentAmount']>, ParentType, ContextType>;
  totalLimit?: Resolver<ResolversTypes['CentAmount'], ParentType, ContextType>;
};

export type AccountLimitsResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountLimits'] = ResolversParentTypes['AccountLimits']> = {
  convert?: Resolver<ReadonlyArray<ResolversTypes['AccountLimit']>, ParentType, ContextType>;
  internalSend?: Resolver<ReadonlyArray<ResolversTypes['AccountLimit']>, ParentType, ContextType>;
  withdrawal?: Resolver<ReadonlyArray<ResolversTypes['AccountLimit']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountUpdateDefaultWalletIdPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountUpdateDefaultWalletIdPayload'] = ResolversParentTypes['AccountUpdateDefaultWalletIdPayload']> = {
  account?: Resolver<Maybe<ResolversTypes['ConsumerAccount']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountUpdateDisplayCurrencyPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountUpdateDisplayCurrencyPayload'] = ResolversParentTypes['AccountUpdateDisplayCurrencyPayload']> = {
  account?: Resolver<Maybe<ResolversTypes['ConsumerAccount']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AccountUpdateNotificationSettingsPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AccountUpdateNotificationSettingsPayload'] = ResolversParentTypes['AccountUpdateNotificationSettingsPayload']> = {
  account?: Resolver<Maybe<ResolversTypes['ConsumerAccount']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApiKeyResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApiKey'] = ResolversParentTypes['ApiKey']> = {
  createdAt?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  expired?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  expiresAt?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  lastUsedAt?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  readOnly?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  revoked?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  scopes?: Resolver<ReadonlyArray<ResolversTypes['Scope']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApiKeyCreatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApiKeyCreatePayload'] = ResolversParentTypes['ApiKeyCreatePayload']> = {
  apiKey?: Resolver<ResolversTypes['ApiKey'], ParentType, ContextType>;
  apiKeySecret?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApiKeyRevokePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApiKeyRevokePayload'] = ResolversParentTypes['ApiKeyRevokePayload']> = {
  apiKey?: Resolver<ResolversTypes['ApiKey'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface AuthTokenScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['AuthToken'], any> {
  name: 'AuthToken';
}

export type AuthTokenPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['AuthTokenPayload'] = ResolversParentTypes['AuthTokenPayload']> = {
  authToken?: Resolver<Maybe<ResolversTypes['AuthToken']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  totpRequired?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AuthorizationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Authorization'] = ResolversParentTypes['Authorization']> = {
  scopes?: Resolver<ReadonlyArray<ResolversTypes['Scope']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BtcWalletResolvers<ContextType = any, ParentType extends ResolversParentTypes['BTCWallet'] = ResolversParentTypes['BTCWallet']> = {
  accountId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  balance?: Resolver<ResolversTypes['SignedAmount'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoiceByPaymentHash?: Resolver<ResolversTypes['Invoice'], ParentType, ContextType, RequireFields<BtcWalletInvoiceByPaymentHashArgs, 'paymentHash'>>;
  invoices?: Resolver<Maybe<ResolversTypes['InvoiceConnection']>, ParentType, ContextType, Partial<BtcWalletInvoicesArgs>>;
  pendingIncomingBalance?: Resolver<ResolversTypes['SignedAmount'], ParentType, ContextType>;
  pendingIncomingTransactions?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType>;
  pendingIncomingTransactionsByAddress?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<BtcWalletPendingIncomingTransactionsByAddressArgs, 'address'>>;
  transactionById?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<BtcWalletTransactionByIdArgs, 'transactionId'>>;
  transactions?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, Partial<BtcWalletTransactionsArgs>>;
  transactionsByAddress?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, RequireFields<BtcWalletTransactionsByAddressArgs, 'address'>>;
  transactionsByPaymentHash?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<BtcWalletTransactionsByPaymentHashArgs, 'paymentHash'>>;
  transactionsByPaymentRequest?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<BtcWalletTransactionsByPaymentRequestArgs, 'paymentRequest'>>;
  walletCurrency?: Resolver<ResolversTypes['WalletCurrency'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type BuildInformationResolvers<ContextType = any, ParentType extends ResolversParentTypes['BuildInformation'] = ResolversParentTypes['BuildInformation']> = {
  commitHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  helmRevision?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CallbackEndpointResolvers<ContextType = any, ParentType extends ResolversParentTypes['CallbackEndpoint'] = ResolversParentTypes['CallbackEndpoint']> = {
  id?: Resolver<ResolversTypes['EndpointId'], ParentType, ContextType>;
  url?: Resolver<ResolversTypes['EndpointUrl'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CallbackEndpointAddPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CallbackEndpointAddPayload'] = ResolversParentTypes['CallbackEndpointAddPayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['EndpointId']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CaptchaCreateChallengePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CaptchaCreateChallengePayload'] = ResolversParentTypes['CaptchaCreateChallengePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  result?: Resolver<Maybe<ResolversTypes['CaptchaCreateChallengeResult']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CaptchaCreateChallengeResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['CaptchaCreateChallengeResult'] = ResolversParentTypes['CaptchaCreateChallengeResult']> = {
  challengeCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  failbackMode?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  newCaptcha?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface CentAmountScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['CentAmount'], any> {
  name: 'CentAmount';
}

export type CentAmountPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CentAmountPayload'] = ResolversParentTypes['CentAmountPayload']> = {
  amount?: Resolver<Maybe<ResolversTypes['CentAmount']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConsumerAccountResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConsumerAccount'] = ResolversParentTypes['ConsumerAccount']> = {
  btcWallet?: Resolver<Maybe<ResolversTypes['BTCWallet']>, ParentType, ContextType>;
  callbackEndpoints?: Resolver<ReadonlyArray<ResolversTypes['CallbackEndpoint']>, ParentType, ContextType>;
  callbackPortalUrl?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  csvTransactions?: Resolver<ResolversTypes['String'], ParentType, ContextType, RequireFields<ConsumerAccountCsvTransactionsArgs, 'walletIds'>>;
  defaultWallet?: Resolver<ResolversTypes['PublicWallet'], ParentType, ContextType>;
  defaultWalletId?: Resolver<ResolversTypes['WalletId'], ParentType, ContextType>;
  displayCurrency?: Resolver<ResolversTypes['DisplayCurrency'], ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoices?: Resolver<Maybe<ResolversTypes['InvoiceConnection']>, ParentType, ContextType, Partial<ConsumerAccountInvoicesArgs>>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  level?: Resolver<ResolversTypes['AccountLevel'], ParentType, ContextType>;
  limits?: Resolver<ResolversTypes['AccountLimits'], ParentType, ContextType>;
  notificationSettings?: Resolver<ResolversTypes['NotificationSettings'], ParentType, ContextType>;
  onboardingStatus?: Resolver<Maybe<ResolversTypes['OnboardingStatus']>, ParentType, ContextType>;
  pendingIncomingTransactions?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, Partial<ConsumerAccountPendingIncomingTransactionsArgs>>;
  quiz?: Resolver<ReadonlyArray<ResolversTypes['Quiz']>, ParentType, ContextType>;
  realtimePrice?: Resolver<ResolversTypes['RealtimePrice'], ParentType, ContextType>;
  transactions?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, Partial<ConsumerAccountTransactionsArgs>>;
  usdWallet?: Resolver<Maybe<ResolversTypes['UsdWallet']>, ParentType, ContextType>;
  walletById?: Resolver<ResolversTypes['Wallet'], ParentType, ContextType, RequireFields<ConsumerAccountWalletByIdArgs, 'walletId'>>;
  wallets?: Resolver<ReadonlyArray<ResolversTypes['Wallet']>, ParentType, ContextType>;
  welcomeProfile?: Resolver<Maybe<ResolversTypes['WelcomeProfile']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ContactResolvers<ContextType = any, ParentType extends ResolversParentTypes['Contact'] = ResolversParentTypes['Contact']> = {
  prettyName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface ContactAliasScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['ContactAlias'], any> {
  name: 'ContactAlias';
}

export type CoordinatesResolvers<ContextType = any, ParentType extends ResolversParentTypes['Coordinates'] = ResolversParentTypes['Coordinates']> = {
  latitude?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  longitude?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Country'] = ResolversParentTypes['Country']> = {
  id?: Resolver<ResolversTypes['CountryCode'], ParentType, ContextType>;
  supportedAuthChannels?: Resolver<ReadonlyArray<ResolversTypes['PhoneCodeChannelType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface CountryCodeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['CountryCode'], any> {
  name: 'CountryCode';
}

export type CurrencyResolvers<ContextType = any, ParentType extends ResolversParentTypes['Currency'] = ResolversParentTypes['Currency']> = {
  flag?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fractionDigits?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  symbol?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CurrencyConversionEstimationResolvers<ContextType = any, ParentType extends ResolversParentTypes['CurrencyConversionEstimation'] = ResolversParentTypes['CurrencyConversionEstimation']> = {
  btcSatAmount?: Resolver<ResolversTypes['SatAmount'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  usdCentAmount?: Resolver<ResolversTypes['CentAmount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DepositFeesInformationResolvers<ContextType = any, ParentType extends ResolversParentTypes['DepositFeesInformation'] = ResolversParentTypes['DepositFeesInformation']> = {
  minBankFee?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  minBankFeeThreshold?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  ratio?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DisplayCurrencyScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['DisplayCurrency'], any> {
  name: 'DisplayCurrency';
}

export type EmailResolvers<ContextType = any, ParentType extends ResolversParentTypes['Email'] = ResolversParentTypes['Email']> = {
  address?: Resolver<Maybe<ResolversTypes['EmailAddress']>, ParentType, ContextType>;
  verified?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface EmailAddressScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['EmailAddress'], any> {
  name: 'EmailAddress';
}

export interface EmailRegistrationIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['EmailRegistrationId'], any> {
  name: 'EmailRegistrationId';
}

export interface EndpointIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['EndpointId'], any> {
  name: 'EndpointId';
}

export interface EndpointUrlScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['EndpointUrl'], any> {
  name: 'EndpointUrl';
}

export type ErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['Error'] = ResolversParentTypes['Error']> = {
  __resolveType: TypeResolveFn<'GraphQLApplicationError', ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
};

export interface FeedbackScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Feedback'], any> {
  name: 'Feedback';
}

export type FeesInformationResolvers<ContextType = any, ParentType extends ResolversParentTypes['FeesInformation'] = ResolversParentTypes['FeesInformation']> = {
  deposit?: Resolver<ResolversTypes['DepositFeesInformation'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GlobalsResolvers<ContextType = any, ParentType extends ResolversParentTypes['Globals'] = ResolversParentTypes['Globals']> = {
  buildInformation?: Resolver<ResolversTypes['BuildInformation'], ParentType, ContextType>;
  feesInformation?: Resolver<ResolversTypes['FeesInformation'], ParentType, ContextType>;
  lightningAddressDomain?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  lightningAddressDomainAliases?: Resolver<ReadonlyArray<ResolversTypes['String']>, ParentType, ContextType>;
  network?: Resolver<ResolversTypes['Network'], ParentType, ContextType>;
  nodesIds?: Resolver<ReadonlyArray<ResolversTypes['String']>, ParentType, ContextType>;
  supportedCountries?: Resolver<ReadonlyArray<ResolversTypes['Country']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GraphQlApplicationErrorResolvers<ContextType = any, ParentType extends ResolversParentTypes['GraphQLApplicationError'] = ResolversParentTypes['GraphQLApplicationError']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  path?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface Hex32BytesScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Hex32Bytes'], any> {
  name: 'Hex32Bytes';
}

export type InitiationViaResolvers<ContextType = any, ParentType extends ResolversParentTypes['InitiationVia'] = ResolversParentTypes['InitiationVia']> = {
  __resolveType: TypeResolveFn<'InitiationViaIntraLedger' | 'InitiationViaLn' | 'InitiationViaOnChain', ParentType, ContextType>;
};

export type InitiationViaIntraLedgerResolvers<ContextType = any, ParentType extends ResolversParentTypes['InitiationViaIntraLedger'] = ResolversParentTypes['InitiationViaIntraLedger']> = {
  counterPartyUsername?: Resolver<Maybe<ResolversTypes['Username']>, ParentType, ContextType>;
  counterPartyWalletId?: Resolver<Maybe<ResolversTypes['WalletId']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InitiationViaLnResolvers<ContextType = any, ParentType extends ResolversParentTypes['InitiationViaLn'] = ResolversParentTypes['InitiationViaLn']> = {
  paymentHash?: Resolver<ResolversTypes['PaymentHash'], ParentType, ContextType>;
  paymentRequest?: Resolver<ResolversTypes['LnPaymentRequest'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InitiationViaOnChainResolvers<ContextType = any, ParentType extends ResolversParentTypes['InitiationViaOnChain'] = ResolversParentTypes['InitiationViaOnChain']> = {
  address?: Resolver<ResolversTypes['OnChainAddress'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type IntraLedgerUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['IntraLedgerUpdate'] = ResolversParentTypes['IntraLedgerUpdate']> = {
  amount?: Resolver<ResolversTypes['SatAmount'], ParentType, ContextType>;
  displayCurrencyPerSat?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  transaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
  txNotificationType?: Resolver<ResolversTypes['TxNotificationType'], ParentType, ContextType>;
  usdPerSat?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  walletId?: Resolver<ResolversTypes['WalletId'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Invoice'] = ResolversParentTypes['Invoice']> = {
  __resolveType: TypeResolveFn<'LnInvoice' | 'LnNoAmountInvoice', ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  externalId?: Resolver<ResolversTypes['TxExternalId'], ParentType, ContextType>;
  paymentHash?: Resolver<ResolversTypes['PaymentHash'], ParentType, ContextType>;
  paymentRequest?: Resolver<ResolversTypes['LnPaymentRequest'], ParentType, ContextType>;
  paymentSecret?: Resolver<ResolversTypes['LnPaymentSecret'], ParentType, ContextType>;
  paymentStatus?: Resolver<ResolversTypes['InvoicePaymentStatus'], ParentType, ContextType>;
};

export type InvoiceConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceConnection'] = ResolversParentTypes['InvoiceConnection']> = {
  edges?: Resolver<Maybe<ReadonlyArray<ResolversTypes['InvoiceEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type InvoiceEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['InvoiceEdge'] = ResolversParentTypes['InvoiceEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Invoice'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface LanguageScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Language'], any> {
  name: 'Language';
}

export type LeaderResolvers<ContextType = any, ParentType extends ResolversParentTypes['Leader'] = ResolversParentTypes['Leader']> = {
  name?: Resolver<Maybe<ResolversTypes['LeaderboardName']>, ParentType, ContextType>;
  points?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  rank?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LeaderboardResolvers<ContextType = any, ParentType extends ResolversParentTypes['Leaderboard'] = ResolversParentTypes['Leaderboard']> = {
  leaders?: Resolver<ReadonlyArray<ResolversTypes['Leader']>, ParentType, ContextType>;
  range?: Resolver<ResolversTypes['WelcomeRange'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface LeaderboardNameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['LeaderboardName'], any> {
  name: 'LeaderboardName';
}

export type LnInvoiceResolvers<ContextType = any, ParentType extends ResolversParentTypes['LnInvoice'] = ResolversParentTypes['LnInvoice']> = {
  createdAt?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  externalId?: Resolver<ResolversTypes['TxExternalId'], ParentType, ContextType>;
  paymentHash?: Resolver<ResolversTypes['PaymentHash'], ParentType, ContextType>;
  paymentRequest?: Resolver<ResolversTypes['LnPaymentRequest'], ParentType, ContextType>;
  paymentSecret?: Resolver<ResolversTypes['LnPaymentSecret'], ParentType, ContextType>;
  paymentStatus?: Resolver<ResolversTypes['InvoicePaymentStatus'], ParentType, ContextType>;
  satoshis?: Resolver<ResolversTypes['SatAmount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LnInvoicePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['LnInvoicePayload'] = ResolversParentTypes['LnInvoicePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['LnInvoice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LnInvoicePaymentStatusResolvers<ContextType = any, ParentType extends ResolversParentTypes['LnInvoicePaymentStatus'] = ResolversParentTypes['LnInvoicePaymentStatus']> = {
  paymentHash?: Resolver<Maybe<ResolversTypes['PaymentHash']>, ParentType, ContextType>;
  paymentRequest?: Resolver<Maybe<ResolversTypes['LnPaymentRequest']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['InvoicePaymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LnInvoicePaymentStatusPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['LnInvoicePaymentStatusPayload'] = ResolversParentTypes['LnInvoicePaymentStatusPayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  paymentHash?: Resolver<Maybe<ResolversTypes['PaymentHash']>, ParentType, ContextType>;
  paymentRequest?: Resolver<Maybe<ResolversTypes['LnPaymentRequest']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['InvoicePaymentStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LnNoAmountInvoiceResolvers<ContextType = any, ParentType extends ResolversParentTypes['LnNoAmountInvoice'] = ResolversParentTypes['LnNoAmountInvoice']> = {
  createdAt?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  externalId?: Resolver<ResolversTypes['TxExternalId'], ParentType, ContextType>;
  paymentHash?: Resolver<ResolversTypes['PaymentHash'], ParentType, ContextType>;
  paymentRequest?: Resolver<ResolversTypes['LnPaymentRequest'], ParentType, ContextType>;
  paymentSecret?: Resolver<ResolversTypes['LnPaymentSecret'], ParentType, ContextType>;
  paymentStatus?: Resolver<ResolversTypes['InvoicePaymentStatus'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type LnNoAmountInvoicePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['LnNoAmountInvoicePayload'] = ResolversParentTypes['LnNoAmountInvoicePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  invoice?: Resolver<Maybe<ResolversTypes['LnNoAmountInvoice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface LnPaymentPreImageScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['LnPaymentPreImage'], any> {
  name: 'LnPaymentPreImage';
}

export interface LnPaymentRequestScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['LnPaymentRequest'], any> {
  name: 'LnPaymentRequest';
}

export interface LnPaymentSecretScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['LnPaymentSecret'], any> {
  name: 'LnPaymentSecret';
}

export type LnUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['LnUpdate'] = ResolversParentTypes['LnUpdate']> = {
  paymentHash?: Resolver<ResolversTypes['PaymentHash'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['InvoicePaymentStatus'], ParentType, ContextType>;
  transaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
  walletId?: Resolver<ResolversTypes['WalletId'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MapInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['MapInfo'] = ResolversParentTypes['MapInfo']> = {
  coordinates?: Resolver<ResolversTypes['Coordinates'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MapMarkerResolvers<ContextType = any, ParentType extends ResolversParentTypes['MapMarker'] = ResolversParentTypes['MapMarker']> = {
  mapInfo?: Resolver<ResolversTypes['MapInfo'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['Username'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface MemoScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Memo'], any> {
  name: 'Memo';
}

export type MerchantResolvers<ContextType = any, ParentType extends ResolversParentTypes['Merchant'] = ResolversParentTypes['Merchant']> = {
  coordinates?: Resolver<ResolversTypes['Coordinates'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['Username'], ParentType, ContextType>;
  validated?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MerchantPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['MerchantPayload'] = ResolversParentTypes['MerchantPayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  merchant?: Resolver<Maybe<ResolversTypes['Merchant']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface MinutesScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Minutes'], any> {
  name: 'Minutes';
}

export type MobileVersionsResolvers<ContextType = any, ParentType extends ResolversParentTypes['MobileVersions'] = ResolversParentTypes['MobileVersions']> = {
  currentSupported?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  minSupported?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  platform?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  accountDelete?: Resolver<ResolversTypes['AccountDeletePayload'], ParentType, ContextType>;
  accountDisableNotificationCategory?: Resolver<ResolversTypes['AccountUpdateNotificationSettingsPayload'], ParentType, ContextType, RequireFields<MutationAccountDisableNotificationCategoryArgs, 'input'>>;
  accountDisableNotificationChannel?: Resolver<ResolversTypes['AccountUpdateNotificationSettingsPayload'], ParentType, ContextType, RequireFields<MutationAccountDisableNotificationChannelArgs, 'input'>>;
  accountEnableNotificationCategory?: Resolver<ResolversTypes['AccountUpdateNotificationSettingsPayload'], ParentType, ContextType, RequireFields<MutationAccountEnableNotificationCategoryArgs, 'input'>>;
  accountEnableNotificationChannel?: Resolver<ResolversTypes['AccountUpdateNotificationSettingsPayload'], ParentType, ContextType, RequireFields<MutationAccountEnableNotificationChannelArgs, 'input'>>;
  accountUpdateDefaultWalletId?: Resolver<ResolversTypes['AccountUpdateDefaultWalletIdPayload'], ParentType, ContextType, RequireFields<MutationAccountUpdateDefaultWalletIdArgs, 'input'>>;
  accountUpdateDisplayCurrency?: Resolver<ResolversTypes['AccountUpdateDisplayCurrencyPayload'], ParentType, ContextType, RequireFields<MutationAccountUpdateDisplayCurrencyArgs, 'input'>>;
  apiKeyCreate?: Resolver<ResolversTypes['ApiKeyCreatePayload'], ParentType, ContextType, RequireFields<MutationApiKeyCreateArgs, 'input'>>;
  apiKeyRevoke?: Resolver<ResolversTypes['ApiKeyRevokePayload'], ParentType, ContextType, RequireFields<MutationApiKeyRevokeArgs, 'input'>>;
  callbackEndpointAdd?: Resolver<ResolversTypes['CallbackEndpointAddPayload'], ParentType, ContextType, RequireFields<MutationCallbackEndpointAddArgs, 'input'>>;
  callbackEndpointDelete?: Resolver<ResolversTypes['SuccessPayload'], ParentType, ContextType, RequireFields<MutationCallbackEndpointDeleteArgs, 'input'>>;
  captchaCreateChallenge?: Resolver<ResolversTypes['CaptchaCreateChallengePayload'], ParentType, ContextType>;
  captchaRequestAuthCode?: Resolver<ResolversTypes['SuccessPayload'], ParentType, ContextType, RequireFields<MutationCaptchaRequestAuthCodeArgs, 'input'>>;
  deviceNotificationTokenCreate?: Resolver<ResolversTypes['SuccessPayload'], ParentType, ContextType, RequireFields<MutationDeviceNotificationTokenCreateArgs, 'input'>>;
  feedbackSubmit?: Resolver<ResolversTypes['SuccessPayload'], ParentType, ContextType, RequireFields<MutationFeedbackSubmitArgs, 'input'>>;
  intraLedgerPaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationIntraLedgerPaymentSendArgs, 'input'>>;
  intraLedgerUsdPaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationIntraLedgerUsdPaymentSendArgs, 'input'>>;
  lnAddressPaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationLnAddressPaymentSendArgs, 'input'>>;
  lnInvoiceCancel?: Resolver<ResolversTypes['SuccessPayload'], ParentType, ContextType, RequireFields<MutationLnInvoiceCancelArgs, 'input'>>;
  lnInvoiceCreate?: Resolver<ResolversTypes['LnInvoicePayload'], ParentType, ContextType, RequireFields<MutationLnInvoiceCreateArgs, 'input'>>;
  lnInvoiceCreateOnBehalfOfRecipient?: Resolver<ResolversTypes['LnInvoicePayload'], ParentType, ContextType, RequireFields<MutationLnInvoiceCreateOnBehalfOfRecipientArgs, 'input'>>;
  lnInvoiceFeeProbe?: Resolver<ResolversTypes['SatAmountPayload'], ParentType, ContextType, RequireFields<MutationLnInvoiceFeeProbeArgs, 'input'>>;
  lnInvoicePaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationLnInvoicePaymentSendArgs, 'input'>>;
  lnNoAmountInvoiceCreate?: Resolver<ResolversTypes['LnNoAmountInvoicePayload'], ParentType, ContextType, RequireFields<MutationLnNoAmountInvoiceCreateArgs, 'input'>>;
  lnNoAmountInvoiceCreateOnBehalfOfRecipient?: Resolver<ResolversTypes['LnNoAmountInvoicePayload'], ParentType, ContextType, RequireFields<MutationLnNoAmountInvoiceCreateOnBehalfOfRecipientArgs, 'input'>>;
  lnNoAmountInvoiceFeeProbe?: Resolver<ResolversTypes['SatAmountPayload'], ParentType, ContextType, RequireFields<MutationLnNoAmountInvoiceFeeProbeArgs, 'input'>>;
  lnNoAmountInvoicePaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationLnNoAmountInvoicePaymentSendArgs, 'input'>>;
  lnNoAmountUsdInvoiceFeeProbe?: Resolver<ResolversTypes['CentAmountPayload'], ParentType, ContextType, RequireFields<MutationLnNoAmountUsdInvoiceFeeProbeArgs, 'input'>>;
  lnNoAmountUsdInvoicePaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationLnNoAmountUsdInvoicePaymentSendArgs, 'input'>>;
  lnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipient?: Resolver<ResolversTypes['LnInvoicePayload'], ParentType, ContextType, RequireFields<MutationLnUsdInvoiceBtcDenominatedCreateOnBehalfOfRecipientArgs, 'input'>>;
  lnUsdInvoiceCreate?: Resolver<ResolversTypes['LnInvoicePayload'], ParentType, ContextType, RequireFields<MutationLnUsdInvoiceCreateArgs, 'input'>>;
  lnUsdInvoiceCreateOnBehalfOfRecipient?: Resolver<ResolversTypes['LnInvoicePayload'], ParentType, ContextType, RequireFields<MutationLnUsdInvoiceCreateOnBehalfOfRecipientArgs, 'input'>>;
  lnUsdInvoiceFeeProbe?: Resolver<ResolversTypes['SatAmountPayload'], ParentType, ContextType, RequireFields<MutationLnUsdInvoiceFeeProbeArgs, 'input'>>;
  lnurlPaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationLnurlPaymentSendArgs, 'input'>>;
  merchantMapSuggest?: Resolver<ResolversTypes['MerchantPayload'], ParentType, ContextType, RequireFields<MutationMerchantMapSuggestArgs, 'input'>>;
  onChainAddressCreate?: Resolver<ResolversTypes['OnChainAddressPayload'], ParentType, ContextType, RequireFields<MutationOnChainAddressCreateArgs, 'input'>>;
  onChainAddressCurrent?: Resolver<ResolversTypes['OnChainAddressPayload'], ParentType, ContextType, RequireFields<MutationOnChainAddressCurrentArgs, 'input'>>;
  onChainPaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationOnChainPaymentSendArgs, 'input'>>;
  onChainPaymentSendAll?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationOnChainPaymentSendAllArgs, 'input'>>;
  onChainUsdPaymentSend?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationOnChainUsdPaymentSendArgs, 'input'>>;
  onChainUsdPaymentSendAsBtcDenominated?: Resolver<ResolversTypes['PaymentSendPayload'], ParentType, ContextType, RequireFields<MutationOnChainUsdPaymentSendAsBtcDenominatedArgs, 'input'>>;
  onboardingFlowStart?: Resolver<ResolversTypes['OnboardingFlowStartResult'], ParentType, ContextType, RequireFields<MutationOnboardingFlowStartArgs, 'input'>>;
  quizClaim?: Resolver<ResolversTypes['QuizClaimPayload'], ParentType, ContextType, RequireFields<MutationQuizClaimArgs, 'input'>>;
  statefulNotificationAcknowledge?: Resolver<ResolversTypes['StatefulNotificationAcknowledgePayload'], ParentType, ContextType, RequireFields<MutationStatefulNotificationAcknowledgeArgs, 'input'>>;
  supportChatMessageAdd?: Resolver<ResolversTypes['SupportChatMessageAddPayload'], ParentType, ContextType, RequireFields<MutationSupportChatMessageAddArgs, 'input'>>;
  supportChatReset?: Resolver<ResolversTypes['SuccessPayload'], ParentType, ContextType>;
  userContactUpdateAlias?: Resolver<ResolversTypes['UserContactUpdateAliasPayload'], ParentType, ContextType, RequireFields<MutationUserContactUpdateAliasArgs, 'input'>>;
  userEmailDelete?: Resolver<ResolversTypes['UserEmailDeletePayload'], ParentType, ContextType>;
  userEmailRegistrationInitiate?: Resolver<ResolversTypes['UserEmailRegistrationInitiatePayload'], ParentType, ContextType, RequireFields<MutationUserEmailRegistrationInitiateArgs, 'input'>>;
  userEmailRegistrationValidate?: Resolver<ResolversTypes['UserEmailRegistrationValidatePayload'], ParentType, ContextType, RequireFields<MutationUserEmailRegistrationValidateArgs, 'input'>>;
  userLogin?: Resolver<ResolversTypes['AuthTokenPayload'], ParentType, ContextType, RequireFields<MutationUserLoginArgs, 'input'>>;
  userLoginUpgrade?: Resolver<ResolversTypes['UpgradePayload'], ParentType, ContextType, RequireFields<MutationUserLoginUpgradeArgs, 'input'>>;
  userLogout?: Resolver<ResolversTypes['SuccessPayload'], ParentType, ContextType, Partial<MutationUserLogoutArgs>>;
  userPhoneDelete?: Resolver<ResolversTypes['UserPhoneDeletePayload'], ParentType, ContextType>;
  userPhoneRegistrationInitiate?: Resolver<ResolversTypes['SuccessPayload'], ParentType, ContextType, RequireFields<MutationUserPhoneRegistrationInitiateArgs, 'input'>>;
  userPhoneRegistrationValidate?: Resolver<ResolversTypes['UserPhoneRegistrationValidatePayload'], ParentType, ContextType, RequireFields<MutationUserPhoneRegistrationValidateArgs, 'input'>>;
  userTotpDelete?: Resolver<ResolversTypes['UserTotpDeletePayload'], ParentType, ContextType>;
  userTotpRegistrationInitiate?: Resolver<ResolversTypes['UserTotpRegistrationInitiatePayload'], ParentType, ContextType>;
  userTotpRegistrationValidate?: Resolver<ResolversTypes['UserTotpRegistrationValidatePayload'], ParentType, ContextType, RequireFields<MutationUserTotpRegistrationValidateArgs, 'input'>>;
  userUpdateLanguage?: Resolver<ResolversTypes['UserUpdateLanguagePayload'], ParentType, ContextType, RequireFields<MutationUserUpdateLanguageArgs, 'input'>>;
  userUpdateUsername?: Resolver<ResolversTypes['UserUpdateUsernamePayload'], ParentType, ContextType, RequireFields<MutationUserUpdateUsernameArgs, 'input'>>;
};

export type MyUpdatesPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['MyUpdatesPayload'] = ResolversParentTypes['MyUpdatesPayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  update?: Resolver<Maybe<ResolversTypes['UserUpdate']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationAction'] = ResolversParentTypes['NotificationAction']> = {
  __resolveType: TypeResolveFn<'OpenDeepLinkAction' | 'OpenExternalLinkAction', ParentType, ContextType>;
};

export interface NotificationCategoryScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['NotificationCategory'], any> {
  name: 'NotificationCategory';
}

export type NotificationChannelSettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationChannelSettings'] = ResolversParentTypes['NotificationChannelSettings']> = {
  disabledCategories?: Resolver<ReadonlyArray<ResolversTypes['NotificationCategory']>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationSettingsResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationSettings'] = ResolversParentTypes['NotificationSettings']> = {
  push?: Resolver<ResolversTypes['NotificationChannelSettings'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface OnChainAddressScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['OnChainAddress'], any> {
  name: 'OnChainAddress';
}

export type OnChainAddressPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['OnChainAddressPayload'] = ResolversParentTypes['OnChainAddressPayload']> = {
  address?: Resolver<Maybe<ResolversTypes['OnChainAddress']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OnChainTxFeeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OnChainTxFee'] = ResolversParentTypes['OnChainTxFee']> = {
  amount?: Resolver<ResolversTypes['SatAmount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface OnChainTxHashScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['OnChainTxHash'], any> {
  name: 'OnChainTxHash';
}

export type OnChainUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['OnChainUpdate'] = ResolversParentTypes['OnChainUpdate']> = {
  amount?: Resolver<ResolversTypes['SatAmount'], ParentType, ContextType>;
  displayCurrencyPerSat?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  transaction?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
  txHash?: Resolver<ResolversTypes['OnChainTxHash'], ParentType, ContextType>;
  txNotificationType?: Resolver<ResolversTypes['TxNotificationType'], ParentType, ContextType>;
  usdPerSat?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  walletId?: Resolver<ResolversTypes['WalletId'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OnChainUsdTxFeeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OnChainUsdTxFee'] = ResolversParentTypes['OnChainUsdTxFee']> = {
  amount?: Resolver<ResolversTypes['CentAmount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OnboardingFlowStartResultResolvers<ContextType = any, ParentType extends ResolversParentTypes['OnboardingFlowStartResult'] = ResolversParentTypes['OnboardingFlowStartResult']> = {
  tokenAndroid?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tokenIos?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tokenWeb?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  workflowRunId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OneDayAccountLimitResolvers<ContextType = any, ParentType extends ResolversParentTypes['OneDayAccountLimit'] = ResolversParentTypes['OneDayAccountLimit']> = {
  interval?: Resolver<Maybe<ResolversTypes['Seconds']>, ParentType, ContextType>;
  remainingLimit?: Resolver<Maybe<ResolversTypes['CentAmount']>, ParentType, ContextType>;
  totalLimit?: Resolver<ResolversTypes['CentAmount'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface OneTimeAuthCodeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['OneTimeAuthCode'], any> {
  name: 'OneTimeAuthCode';
}

export type OpenDeepLinkActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OpenDeepLinkAction'] = ResolversParentTypes['OpenDeepLinkAction']> = {
  deepLink?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OpenExternalLinkActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OpenExternalLinkAction'] = ResolversParentTypes['OpenExternalLinkAction']> = {
  url?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface PaymentHashScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['PaymentHash'], any> {
  name: 'PaymentHash';
}

export type PaymentSendPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['PaymentSendPayload'] = ResolversParentTypes['PaymentSendPayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['PaymentSendResult']>, ParentType, ContextType>;
  transaction?: Resolver<Maybe<ResolversTypes['Transaction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface PhoneScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Phone'], any> {
  name: 'Phone';
}

export type PriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['Price'] = ResolversParentTypes['Price']> = {
  base?: Resolver<ResolversTypes['SafeInt'], ParentType, ContextType>;
  currencyUnit?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  formattedAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PriceInterfaceResolvers<ContextType = any, ParentType extends ResolversParentTypes['PriceInterface'] = ResolversParentTypes['PriceInterface']> = {
  __resolveType: TypeResolveFn<'PriceOfOneSatInMinorUnit' | 'PriceOfOneSettlementMinorUnitInDisplayMinorUnit' | 'PriceOfOneUsdCentInMinorUnit', ParentType, ContextType>;
  base?: Resolver<ResolversTypes['SafeInt'], ParentType, ContextType>;
  currencyUnit?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
};

export type PriceOfOneSatInMinorUnitResolvers<ContextType = any, ParentType extends ResolversParentTypes['PriceOfOneSatInMinorUnit'] = ResolversParentTypes['PriceOfOneSatInMinorUnit']> = {
  base?: Resolver<ResolversTypes['SafeInt'], ParentType, ContextType>;
  currencyUnit?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PriceOfOneSettlementMinorUnitInDisplayMinorUnitResolvers<ContextType = any, ParentType extends ResolversParentTypes['PriceOfOneSettlementMinorUnitInDisplayMinorUnit'] = ResolversParentTypes['PriceOfOneSettlementMinorUnitInDisplayMinorUnit']> = {
  base?: Resolver<ResolversTypes['SafeInt'], ParentType, ContextType>;
  currencyUnit?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  formattedAmount?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PriceOfOneUsdCentInMinorUnitResolvers<ContextType = any, ParentType extends ResolversParentTypes['PriceOfOneUsdCentInMinorUnit'] = ResolversParentTypes['PriceOfOneUsdCentInMinorUnit']> = {
  base?: Resolver<ResolversTypes['SafeInt'], ParentType, ContextType>;
  currencyUnit?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  offset?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PricePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['PricePayload'] = ResolversParentTypes['PricePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  price?: Resolver<Maybe<ResolversTypes['Price']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PricePointResolvers<ContextType = any, ParentType extends ResolversParentTypes['PricePoint'] = ResolversParentTypes['PricePoint']> = {
  price?: Resolver<ResolversTypes['Price'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PublicWalletResolvers<ContextType = any, ParentType extends ResolversParentTypes['PublicWallet'] = ResolversParentTypes['PublicWallet']> = {
  currency?: Resolver<ResolversTypes['WalletCurrency'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  walletCurrency?: Resolver<ResolversTypes['WalletCurrency'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  accountDefaultWallet?: Resolver<ResolversTypes['PublicWallet'], ParentType, ContextType, RequireFields<QueryAccountDefaultWalletArgs, 'username'>>;
  authorization?: Resolver<ResolversTypes['Authorization'], ParentType, ContextType>;
  beta?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  btcPriceList?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['PricePoint']>>>, ParentType, ContextType, RequireFields<QueryBtcPriceListArgs, 'range'>>;
  businessMapMarkers?: Resolver<ReadonlyArray<ResolversTypes['MapMarker']>, ParentType, ContextType>;
  colorScheme?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  countryCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  currencyConversionEstimation?: Resolver<ResolversTypes['CurrencyConversionEstimation'], ParentType, ContextType, RequireFields<QueryCurrencyConversionEstimationArgs, 'amount' | 'currency'>>;
  currencyList?: Resolver<ReadonlyArray<ResolversTypes['Currency']>, ParentType, ContextType>;
  feedbackModalShown?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  globals?: Resolver<Maybe<ResolversTypes['Globals']>, ParentType, ContextType>;
  hasPromptedSetDefaultAccount?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hiddenBalanceToolTip?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hideBalance?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  innerCircleValue?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  introducingCirclesModalShown?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  lnInvoicePaymentStatus?: Resolver<ResolversTypes['LnInvoicePaymentStatusPayload'], ParentType, ContextType, RequireFields<QueryLnInvoicePaymentStatusArgs, 'input'>>;
  lnInvoicePaymentStatusByHash?: Resolver<ResolversTypes['LnInvoicePaymentStatus'], ParentType, ContextType, RequireFields<QueryLnInvoicePaymentStatusByHashArgs, 'input'>>;
  lnInvoicePaymentStatusByPaymentRequest?: Resolver<ResolversTypes['LnInvoicePaymentStatus'], ParentType, ContextType, RequireFields<QueryLnInvoicePaymentStatusByPaymentRequestArgs, 'input'>>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  mobileVersions?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['MobileVersions']>>>, ParentType, ContextType>;
  onChainTxFee?: Resolver<ResolversTypes['OnChainTxFee'], ParentType, ContextType, RequireFields<QueryOnChainTxFeeArgs, 'address' | 'amount' | 'speed' | 'walletId'>>;
  onChainUsdTxFee?: Resolver<ResolversTypes['OnChainUsdTxFee'], ParentType, ContextType, RequireFields<QueryOnChainUsdTxFeeArgs, 'address' | 'amount' | 'speed' | 'walletId'>>;
  onChainUsdTxFeeAsBtcDenominated?: Resolver<ResolversTypes['OnChainUsdTxFee'], ParentType, ContextType, RequireFields<QueryOnChainUsdTxFeeAsBtcDenominatedArgs, 'address' | 'amount' | 'speed' | 'walletId'>>;
  price?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  realtimePrice?: Resolver<ResolversTypes['RealtimePrice'], ParentType, ContextType, RequireFields<QueryRealtimePriceArgs, 'currency'>>;
  region?: Resolver<Maybe<ResolversTypes['Region']>, ParentType, ContextType>;
  userDefaultWalletId?: Resolver<ResolversTypes['WalletId'], ParentType, ContextType, RequireFields<QueryUserDefaultWalletIdArgs, 'username'>>;
  usernameAvailable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryUsernameAvailableArgs, 'username'>>;
  welcomeLeaderboard?: Resolver<ResolversTypes['Leaderboard'], ParentType, ContextType, RequireFields<QueryWelcomeLeaderboardArgs, 'input'>>;
};

export type QuizResolvers<ContextType = any, ParentType extends ResolversParentTypes['Quiz'] = ResolversParentTypes['Quiz']> = {
  amount?: Resolver<ResolversTypes['SatAmount'], ParentType, ContextType>;
  completed?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  notBefore?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QuizClaimPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['QuizClaimPayload'] = ResolversParentTypes['QuizClaimPayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  quizzes?: Resolver<ReadonlyArray<ResolversTypes['Quiz']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RealtimePriceResolvers<ContextType = any, ParentType extends ResolversParentTypes['RealtimePrice'] = ResolversParentTypes['RealtimePrice']> = {
  btcSatPrice?: Resolver<ResolversTypes['PriceOfOneSatInMinorUnit'], ParentType, ContextType>;
  denominatorCurrency?: Resolver<ResolversTypes['DisplayCurrency'], ParentType, ContextType>;
  denominatorCurrencyDetails?: Resolver<ResolversTypes['Currency'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  usdCentPrice?: Resolver<ResolversTypes['PriceOfOneUsdCentInMinorUnit'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RealtimePricePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['RealtimePricePayload'] = ResolversParentTypes['RealtimePricePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  realtimePrice?: Resolver<Maybe<ResolversTypes['RealtimePrice']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type RegionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Region'] = ResolversParentTypes['Region']> = {
  latitude?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  latitudeDelta?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  longitude?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  longitudeDelta?: Resolver<ResolversTypes['Float'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SafeIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['SafeInt'], any> {
  name: 'SafeInt';
}

export interface SatAmountScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['SatAmount'], any> {
  name: 'SatAmount';
}

export type SatAmountPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['SatAmountPayload'] = ResolversParentTypes['SatAmountPayload']> = {
  amount?: Resolver<Maybe<ResolversTypes['SatAmount']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SecondsScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Seconds'], any> {
  name: 'Seconds';
}

export type SettlementViaResolvers<ContextType = any, ParentType extends ResolversParentTypes['SettlementVia'] = ResolversParentTypes['SettlementVia']> = {
  __resolveType: TypeResolveFn<'SettlementViaIntraLedger' | 'SettlementViaLn' | 'SettlementViaOnChain', ParentType, ContextType>;
};

export type SettlementViaIntraLedgerResolvers<ContextType = any, ParentType extends ResolversParentTypes['SettlementViaIntraLedger'] = ResolversParentTypes['SettlementViaIntraLedger']> = {
  counterPartyUsername?: Resolver<Maybe<ResolversTypes['Username']>, ParentType, ContextType>;
  counterPartyWalletId?: Resolver<Maybe<ResolversTypes['WalletId']>, ParentType, ContextType>;
  preImage?: Resolver<Maybe<ResolversTypes['LnPaymentPreImage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SettlementViaLnResolvers<ContextType = any, ParentType extends ResolversParentTypes['SettlementViaLn'] = ResolversParentTypes['SettlementViaLn']> = {
  paymentSecret?: Resolver<Maybe<ResolversTypes['LnPaymentSecret']>, ParentType, ContextType>;
  preImage?: Resolver<Maybe<ResolversTypes['LnPaymentPreImage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SettlementViaOnChainResolvers<ContextType = any, ParentType extends ResolversParentTypes['SettlementViaOnChain'] = ResolversParentTypes['SettlementViaOnChain']> = {
  arrivalInMempoolEstimatedAt?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  transactionHash?: Resolver<Maybe<ResolversTypes['OnChainTxHash']>, ParentType, ContextType>;
  vout?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SignedAmountScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['SignedAmount'], any> {
  name: 'SignedAmount';
}

export interface SignedDisplayMajorAmountScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['SignedDisplayMajorAmount'], any> {
  name: 'SignedDisplayMajorAmount';
}

export type StatefulNotificationResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatefulNotification'] = ResolversParentTypes['StatefulNotification']> = {
  acknowledgedAt?: Resolver<Maybe<ResolversTypes['Timestamp']>, ParentType, ContextType>;
  action?: Resolver<Maybe<ResolversTypes['NotificationAction']>, ParentType, ContextType>;
  body?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  bulletinEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  deepLink?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['Icon']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  title?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatefulNotificationAcknowledgePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatefulNotificationAcknowledgePayload'] = ResolversParentTypes['StatefulNotificationAcknowledgePayload']> = {
  notification?: Resolver<ResolversTypes['StatefulNotification'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatefulNotificationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatefulNotificationConnection'] = ResolversParentTypes['StatefulNotificationConnection']> = {
  edges?: Resolver<ReadonlyArray<ResolversTypes['StatefulNotificationEdge']>, ParentType, ContextType>;
  nodes?: Resolver<ReadonlyArray<ResolversTypes['StatefulNotification']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type StatefulNotificationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['StatefulNotificationEdge'] = ResolversParentTypes['StatefulNotificationEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['StatefulNotification'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SubscriptionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Subscription'] = ResolversParentTypes['Subscription']> = {
  lnInvoicePaymentStatus?: SubscriptionResolver<ResolversTypes['LnInvoicePaymentStatusPayload'], "lnInvoicePaymentStatus", ParentType, ContextType, RequireFields<SubscriptionLnInvoicePaymentStatusArgs, 'input'>>;
  lnInvoicePaymentStatusByHash?: SubscriptionResolver<ResolversTypes['LnInvoicePaymentStatusPayload'], "lnInvoicePaymentStatusByHash", ParentType, ContextType, RequireFields<SubscriptionLnInvoicePaymentStatusByHashArgs, 'input'>>;
  lnInvoicePaymentStatusByPaymentRequest?: SubscriptionResolver<ResolversTypes['LnInvoicePaymentStatusPayload'], "lnInvoicePaymentStatusByPaymentRequest", ParentType, ContextType, RequireFields<SubscriptionLnInvoicePaymentStatusByPaymentRequestArgs, 'input'>>;
  myUpdates?: SubscriptionResolver<ResolversTypes['MyUpdatesPayload'], "myUpdates", ParentType, ContextType>;
  price?: SubscriptionResolver<ResolversTypes['PricePayload'], "price", ParentType, ContextType, RequireFields<SubscriptionPriceArgs, 'input'>>;
  realtimePrice?: SubscriptionResolver<ResolversTypes['RealtimePricePayload'], "realtimePrice", ParentType, ContextType, RequireFields<SubscriptionRealtimePriceArgs, 'input'>>;
};

export type SuccessPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['SuccessPayload'] = ResolversParentTypes['SuccessPayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  success?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SupportChatMessageAddPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['SupportChatMessageAddPayload'] = ResolversParentTypes['SupportChatMessageAddPayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  supportMessage?: Resolver<Maybe<ReadonlyArray<Maybe<ResolversTypes['SupportMessage']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SupportMessageResolvers<ContextType = any, ParentType extends ResolversParentTypes['SupportMessage'] = ResolversParentTypes['SupportMessage']> = {
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  message?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  role?: Resolver<ResolversTypes['SupportRole'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface TimestampScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Timestamp'], any> {
  name: 'Timestamp';
}

export interface TotpCodeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['TotpCode'], any> {
  name: 'TotpCode';
}

export interface TotpRegistrationIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['TotpRegistrationId'], any> {
  name: 'TotpRegistrationId';
}

export interface TotpSecretScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['TotpSecret'], any> {
  name: 'TotpSecret';
}

export type TransactionResolvers<ContextType = any, ParentType extends ResolversParentTypes['Transaction'] = ResolversParentTypes['Transaction']> = {
  createdAt?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  direction?: Resolver<ResolversTypes['TxDirection'], ParentType, ContextType>;
  externalId?: Resolver<Maybe<ResolversTypes['TxExternalId']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  initiationVia?: Resolver<ResolversTypes['InitiationVia'], ParentType, ContextType>;
  memo?: Resolver<Maybe<ResolversTypes['Memo']>, ParentType, ContextType>;
  settlementAmount?: Resolver<ResolversTypes['SignedAmount'], ParentType, ContextType>;
  settlementCurrency?: Resolver<ResolversTypes['WalletCurrency'], ParentType, ContextType>;
  settlementDisplayAmount?: Resolver<ResolversTypes['SignedDisplayMajorAmount'], ParentType, ContextType>;
  settlementDisplayCurrency?: Resolver<ResolversTypes['DisplayCurrency'], ParentType, ContextType>;
  settlementDisplayFee?: Resolver<ResolversTypes['SignedDisplayMajorAmount'], ParentType, ContextType>;
  settlementFee?: Resolver<ResolversTypes['SignedAmount'], ParentType, ContextType>;
  settlementPrice?: Resolver<ResolversTypes['PriceOfOneSettlementMinorUnitInDisplayMinorUnit'], ParentType, ContextType>;
  settlementVia?: Resolver<ResolversTypes['SettlementVia'], ParentType, ContextType>;
  status?: Resolver<ResolversTypes['TxStatus'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionConnection'] = ResolversParentTypes['TransactionConnection']> = {
  edges?: Resolver<Maybe<ReadonlyArray<ResolversTypes['TransactionEdge']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TransactionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TransactionEdge'] = ResolversParentTypes['TransactionEdge']> = {
  cursor?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  node?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface TxExternalIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['TxExternalId'], any> {
  name: 'TxExternalId';
}

export type UpgradePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpgradePayload'] = ResolversParentTypes['UpgradePayload']> = {
  authToken?: Resolver<Maybe<ResolversTypes['AuthToken']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  success?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UsdWalletResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsdWallet'] = ResolversParentTypes['UsdWallet']> = {
  accountId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  balance?: Resolver<ResolversTypes['SignedAmount'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoiceByPaymentHash?: Resolver<ResolversTypes['Invoice'], ParentType, ContextType, RequireFields<UsdWalletInvoiceByPaymentHashArgs, 'paymentHash'>>;
  invoices?: Resolver<Maybe<ResolversTypes['InvoiceConnection']>, ParentType, ContextType, Partial<UsdWalletInvoicesArgs>>;
  pendingIncomingBalance?: Resolver<ResolversTypes['SignedAmount'], ParentType, ContextType>;
  pendingIncomingTransactions?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType>;
  pendingIncomingTransactionsByAddress?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<UsdWalletPendingIncomingTransactionsByAddressArgs, 'address'>>;
  transactionById?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<UsdWalletTransactionByIdArgs, 'transactionId'>>;
  transactions?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, Partial<UsdWalletTransactionsArgs>>;
  transactionsByAddress?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, RequireFields<UsdWalletTransactionsByAddressArgs, 'address'>>;
  transactionsByPaymentHash?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<UsdWalletTransactionsByPaymentHashArgs, 'paymentHash'>>;
  transactionsByPaymentRequest?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<UsdWalletTransactionsByPaymentRequestArgs, 'paymentRequest'>>;
  walletCurrency?: Resolver<ResolversTypes['WalletCurrency'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  apiKeys?: Resolver<ReadonlyArray<ResolversTypes['ApiKey']>, ParentType, ContextType>;
  contactByUsername?: Resolver<ResolversTypes['UserContact'], ParentType, ContextType, RequireFields<UserContactByUsernameArgs, 'username'>>;
  contacts?: Resolver<ReadonlyArray<ResolversTypes['UserContact']>, ParentType, ContextType>;
  createdAt?: Resolver<ResolversTypes['Timestamp'], ParentType, ContextType>;
  defaultAccount?: Resolver<ResolversTypes['Account'], ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['Email']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  language?: Resolver<ResolversTypes['Language'], ParentType, ContextType>;
  phone?: Resolver<Maybe<ResolversTypes['Phone']>, ParentType, ContextType>;
  statefulNotifications?: Resolver<ResolversTypes['StatefulNotificationConnection'], ParentType, ContextType, RequireFields<UserStatefulNotificationsArgs, 'first'>>;
  statefulNotificationsWithoutBulletinEnabled?: Resolver<ResolversTypes['StatefulNotificationConnection'], ParentType, ContextType, RequireFields<UserStatefulNotificationsWithoutBulletinEnabledArgs, 'first'>>;
  supportChat?: Resolver<ReadonlyArray<ResolversTypes['SupportMessage']>, ParentType, ContextType>;
  totpEnabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  unacknowledgedStatefulNotificationsWithBulletinEnabled?: Resolver<ResolversTypes['StatefulNotificationConnection'], ParentType, ContextType, RequireFields<UserUnacknowledgedStatefulNotificationsWithBulletinEnabledArgs, 'first'>>;
  unacknowledgedStatefulNotificationsWithoutBulletinEnabledCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['Username']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserContactResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserContact'] = ResolversParentTypes['UserContact']> = {
  alias?: Resolver<Maybe<ResolversTypes['ContactAlias']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Username'], ParentType, ContextType>;
  transactions?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, Partial<UserContactTransactionsArgs>>;
  transactionsCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  username?: Resolver<ResolversTypes['Username'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserContactUpdateAliasPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserContactUpdateAliasPayload'] = ResolversParentTypes['UserContactUpdateAliasPayload']> = {
  contact?: Resolver<Maybe<ResolversTypes['UserContact']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEmailDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEmailDeletePayload'] = ResolversParentTypes['UserEmailDeletePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEmailRegistrationInitiatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEmailRegistrationInitiatePayload'] = ResolversParentTypes['UserEmailRegistrationInitiatePayload']> = {
  emailRegistrationId?: Resolver<Maybe<ResolversTypes['EmailRegistrationId']>, ParentType, ContextType>;
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserEmailRegistrationValidatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserEmailRegistrationValidatePayload'] = ResolversParentTypes['UserEmailRegistrationValidatePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserPhoneDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserPhoneDeletePayload'] = ResolversParentTypes['UserPhoneDeletePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserPhoneRegistrationValidatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserPhoneRegistrationValidatePayload'] = ResolversParentTypes['UserPhoneRegistrationValidatePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserTotpDeletePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserTotpDeletePayload'] = ResolversParentTypes['UserTotpDeletePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserTotpRegistrationInitiatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserTotpRegistrationInitiatePayload'] = ResolversParentTypes['UserTotpRegistrationInitiatePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  totpRegistrationId?: Resolver<Maybe<ResolversTypes['TotpRegistrationId']>, ParentType, ContextType>;
  totpSecret?: Resolver<Maybe<ResolversTypes['TotpSecret']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserTotpRegistrationValidatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserTotpRegistrationValidatePayload'] = ResolversParentTypes['UserTotpRegistrationValidatePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  me?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserUpdateResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserUpdate'] = ResolversParentTypes['UserUpdate']> = {
  __resolveType: TypeResolveFn<'IntraLedgerUpdate' | 'LnUpdate' | 'OnChainUpdate' | 'Price' | 'RealtimePrice', ParentType, ContextType>;
};

export type UserUpdateLanguagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserUpdateLanguagePayload'] = ResolversParentTypes['UserUpdateLanguagePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserUpdateUsernamePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserUpdateUsernamePayload'] = ResolversParentTypes['UserUpdateUsernamePayload']> = {
  errors?: Resolver<ReadonlyArray<ResolversTypes['Error']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface UsernameScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Username'], any> {
  name: 'Username';
}

export type WalletResolvers<ContextType = any, ParentType extends ResolversParentTypes['Wallet'] = ResolversParentTypes['Wallet']> = {
  __resolveType: TypeResolveFn<'BTCWallet' | 'UsdWallet', ParentType, ContextType>;
  accountId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  balance?: Resolver<ResolversTypes['SignedAmount'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  invoiceByPaymentHash?: Resolver<ResolversTypes['Invoice'], ParentType, ContextType, RequireFields<WalletInvoiceByPaymentHashArgs, 'paymentHash'>>;
  invoices?: Resolver<Maybe<ResolversTypes['InvoiceConnection']>, ParentType, ContextType, Partial<WalletInvoicesArgs>>;
  pendingIncomingBalance?: Resolver<ResolversTypes['SignedAmount'], ParentType, ContextType>;
  pendingIncomingTransactions?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType>;
  pendingIncomingTransactionsByAddress?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<WalletPendingIncomingTransactionsByAddressArgs, 'address'>>;
  transactionById?: Resolver<ResolversTypes['Transaction'], ParentType, ContextType, RequireFields<WalletTransactionByIdArgs, 'transactionId'>>;
  transactions?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, Partial<WalletTransactionsArgs>>;
  transactionsByAddress?: Resolver<Maybe<ResolversTypes['TransactionConnection']>, ParentType, ContextType, RequireFields<WalletTransactionsByAddressArgs, 'address'>>;
  transactionsByPaymentHash?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<WalletTransactionsByPaymentHashArgs, 'paymentHash'>>;
  transactionsByPaymentRequest?: Resolver<ReadonlyArray<ResolversTypes['Transaction']>, ParentType, ContextType, RequireFields<WalletTransactionsByPaymentRequestArgs, 'paymentRequest'>>;
  walletCurrency?: Resolver<ResolversTypes['WalletCurrency'], ParentType, ContextType>;
};

export interface WalletIdScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['WalletId'], any> {
  name: 'WalletId';
}

export type WelcomeProfileResolvers<ContextType = any, ParentType extends ResolversParentTypes['WelcomeProfile'] = ResolversParentTypes['WelcomeProfile']> = {
  allTimePoints?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  allTimeRank?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  innerCircleAllTimeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  innerCircleThisMonthCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  leaderboardName?: Resolver<Maybe<ResolversTypes['LeaderboardName']>, ParentType, ContextType>;
  outerCircleAllTimeCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  outerCircleThisMonthCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  thisMonthPoints?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  thisMonthRank?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  Account?: AccountResolvers<ContextType>;
  AccountDeletePayload?: AccountDeletePayloadResolvers<ContextType>;
  AccountLimit?: AccountLimitResolvers<ContextType>;
  AccountLimits?: AccountLimitsResolvers<ContextType>;
  AccountUpdateDefaultWalletIdPayload?: AccountUpdateDefaultWalletIdPayloadResolvers<ContextType>;
  AccountUpdateDisplayCurrencyPayload?: AccountUpdateDisplayCurrencyPayloadResolvers<ContextType>;
  AccountUpdateNotificationSettingsPayload?: AccountUpdateNotificationSettingsPayloadResolvers<ContextType>;
  ApiKey?: ApiKeyResolvers<ContextType>;
  ApiKeyCreatePayload?: ApiKeyCreatePayloadResolvers<ContextType>;
  ApiKeyRevokePayload?: ApiKeyRevokePayloadResolvers<ContextType>;
  AuthToken?: GraphQLScalarType;
  AuthTokenPayload?: AuthTokenPayloadResolvers<ContextType>;
  Authorization?: AuthorizationResolvers<ContextType>;
  BTCWallet?: BtcWalletResolvers<ContextType>;
  BuildInformation?: BuildInformationResolvers<ContextType>;
  CallbackEndpoint?: CallbackEndpointResolvers<ContextType>;
  CallbackEndpointAddPayload?: CallbackEndpointAddPayloadResolvers<ContextType>;
  CaptchaCreateChallengePayload?: CaptchaCreateChallengePayloadResolvers<ContextType>;
  CaptchaCreateChallengeResult?: CaptchaCreateChallengeResultResolvers<ContextType>;
  CentAmount?: GraphQLScalarType;
  CentAmountPayload?: CentAmountPayloadResolvers<ContextType>;
  ConsumerAccount?: ConsumerAccountResolvers<ContextType>;
  Contact?: ContactResolvers<ContextType>;
  ContactAlias?: GraphQLScalarType;
  Coordinates?: CoordinatesResolvers<ContextType>;
  Country?: CountryResolvers<ContextType>;
  CountryCode?: GraphQLScalarType;
  Currency?: CurrencyResolvers<ContextType>;
  CurrencyConversionEstimation?: CurrencyConversionEstimationResolvers<ContextType>;
  DepositFeesInformation?: DepositFeesInformationResolvers<ContextType>;
  DisplayCurrency?: GraphQLScalarType;
  Email?: EmailResolvers<ContextType>;
  EmailAddress?: GraphQLScalarType;
  EmailRegistrationId?: GraphQLScalarType;
  EndpointId?: GraphQLScalarType;
  EndpointUrl?: GraphQLScalarType;
  Error?: ErrorResolvers<ContextType>;
  Feedback?: GraphQLScalarType;
  FeesInformation?: FeesInformationResolvers<ContextType>;
  Globals?: GlobalsResolvers<ContextType>;
  GraphQLApplicationError?: GraphQlApplicationErrorResolvers<ContextType>;
  Hex32Bytes?: GraphQLScalarType;
  InitiationVia?: InitiationViaResolvers<ContextType>;
  InitiationViaIntraLedger?: InitiationViaIntraLedgerResolvers<ContextType>;
  InitiationViaLn?: InitiationViaLnResolvers<ContextType>;
  InitiationViaOnChain?: InitiationViaOnChainResolvers<ContextType>;
  IntraLedgerUpdate?: IntraLedgerUpdateResolvers<ContextType>;
  Invoice?: InvoiceResolvers<ContextType>;
  InvoiceConnection?: InvoiceConnectionResolvers<ContextType>;
  InvoiceEdge?: InvoiceEdgeResolvers<ContextType>;
  Language?: GraphQLScalarType;
  Leader?: LeaderResolvers<ContextType>;
  Leaderboard?: LeaderboardResolvers<ContextType>;
  LeaderboardName?: GraphQLScalarType;
  LnInvoice?: LnInvoiceResolvers<ContextType>;
  LnInvoicePayload?: LnInvoicePayloadResolvers<ContextType>;
  LnInvoicePaymentStatus?: LnInvoicePaymentStatusResolvers<ContextType>;
  LnInvoicePaymentStatusPayload?: LnInvoicePaymentStatusPayloadResolvers<ContextType>;
  LnNoAmountInvoice?: LnNoAmountInvoiceResolvers<ContextType>;
  LnNoAmountInvoicePayload?: LnNoAmountInvoicePayloadResolvers<ContextType>;
  LnPaymentPreImage?: GraphQLScalarType;
  LnPaymentRequest?: GraphQLScalarType;
  LnPaymentSecret?: GraphQLScalarType;
  LnUpdate?: LnUpdateResolvers<ContextType>;
  MapInfo?: MapInfoResolvers<ContextType>;
  MapMarker?: MapMarkerResolvers<ContextType>;
  Memo?: GraphQLScalarType;
  Merchant?: MerchantResolvers<ContextType>;
  MerchantPayload?: MerchantPayloadResolvers<ContextType>;
  Minutes?: GraphQLScalarType;
  MobileVersions?: MobileVersionsResolvers<ContextType>;
  Mutation?: MutationResolvers<ContextType>;
  MyUpdatesPayload?: MyUpdatesPayloadResolvers<ContextType>;
  NotificationAction?: NotificationActionResolvers<ContextType>;
  NotificationCategory?: GraphQLScalarType;
  NotificationChannelSettings?: NotificationChannelSettingsResolvers<ContextType>;
  NotificationSettings?: NotificationSettingsResolvers<ContextType>;
  OnChainAddress?: GraphQLScalarType;
  OnChainAddressPayload?: OnChainAddressPayloadResolvers<ContextType>;
  OnChainTxFee?: OnChainTxFeeResolvers<ContextType>;
  OnChainTxHash?: GraphQLScalarType;
  OnChainUpdate?: OnChainUpdateResolvers<ContextType>;
  OnChainUsdTxFee?: OnChainUsdTxFeeResolvers<ContextType>;
  OnboardingFlowStartResult?: OnboardingFlowStartResultResolvers<ContextType>;
  OneDayAccountLimit?: OneDayAccountLimitResolvers<ContextType>;
  OneTimeAuthCode?: GraphQLScalarType;
  OpenDeepLinkAction?: OpenDeepLinkActionResolvers<ContextType>;
  OpenExternalLinkAction?: OpenExternalLinkActionResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PaymentHash?: GraphQLScalarType;
  PaymentSendPayload?: PaymentSendPayloadResolvers<ContextType>;
  Phone?: GraphQLScalarType;
  Price?: PriceResolvers<ContextType>;
  PriceInterface?: PriceInterfaceResolvers<ContextType>;
  PriceOfOneSatInMinorUnit?: PriceOfOneSatInMinorUnitResolvers<ContextType>;
  PriceOfOneSettlementMinorUnitInDisplayMinorUnit?: PriceOfOneSettlementMinorUnitInDisplayMinorUnitResolvers<ContextType>;
  PriceOfOneUsdCentInMinorUnit?: PriceOfOneUsdCentInMinorUnitResolvers<ContextType>;
  PricePayload?: PricePayloadResolvers<ContextType>;
  PricePoint?: PricePointResolvers<ContextType>;
  PublicWallet?: PublicWalletResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Quiz?: QuizResolvers<ContextType>;
  QuizClaimPayload?: QuizClaimPayloadResolvers<ContextType>;
  RealtimePrice?: RealtimePriceResolvers<ContextType>;
  RealtimePricePayload?: RealtimePricePayloadResolvers<ContextType>;
  Region?: RegionResolvers<ContextType>;
  SafeInt?: GraphQLScalarType;
  SatAmount?: GraphQLScalarType;
  SatAmountPayload?: SatAmountPayloadResolvers<ContextType>;
  Seconds?: GraphQLScalarType;
  SettlementVia?: SettlementViaResolvers<ContextType>;
  SettlementViaIntraLedger?: SettlementViaIntraLedgerResolvers<ContextType>;
  SettlementViaLn?: SettlementViaLnResolvers<ContextType>;
  SettlementViaOnChain?: SettlementViaOnChainResolvers<ContextType>;
  SignedAmount?: GraphQLScalarType;
  SignedDisplayMajorAmount?: GraphQLScalarType;
  StatefulNotification?: StatefulNotificationResolvers<ContextType>;
  StatefulNotificationAcknowledgePayload?: StatefulNotificationAcknowledgePayloadResolvers<ContextType>;
  StatefulNotificationConnection?: StatefulNotificationConnectionResolvers<ContextType>;
  StatefulNotificationEdge?: StatefulNotificationEdgeResolvers<ContextType>;
  Subscription?: SubscriptionResolvers<ContextType>;
  SuccessPayload?: SuccessPayloadResolvers<ContextType>;
  SupportChatMessageAddPayload?: SupportChatMessageAddPayloadResolvers<ContextType>;
  SupportMessage?: SupportMessageResolvers<ContextType>;
  Timestamp?: GraphQLScalarType;
  TotpCode?: GraphQLScalarType;
  TotpRegistrationId?: GraphQLScalarType;
  TotpSecret?: GraphQLScalarType;
  Transaction?: TransactionResolvers<ContextType>;
  TransactionConnection?: TransactionConnectionResolvers<ContextType>;
  TransactionEdge?: TransactionEdgeResolvers<ContextType>;
  TxExternalId?: GraphQLScalarType;
  UpgradePayload?: UpgradePayloadResolvers<ContextType>;
  UsdWallet?: UsdWalletResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserContact?: UserContactResolvers<ContextType>;
  UserContactUpdateAliasPayload?: UserContactUpdateAliasPayloadResolvers<ContextType>;
  UserEmailDeletePayload?: UserEmailDeletePayloadResolvers<ContextType>;
  UserEmailRegistrationInitiatePayload?: UserEmailRegistrationInitiatePayloadResolvers<ContextType>;
  UserEmailRegistrationValidatePayload?: UserEmailRegistrationValidatePayloadResolvers<ContextType>;
  UserPhoneDeletePayload?: UserPhoneDeletePayloadResolvers<ContextType>;
  UserPhoneRegistrationValidatePayload?: UserPhoneRegistrationValidatePayloadResolvers<ContextType>;
  UserTotpDeletePayload?: UserTotpDeletePayloadResolvers<ContextType>;
  UserTotpRegistrationInitiatePayload?: UserTotpRegistrationInitiatePayloadResolvers<ContextType>;
  UserTotpRegistrationValidatePayload?: UserTotpRegistrationValidatePayloadResolvers<ContextType>;
  UserUpdate?: UserUpdateResolvers<ContextType>;
  UserUpdateLanguagePayload?: UserUpdateLanguagePayloadResolvers<ContextType>;
  UserUpdateUsernamePayload?: UserUpdateUsernamePayloadResolvers<ContextType>;
  Username?: GraphQLScalarType;
  Wallet?: WalletResolvers<ContextType>;
  WalletId?: GraphQLScalarType;
  WelcomeProfile?: WelcomeProfileResolvers<ContextType>;
};

export type DirectiveResolvers<ContextType = any> = {
  defer?: DeferDirectiveResolver<any, any, ContextType>;
};
