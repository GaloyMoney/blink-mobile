/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const lnrpc = $root.lnrpc = (() => {

    /**
     * Namespace lnrpc.
     * @exports lnrpc
     * @namespace
     */
    const lnrpc = {};

    lnrpc.WalletUnlocker = (function() {

        /**
         * Constructs a new WalletUnlocker service.
         * @memberof lnrpc
         * @classdesc Represents a WalletUnlocker
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function WalletUnlocker(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (WalletUnlocker.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = WalletUnlocker;

        /**
         * Creates new WalletUnlocker service using the specified rpc implementation.
         * @function create
         * @memberof lnrpc.WalletUnlocker
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {WalletUnlocker} RPC service. Useful where requests and/or responses are streamed.
         */
        WalletUnlocker.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link lnrpc.WalletUnlocker#genSeed}.
         * @memberof lnrpc.WalletUnlocker
         * @typedef GenSeedCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GenSeedResponse} [response] GenSeedResponse
         */

        /**
         * GenSeed is the first method that should be used to instantiate a new lnd
         * instance. This method allows a caller to generate a new aezeed cipher seed
         * given an optional passphrase. If provided, the passphrase will be necessary
         * to decrypt the cipherseed to expose the internal wallet seed.
         * 
         * Once the cipherseed is obtained and verified by the user, the InitWallet
         * method should be used to commit the newly generated seed, and create the
         * wallet.
         * @function genSeed
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IGenSeedRequest} request GenSeedRequest message or plain object
         * @param {lnrpc.WalletUnlocker.GenSeedCallback} callback Node-style callback called with the error, if any, and GenSeedResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(WalletUnlocker.prototype.genSeed = function genSeed(request, callback) {
            return this.rpcCall(genSeed, $root.lnrpc.GenSeedRequest, $root.lnrpc.GenSeedResponse, request, callback);
        }, "name", { value: "GenSeed" });

        /**
         * GenSeed is the first method that should be used to instantiate a new lnd
         * instance. This method allows a caller to generate a new aezeed cipher seed
         * given an optional passphrase. If provided, the passphrase will be necessary
         * to decrypt the cipherseed to expose the internal wallet seed.
         * 
         * Once the cipherseed is obtained and verified by the user, the InitWallet
         * method should be used to commit the newly generated seed, and create the
         * wallet.
         * @function genSeed
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IGenSeedRequest} request GenSeedRequest message or plain object
         * @returns {Promise<lnrpc.GenSeedResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.WalletUnlocker#initWallet}.
         * @memberof lnrpc.WalletUnlocker
         * @typedef InitWalletCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.InitWalletResponse} [response] InitWalletResponse
         */

        /**
         * InitWallet is used when lnd is starting up for the first time to fully
         * initialize the daemon and its internal wallet. At the very least a wallet
         * password must be provided. This will be used to encrypt sensitive material
         * on disk.
         * 
         * In the case of a recovery scenario, the user can also specify their aezeed
         * mnemonic and passphrase. If set, then the daemon will use this prior state
         * to initialize its internal wallet.
         * 
         * Alternatively, this can be used along with the GenSeed RPC to obtain a
         * seed, then present it to the user. Once it has been verified by the user,
         * the seed can be fed into this RPC in order to commit the new wallet.
         * @function initWallet
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IInitWalletRequest} request InitWalletRequest message or plain object
         * @param {lnrpc.WalletUnlocker.InitWalletCallback} callback Node-style callback called with the error, if any, and InitWalletResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(WalletUnlocker.prototype.initWallet = function initWallet(request, callback) {
            return this.rpcCall(initWallet, $root.lnrpc.InitWalletRequest, $root.lnrpc.InitWalletResponse, request, callback);
        }, "name", { value: "InitWallet" });

        /**
         * InitWallet is used when lnd is starting up for the first time to fully
         * initialize the daemon and its internal wallet. At the very least a wallet
         * password must be provided. This will be used to encrypt sensitive material
         * on disk.
         * 
         * In the case of a recovery scenario, the user can also specify their aezeed
         * mnemonic and passphrase. If set, then the daemon will use this prior state
         * to initialize its internal wallet.
         * 
         * Alternatively, this can be used along with the GenSeed RPC to obtain a
         * seed, then present it to the user. Once it has been verified by the user,
         * the seed can be fed into this RPC in order to commit the new wallet.
         * @function initWallet
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IInitWalletRequest} request InitWalletRequest message or plain object
         * @returns {Promise<lnrpc.InitWalletResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.WalletUnlocker#unlockWallet}.
         * @memberof lnrpc.WalletUnlocker
         * @typedef UnlockWalletCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.UnlockWalletResponse} [response] UnlockWalletResponse
         */

        /**
         * lncli: `unlock`
         * UnlockWallet is used at startup of lnd to provide a password to unlock
         * the wallet database.
         * @function unlockWallet
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IUnlockWalletRequest} request UnlockWalletRequest message or plain object
         * @param {lnrpc.WalletUnlocker.UnlockWalletCallback} callback Node-style callback called with the error, if any, and UnlockWalletResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(WalletUnlocker.prototype.unlockWallet = function unlockWallet(request, callback) {
            return this.rpcCall(unlockWallet, $root.lnrpc.UnlockWalletRequest, $root.lnrpc.UnlockWalletResponse, request, callback);
        }, "name", { value: "UnlockWallet" });

        /**
         * lncli: `unlock`
         * UnlockWallet is used at startup of lnd to provide a password to unlock
         * the wallet database.
         * @function unlockWallet
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IUnlockWalletRequest} request UnlockWalletRequest message or plain object
         * @returns {Promise<lnrpc.UnlockWalletResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.WalletUnlocker#changePassword}.
         * @memberof lnrpc.WalletUnlocker
         * @typedef ChangePasswordCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChangePasswordResponse} [response] ChangePasswordResponse
         */

        /**
         * lncli: `changepassword`
         * ChangePassword changes the password of the encrypted wallet. This will
         * automatically unlock the wallet database if successful.
         * @function changePassword
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IChangePasswordRequest} request ChangePasswordRequest message or plain object
         * @param {lnrpc.WalletUnlocker.ChangePasswordCallback} callback Node-style callback called with the error, if any, and ChangePasswordResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(WalletUnlocker.prototype.changePassword = function changePassword(request, callback) {
            return this.rpcCall(changePassword, $root.lnrpc.ChangePasswordRequest, $root.lnrpc.ChangePasswordResponse, request, callback);
        }, "name", { value: "ChangePassword" });

        /**
         * lncli: `changepassword`
         * ChangePassword changes the password of the encrypted wallet. This will
         * automatically unlock the wallet database if successful.
         * @function changePassword
         * @memberof lnrpc.WalletUnlocker
         * @instance
         * @param {lnrpc.IChangePasswordRequest} request ChangePasswordRequest message or plain object
         * @returns {Promise<lnrpc.ChangePasswordResponse>} Promise
         * @variation 2
         */

        return WalletUnlocker;
    })();

    lnrpc.GenSeedRequest = (function() {

        /**
         * Properties of a GenSeedRequest.
         * @memberof lnrpc
         * @interface IGenSeedRequest
         * @property {Uint8Array|null} [aezeedPassphrase] aezeed_passphrase is an optional user provided passphrase that will be used
         * to encrypt the generated aezeed cipher seed.
         * @property {Uint8Array|null} [seedEntropy] seed_entropy is an optional 16-bytes generated via CSPRNG. If not
         * specified, then a fresh set of randomness will be used to create the seed.
         */

        /**
         * Constructs a new GenSeedRequest.
         * @memberof lnrpc
         * @classdesc Represents a GenSeedRequest.
         * @implements IGenSeedRequest
         * @constructor
         * @param {lnrpc.IGenSeedRequest=} [properties] Properties to set
         */
        function GenSeedRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * aezeed_passphrase is an optional user provided passphrase that will be used
         * to encrypt the generated aezeed cipher seed.
         * @member {Uint8Array} aezeedPassphrase
         * @memberof lnrpc.GenSeedRequest
         * @instance
         */
        GenSeedRequest.prototype.aezeedPassphrase = $util.newBuffer([]);

        /**
         * seed_entropy is an optional 16-bytes generated via CSPRNG. If not
         * specified, then a fresh set of randomness will be used to create the seed.
         * @member {Uint8Array} seedEntropy
         * @memberof lnrpc.GenSeedRequest
         * @instance
         */
        GenSeedRequest.prototype.seedEntropy = $util.newBuffer([]);

        /**
         * Creates a new GenSeedRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {lnrpc.IGenSeedRequest=} [properties] Properties to set
         * @returns {lnrpc.GenSeedRequest} GenSeedRequest instance
         */
        GenSeedRequest.create = function create(properties) {
            return new GenSeedRequest(properties);
        };

        /**
         * Encodes the specified GenSeedRequest message. Does not implicitly {@link lnrpc.GenSeedRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {lnrpc.IGenSeedRequest} message GenSeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenSeedRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.aezeedPassphrase);
            if (message.seedEntropy != null && message.hasOwnProperty("seedEntropy"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.seedEntropy);
            return writer;
        };

        /**
         * Encodes the specified GenSeedRequest message, length delimited. Does not implicitly {@link lnrpc.GenSeedRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {lnrpc.IGenSeedRequest} message GenSeedRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenSeedRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenSeedRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GenSeedRequest} GenSeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenSeedRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GenSeedRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.aezeedPassphrase = reader.bytes();
                    break;
                case 2:
                    message.seedEntropy = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenSeedRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GenSeedRequest} GenSeedRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenSeedRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenSeedRequest message.
         * @function verify
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenSeedRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                if (!(message.aezeedPassphrase && typeof message.aezeedPassphrase.length === "number" || $util.isString(message.aezeedPassphrase)))
                    return "aezeedPassphrase: buffer expected";
            if (message.seedEntropy != null && message.hasOwnProperty("seedEntropy"))
                if (!(message.seedEntropy && typeof message.seedEntropy.length === "number" || $util.isString(message.seedEntropy)))
                    return "seedEntropy: buffer expected";
            return null;
        };

        /**
         * Creates a GenSeedRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GenSeedRequest} GenSeedRequest
         */
        GenSeedRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GenSeedRequest)
                return object;
            let message = new $root.lnrpc.GenSeedRequest();
            if (object.aezeedPassphrase != null)
                if (typeof object.aezeedPassphrase === "string")
                    $util.base64.decode(object.aezeedPassphrase, message.aezeedPassphrase = $util.newBuffer($util.base64.length(object.aezeedPassphrase)), 0);
                else if (object.aezeedPassphrase.length)
                    message.aezeedPassphrase = object.aezeedPassphrase;
            if (object.seedEntropy != null)
                if (typeof object.seedEntropy === "string")
                    $util.base64.decode(object.seedEntropy, message.seedEntropy = $util.newBuffer($util.base64.length(object.seedEntropy)), 0);
                else if (object.seedEntropy.length)
                    message.seedEntropy = object.seedEntropy;
            return message;
        };

        /**
         * Creates a plain object from a GenSeedRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GenSeedRequest
         * @static
         * @param {lnrpc.GenSeedRequest} message GenSeedRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenSeedRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.aezeedPassphrase = "";
                else {
                    object.aezeedPassphrase = [];
                    if (options.bytes !== Array)
                        object.aezeedPassphrase = $util.newBuffer(object.aezeedPassphrase);
                }
                if (options.bytes === String)
                    object.seedEntropy = "";
                else {
                    object.seedEntropy = [];
                    if (options.bytes !== Array)
                        object.seedEntropy = $util.newBuffer(object.seedEntropy);
                }
            }
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                object.aezeedPassphrase = options.bytes === String ? $util.base64.encode(message.aezeedPassphrase, 0, message.aezeedPassphrase.length) : options.bytes === Array ? Array.prototype.slice.call(message.aezeedPassphrase) : message.aezeedPassphrase;
            if (message.seedEntropy != null && message.hasOwnProperty("seedEntropy"))
                object.seedEntropy = options.bytes === String ? $util.base64.encode(message.seedEntropy, 0, message.seedEntropy.length) : options.bytes === Array ? Array.prototype.slice.call(message.seedEntropy) : message.seedEntropy;
            return object;
        };

        /**
         * Converts this GenSeedRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GenSeedRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenSeedRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenSeedRequest;
    })();

    lnrpc.GenSeedResponse = (function() {

        /**
         * Properties of a GenSeedResponse.
         * @memberof lnrpc
         * @interface IGenSeedResponse
         * @property {Array.<string>|null} [cipherSeedMnemonic] cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
         * cipher seed obtained by the user. This field is optional, as if not
         * provided, then the daemon will generate a new cipher seed for the user.
         * Otherwise, then the daemon will attempt to recover the wallet state linked
         * to this cipher seed.
         * @property {Uint8Array|null} [encipheredSeed] enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
         * cipher text before run through our mnemonic encoding scheme.
         */

        /**
         * Constructs a new GenSeedResponse.
         * @memberof lnrpc
         * @classdesc Represents a GenSeedResponse.
         * @implements IGenSeedResponse
         * @constructor
         * @param {lnrpc.IGenSeedResponse=} [properties] Properties to set
         */
        function GenSeedResponse(properties) {
            this.cipherSeedMnemonic = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
         * cipher seed obtained by the user. This field is optional, as if not
         * provided, then the daemon will generate a new cipher seed for the user.
         * Otherwise, then the daemon will attempt to recover the wallet state linked
         * to this cipher seed.
         * @member {Array.<string>} cipherSeedMnemonic
         * @memberof lnrpc.GenSeedResponse
         * @instance
         */
        GenSeedResponse.prototype.cipherSeedMnemonic = $util.emptyArray;

        /**
         * enciphered_seed are the raw aezeed cipher seed bytes. This is the raw
         * cipher text before run through our mnemonic encoding scheme.
         * @member {Uint8Array} encipheredSeed
         * @memberof lnrpc.GenSeedResponse
         * @instance
         */
        GenSeedResponse.prototype.encipheredSeed = $util.newBuffer([]);

        /**
         * Creates a new GenSeedResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {lnrpc.IGenSeedResponse=} [properties] Properties to set
         * @returns {lnrpc.GenSeedResponse} GenSeedResponse instance
         */
        GenSeedResponse.create = function create(properties) {
            return new GenSeedResponse(properties);
        };

        /**
         * Encodes the specified GenSeedResponse message. Does not implicitly {@link lnrpc.GenSeedResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {lnrpc.IGenSeedResponse} message GenSeedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenSeedResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cipherSeedMnemonic != null && message.cipherSeedMnemonic.length)
                for (let i = 0; i < message.cipherSeedMnemonic.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cipherSeedMnemonic[i]);
            if (message.encipheredSeed != null && message.hasOwnProperty("encipheredSeed"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.encipheredSeed);
            return writer;
        };

        /**
         * Encodes the specified GenSeedResponse message, length delimited. Does not implicitly {@link lnrpc.GenSeedResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {lnrpc.IGenSeedResponse} message GenSeedResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GenSeedResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GenSeedResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GenSeedResponse} GenSeedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenSeedResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GenSeedResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.cipherSeedMnemonic && message.cipherSeedMnemonic.length))
                        message.cipherSeedMnemonic = [];
                    message.cipherSeedMnemonic.push(reader.string());
                    break;
                case 2:
                    message.encipheredSeed = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GenSeedResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GenSeedResponse} GenSeedResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GenSeedResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GenSeedResponse message.
         * @function verify
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GenSeedResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cipherSeedMnemonic != null && message.hasOwnProperty("cipherSeedMnemonic")) {
                if (!Array.isArray(message.cipherSeedMnemonic))
                    return "cipherSeedMnemonic: array expected";
                for (let i = 0; i < message.cipherSeedMnemonic.length; ++i)
                    if (!$util.isString(message.cipherSeedMnemonic[i]))
                        return "cipherSeedMnemonic: string[] expected";
            }
            if (message.encipheredSeed != null && message.hasOwnProperty("encipheredSeed"))
                if (!(message.encipheredSeed && typeof message.encipheredSeed.length === "number" || $util.isString(message.encipheredSeed)))
                    return "encipheredSeed: buffer expected";
            return null;
        };

        /**
         * Creates a GenSeedResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GenSeedResponse} GenSeedResponse
         */
        GenSeedResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GenSeedResponse)
                return object;
            let message = new $root.lnrpc.GenSeedResponse();
            if (object.cipherSeedMnemonic) {
                if (!Array.isArray(object.cipherSeedMnemonic))
                    throw TypeError(".lnrpc.GenSeedResponse.cipherSeedMnemonic: array expected");
                message.cipherSeedMnemonic = [];
                for (let i = 0; i < object.cipherSeedMnemonic.length; ++i)
                    message.cipherSeedMnemonic[i] = String(object.cipherSeedMnemonic[i]);
            }
            if (object.encipheredSeed != null)
                if (typeof object.encipheredSeed === "string")
                    $util.base64.decode(object.encipheredSeed, message.encipheredSeed = $util.newBuffer($util.base64.length(object.encipheredSeed)), 0);
                else if (object.encipheredSeed.length)
                    message.encipheredSeed = object.encipheredSeed;
            return message;
        };

        /**
         * Creates a plain object from a GenSeedResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GenSeedResponse
         * @static
         * @param {lnrpc.GenSeedResponse} message GenSeedResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GenSeedResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.cipherSeedMnemonic = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.encipheredSeed = "";
                else {
                    object.encipheredSeed = [];
                    if (options.bytes !== Array)
                        object.encipheredSeed = $util.newBuffer(object.encipheredSeed);
                }
            if (message.cipherSeedMnemonic && message.cipherSeedMnemonic.length) {
                object.cipherSeedMnemonic = [];
                for (let j = 0; j < message.cipherSeedMnemonic.length; ++j)
                    object.cipherSeedMnemonic[j] = message.cipherSeedMnemonic[j];
            }
            if (message.encipheredSeed != null && message.hasOwnProperty("encipheredSeed"))
                object.encipheredSeed = options.bytes === String ? $util.base64.encode(message.encipheredSeed, 0, message.encipheredSeed.length) : options.bytes === Array ? Array.prototype.slice.call(message.encipheredSeed) : message.encipheredSeed;
            return object;
        };

        /**
         * Converts this GenSeedResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.GenSeedResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GenSeedResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GenSeedResponse;
    })();

    lnrpc.InitWalletRequest = (function() {

        /**
         * Properties of an InitWalletRequest.
         * @memberof lnrpc
         * @interface IInitWalletRequest
         * @property {Uint8Array|null} [walletPassword] wallet_password is the passphrase that should be used to encrypt the
         * wallet. This MUST be at least 8 chars in length. After creation, this
         * password is required to unlock the daemon.
         * @property {Array.<string>|null} [cipherSeedMnemonic] cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
         * cipher seed obtained by the user. This may have been generated by the
         * GenSeed method, or be an existing seed.
         * @property {Uint8Array|null} [aezeedPassphrase] aezeed_passphrase is an optional user provided passphrase that will be used
         * to encrypt the generated aezeed cipher seed.
         * @property {number|null} [recoveryWindow] recovery_window is an optional argument specifying the address lookahead
         * when restoring a wallet seed. The recovery window applies to each
         * individual branch of the BIP44 derivation paths. Supplying a recovery
         * window of zero indicates that no addresses should be recovered, such after
         * the first initialization of the wallet.
         * @property {lnrpc.IChanBackupSnapshot|null} [channelBackups] channel_backups is an optional argument that allows clients to recover the
         * settled funds within a set of channels. This should be populated if the
         * user was unable to close out all channels and sweep funds before partial or
         * total data loss occurred. If specified, then after on-chain recovery of
         * funds, lnd begin to carry out the data loss recovery protocol in order to
         * recover the funds in each channel from a remote force closed transaction.
         */

        /**
         * Constructs a new InitWalletRequest.
         * @memberof lnrpc
         * @classdesc Represents an InitWalletRequest.
         * @implements IInitWalletRequest
         * @constructor
         * @param {lnrpc.IInitWalletRequest=} [properties] Properties to set
         */
        function InitWalletRequest(properties) {
            this.cipherSeedMnemonic = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * wallet_password is the passphrase that should be used to encrypt the
         * wallet. This MUST be at least 8 chars in length. After creation, this
         * password is required to unlock the daemon.
         * @member {Uint8Array} walletPassword
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.walletPassword = $util.newBuffer([]);

        /**
         * cipher_seed_mnemonic is a 24-word mnemonic that encodes a prior aezeed
         * cipher seed obtained by the user. This may have been generated by the
         * GenSeed method, or be an existing seed.
         * @member {Array.<string>} cipherSeedMnemonic
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.cipherSeedMnemonic = $util.emptyArray;

        /**
         * aezeed_passphrase is an optional user provided passphrase that will be used
         * to encrypt the generated aezeed cipher seed.
         * @member {Uint8Array} aezeedPassphrase
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.aezeedPassphrase = $util.newBuffer([]);

        /**
         * recovery_window is an optional argument specifying the address lookahead
         * when restoring a wallet seed. The recovery window applies to each
         * individual branch of the BIP44 derivation paths. Supplying a recovery
         * window of zero indicates that no addresses should be recovered, such after
         * the first initialization of the wallet.
         * @member {number} recoveryWindow
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.recoveryWindow = 0;

        /**
         * channel_backups is an optional argument that allows clients to recover the
         * settled funds within a set of channels. This should be populated if the
         * user was unable to close out all channels and sweep funds before partial or
         * total data loss occurred. If specified, then after on-chain recovery of
         * funds, lnd begin to carry out the data loss recovery protocol in order to
         * recover the funds in each channel from a remote force closed transaction.
         * @member {lnrpc.IChanBackupSnapshot|null|undefined} channelBackups
         * @memberof lnrpc.InitWalletRequest
         * @instance
         */
        InitWalletRequest.prototype.channelBackups = null;

        /**
         * Creates a new InitWalletRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {lnrpc.IInitWalletRequest=} [properties] Properties to set
         * @returns {lnrpc.InitWalletRequest} InitWalletRequest instance
         */
        InitWalletRequest.create = function create(properties) {
            return new InitWalletRequest(properties);
        };

        /**
         * Encodes the specified InitWalletRequest message. Does not implicitly {@link lnrpc.InitWalletRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {lnrpc.IInitWalletRequest} message InitWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitWalletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.walletPassword);
            if (message.cipherSeedMnemonic != null && message.cipherSeedMnemonic.length)
                for (let i = 0; i < message.cipherSeedMnemonic.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cipherSeedMnemonic[i]);
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.aezeedPassphrase);
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.recoveryWindow);
            if (message.channelBackups != null && message.hasOwnProperty("channelBackups"))
                $root.lnrpc.ChanBackupSnapshot.encode(message.channelBackups, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InitWalletRequest message, length delimited. Does not implicitly {@link lnrpc.InitWalletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {lnrpc.IInitWalletRequest} message InitWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitWalletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitWalletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.InitWalletRequest} InitWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitWalletRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.InitWalletRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.walletPassword = reader.bytes();
                    break;
                case 2:
                    if (!(message.cipherSeedMnemonic && message.cipherSeedMnemonic.length))
                        message.cipherSeedMnemonic = [];
                    message.cipherSeedMnemonic.push(reader.string());
                    break;
                case 3:
                    message.aezeedPassphrase = reader.bytes();
                    break;
                case 4:
                    message.recoveryWindow = reader.int32();
                    break;
                case 5:
                    message.channelBackups = $root.lnrpc.ChanBackupSnapshot.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitWalletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.InitWalletRequest} InitWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitWalletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitWalletRequest message.
         * @function verify
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitWalletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                if (!(message.walletPassword && typeof message.walletPassword.length === "number" || $util.isString(message.walletPassword)))
                    return "walletPassword: buffer expected";
            if (message.cipherSeedMnemonic != null && message.hasOwnProperty("cipherSeedMnemonic")) {
                if (!Array.isArray(message.cipherSeedMnemonic))
                    return "cipherSeedMnemonic: array expected";
                for (let i = 0; i < message.cipherSeedMnemonic.length; ++i)
                    if (!$util.isString(message.cipherSeedMnemonic[i]))
                        return "cipherSeedMnemonic: string[] expected";
            }
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                if (!(message.aezeedPassphrase && typeof message.aezeedPassphrase.length === "number" || $util.isString(message.aezeedPassphrase)))
                    return "aezeedPassphrase: buffer expected";
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                if (!$util.isInteger(message.recoveryWindow))
                    return "recoveryWindow: integer expected";
            if (message.channelBackups != null && message.hasOwnProperty("channelBackups")) {
                let error = $root.lnrpc.ChanBackupSnapshot.verify(message.channelBackups);
                if (error)
                    return "channelBackups." + error;
            }
            return null;
        };

        /**
         * Creates an InitWalletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.InitWalletRequest} InitWalletRequest
         */
        InitWalletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.InitWalletRequest)
                return object;
            let message = new $root.lnrpc.InitWalletRequest();
            if (object.walletPassword != null)
                if (typeof object.walletPassword === "string")
                    $util.base64.decode(object.walletPassword, message.walletPassword = $util.newBuffer($util.base64.length(object.walletPassword)), 0);
                else if (object.walletPassword.length)
                    message.walletPassword = object.walletPassword;
            if (object.cipherSeedMnemonic) {
                if (!Array.isArray(object.cipherSeedMnemonic))
                    throw TypeError(".lnrpc.InitWalletRequest.cipherSeedMnemonic: array expected");
                message.cipherSeedMnemonic = [];
                for (let i = 0; i < object.cipherSeedMnemonic.length; ++i)
                    message.cipherSeedMnemonic[i] = String(object.cipherSeedMnemonic[i]);
            }
            if (object.aezeedPassphrase != null)
                if (typeof object.aezeedPassphrase === "string")
                    $util.base64.decode(object.aezeedPassphrase, message.aezeedPassphrase = $util.newBuffer($util.base64.length(object.aezeedPassphrase)), 0);
                else if (object.aezeedPassphrase.length)
                    message.aezeedPassphrase = object.aezeedPassphrase;
            if (object.recoveryWindow != null)
                message.recoveryWindow = object.recoveryWindow | 0;
            if (object.channelBackups != null) {
                if (typeof object.channelBackups !== "object")
                    throw TypeError(".lnrpc.InitWalletRequest.channelBackups: object expected");
                message.channelBackups = $root.lnrpc.ChanBackupSnapshot.fromObject(object.channelBackups);
            }
            return message;
        };

        /**
         * Creates a plain object from an InitWalletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.InitWalletRequest
         * @static
         * @param {lnrpc.InitWalletRequest} message InitWalletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitWalletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.cipherSeedMnemonic = [];
            if (options.defaults) {
                if (options.bytes === String)
                    object.walletPassword = "";
                else {
                    object.walletPassword = [];
                    if (options.bytes !== Array)
                        object.walletPassword = $util.newBuffer(object.walletPassword);
                }
                if (options.bytes === String)
                    object.aezeedPassphrase = "";
                else {
                    object.aezeedPassphrase = [];
                    if (options.bytes !== Array)
                        object.aezeedPassphrase = $util.newBuffer(object.aezeedPassphrase);
                }
                object.recoveryWindow = 0;
                object.channelBackups = null;
            }
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                object.walletPassword = options.bytes === String ? $util.base64.encode(message.walletPassword, 0, message.walletPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.walletPassword) : message.walletPassword;
            if (message.cipherSeedMnemonic && message.cipherSeedMnemonic.length) {
                object.cipherSeedMnemonic = [];
                for (let j = 0; j < message.cipherSeedMnemonic.length; ++j)
                    object.cipherSeedMnemonic[j] = message.cipherSeedMnemonic[j];
            }
            if (message.aezeedPassphrase != null && message.hasOwnProperty("aezeedPassphrase"))
                object.aezeedPassphrase = options.bytes === String ? $util.base64.encode(message.aezeedPassphrase, 0, message.aezeedPassphrase.length) : options.bytes === Array ? Array.prototype.slice.call(message.aezeedPassphrase) : message.aezeedPassphrase;
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                object.recoveryWindow = message.recoveryWindow;
            if (message.channelBackups != null && message.hasOwnProperty("channelBackups"))
                object.channelBackups = $root.lnrpc.ChanBackupSnapshot.toObject(message.channelBackups, options);
            return object;
        };

        /**
         * Converts this InitWalletRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.InitWalletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitWalletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitWalletRequest;
    })();

    lnrpc.InitWalletResponse = (function() {

        /**
         * Properties of an InitWalletResponse.
         * @memberof lnrpc
         * @interface IInitWalletResponse
         */

        /**
         * Constructs a new InitWalletResponse.
         * @memberof lnrpc
         * @classdesc Represents an InitWalletResponse.
         * @implements IInitWalletResponse
         * @constructor
         * @param {lnrpc.IInitWalletResponse=} [properties] Properties to set
         */
        function InitWalletResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new InitWalletResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {lnrpc.IInitWalletResponse=} [properties] Properties to set
         * @returns {lnrpc.InitWalletResponse} InitWalletResponse instance
         */
        InitWalletResponse.create = function create(properties) {
            return new InitWalletResponse(properties);
        };

        /**
         * Encodes the specified InitWalletResponse message. Does not implicitly {@link lnrpc.InitWalletResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {lnrpc.IInitWalletResponse} message InitWalletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitWalletResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified InitWalletResponse message, length delimited. Does not implicitly {@link lnrpc.InitWalletResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {lnrpc.IInitWalletResponse} message InitWalletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InitWalletResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InitWalletResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.InitWalletResponse} InitWalletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitWalletResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.InitWalletResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InitWalletResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.InitWalletResponse} InitWalletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InitWalletResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InitWalletResponse message.
         * @function verify
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InitWalletResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an InitWalletResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.InitWalletResponse} InitWalletResponse
         */
        InitWalletResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.InitWalletResponse)
                return object;
            return new $root.lnrpc.InitWalletResponse();
        };

        /**
         * Creates a plain object from an InitWalletResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.InitWalletResponse
         * @static
         * @param {lnrpc.InitWalletResponse} message InitWalletResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InitWalletResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this InitWalletResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.InitWalletResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InitWalletResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InitWalletResponse;
    })();

    lnrpc.UnlockWalletRequest = (function() {

        /**
         * Properties of an UnlockWalletRequest.
         * @memberof lnrpc
         * @interface IUnlockWalletRequest
         * @property {Uint8Array|null} [walletPassword] wallet_password should be the current valid passphrase for the daemon. This
         * will be required to decrypt on-disk material that the daemon requires to
         * function properly.
         * @property {number|null} [recoveryWindow] recovery_window is an optional argument specifying the address lookahead
         * when restoring a wallet seed. The recovery window applies to each
         * individual branch of the BIP44 derivation paths. Supplying a recovery
         * window of zero indicates that no addresses should be recovered, such after
         * the first initialization of the wallet.
         * @property {lnrpc.IChanBackupSnapshot|null} [channelBackups] channel_backups is an optional argument that allows clients to recover the
         * settled funds within a set of channels. This should be populated if the
         * user was unable to close out all channels and sweep funds before partial or
         * total data loss occurred. If specified, then after on-chain recovery of
         * funds, lnd begin to carry out the data loss recovery protocol in order to
         * recover the funds in each channel from a remote force closed transaction.
         */

        /**
         * Constructs a new UnlockWalletRequest.
         * @memberof lnrpc
         * @classdesc Represents an UnlockWalletRequest.
         * @implements IUnlockWalletRequest
         * @constructor
         * @param {lnrpc.IUnlockWalletRequest=} [properties] Properties to set
         */
        function UnlockWalletRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * wallet_password should be the current valid passphrase for the daemon. This
         * will be required to decrypt on-disk material that the daemon requires to
         * function properly.
         * @member {Uint8Array} walletPassword
         * @memberof lnrpc.UnlockWalletRequest
         * @instance
         */
        UnlockWalletRequest.prototype.walletPassword = $util.newBuffer([]);

        /**
         * recovery_window is an optional argument specifying the address lookahead
         * when restoring a wallet seed. The recovery window applies to each
         * individual branch of the BIP44 derivation paths. Supplying a recovery
         * window of zero indicates that no addresses should be recovered, such after
         * the first initialization of the wallet.
         * @member {number} recoveryWindow
         * @memberof lnrpc.UnlockWalletRequest
         * @instance
         */
        UnlockWalletRequest.prototype.recoveryWindow = 0;

        /**
         * channel_backups is an optional argument that allows clients to recover the
         * settled funds within a set of channels. This should be populated if the
         * user was unable to close out all channels and sweep funds before partial or
         * total data loss occurred. If specified, then after on-chain recovery of
         * funds, lnd begin to carry out the data loss recovery protocol in order to
         * recover the funds in each channel from a remote force closed transaction.
         * @member {lnrpc.IChanBackupSnapshot|null|undefined} channelBackups
         * @memberof lnrpc.UnlockWalletRequest
         * @instance
         */
        UnlockWalletRequest.prototype.channelBackups = null;

        /**
         * Creates a new UnlockWalletRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {lnrpc.IUnlockWalletRequest=} [properties] Properties to set
         * @returns {lnrpc.UnlockWalletRequest} UnlockWalletRequest instance
         */
        UnlockWalletRequest.create = function create(properties) {
            return new UnlockWalletRequest(properties);
        };

        /**
         * Encodes the specified UnlockWalletRequest message. Does not implicitly {@link lnrpc.UnlockWalletRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {lnrpc.IUnlockWalletRequest} message UnlockWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockWalletRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.walletPassword);
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.recoveryWindow);
            if (message.channelBackups != null && message.hasOwnProperty("channelBackups"))
                $root.lnrpc.ChanBackupSnapshot.encode(message.channelBackups, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UnlockWalletRequest message, length delimited. Does not implicitly {@link lnrpc.UnlockWalletRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {lnrpc.IUnlockWalletRequest} message UnlockWalletRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockWalletRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockWalletRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.UnlockWalletRequest} UnlockWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockWalletRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.UnlockWalletRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.walletPassword = reader.bytes();
                    break;
                case 2:
                    message.recoveryWindow = reader.int32();
                    break;
                case 3:
                    message.channelBackups = $root.lnrpc.ChanBackupSnapshot.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlockWalletRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.UnlockWalletRequest} UnlockWalletRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockWalletRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockWalletRequest message.
         * @function verify
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockWalletRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                if (!(message.walletPassword && typeof message.walletPassword.length === "number" || $util.isString(message.walletPassword)))
                    return "walletPassword: buffer expected";
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                if (!$util.isInteger(message.recoveryWindow))
                    return "recoveryWindow: integer expected";
            if (message.channelBackups != null && message.hasOwnProperty("channelBackups")) {
                let error = $root.lnrpc.ChanBackupSnapshot.verify(message.channelBackups);
                if (error)
                    return "channelBackups." + error;
            }
            return null;
        };

        /**
         * Creates an UnlockWalletRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.UnlockWalletRequest} UnlockWalletRequest
         */
        UnlockWalletRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.UnlockWalletRequest)
                return object;
            let message = new $root.lnrpc.UnlockWalletRequest();
            if (object.walletPassword != null)
                if (typeof object.walletPassword === "string")
                    $util.base64.decode(object.walletPassword, message.walletPassword = $util.newBuffer($util.base64.length(object.walletPassword)), 0);
                else if (object.walletPassword.length)
                    message.walletPassword = object.walletPassword;
            if (object.recoveryWindow != null)
                message.recoveryWindow = object.recoveryWindow | 0;
            if (object.channelBackups != null) {
                if (typeof object.channelBackups !== "object")
                    throw TypeError(".lnrpc.UnlockWalletRequest.channelBackups: object expected");
                message.channelBackups = $root.lnrpc.ChanBackupSnapshot.fromObject(object.channelBackups);
            }
            return message;
        };

        /**
         * Creates a plain object from an UnlockWalletRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.UnlockWalletRequest
         * @static
         * @param {lnrpc.UnlockWalletRequest} message UnlockWalletRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockWalletRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.walletPassword = "";
                else {
                    object.walletPassword = [];
                    if (options.bytes !== Array)
                        object.walletPassword = $util.newBuffer(object.walletPassword);
                }
                object.recoveryWindow = 0;
                object.channelBackups = null;
            }
            if (message.walletPassword != null && message.hasOwnProperty("walletPassword"))
                object.walletPassword = options.bytes === String ? $util.base64.encode(message.walletPassword, 0, message.walletPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.walletPassword) : message.walletPassword;
            if (message.recoveryWindow != null && message.hasOwnProperty("recoveryWindow"))
                object.recoveryWindow = message.recoveryWindow;
            if (message.channelBackups != null && message.hasOwnProperty("channelBackups"))
                object.channelBackups = $root.lnrpc.ChanBackupSnapshot.toObject(message.channelBackups, options);
            return object;
        };

        /**
         * Converts this UnlockWalletRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.UnlockWalletRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockWalletRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlockWalletRequest;
    })();

    lnrpc.UnlockWalletResponse = (function() {

        /**
         * Properties of an UnlockWalletResponse.
         * @memberof lnrpc
         * @interface IUnlockWalletResponse
         */

        /**
         * Constructs a new UnlockWalletResponse.
         * @memberof lnrpc
         * @classdesc Represents an UnlockWalletResponse.
         * @implements IUnlockWalletResponse
         * @constructor
         * @param {lnrpc.IUnlockWalletResponse=} [properties] Properties to set
         */
        function UnlockWalletResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new UnlockWalletResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {lnrpc.IUnlockWalletResponse=} [properties] Properties to set
         * @returns {lnrpc.UnlockWalletResponse} UnlockWalletResponse instance
         */
        UnlockWalletResponse.create = function create(properties) {
            return new UnlockWalletResponse(properties);
        };

        /**
         * Encodes the specified UnlockWalletResponse message. Does not implicitly {@link lnrpc.UnlockWalletResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {lnrpc.IUnlockWalletResponse} message UnlockWalletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockWalletResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified UnlockWalletResponse message, length delimited. Does not implicitly {@link lnrpc.UnlockWalletResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {lnrpc.IUnlockWalletResponse} message UnlockWalletResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockWalletResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockWalletResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.UnlockWalletResponse} UnlockWalletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockWalletResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.UnlockWalletResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlockWalletResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.UnlockWalletResponse} UnlockWalletResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockWalletResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockWalletResponse message.
         * @function verify
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockWalletResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an UnlockWalletResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.UnlockWalletResponse} UnlockWalletResponse
         */
        UnlockWalletResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.UnlockWalletResponse)
                return object;
            return new $root.lnrpc.UnlockWalletResponse();
        };

        /**
         * Creates a plain object from an UnlockWalletResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.UnlockWalletResponse
         * @static
         * @param {lnrpc.UnlockWalletResponse} message UnlockWalletResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UnlockWalletResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this UnlockWalletResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.UnlockWalletResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UnlockWalletResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UnlockWalletResponse;
    })();

    lnrpc.ChangePasswordRequest = (function() {

        /**
         * Properties of a ChangePasswordRequest.
         * @memberof lnrpc
         * @interface IChangePasswordRequest
         * @property {Uint8Array|null} [currentPassword] current_password should be the current valid passphrase used to unlock the
         * daemon.
         * @property {Uint8Array|null} [newPassword] new_password should be the new passphrase that will be needed to unlock the
         * daemon.
         */

        /**
         * Constructs a new ChangePasswordRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChangePasswordRequest.
         * @implements IChangePasswordRequest
         * @constructor
         * @param {lnrpc.IChangePasswordRequest=} [properties] Properties to set
         */
        function ChangePasswordRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * current_password should be the current valid passphrase used to unlock the
         * daemon.
         * @member {Uint8Array} currentPassword
         * @memberof lnrpc.ChangePasswordRequest
         * @instance
         */
        ChangePasswordRequest.prototype.currentPassword = $util.newBuffer([]);

        /**
         * new_password should be the new passphrase that will be needed to unlock the
         * daemon.
         * @member {Uint8Array} newPassword
         * @memberof lnrpc.ChangePasswordRequest
         * @instance
         */
        ChangePasswordRequest.prototype.newPassword = $util.newBuffer([]);

        /**
         * Creates a new ChangePasswordRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {lnrpc.IChangePasswordRequest=} [properties] Properties to set
         * @returns {lnrpc.ChangePasswordRequest} ChangePasswordRequest instance
         */
        ChangePasswordRequest.create = function create(properties) {
            return new ChangePasswordRequest(properties);
        };

        /**
         * Encodes the specified ChangePasswordRequest message. Does not implicitly {@link lnrpc.ChangePasswordRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {lnrpc.IChangePasswordRequest} message ChangePasswordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangePasswordRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.currentPassword != null && message.hasOwnProperty("currentPassword"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.currentPassword);
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.newPassword);
            return writer;
        };

        /**
         * Encodes the specified ChangePasswordRequest message, length delimited. Does not implicitly {@link lnrpc.ChangePasswordRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {lnrpc.IChangePasswordRequest} message ChangePasswordRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangePasswordRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangePasswordRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChangePasswordRequest} ChangePasswordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangePasswordRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChangePasswordRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.currentPassword = reader.bytes();
                    break;
                case 2:
                    message.newPassword = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangePasswordRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChangePasswordRequest} ChangePasswordRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangePasswordRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangePasswordRequest message.
         * @function verify
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangePasswordRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.currentPassword != null && message.hasOwnProperty("currentPassword"))
                if (!(message.currentPassword && typeof message.currentPassword.length === "number" || $util.isString(message.currentPassword)))
                    return "currentPassword: buffer expected";
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                if (!(message.newPassword && typeof message.newPassword.length === "number" || $util.isString(message.newPassword)))
                    return "newPassword: buffer expected";
            return null;
        };

        /**
         * Creates a ChangePasswordRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChangePasswordRequest} ChangePasswordRequest
         */
        ChangePasswordRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChangePasswordRequest)
                return object;
            let message = new $root.lnrpc.ChangePasswordRequest();
            if (object.currentPassword != null)
                if (typeof object.currentPassword === "string")
                    $util.base64.decode(object.currentPassword, message.currentPassword = $util.newBuffer($util.base64.length(object.currentPassword)), 0);
                else if (object.currentPassword.length)
                    message.currentPassword = object.currentPassword;
            if (object.newPassword != null)
                if (typeof object.newPassword === "string")
                    $util.base64.decode(object.newPassword, message.newPassword = $util.newBuffer($util.base64.length(object.newPassword)), 0);
                else if (object.newPassword.length)
                    message.newPassword = object.newPassword;
            return message;
        };

        /**
         * Creates a plain object from a ChangePasswordRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChangePasswordRequest
         * @static
         * @param {lnrpc.ChangePasswordRequest} message ChangePasswordRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangePasswordRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.currentPassword = "";
                else {
                    object.currentPassword = [];
                    if (options.bytes !== Array)
                        object.currentPassword = $util.newBuffer(object.currentPassword);
                }
                if (options.bytes === String)
                    object.newPassword = "";
                else {
                    object.newPassword = [];
                    if (options.bytes !== Array)
                        object.newPassword = $util.newBuffer(object.newPassword);
                }
            }
            if (message.currentPassword != null && message.hasOwnProperty("currentPassword"))
                object.currentPassword = options.bytes === String ? $util.base64.encode(message.currentPassword, 0, message.currentPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.currentPassword) : message.currentPassword;
            if (message.newPassword != null && message.hasOwnProperty("newPassword"))
                object.newPassword = options.bytes === String ? $util.base64.encode(message.newPassword, 0, message.newPassword.length) : options.bytes === Array ? Array.prototype.slice.call(message.newPassword) : message.newPassword;
            return object;
        };

        /**
         * Converts this ChangePasswordRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChangePasswordRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangePasswordRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangePasswordRequest;
    })();

    lnrpc.ChangePasswordResponse = (function() {

        /**
         * Properties of a ChangePasswordResponse.
         * @memberof lnrpc
         * @interface IChangePasswordResponse
         */

        /**
         * Constructs a new ChangePasswordResponse.
         * @memberof lnrpc
         * @classdesc Represents a ChangePasswordResponse.
         * @implements IChangePasswordResponse
         * @constructor
         * @param {lnrpc.IChangePasswordResponse=} [properties] Properties to set
         */
        function ChangePasswordResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChangePasswordResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {lnrpc.IChangePasswordResponse=} [properties] Properties to set
         * @returns {lnrpc.ChangePasswordResponse} ChangePasswordResponse instance
         */
        ChangePasswordResponse.create = function create(properties) {
            return new ChangePasswordResponse(properties);
        };

        /**
         * Encodes the specified ChangePasswordResponse message. Does not implicitly {@link lnrpc.ChangePasswordResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {lnrpc.IChangePasswordResponse} message ChangePasswordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangePasswordResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChangePasswordResponse message, length delimited. Does not implicitly {@link lnrpc.ChangePasswordResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {lnrpc.IChangePasswordResponse} message ChangePasswordResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangePasswordResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangePasswordResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChangePasswordResponse} ChangePasswordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangePasswordResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChangePasswordResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangePasswordResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChangePasswordResponse} ChangePasswordResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangePasswordResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangePasswordResponse message.
         * @function verify
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangePasswordResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChangePasswordResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChangePasswordResponse} ChangePasswordResponse
         */
        ChangePasswordResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChangePasswordResponse)
                return object;
            return new $root.lnrpc.ChangePasswordResponse();
        };

        /**
         * Creates a plain object from a ChangePasswordResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChangePasswordResponse
         * @static
         * @param {lnrpc.ChangePasswordResponse} message ChangePasswordResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChangePasswordResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChangePasswordResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ChangePasswordResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChangePasswordResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChangePasswordResponse;
    })();

    lnrpc.Lightning = (function() {

        /**
         * Constructs a new Lightning service.
         * @memberof lnrpc
         * @classdesc Represents a Lightning
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Lightning(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Lightning.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Lightning;

        /**
         * Creates new Lightning service using the specified rpc implementation.
         * @function create
         * @memberof lnrpc.Lightning
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {Lightning} RPC service. Useful where requests and/or responses are streamed.
         */
        Lightning.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link lnrpc.Lightning#walletBalance}.
         * @memberof lnrpc.Lightning
         * @typedef WalletBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.WalletBalanceResponse} [response] WalletBalanceResponse
         */

        /**
         * lncli: `walletbalance`
         * WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
         * confirmed unspent outputs and all unconfirmed unspent outputs under control
         * of the wallet.
         * @function walletBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IWalletBalanceRequest} request WalletBalanceRequest message or plain object
         * @param {lnrpc.Lightning.WalletBalanceCallback} callback Node-style callback called with the error, if any, and WalletBalanceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.walletBalance = function walletBalance(request, callback) {
            return this.rpcCall(walletBalance, $root.lnrpc.WalletBalanceRequest, $root.lnrpc.WalletBalanceResponse, request, callback);
        }, "name", { value: "WalletBalance" });

        /**
         * lncli: `walletbalance`
         * WalletBalance returns total unspent outputs(confirmed and unconfirmed), all
         * confirmed unspent outputs and all unconfirmed unspent outputs under control
         * of the wallet.
         * @function walletBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IWalletBalanceRequest} request WalletBalanceRequest message or plain object
         * @returns {Promise<lnrpc.WalletBalanceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#channelBalance}.
         * @memberof lnrpc.Lightning
         * @typedef ChannelBalanceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelBalanceResponse} [response] ChannelBalanceResponse
         */

        /**
         * lncli: `channelbalance`
         * ChannelBalance returns the total funds available across all open channels
         * in satoshis.
         * @function channelBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBalanceRequest} request ChannelBalanceRequest message or plain object
         * @param {lnrpc.Lightning.ChannelBalanceCallback} callback Node-style callback called with the error, if any, and ChannelBalanceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.channelBalance = function channelBalance(request, callback) {
            return this.rpcCall(channelBalance, $root.lnrpc.ChannelBalanceRequest, $root.lnrpc.ChannelBalanceResponse, request, callback);
        }, "name", { value: "ChannelBalance" });

        /**
         * lncli: `channelbalance`
         * ChannelBalance returns the total funds available across all open channels
         * in satoshis.
         * @function channelBalance
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBalanceRequest} request ChannelBalanceRequest message or plain object
         * @returns {Promise<lnrpc.ChannelBalanceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getTransactions}.
         * @memberof lnrpc.Lightning
         * @typedef GetTransactionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.TransactionDetails} [response] TransactionDetails
         */

        /**
         * lncli: `listchaintxns`
         * GetTransactions returns a list describing all the known transactions
         * relevant to the wallet.
         * @function getTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @param {lnrpc.Lightning.GetTransactionsCallback} callback Node-style callback called with the error, if any, and TransactionDetails
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getTransactions = function getTransactions(request, callback) {
            return this.rpcCall(getTransactions, $root.lnrpc.GetTransactionsRequest, $root.lnrpc.TransactionDetails, request, callback);
        }, "name", { value: "GetTransactions" });

        /**
         * lncli: `listchaintxns`
         * GetTransactions returns a list describing all the known transactions
         * relevant to the wallet.
         * @function getTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @returns {Promise<lnrpc.TransactionDetails>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#estimateFee}.
         * @memberof lnrpc.Lightning
         * @typedef EstimateFeeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.EstimateFeeResponse} [response] EstimateFeeResponse
         */

        /**
         * lncli: `estimatefee`
         * EstimateFee asks the chain backend to estimate the fee rate and total fees
         * for a transaction that pays to multiple specified outputs.
         * @function estimateFee
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IEstimateFeeRequest} request EstimateFeeRequest message or plain object
         * @param {lnrpc.Lightning.EstimateFeeCallback} callback Node-style callback called with the error, if any, and EstimateFeeResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.estimateFee = function estimateFee(request, callback) {
            return this.rpcCall(estimateFee, $root.lnrpc.EstimateFeeRequest, $root.lnrpc.EstimateFeeResponse, request, callback);
        }, "name", { value: "EstimateFee" });

        /**
         * lncli: `estimatefee`
         * EstimateFee asks the chain backend to estimate the fee rate and total fees
         * for a transaction that pays to multiple specified outputs.
         * @function estimateFee
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IEstimateFeeRequest} request EstimateFeeRequest message or plain object
         * @returns {Promise<lnrpc.EstimateFeeResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendCoins}.
         * @memberof lnrpc.Lightning
         * @typedef SendCoinsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendCoinsResponse} [response] SendCoinsResponse
         */

        /**
         * lncli: `sendcoins`
         * SendCoins executes a request to send coins to a particular address. Unlike
         * SendMany, this RPC call only allows creating a single output at a time. If
         * neither target_conf, or sat_per_byte are set, then the internal wallet will
         * consult its fee model to determine a fee for the default confirmation
         * target.
         * @function sendCoins
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendCoinsRequest} request SendCoinsRequest message or plain object
         * @param {lnrpc.Lightning.SendCoinsCallback} callback Node-style callback called with the error, if any, and SendCoinsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendCoins = function sendCoins(request, callback) {
            return this.rpcCall(sendCoins, $root.lnrpc.SendCoinsRequest, $root.lnrpc.SendCoinsResponse, request, callback);
        }, "name", { value: "SendCoins" });

        /**
         * lncli: `sendcoins`
         * SendCoins executes a request to send coins to a particular address. Unlike
         * SendMany, this RPC call only allows creating a single output at a time. If
         * neither target_conf, or sat_per_byte are set, then the internal wallet will
         * consult its fee model to determine a fee for the default confirmation
         * target.
         * @function sendCoins
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendCoinsRequest} request SendCoinsRequest message or plain object
         * @returns {Promise<lnrpc.SendCoinsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listUnspent}.
         * @memberof lnrpc.Lightning
         * @typedef ListUnspentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListUnspentResponse} [response] ListUnspentResponse
         */

        /**
         * lncli: `listunspent`
         * ListUnspent returns a list of all utxos spendable by the wallet with a
         * number of confirmations between the specified minimum and maximum.
         * @function listUnspent
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListUnspentRequest} request ListUnspentRequest message or plain object
         * @param {lnrpc.Lightning.ListUnspentCallback} callback Node-style callback called with the error, if any, and ListUnspentResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listUnspent = function listUnspent(request, callback) {
            return this.rpcCall(listUnspent, $root.lnrpc.ListUnspentRequest, $root.lnrpc.ListUnspentResponse, request, callback);
        }, "name", { value: "ListUnspent" });

        /**
         * lncli: `listunspent`
         * ListUnspent returns a list of all utxos spendable by the wallet with a
         * number of confirmations between the specified minimum and maximum.
         * @function listUnspent
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListUnspentRequest} request ListUnspentRequest message or plain object
         * @returns {Promise<lnrpc.ListUnspentResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeTransactions}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeTransactionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Transaction} [response] Transaction
         */

        /**
         * SubscribeTransactions creates a uni-directional stream from the server to
         * the client in which any newly discovered transactions relevant to the
         * wallet are sent over.
         * @function subscribeTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @param {lnrpc.Lightning.SubscribeTransactionsCallback} callback Node-style callback called with the error, if any, and Transaction
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeTransactions = function subscribeTransactions(request, callback) {
            return this.rpcCall(subscribeTransactions, $root.lnrpc.GetTransactionsRequest, $root.lnrpc.Transaction, request, callback);
        }, "name", { value: "SubscribeTransactions" });

        /**
         * SubscribeTransactions creates a uni-directional stream from the server to
         * the client in which any newly discovered transactions relevant to the
         * wallet are sent over.
         * @function subscribeTransactions
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetTransactionsRequest} request GetTransactionsRequest message or plain object
         * @returns {Promise<lnrpc.Transaction>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendMany}.
         * @memberof lnrpc.Lightning
         * @typedef SendManyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendManyResponse} [response] SendManyResponse
         */

        /**
         * lncli: `sendmany`
         * SendMany handles a request for a transaction that creates multiple specified
         * outputs in parallel. If neither target_conf, or sat_per_byte are set, then
         * the internal wallet will consult its fee model to determine a fee for the
         * default confirmation target.
         * @function sendMany
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendManyRequest} request SendManyRequest message or plain object
         * @param {lnrpc.Lightning.SendManyCallback} callback Node-style callback called with the error, if any, and SendManyResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendMany = function sendMany(request, callback) {
            return this.rpcCall(sendMany, $root.lnrpc.SendManyRequest, $root.lnrpc.SendManyResponse, request, callback);
        }, "name", { value: "SendMany" });

        /**
         * lncli: `sendmany`
         * SendMany handles a request for a transaction that creates multiple specified
         * outputs in parallel. If neither target_conf, or sat_per_byte are set, then
         * the internal wallet will consult its fee model to determine a fee for the
         * default confirmation target.
         * @function sendMany
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendManyRequest} request SendManyRequest message or plain object
         * @returns {Promise<lnrpc.SendManyResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#newAddress}.
         * @memberof lnrpc.Lightning
         * @typedef NewAddressCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NewAddressResponse} [response] NewAddressResponse
         */

        /**
         * lncli: `newaddress`
         * NewAddress creates a new address under control of the local wallet.
         * @function newAddress
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INewAddressRequest} request NewAddressRequest message or plain object
         * @param {lnrpc.Lightning.NewAddressCallback} callback Node-style callback called with the error, if any, and NewAddressResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.newAddress = function newAddress(request, callback) {
            return this.rpcCall(newAddress, $root.lnrpc.NewAddressRequest, $root.lnrpc.NewAddressResponse, request, callback);
        }, "name", { value: "NewAddress" });

        /**
         * lncli: `newaddress`
         * NewAddress creates a new address under control of the local wallet.
         * @function newAddress
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INewAddressRequest} request NewAddressRequest message or plain object
         * @returns {Promise<lnrpc.NewAddressResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#signMessage}.
         * @memberof lnrpc.Lightning
         * @typedef SignMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SignMessageResponse} [response] SignMessageResponse
         */

        /**
         * lncli: `signmessage`
         * SignMessage signs a message with this node's private key. The returned
         * signature string is `zbase32` encoded and pubkey recoverable, meaning that
         * only the message digest and signature are needed for verification.
         * @function signMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISignMessageRequest} request SignMessageRequest message or plain object
         * @param {lnrpc.Lightning.SignMessageCallback} callback Node-style callback called with the error, if any, and SignMessageResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.signMessage = function signMessage(request, callback) {
            return this.rpcCall(signMessage, $root.lnrpc.SignMessageRequest, $root.lnrpc.SignMessageResponse, request, callback);
        }, "name", { value: "SignMessage" });

        /**
         * lncli: `signmessage`
         * SignMessage signs a message with this node's private key. The returned
         * signature string is `zbase32` encoded and pubkey recoverable, meaning that
         * only the message digest and signature are needed for verification.
         * @function signMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISignMessageRequest} request SignMessageRequest message or plain object
         * @returns {Promise<lnrpc.SignMessageResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#verifyMessage}.
         * @memberof lnrpc.Lightning
         * @typedef VerifyMessageCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.VerifyMessageResponse} [response] VerifyMessageResponse
         */

        /**
         * lncli: `verifymessage`
         * VerifyMessage verifies a signature over a msg. The signature must be
         * zbase32 encoded and signed by an active node in the resident node's
         * channel database. In addition to returning the validity of the signature,
         * VerifyMessage also returns the recovered pubkey from the signature.
         * @function verifyMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IVerifyMessageRequest} request VerifyMessageRequest message or plain object
         * @param {lnrpc.Lightning.VerifyMessageCallback} callback Node-style callback called with the error, if any, and VerifyMessageResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.verifyMessage = function verifyMessage(request, callback) {
            return this.rpcCall(verifyMessage, $root.lnrpc.VerifyMessageRequest, $root.lnrpc.VerifyMessageResponse, request, callback);
        }, "name", { value: "VerifyMessage" });

        /**
         * lncli: `verifymessage`
         * VerifyMessage verifies a signature over a msg. The signature must be
         * zbase32 encoded and signed by an active node in the resident node's
         * channel database. In addition to returning the validity of the signature,
         * VerifyMessage also returns the recovered pubkey from the signature.
         * @function verifyMessage
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IVerifyMessageRequest} request VerifyMessageRequest message or plain object
         * @returns {Promise<lnrpc.VerifyMessageResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#connectPeer}.
         * @memberof lnrpc.Lightning
         * @typedef ConnectPeerCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ConnectPeerResponse} [response] ConnectPeerResponse
         */

        /**
         * lncli: `connect`
         * ConnectPeer attempts to establish a connection to a remote peer. This is at
         * the networking level, and is used for communication between nodes. This is
         * distinct from establishing a channel with a peer.
         * @function connectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IConnectPeerRequest} request ConnectPeerRequest message or plain object
         * @param {lnrpc.Lightning.ConnectPeerCallback} callback Node-style callback called with the error, if any, and ConnectPeerResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.connectPeer = function connectPeer(request, callback) {
            return this.rpcCall(connectPeer, $root.lnrpc.ConnectPeerRequest, $root.lnrpc.ConnectPeerResponse, request, callback);
        }, "name", { value: "ConnectPeer" });

        /**
         * lncli: `connect`
         * ConnectPeer attempts to establish a connection to a remote peer. This is at
         * the networking level, and is used for communication between nodes. This is
         * distinct from establishing a channel with a peer.
         * @function connectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IConnectPeerRequest} request ConnectPeerRequest message or plain object
         * @returns {Promise<lnrpc.ConnectPeerResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#disconnectPeer}.
         * @memberof lnrpc.Lightning
         * @typedef DisconnectPeerCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DisconnectPeerResponse} [response] DisconnectPeerResponse
         */

        /**
         * lncli: `disconnect`
         * DisconnectPeer attempts to disconnect one peer from another identified by a
         * given pubKey. In the case that we currently have a pending or active channel
         * with the target peer, then this action will be not be allowed.
         * @function disconnectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDisconnectPeerRequest} request DisconnectPeerRequest message or plain object
         * @param {lnrpc.Lightning.DisconnectPeerCallback} callback Node-style callback called with the error, if any, and DisconnectPeerResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.disconnectPeer = function disconnectPeer(request, callback) {
            return this.rpcCall(disconnectPeer, $root.lnrpc.DisconnectPeerRequest, $root.lnrpc.DisconnectPeerResponse, request, callback);
        }, "name", { value: "DisconnectPeer" });

        /**
         * lncli: `disconnect`
         * DisconnectPeer attempts to disconnect one peer from another identified by a
         * given pubKey. In the case that we currently have a pending or active channel
         * with the target peer, then this action will be not be allowed.
         * @function disconnectPeer
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDisconnectPeerRequest} request DisconnectPeerRequest message or plain object
         * @returns {Promise<lnrpc.DisconnectPeerResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listPeers}.
         * @memberof lnrpc.Lightning
         * @typedef ListPeersCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListPeersResponse} [response] ListPeersResponse
         */

        /**
         * lncli: `listpeers`
         * ListPeers returns a verbose listing of all currently active peers.
         * @function listPeers
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPeersRequest} request ListPeersRequest message or plain object
         * @param {lnrpc.Lightning.ListPeersCallback} callback Node-style callback called with the error, if any, and ListPeersResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listPeers = function listPeers(request, callback) {
            return this.rpcCall(listPeers, $root.lnrpc.ListPeersRequest, $root.lnrpc.ListPeersResponse, request, callback);
        }, "name", { value: "ListPeers" });

        /**
         * lncli: `listpeers`
         * ListPeers returns a verbose listing of all currently active peers.
         * @function listPeers
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPeersRequest} request ListPeersRequest message or plain object
         * @returns {Promise<lnrpc.ListPeersResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GetInfoResponse} [response] GetInfoResponse
         */

        /**
         * lncli: `getinfo`
         * GetInfo returns general information concerning the lightning node including
         * it's identity pubkey, alias, the chains it is connected to, and information
         * concerning the number of open+pending channels.
         * @function getInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetInfoRequest} request GetInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetInfoCallback} callback Node-style callback called with the error, if any, and GetInfoResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getInfo = function getInfo(request, callback) {
            return this.rpcCall(getInfo, $root.lnrpc.GetInfoRequest, $root.lnrpc.GetInfoResponse, request, callback);
        }, "name", { value: "GetInfo" });

        /**
         * lncli: `getinfo`
         * GetInfo returns general information concerning the lightning node including
         * it's identity pubkey, alias, the chains it is connected to, and information
         * concerning the number of open+pending channels.
         * @function getInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGetInfoRequest} request GetInfoRequest message or plain object
         * @returns {Promise<lnrpc.GetInfoResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#pendingChannels}.
         * @memberof lnrpc.Lightning
         * @typedef PendingChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PendingChannelsResponse} [response] PendingChannelsResponse
         */

        /**
         * lncli: `pendingchannels`
         * PendingChannels returns a list of all the channels that are currently
         * considered "pending". A channel is pending if it has finished the funding
         * workflow and is waiting for confirmations for the funding txn, or is in the
         * process of closure, either initiated cooperatively or non-cooperatively.
         * @function pendingChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPendingChannelsRequest} request PendingChannelsRequest message or plain object
         * @param {lnrpc.Lightning.PendingChannelsCallback} callback Node-style callback called with the error, if any, and PendingChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.pendingChannels = function pendingChannels(request, callback) {
            return this.rpcCall(pendingChannels, $root.lnrpc.PendingChannelsRequest, $root.lnrpc.PendingChannelsResponse, request, callback);
        }, "name", { value: "PendingChannels" });

        /**
         * lncli: `pendingchannels`
         * PendingChannels returns a list of all the channels that are currently
         * considered "pending". A channel is pending if it has finished the funding
         * workflow and is waiting for confirmations for the funding txn, or is in the
         * process of closure, either initiated cooperatively or non-cooperatively.
         * @function pendingChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPendingChannelsRequest} request PendingChannelsRequest message or plain object
         * @returns {Promise<lnrpc.PendingChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listChannels}.
         * @memberof lnrpc.Lightning
         * @typedef ListChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListChannelsResponse} [response] ListChannelsResponse
         */

        /**
         * lncli: `listchannels`
         * ListChannels returns a description of all the open channels that this node
         * is a participant in.
         * @function listChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListChannelsRequest} request ListChannelsRequest message or plain object
         * @param {lnrpc.Lightning.ListChannelsCallback} callback Node-style callback called with the error, if any, and ListChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listChannels = function listChannels(request, callback) {
            return this.rpcCall(listChannels, $root.lnrpc.ListChannelsRequest, $root.lnrpc.ListChannelsResponse, request, callback);
        }, "name", { value: "ListChannels" });

        /**
         * lncli: `listchannels`
         * ListChannels returns a description of all the open channels that this node
         * is a participant in.
         * @function listChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListChannelsRequest} request ListChannelsRequest message or plain object
         * @returns {Promise<lnrpc.ListChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeChannelEvents}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeChannelEventsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelEventUpdate} [response] ChannelEventUpdate
         */

        /**
         * lncli: `subscribechannelevents`
         * SubscribeChannelEvents creates a uni-directional stream from the server to
         * the client in which any updates relevant to the state of the channels are
         * sent over. Events include new active channels, inactive channels, and closed
         * channels.
         * @function subscribeChannelEvents
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelEventSubscription} request ChannelEventSubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeChannelEventsCallback} callback Node-style callback called with the error, if any, and ChannelEventUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeChannelEvents = function subscribeChannelEvents(request, callback) {
            return this.rpcCall(subscribeChannelEvents, $root.lnrpc.ChannelEventSubscription, $root.lnrpc.ChannelEventUpdate, request, callback);
        }, "name", { value: "SubscribeChannelEvents" });

        /**
         * lncli: `subscribechannelevents`
         * SubscribeChannelEvents creates a uni-directional stream from the server to
         * the client in which any updates relevant to the state of the channels are
         * sent over. Events include new active channels, inactive channels, and closed
         * channels.
         * @function subscribeChannelEvents
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelEventSubscription} request ChannelEventSubscription message or plain object
         * @returns {Promise<lnrpc.ChannelEventUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#closedChannels}.
         * @memberof lnrpc.Lightning
         * @typedef ClosedChannelsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ClosedChannelsResponse} [response] ClosedChannelsResponse
         */

        /**
         * lncli: `closedchannels`
         * ClosedChannels returns a description of all the closed channels that
         * this node was a participant in.
         * @function closedChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IClosedChannelsRequest} request ClosedChannelsRequest message or plain object
         * @param {lnrpc.Lightning.ClosedChannelsCallback} callback Node-style callback called with the error, if any, and ClosedChannelsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.closedChannels = function closedChannels(request, callback) {
            return this.rpcCall(closedChannels, $root.lnrpc.ClosedChannelsRequest, $root.lnrpc.ClosedChannelsResponse, request, callback);
        }, "name", { value: "ClosedChannels" });

        /**
         * lncli: `closedchannels`
         * ClosedChannels returns a description of all the closed channels that
         * this node was a participant in.
         * @function closedChannels
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IClosedChannelsRequest} request ClosedChannelsRequest message or plain object
         * @returns {Promise<lnrpc.ClosedChannelsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#openChannelSync}.
         * @memberof lnrpc.Lightning
         * @typedef OpenChannelSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelPoint} [response] ChannelPoint
         */

        /**
         * OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
         * call is meant to be consumed by clients to the REST proxy. As with all
         * other sync calls, all byte slices are intended to be populated as hex
         * encoded strings.
         * @function openChannelSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @param {lnrpc.Lightning.OpenChannelSyncCallback} callback Node-style callback called with the error, if any, and ChannelPoint
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.openChannelSync = function openChannelSync(request, callback) {
            return this.rpcCall(openChannelSync, $root.lnrpc.OpenChannelRequest, $root.lnrpc.ChannelPoint, request, callback);
        }, "name", { value: "OpenChannelSync" });

        /**
         * OpenChannelSync is a synchronous version of the OpenChannel RPC call. This
         * call is meant to be consumed by clients to the REST proxy. As with all
         * other sync calls, all byte slices are intended to be populated as hex
         * encoded strings.
         * @function openChannelSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @returns {Promise<lnrpc.ChannelPoint>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#openChannel}.
         * @memberof lnrpc.Lightning
         * @typedef OpenChannelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.OpenStatusUpdate} [response] OpenStatusUpdate
         */

        /**
         * lncli: `openchannel`
         * OpenChannel attempts to open a singly funded channel specified in the
         * request to a remote peer. Users are able to specify a target number of
         * blocks that the funding transaction should be confirmed in, or a manual fee
         * rate to us for the funding transaction. If neither are specified, then a
         * lax block confirmation target is used.
         * @function openChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @param {lnrpc.Lightning.OpenChannelCallback} callback Node-style callback called with the error, if any, and OpenStatusUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.openChannel = function openChannel(request, callback) {
            return this.rpcCall(openChannel, $root.lnrpc.OpenChannelRequest, $root.lnrpc.OpenStatusUpdate, request, callback);
        }, "name", { value: "OpenChannel" });

        /**
         * lncli: `openchannel`
         * OpenChannel attempts to open a singly funded channel specified in the
         * request to a remote peer. Users are able to specify a target number of
         * blocks that the funding transaction should be confirmed in, or a manual fee
         * rate to us for the funding transaction. If neither are specified, then a
         * lax block confirmation target is used.
         * @function openChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IOpenChannelRequest} request OpenChannelRequest message or plain object
         * @returns {Promise<lnrpc.OpenStatusUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#closeChannel}.
         * @memberof lnrpc.Lightning
         * @typedef CloseChannelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.CloseStatusUpdate} [response] CloseStatusUpdate
         */

        /**
         * lncli: `closechannel`
         * CloseChannel attempts to close an active channel identified by its channel
         * outpoint (ChannelPoint). The actions of this method can additionally be
         * augmented to attempt a force close after a timeout period in the case of an
         * inactive peer. If a non-force close (cooperative closure) is requested,
         * then the user can specify either a target number of blocks until the
         * closure transaction is confirmed, or a manual fee rate. If neither are
         * specified, then a default lax, block confirmation target is used.
         * @function closeChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ICloseChannelRequest} request CloseChannelRequest message or plain object
         * @param {lnrpc.Lightning.CloseChannelCallback} callback Node-style callback called with the error, if any, and CloseStatusUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.closeChannel = function closeChannel(request, callback) {
            return this.rpcCall(closeChannel, $root.lnrpc.CloseChannelRequest, $root.lnrpc.CloseStatusUpdate, request, callback);
        }, "name", { value: "CloseChannel" });

        /**
         * lncli: `closechannel`
         * CloseChannel attempts to close an active channel identified by its channel
         * outpoint (ChannelPoint). The actions of this method can additionally be
         * augmented to attempt a force close after a timeout period in the case of an
         * inactive peer. If a non-force close (cooperative closure) is requested,
         * then the user can specify either a target number of blocks until the
         * closure transaction is confirmed, or a manual fee rate. If neither are
         * specified, then a default lax, block confirmation target is used.
         * @function closeChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ICloseChannelRequest} request CloseChannelRequest message or plain object
         * @returns {Promise<lnrpc.CloseStatusUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#abandonChannel}.
         * @memberof lnrpc.Lightning
         * @typedef AbandonChannelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.AbandonChannelResponse} [response] AbandonChannelResponse
         */

        /**
         * lncli: `abandonchannel`
         * AbandonChannel removes all channel state from the database except for a
         * close summary. This method can be used to get rid of permanently unusable
         * channels due to bugs fixed in newer versions of lnd. Only available
         * when in debug builds of lnd.
         * @function abandonChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IAbandonChannelRequest} request AbandonChannelRequest message or plain object
         * @param {lnrpc.Lightning.AbandonChannelCallback} callback Node-style callback called with the error, if any, and AbandonChannelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.abandonChannel = function abandonChannel(request, callback) {
            return this.rpcCall(abandonChannel, $root.lnrpc.AbandonChannelRequest, $root.lnrpc.AbandonChannelResponse, request, callback);
        }, "name", { value: "AbandonChannel" });

        /**
         * lncli: `abandonchannel`
         * AbandonChannel removes all channel state from the database except for a
         * close summary. This method can be used to get rid of permanently unusable
         * channels due to bugs fixed in newer versions of lnd. Only available
         * when in debug builds of lnd.
         * @function abandonChannel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IAbandonChannelRequest} request AbandonChannelRequest message or plain object
         * @returns {Promise<lnrpc.AbandonChannelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendPayment}.
         * @memberof lnrpc.Lightning
         * @typedef SendPaymentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * lncli: `sendpayment`
         * SendPayment dispatches a bi-directional streaming RPC for sending payments
         * through the Lightning Network. A single RPC invocation creates a persistent
         * bi-directional stream allowing clients to rapidly send payments through the
         * Lightning Network with a single persistent connection.
         * @function sendPayment
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @param {lnrpc.Lightning.SendPaymentCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendPayment = function sendPayment(request, callback) {
            return this.rpcCall(sendPayment, $root.lnrpc.SendRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendPayment" });

        /**
         * lncli: `sendpayment`
         * SendPayment dispatches a bi-directional streaming RPC for sending payments
         * through the Lightning Network. A single RPC invocation creates a persistent
         * bi-directional stream allowing clients to rapidly send payments through the
         * Lightning Network with a single persistent connection.
         * @function sendPayment
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendPaymentSync}.
         * @memberof lnrpc.Lightning
         * @typedef SendPaymentSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * SendPaymentSync is the synchronous non-streaming version of SendPayment.
         * This RPC is intended to be consumed by clients of the REST proxy.
         * Additionally, this RPC expects the destination's public key and the payment
         * hash (if any) to be encoded as hex strings.
         * @function sendPaymentSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @param {lnrpc.Lightning.SendPaymentSyncCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendPaymentSync = function sendPaymentSync(request, callback) {
            return this.rpcCall(sendPaymentSync, $root.lnrpc.SendRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendPaymentSync" });

        /**
         * SendPaymentSync is the synchronous non-streaming version of SendPayment.
         * This RPC is intended to be consumed by clients of the REST proxy.
         * Additionally, this RPC expects the destination's public key and the payment
         * hash (if any) to be encoded as hex strings.
         * @function sendPaymentSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendRequest} request SendRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendToRoute}.
         * @memberof lnrpc.Lightning
         * @typedef SendToRouteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * lncli: `sendtoroute`
         * SendToRoute is a bi-directional streaming RPC for sending payment through
         * the Lightning Network. This method differs from SendPayment in that it
         * allows users to specify a full route manually. This can be used for things
         * like rebalancing, and atomic swaps.
         * @function sendToRoute
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @param {lnrpc.Lightning.SendToRouteCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendToRoute = function sendToRoute(request, callback) {
            return this.rpcCall(sendToRoute, $root.lnrpc.SendToRouteRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendToRoute" });

        /**
         * lncli: `sendtoroute`
         * SendToRoute is a bi-directional streaming RPC for sending payment through
         * the Lightning Network. This method differs from SendPayment in that it
         * allows users to specify a full route manually. This can be used for things
         * like rebalancing, and atomic swaps.
         * @function sendToRoute
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#sendToRouteSync}.
         * @memberof lnrpc.Lightning
         * @typedef SendToRouteSyncCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SendResponse} [response] SendResponse
         */

        /**
         * SendToRouteSync is a synchronous version of SendToRoute. It Will block
         * until the payment either fails or succeeds.
         * @function sendToRouteSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @param {lnrpc.Lightning.SendToRouteSyncCallback} callback Node-style callback called with the error, if any, and SendResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.sendToRouteSync = function sendToRouteSync(request, callback) {
            return this.rpcCall(sendToRouteSync, $root.lnrpc.SendToRouteRequest, $root.lnrpc.SendResponse, request, callback);
        }, "name", { value: "SendToRouteSync" });

        /**
         * SendToRouteSync is a synchronous version of SendToRoute. It Will block
         * until the payment either fails or succeeds.
         * @function sendToRouteSync
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.ISendToRouteRequest} request SendToRouteRequest message or plain object
         * @returns {Promise<lnrpc.SendResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#addInvoice}.
         * @memberof lnrpc.Lightning
         * @typedef AddInvoiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.AddInvoiceResponse} [response] AddInvoiceResponse
         */

        /**
         * lncli: `addinvoice`
         * AddInvoice attempts to add a new invoice to the invoice database. Any
         * duplicated invoices are rejected, therefore all invoices *must* have a
         * unique payment preimage.
         * @function addInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoice} request Invoice message or plain object
         * @param {lnrpc.Lightning.AddInvoiceCallback} callback Node-style callback called with the error, if any, and AddInvoiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.addInvoice = function addInvoice(request, callback) {
            return this.rpcCall(addInvoice, $root.lnrpc.Invoice, $root.lnrpc.AddInvoiceResponse, request, callback);
        }, "name", { value: "AddInvoice" });

        /**
         * lncli: `addinvoice`
         * AddInvoice attempts to add a new invoice to the invoice database. Any
         * duplicated invoices are rejected, therefore all invoices *must* have a
         * unique payment preimage.
         * @function addInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoice} request Invoice message or plain object
         * @returns {Promise<lnrpc.AddInvoiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listInvoices}.
         * @memberof lnrpc.Lightning
         * @typedef ListInvoicesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListInvoiceResponse} [response] ListInvoiceResponse
         */

        /**
         * lncli: `listinvoices`
         * ListInvoices returns a list of all the invoices currently stored within the
         * database. Any active debug invoices are ignored. It has full support for
         * paginated responses, allowing users to query for specific invoices through
         * their add_index. This can be done by using either the first_index_offset or
         * last_index_offset fields included in the response as the index_offset of the
         * next request. By default, the first 100 invoices created will be returned.
         * Backwards pagination is also supported through the Reversed flag.
         * @function listInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListInvoiceRequest} request ListInvoiceRequest message or plain object
         * @param {lnrpc.Lightning.ListInvoicesCallback} callback Node-style callback called with the error, if any, and ListInvoiceResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listInvoices = function listInvoices(request, callback) {
            return this.rpcCall(listInvoices, $root.lnrpc.ListInvoiceRequest, $root.lnrpc.ListInvoiceResponse, request, callback);
        }, "name", { value: "ListInvoices" });

        /**
         * lncli: `listinvoices`
         * ListInvoices returns a list of all the invoices currently stored within the
         * database. Any active debug invoices are ignored. It has full support for
         * paginated responses, allowing users to query for specific invoices through
         * their add_index. This can be done by using either the first_index_offset or
         * last_index_offset fields included in the response as the index_offset of the
         * next request. By default, the first 100 invoices created will be returned.
         * Backwards pagination is also supported through the Reversed flag.
         * @function listInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListInvoiceRequest} request ListInvoiceRequest message or plain object
         * @returns {Promise<lnrpc.ListInvoiceResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#lookupInvoice}.
         * @memberof lnrpc.Lightning
         * @typedef LookupInvoiceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Invoice} [response] Invoice
         */

        /**
         * lncli: `lookupinvoice`
         * LookupInvoice attempts to look up an invoice according to its payment hash.
         * The passed payment hash *must* be exactly 32 bytes, if not, an error is
         * returned.
         * @function lookupInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPaymentHash} request PaymentHash message or plain object
         * @param {lnrpc.Lightning.LookupInvoiceCallback} callback Node-style callback called with the error, if any, and Invoice
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.lookupInvoice = function lookupInvoice(request, callback) {
            return this.rpcCall(lookupInvoice, $root.lnrpc.PaymentHash, $root.lnrpc.Invoice, request, callback);
        }, "name", { value: "LookupInvoice" });

        /**
         * lncli: `lookupinvoice`
         * LookupInvoice attempts to look up an invoice according to its payment hash.
         * The passed payment hash *must* be exactly 32 bytes, if not, an error is
         * returned.
         * @function lookupInvoice
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPaymentHash} request PaymentHash message or plain object
         * @returns {Promise<lnrpc.Invoice>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeInvoices}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeInvoicesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.Invoice} [response] Invoice
         */

        /**
         * SubscribeInvoices returns a uni-directional stream (server -> client) for
         * notifying the client of newly added/settled invoices. The caller can
         * optionally specify the add_index and/or the settle_index. If the add_index
         * is specified, then we'll first start by sending add invoice events for all
         * invoices with an add_index greater than the specified value.  If the
         * settle_index is specified, the next, we'll send out all settle events for
         * invoices with a settle_index greater than the specified value.  One or both
         * of these fields can be set. If no fields are set, then we'll only send out
         * the latest add/settle events.
         * @function subscribeInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoiceSubscription} request InvoiceSubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeInvoicesCallback} callback Node-style callback called with the error, if any, and Invoice
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeInvoices = function subscribeInvoices(request, callback) {
            return this.rpcCall(subscribeInvoices, $root.lnrpc.InvoiceSubscription, $root.lnrpc.Invoice, request, callback);
        }, "name", { value: "SubscribeInvoices" });

        /**
         * SubscribeInvoices returns a uni-directional stream (server -> client) for
         * notifying the client of newly added/settled invoices. The caller can
         * optionally specify the add_index and/or the settle_index. If the add_index
         * is specified, then we'll first start by sending add invoice events for all
         * invoices with an add_index greater than the specified value.  If the
         * settle_index is specified, the next, we'll send out all settle events for
         * invoices with a settle_index greater than the specified value.  One or both
         * of these fields can be set. If no fields are set, then we'll only send out
         * the latest add/settle events.
         * @function subscribeInvoices
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IInvoiceSubscription} request InvoiceSubscription message or plain object
         * @returns {Promise<lnrpc.Invoice>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#decodePayReq}.
         * @memberof lnrpc.Lightning
         * @typedef DecodePayReqCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PayReq} [response] PayReq
         */

        /**
         * lncli: `decodepayreq`
         * DecodePayReq takes an encoded payment request string and attempts to decode
         * it, returning a full description of the conditions encoded within the
         * payment request.
         * @function decodePayReq
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPayReqString} request PayReqString message or plain object
         * @param {lnrpc.Lightning.DecodePayReqCallback} callback Node-style callback called with the error, if any, and PayReq
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.decodePayReq = function decodePayReq(request, callback) {
            return this.rpcCall(decodePayReq, $root.lnrpc.PayReqString, $root.lnrpc.PayReq, request, callback);
        }, "name", { value: "DecodePayReq" });

        /**
         * lncli: `decodepayreq`
         * DecodePayReq takes an encoded payment request string and attempts to decode
         * it, returning a full description of the conditions encoded within the
         * payment request.
         * @function decodePayReq
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPayReqString} request PayReqString message or plain object
         * @returns {Promise<lnrpc.PayReq>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#listPayments}.
         * @memberof lnrpc.Lightning
         * @typedef ListPaymentsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ListPaymentsResponse} [response] ListPaymentsResponse
         */

        /**
         * lncli: `listpayments`
         * ListPayments returns a list of all outgoing payments.
         * @function listPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPaymentsRequest} request ListPaymentsRequest message or plain object
         * @param {lnrpc.Lightning.ListPaymentsCallback} callback Node-style callback called with the error, if any, and ListPaymentsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.listPayments = function listPayments(request, callback) {
            return this.rpcCall(listPayments, $root.lnrpc.ListPaymentsRequest, $root.lnrpc.ListPaymentsResponse, request, callback);
        }, "name", { value: "ListPayments" });

        /**
         * lncli: `listpayments`
         * ListPayments returns a list of all outgoing payments.
         * @function listPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IListPaymentsRequest} request ListPaymentsRequest message or plain object
         * @returns {Promise<lnrpc.ListPaymentsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#deleteAllPayments}.
         * @memberof lnrpc.Lightning
         * @typedef DeleteAllPaymentsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DeleteAllPaymentsResponse} [response] DeleteAllPaymentsResponse
         */

        /**
         * DeleteAllPayments deletes all outgoing payments from DB.
         * @function deleteAllPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDeleteAllPaymentsRequest} request DeleteAllPaymentsRequest message or plain object
         * @param {lnrpc.Lightning.DeleteAllPaymentsCallback} callback Node-style callback called with the error, if any, and DeleteAllPaymentsResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.deleteAllPayments = function deleteAllPayments(request, callback) {
            return this.rpcCall(deleteAllPayments, $root.lnrpc.DeleteAllPaymentsRequest, $root.lnrpc.DeleteAllPaymentsResponse, request, callback);
        }, "name", { value: "DeleteAllPayments" });

        /**
         * DeleteAllPayments deletes all outgoing payments from DB.
         * @function deleteAllPayments
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDeleteAllPaymentsRequest} request DeleteAllPaymentsRequest message or plain object
         * @returns {Promise<lnrpc.DeleteAllPaymentsResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#describeGraph}.
         * @memberof lnrpc.Lightning
         * @typedef DescribeGraphCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelGraph} [response] ChannelGraph
         */

        /**
         * lncli: `describegraph`
         * DescribeGraph returns a description of the latest graph state from the
         * point of view of the node. The graph information is partitioned into two
         * components: all the nodes/vertexes, and all the edges that connect the
         * vertexes themselves.  As this is a directed graph, the edges also contain
         * the node directional specific routing policy which includes: the time lock
         * delta, fee information, etc.
         * @function describeGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelGraphRequest} request ChannelGraphRequest message or plain object
         * @param {lnrpc.Lightning.DescribeGraphCallback} callback Node-style callback called with the error, if any, and ChannelGraph
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.describeGraph = function describeGraph(request, callback) {
            return this.rpcCall(describeGraph, $root.lnrpc.ChannelGraphRequest, $root.lnrpc.ChannelGraph, request, callback);
        }, "name", { value: "DescribeGraph" });

        /**
         * lncli: `describegraph`
         * DescribeGraph returns a description of the latest graph state from the
         * point of view of the node. The graph information is partitioned into two
         * components: all the nodes/vertexes, and all the edges that connect the
         * vertexes themselves.  As this is a directed graph, the edges also contain
         * the node directional specific routing policy which includes: the time lock
         * delta, fee information, etc.
         * @function describeGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelGraphRequest} request ChannelGraphRequest message or plain object
         * @returns {Promise<lnrpc.ChannelGraph>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getChanInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetChanInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelEdge} [response] ChannelEdge
         */

        /**
         * lncli: `getchaninfo`
         * GetChanInfo returns the latest authenticated network announcement for the
         * given channel identified by its channel ID: an 8-byte integer which
         * uniquely identifies the location of transaction's funding output within the
         * blockchain.
         * @function getChanInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanInfoRequest} request ChanInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetChanInfoCallback} callback Node-style callback called with the error, if any, and ChannelEdge
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getChanInfo = function getChanInfo(request, callback) {
            return this.rpcCall(getChanInfo, $root.lnrpc.ChanInfoRequest, $root.lnrpc.ChannelEdge, request, callback);
        }, "name", { value: "GetChanInfo" });

        /**
         * lncli: `getchaninfo`
         * GetChanInfo returns the latest authenticated network announcement for the
         * given channel identified by its channel ID: an 8-byte integer which
         * uniquely identifies the location of transaction's funding output within the
         * blockchain.
         * @function getChanInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanInfoRequest} request ChanInfoRequest message or plain object
         * @returns {Promise<lnrpc.ChannelEdge>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getNodeInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetNodeInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NodeInfo} [response] NodeInfo
         */

        /**
         * lncli: `getnodeinfo`
         * GetNodeInfo returns the latest advertised, aggregated, and authenticated
         * channel information for the specified node identified by its public key.
         * @function getNodeInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INodeInfoRequest} request NodeInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetNodeInfoCallback} callback Node-style callback called with the error, if any, and NodeInfo
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getNodeInfo = function getNodeInfo(request, callback) {
            return this.rpcCall(getNodeInfo, $root.lnrpc.NodeInfoRequest, $root.lnrpc.NodeInfo, request, callback);
        }, "name", { value: "GetNodeInfo" });

        /**
         * lncli: `getnodeinfo`
         * GetNodeInfo returns the latest advertised, aggregated, and authenticated
         * channel information for the specified node identified by its public key.
         * @function getNodeInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INodeInfoRequest} request NodeInfoRequest message or plain object
         * @returns {Promise<lnrpc.NodeInfo>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#queryRoutes}.
         * @memberof lnrpc.Lightning
         * @typedef QueryRoutesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.QueryRoutesResponse} [response] QueryRoutesResponse
         */

        /**
         * lncli: `queryroutes`
         * QueryRoutes attempts to query the daemon's Channel Router for a possible
         * route to a target destination capable of carrying a specific amount of
         * satoshis. The returned route contains the full details required to craft and
         * send an HTLC, also including the necessary information that should be
         * present within the Sphinx packet encapsulated within the HTLC.
         * @function queryRoutes
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IQueryRoutesRequest} request QueryRoutesRequest message or plain object
         * @param {lnrpc.Lightning.QueryRoutesCallback} callback Node-style callback called with the error, if any, and QueryRoutesResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.queryRoutes = function queryRoutes(request, callback) {
            return this.rpcCall(queryRoutes, $root.lnrpc.QueryRoutesRequest, $root.lnrpc.QueryRoutesResponse, request, callback);
        }, "name", { value: "QueryRoutes" });

        /**
         * lncli: `queryroutes`
         * QueryRoutes attempts to query the daemon's Channel Router for a possible
         * route to a target destination capable of carrying a specific amount of
         * satoshis. The returned route contains the full details required to craft and
         * send an HTLC, also including the necessary information that should be
         * present within the Sphinx packet encapsulated within the HTLC.
         * @function queryRoutes
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IQueryRoutesRequest} request QueryRoutesRequest message or plain object
         * @returns {Promise<lnrpc.QueryRoutesResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#getNetworkInfo}.
         * @memberof lnrpc.Lightning
         * @typedef GetNetworkInfoCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.NetworkInfo} [response] NetworkInfo
         */

        /**
         * lncli: `getnetworkinfo`
         * GetNetworkInfo returns some basic stats about the known channel graph from
         * the point of view of the node.
         * @function getNetworkInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INetworkInfoRequest} request NetworkInfoRequest message or plain object
         * @param {lnrpc.Lightning.GetNetworkInfoCallback} callback Node-style callback called with the error, if any, and NetworkInfo
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.getNetworkInfo = function getNetworkInfo(request, callback) {
            return this.rpcCall(getNetworkInfo, $root.lnrpc.NetworkInfoRequest, $root.lnrpc.NetworkInfo, request, callback);
        }, "name", { value: "GetNetworkInfo" });

        /**
         * lncli: `getnetworkinfo`
         * GetNetworkInfo returns some basic stats about the known channel graph from
         * the point of view of the node.
         * @function getNetworkInfo
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.INetworkInfoRequest} request NetworkInfoRequest message or plain object
         * @returns {Promise<lnrpc.NetworkInfo>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#stopDaemon}.
         * @memberof lnrpc.Lightning
         * @typedef StopDaemonCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.StopResponse} [response] StopResponse
         */

        /**
         * lncli: `stop`
         * StopDaemon will send a shutdown request to the interrupt handler, triggering
         * a graceful shutdown of the daemon.
         * @function stopDaemon
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IStopRequest} request StopRequest message or plain object
         * @param {lnrpc.Lightning.StopDaemonCallback} callback Node-style callback called with the error, if any, and StopResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.stopDaemon = function stopDaemon(request, callback) {
            return this.rpcCall(stopDaemon, $root.lnrpc.StopRequest, $root.lnrpc.StopResponse, request, callback);
        }, "name", { value: "StopDaemon" });

        /**
         * lncli: `stop`
         * StopDaemon will send a shutdown request to the interrupt handler, triggering
         * a graceful shutdown of the daemon.
         * @function stopDaemon
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IStopRequest} request StopRequest message or plain object
         * @returns {Promise<lnrpc.StopResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeChannelGraph}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeChannelGraphCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.GraphTopologyUpdate} [response] GraphTopologyUpdate
         */

        /**
         * SubscribeChannelGraph launches a streaming RPC that allows the caller to
         * receive notifications upon any changes to the channel graph topology from
         * the point of view of the responding node. Events notified include: new
         * nodes coming online, nodes updating their authenticated attributes, new
         * channels being advertised, updates in the routing policy for a directional
         * channel edge, and when channels are closed on-chain.
         * @function subscribeChannelGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGraphTopologySubscription} request GraphTopologySubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeChannelGraphCallback} callback Node-style callback called with the error, if any, and GraphTopologyUpdate
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeChannelGraph = function subscribeChannelGraph(request, callback) {
            return this.rpcCall(subscribeChannelGraph, $root.lnrpc.GraphTopologySubscription, $root.lnrpc.GraphTopologyUpdate, request, callback);
        }, "name", { value: "SubscribeChannelGraph" });

        /**
         * SubscribeChannelGraph launches a streaming RPC that allows the caller to
         * receive notifications upon any changes to the channel graph topology from
         * the point of view of the responding node. Events notified include: new
         * nodes coming online, nodes updating their authenticated attributes, new
         * channels being advertised, updates in the routing policy for a directional
         * channel edge, and when channels are closed on-chain.
         * @function subscribeChannelGraph
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IGraphTopologySubscription} request GraphTopologySubscription message or plain object
         * @returns {Promise<lnrpc.GraphTopologyUpdate>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#debugLevel}.
         * @memberof lnrpc.Lightning
         * @typedef DebugLevelCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.DebugLevelResponse} [response] DebugLevelResponse
         */

        /**
         * lncli: `debuglevel`
         * DebugLevel allows a caller to programmatically set the logging verbosity of
         * lnd. The logging can be targeted according to a coarse daemon-wide logging
         * level, or in a granular fashion to specify the logging for a target
         * sub-system.
         * @function debugLevel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDebugLevelRequest} request DebugLevelRequest message or plain object
         * @param {lnrpc.Lightning.DebugLevelCallback} callback Node-style callback called with the error, if any, and DebugLevelResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.debugLevel = function debugLevel(request, callback) {
            return this.rpcCall(debugLevel, $root.lnrpc.DebugLevelRequest, $root.lnrpc.DebugLevelResponse, request, callback);
        }, "name", { value: "DebugLevel" });

        /**
         * lncli: `debuglevel`
         * DebugLevel allows a caller to programmatically set the logging verbosity of
         * lnd. The logging can be targeted according to a coarse daemon-wide logging
         * level, or in a granular fashion to specify the logging for a target
         * sub-system.
         * @function debugLevel
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IDebugLevelRequest} request DebugLevelRequest message or plain object
         * @returns {Promise<lnrpc.DebugLevelResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#feeReport}.
         * @memberof lnrpc.Lightning
         * @typedef FeeReportCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.FeeReportResponse} [response] FeeReportResponse
         */

        /**
         * lncli: `feereport`
         * FeeReport allows the caller to obtain a report detailing the current fee
         * schedule enforced by the node globally for each channel.
         * @function feeReport
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IFeeReportRequest} request FeeReportRequest message or plain object
         * @param {lnrpc.Lightning.FeeReportCallback} callback Node-style callback called with the error, if any, and FeeReportResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.feeReport = function feeReport(request, callback) {
            return this.rpcCall(feeReport, $root.lnrpc.FeeReportRequest, $root.lnrpc.FeeReportResponse, request, callback);
        }, "name", { value: "FeeReport" });

        /**
         * lncli: `feereport`
         * FeeReport allows the caller to obtain a report detailing the current fee
         * schedule enforced by the node globally for each channel.
         * @function feeReport
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IFeeReportRequest} request FeeReportRequest message or plain object
         * @returns {Promise<lnrpc.FeeReportResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#updateChannelPolicy}.
         * @memberof lnrpc.Lightning
         * @typedef UpdateChannelPolicyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.PolicyUpdateResponse} [response] PolicyUpdateResponse
         */

        /**
         * lncli: `updatechanpolicy`
         * UpdateChannelPolicy allows the caller to update the fee schedule and
         * channel policies for all channels globally, or a particular channel.
         * @function updateChannelPolicy
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPolicyUpdateRequest} request PolicyUpdateRequest message or plain object
         * @param {lnrpc.Lightning.UpdateChannelPolicyCallback} callback Node-style callback called with the error, if any, and PolicyUpdateResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.updateChannelPolicy = function updateChannelPolicy(request, callback) {
            return this.rpcCall(updateChannelPolicy, $root.lnrpc.PolicyUpdateRequest, $root.lnrpc.PolicyUpdateResponse, request, callback);
        }, "name", { value: "UpdateChannelPolicy" });

        /**
         * lncli: `updatechanpolicy`
         * UpdateChannelPolicy allows the caller to update the fee schedule and
         * channel policies for all channels globally, or a particular channel.
         * @function updateChannelPolicy
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IPolicyUpdateRequest} request PolicyUpdateRequest message or plain object
         * @returns {Promise<lnrpc.PolicyUpdateResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#forwardingHistory}.
         * @memberof lnrpc.Lightning
         * @typedef ForwardingHistoryCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ForwardingHistoryResponse} [response] ForwardingHistoryResponse
         */

        /**
         * lncli: `fwdinghistory`
         * ForwardingHistory allows the caller to query the htlcswitch for a record of
         * all HTLCs forwarded within the target time range, and integer offset
         * within that time range. If no time-range is specified, then the first chunk
         * of the past 24 hrs of forwarding history are returned.
         * 
         * A list of forwarding events are returned. The size of each forwarding event
         * is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
         * As a result each message can only contain 50k entries.  Each response has
         * the index offset of the last entry. The index offset can be provided to the
         * request to allow the caller to skip a series of records.
         * @function forwardingHistory
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IForwardingHistoryRequest} request ForwardingHistoryRequest message or plain object
         * @param {lnrpc.Lightning.ForwardingHistoryCallback} callback Node-style callback called with the error, if any, and ForwardingHistoryResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.forwardingHistory = function forwardingHistory(request, callback) {
            return this.rpcCall(forwardingHistory, $root.lnrpc.ForwardingHistoryRequest, $root.lnrpc.ForwardingHistoryResponse, request, callback);
        }, "name", { value: "ForwardingHistory" });

        /**
         * lncli: `fwdinghistory`
         * ForwardingHistory allows the caller to query the htlcswitch for a record of
         * all HTLCs forwarded within the target time range, and integer offset
         * within that time range. If no time-range is specified, then the first chunk
         * of the past 24 hrs of forwarding history are returned.
         * 
         * A list of forwarding events are returned. The size of each forwarding event
         * is 40 bytes, and the max message size able to be returned in gRPC is 4 MiB.
         * As a result each message can only contain 50k entries.  Each response has
         * the index offset of the last entry. The index offset can be provided to the
         * request to allow the caller to skip a series of records.
         * @function forwardingHistory
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IForwardingHistoryRequest} request ForwardingHistoryRequest message or plain object
         * @returns {Promise<lnrpc.ForwardingHistoryResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#exportChannelBackup}.
         * @memberof lnrpc.Lightning
         * @typedef ExportChannelBackupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChannelBackup} [response] ChannelBackup
         */

        /**
         * lncli: `exportchanbackup`
         * ExportChannelBackup attempts to return an encrypted static channel backup
         * for the target channel identified by it channel point. The backup is
         * encrypted with a key generated from the aezeed seed of the user. The
         * returned backup can either be restored using the RestoreChannelBackup
         * method once lnd is running, or via the InitWallet and UnlockWallet methods
         * from the WalletUnlocker service.
         * @function exportChannelBackup
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IExportChannelBackupRequest} request ExportChannelBackupRequest message or plain object
         * @param {lnrpc.Lightning.ExportChannelBackupCallback} callback Node-style callback called with the error, if any, and ChannelBackup
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.exportChannelBackup = function exportChannelBackup(request, callback) {
            return this.rpcCall(exportChannelBackup, $root.lnrpc.ExportChannelBackupRequest, $root.lnrpc.ChannelBackup, request, callback);
        }, "name", { value: "ExportChannelBackup" });

        /**
         * lncli: `exportchanbackup`
         * ExportChannelBackup attempts to return an encrypted static channel backup
         * for the target channel identified by it channel point. The backup is
         * encrypted with a key generated from the aezeed seed of the user. The
         * returned backup can either be restored using the RestoreChannelBackup
         * method once lnd is running, or via the InitWallet and UnlockWallet methods
         * from the WalletUnlocker service.
         * @function exportChannelBackup
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IExportChannelBackupRequest} request ExportChannelBackupRequest message or plain object
         * @returns {Promise<lnrpc.ChannelBackup>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#exportAllChannelBackups}.
         * @memberof lnrpc.Lightning
         * @typedef ExportAllChannelBackupsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChanBackupSnapshot} [response] ChanBackupSnapshot
         */

        /**
         * ExportAllChannelBackups returns static channel backups for all existing
         * channels known to lnd. A set of regular singular static channel backups for
         * each channel are returned. Additionally, a multi-channel backup is returned
         * as well, which contains a single encrypted blob containing the backups of
         * each channel.
         * @function exportAllChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanBackupExportRequest} request ChanBackupExportRequest message or plain object
         * @param {lnrpc.Lightning.ExportAllChannelBackupsCallback} callback Node-style callback called with the error, if any, and ChanBackupSnapshot
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.exportAllChannelBackups = function exportAllChannelBackups(request, callback) {
            return this.rpcCall(exportAllChannelBackups, $root.lnrpc.ChanBackupExportRequest, $root.lnrpc.ChanBackupSnapshot, request, callback);
        }, "name", { value: "ExportAllChannelBackups" });

        /**
         * ExportAllChannelBackups returns static channel backups for all existing
         * channels known to lnd. A set of regular singular static channel backups for
         * each channel are returned. Additionally, a multi-channel backup is returned
         * as well, which contains a single encrypted blob containing the backups of
         * each channel.
         * @function exportAllChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanBackupExportRequest} request ChanBackupExportRequest message or plain object
         * @returns {Promise<lnrpc.ChanBackupSnapshot>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#verifyChanBackup}.
         * @memberof lnrpc.Lightning
         * @typedef VerifyChanBackupCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.VerifyChanBackupResponse} [response] VerifyChanBackupResponse
         */

        /**
         * VerifyChanBackup allows a caller to verify the integrity of a channel backup
         * snapshot. This method will accept either a packed Single or a packed Multi.
         * Specifying both will result in an error.
         * @function verifyChanBackup
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanBackupSnapshot} request ChanBackupSnapshot message or plain object
         * @param {lnrpc.Lightning.VerifyChanBackupCallback} callback Node-style callback called with the error, if any, and VerifyChanBackupResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.verifyChanBackup = function verifyChanBackup(request, callback) {
            return this.rpcCall(verifyChanBackup, $root.lnrpc.ChanBackupSnapshot, $root.lnrpc.VerifyChanBackupResponse, request, callback);
        }, "name", { value: "VerifyChanBackup" });

        /**
         * VerifyChanBackup allows a caller to verify the integrity of a channel backup
         * snapshot. This method will accept either a packed Single or a packed Multi.
         * Specifying both will result in an error.
         * @function verifyChanBackup
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChanBackupSnapshot} request ChanBackupSnapshot message or plain object
         * @returns {Promise<lnrpc.VerifyChanBackupResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#restoreChannelBackups}.
         * @memberof lnrpc.Lightning
         * @typedef RestoreChannelBackupsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.RestoreBackupResponse} [response] RestoreBackupResponse
         */

        /**
         * lncli: `restorechanbackup`
         * RestoreChannelBackups accepts a set of singular channel backups, or a
         * single encrypted multi-chan backup and attempts to recover any funds
         * remaining within the channel. If we are able to unpack the backup, then the
         * new channel will be shown under listchannels, as well as pending channels.
         * @function restoreChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IRestoreChanBackupRequest} request RestoreChanBackupRequest message or plain object
         * @param {lnrpc.Lightning.RestoreChannelBackupsCallback} callback Node-style callback called with the error, if any, and RestoreBackupResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.restoreChannelBackups = function restoreChannelBackups(request, callback) {
            return this.rpcCall(restoreChannelBackups, $root.lnrpc.RestoreChanBackupRequest, $root.lnrpc.RestoreBackupResponse, request, callback);
        }, "name", { value: "RestoreChannelBackups" });

        /**
         * lncli: `restorechanbackup`
         * RestoreChannelBackups accepts a set of singular channel backups, or a
         * single encrypted multi-chan backup and attempts to recover any funds
         * remaining within the channel. If we are able to unpack the backup, then the
         * new channel will be shown under listchannels, as well as pending channels.
         * @function restoreChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IRestoreChanBackupRequest} request RestoreChanBackupRequest message or plain object
         * @returns {Promise<lnrpc.RestoreBackupResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Lightning#subscribeChannelBackups}.
         * @memberof lnrpc.Lightning
         * @typedef SubscribeChannelBackupsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ChanBackupSnapshot} [response] ChanBackupSnapshot
         */

        /**
         * SubscribeChannelBackups allows a client to sub-subscribe to the most up to
         * date information concerning the state of all channel backups. Each time a
         * new channel is added, we return the new set of channels, along with a
         * multi-chan backup containing the backup info for all channels. Each time a
         * channel is closed, we send a new update, which contains new new chan back
         * ups, but the updated set of encrypted multi-chan backups with the closed
         * channel(s) removed.
         * @function subscribeChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBackupSubscription} request ChannelBackupSubscription message or plain object
         * @param {lnrpc.Lightning.SubscribeChannelBackupsCallback} callback Node-style callback called with the error, if any, and ChanBackupSnapshot
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Lightning.prototype.subscribeChannelBackups = function subscribeChannelBackups(request, callback) {
            return this.rpcCall(subscribeChannelBackups, $root.lnrpc.ChannelBackupSubscription, $root.lnrpc.ChanBackupSnapshot, request, callback);
        }, "name", { value: "SubscribeChannelBackups" });

        /**
         * SubscribeChannelBackups allows a client to sub-subscribe to the most up to
         * date information concerning the state of all channel backups. Each time a
         * new channel is added, we return the new set of channels, along with a
         * multi-chan backup containing the backup info for all channels. Each time a
         * channel is closed, we send a new update, which contains new new chan back
         * ups, but the updated set of encrypted multi-chan backups with the closed
         * channel(s) removed.
         * @function subscribeChannelBackups
         * @memberof lnrpc.Lightning
         * @instance
         * @param {lnrpc.IChannelBackupSubscription} request ChannelBackupSubscription message or plain object
         * @returns {Promise<lnrpc.ChanBackupSnapshot>} Promise
         * @variation 2
         */

        return Lightning;
    })();

    lnrpc.Utxo = (function() {

        /**
         * Properties of an Utxo.
         * @memberof lnrpc
         * @interface IUtxo
         * @property {lnrpc.AddressType|null} [type] The type of address
         * @property {string|null} [address] The address
         * @property {number|Long|null} [amountSat] The value of the unspent coin in satoshis
         * @property {string|null} [pkScript] The pkscript in hex
         * @property {lnrpc.IOutPoint|null} [outpoint] The outpoint in format txid:n
         * @property {number|Long|null} [confirmations] The number of confirmations for the Utxo
         */

        /**
         * Constructs a new Utxo.
         * @memberof lnrpc
         * @classdesc Represents an Utxo.
         * @implements IUtxo
         * @constructor
         * @param {lnrpc.IUtxo=} [properties] Properties to set
         */
        function Utxo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The type of address
         * @member {lnrpc.AddressType} type
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.type = 0;

        /**
         * The address
         * @member {string} address
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.address = "";

        /**
         * The value of the unspent coin in satoshis
         * @member {number|Long} amountSat
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.amountSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The pkscript in hex
         * @member {string} pkScript
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.pkScript = "";

        /**
         * The outpoint in format txid:n
         * @member {lnrpc.IOutPoint|null|undefined} outpoint
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.outpoint = null;

        /**
         * The number of confirmations for the Utxo
         * @member {number|Long} confirmations
         * @memberof lnrpc.Utxo
         * @instance
         */
        Utxo.prototype.confirmations = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Utxo instance using the specified properties.
         * @function create
         * @memberof lnrpc.Utxo
         * @static
         * @param {lnrpc.IUtxo=} [properties] Properties to set
         * @returns {lnrpc.Utxo} Utxo instance
         */
        Utxo.create = function create(properties) {
            return new Utxo(properties);
        };

        /**
         * Encodes the specified Utxo message. Does not implicitly {@link lnrpc.Utxo.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Utxo
         * @static
         * @param {lnrpc.IUtxo} message Utxo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Utxo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);
            if (message.amountSat != null && message.hasOwnProperty("amountSat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amountSat);
            if (message.pkScript != null && message.hasOwnProperty("pkScript"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.pkScript);
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                $root.lnrpc.OutPoint.encode(message.outpoint, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.confirmations != null && message.hasOwnProperty("confirmations"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.confirmations);
            return writer;
        };

        /**
         * Encodes the specified Utxo message, length delimited. Does not implicitly {@link lnrpc.Utxo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Utxo
         * @static
         * @param {lnrpc.IUtxo} message Utxo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Utxo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Utxo message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Utxo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Utxo} Utxo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Utxo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Utxo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.address = reader.string();
                    break;
                case 3:
                    message.amountSat = reader.int64();
                    break;
                case 4:
                    message.pkScript = reader.string();
                    break;
                case 5:
                    message.outpoint = $root.lnrpc.OutPoint.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.confirmations = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Utxo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Utxo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Utxo} Utxo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Utxo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Utxo message.
         * @function verify
         * @memberof lnrpc.Utxo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Utxo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.amountSat != null && message.hasOwnProperty("amountSat"))
                if (!$util.isInteger(message.amountSat) && !(message.amountSat && $util.isInteger(message.amountSat.low) && $util.isInteger(message.amountSat.high)))
                    return "amountSat: integer|Long expected";
            if (message.pkScript != null && message.hasOwnProperty("pkScript"))
                if (!$util.isString(message.pkScript))
                    return "pkScript: string expected";
            if (message.outpoint != null && message.hasOwnProperty("outpoint")) {
                let error = $root.lnrpc.OutPoint.verify(message.outpoint);
                if (error)
                    return "outpoint." + error;
            }
            if (message.confirmations != null && message.hasOwnProperty("confirmations"))
                if (!$util.isInteger(message.confirmations) && !(message.confirmations && $util.isInteger(message.confirmations.low) && $util.isInteger(message.confirmations.high)))
                    return "confirmations: integer|Long expected";
            return null;
        };

        /**
         * Creates an Utxo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Utxo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Utxo} Utxo
         */
        Utxo.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Utxo)
                return object;
            let message = new $root.lnrpc.Utxo();
            switch (object.type) {
            case "WITNESS_PUBKEY_HASH":
            case 0:
                message.type = 0;
                break;
            case "NESTED_PUBKEY_HASH":
            case 1:
                message.type = 1;
                break;
            case "UNUSED_WITNESS_PUBKEY_HASH":
            case 2:
                message.type = 2;
                break;
            case "UNUSED_NESTED_PUBKEY_HASH":
            case 3:
                message.type = 3;
                break;
            }
            if (object.address != null)
                message.address = String(object.address);
            if (object.amountSat != null)
                if ($util.Long)
                    (message.amountSat = $util.Long.fromValue(object.amountSat)).unsigned = false;
                else if (typeof object.amountSat === "string")
                    message.amountSat = parseInt(object.amountSat, 10);
                else if (typeof object.amountSat === "number")
                    message.amountSat = object.amountSat;
                else if (typeof object.amountSat === "object")
                    message.amountSat = new $util.LongBits(object.amountSat.low >>> 0, object.amountSat.high >>> 0).toNumber();
            if (object.pkScript != null)
                message.pkScript = String(object.pkScript);
            if (object.outpoint != null) {
                if (typeof object.outpoint !== "object")
                    throw TypeError(".lnrpc.Utxo.outpoint: object expected");
                message.outpoint = $root.lnrpc.OutPoint.fromObject(object.outpoint);
            }
            if (object.confirmations != null)
                if ($util.Long)
                    (message.confirmations = $util.Long.fromValue(object.confirmations)).unsigned = false;
                else if (typeof object.confirmations === "string")
                    message.confirmations = parseInt(object.confirmations, 10);
                else if (typeof object.confirmations === "number")
                    message.confirmations = object.confirmations;
                else if (typeof object.confirmations === "object")
                    message.confirmations = new $util.LongBits(object.confirmations.low >>> 0, object.confirmations.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an Utxo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Utxo
         * @static
         * @param {lnrpc.Utxo} message Utxo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Utxo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "WITNESS_PUBKEY_HASH" : 0;
                object.address = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amountSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amountSat = options.longs === String ? "0" : 0;
                object.pkScript = "";
                object.outpoint = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.confirmations = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.confirmations = options.longs === String ? "0" : 0;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.lnrpc.AddressType[message.type] : message.type;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.amountSat != null && message.hasOwnProperty("amountSat"))
                if (typeof message.amountSat === "number")
                    object.amountSat = options.longs === String ? String(message.amountSat) : message.amountSat;
                else
                    object.amountSat = options.longs === String ? $util.Long.prototype.toString.call(message.amountSat) : options.longs === Number ? new $util.LongBits(message.amountSat.low >>> 0, message.amountSat.high >>> 0).toNumber() : message.amountSat;
            if (message.pkScript != null && message.hasOwnProperty("pkScript"))
                object.pkScript = message.pkScript;
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                object.outpoint = $root.lnrpc.OutPoint.toObject(message.outpoint, options);
            if (message.confirmations != null && message.hasOwnProperty("confirmations"))
                if (typeof message.confirmations === "number")
                    object.confirmations = options.longs === String ? String(message.confirmations) : message.confirmations;
                else
                    object.confirmations = options.longs === String ? $util.Long.prototype.toString.call(message.confirmations) : options.longs === Number ? new $util.LongBits(message.confirmations.low >>> 0, message.confirmations.high >>> 0).toNumber() : message.confirmations;
            return object;
        };

        /**
         * Converts this Utxo to JSON.
         * @function toJSON
         * @memberof lnrpc.Utxo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Utxo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Utxo;
    })();

    lnrpc.Transaction = (function() {

        /**
         * Properties of a Transaction.
         * @memberof lnrpc
         * @interface ITransaction
         * @property {string|null} [txHash] The transaction hash
         * @property {number|Long|null} [amount] The transaction amount, denominated in satoshis
         * @property {number|null} [numConfirmations] The number of confirmations
         * @property {string|null} [blockHash] The hash of the block this transaction was included in
         * @property {number|null} [blockHeight] The height of the block this transaction was included in
         * @property {number|Long|null} [timeStamp] Timestamp of this transaction
         * @property {number|Long|null} [totalFees] Fees paid for this transaction
         * @property {Array.<string>|null} [destAddresses] Addresses that received funds for this transaction
         * @property {string|null} [rawTxHex] The raw transaction hex.
         */

        /**
         * Constructs a new Transaction.
         * @memberof lnrpc
         * @classdesc Represents a Transaction.
         * @implements ITransaction
         * @constructor
         * @param {lnrpc.ITransaction=} [properties] Properties to set
         */
        function Transaction(properties) {
            this.destAddresses = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The transaction hash
         * @member {string} txHash
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.txHash = "";

        /**
         * The transaction amount, denominated in satoshis
         * @member {number|Long} amount
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The number of confirmations
         * @member {number} numConfirmations
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.numConfirmations = 0;

        /**
         * The hash of the block this transaction was included in
         * @member {string} blockHash
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.blockHash = "";

        /**
         * The height of the block this transaction was included in
         * @member {number} blockHeight
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.blockHeight = 0;

        /**
         * Timestamp of this transaction
         * @member {number|Long} timeStamp
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.timeStamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fees paid for this transaction
         * @member {number|Long} totalFees
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.totalFees = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Addresses that received funds for this transaction
         * @member {Array.<string>} destAddresses
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.destAddresses = $util.emptyArray;

        /**
         * The raw transaction hex.
         * @member {string} rawTxHex
         * @memberof lnrpc.Transaction
         * @instance
         */
        Transaction.prototype.rawTxHex = "";

        /**
         * Creates a new Transaction instance using the specified properties.
         * @function create
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction=} [properties] Properties to set
         * @returns {lnrpc.Transaction} Transaction instance
         */
        Transaction.create = function create(properties) {
            return new Transaction(properties);
        };

        /**
         * Encodes the specified Transaction message. Does not implicitly {@link lnrpc.Transaction.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txHash != null && message.hasOwnProperty("txHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txHash);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.numConfirmations != null && message.hasOwnProperty("numConfirmations"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.numConfirmations);
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.blockHash);
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blockHeight);
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.timeStamp);
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.totalFees);
            if (message.destAddresses != null && message.destAddresses.length)
                for (let i = 0; i < message.destAddresses.length; ++i)
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.destAddresses[i]);
            if (message.rawTxHex != null && message.hasOwnProperty("rawTxHex"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.rawTxHex);
            return writer;
        };

        /**
         * Encodes the specified Transaction message, length delimited. Does not implicitly {@link lnrpc.Transaction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.ITransaction} message Transaction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Transaction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Transaction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txHash = reader.string();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.numConfirmations = reader.int32();
                    break;
                case 4:
                    message.blockHash = reader.string();
                    break;
                case 5:
                    message.blockHeight = reader.int32();
                    break;
                case 6:
                    message.timeStamp = reader.int64();
                    break;
                case 7:
                    message.totalFees = reader.int64();
                    break;
                case 8:
                    if (!(message.destAddresses && message.destAddresses.length))
                        message.destAddresses = [];
                    message.destAddresses.push(reader.string());
                    break;
                case 9:
                    message.rawTxHex = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Transaction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Transaction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Transaction} Transaction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Transaction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Transaction message.
         * @function verify
         * @memberof lnrpc.Transaction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Transaction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txHash != null && message.hasOwnProperty("txHash"))
                if (!$util.isString(message.txHash))
                    return "txHash: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.numConfirmations != null && message.hasOwnProperty("numConfirmations"))
                if (!$util.isInteger(message.numConfirmations))
                    return "numConfirmations: integer expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!$util.isString(message.blockHash))
                    return "blockHash: string expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (!$util.isInteger(message.timeStamp) && !(message.timeStamp && $util.isInteger(message.timeStamp.low) && $util.isInteger(message.timeStamp.high)))
                    return "timeStamp: integer|Long expected";
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (!$util.isInteger(message.totalFees) && !(message.totalFees && $util.isInteger(message.totalFees.low) && $util.isInteger(message.totalFees.high)))
                    return "totalFees: integer|Long expected";
            if (message.destAddresses != null && message.hasOwnProperty("destAddresses")) {
                if (!Array.isArray(message.destAddresses))
                    return "destAddresses: array expected";
                for (let i = 0; i < message.destAddresses.length; ++i)
                    if (!$util.isString(message.destAddresses[i]))
                        return "destAddresses: string[] expected";
            }
            if (message.rawTxHex != null && message.hasOwnProperty("rawTxHex"))
                if (!$util.isString(message.rawTxHex))
                    return "rawTxHex: string expected";
            return null;
        };

        /**
         * Creates a Transaction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Transaction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Transaction} Transaction
         */
        Transaction.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Transaction)
                return object;
            let message = new $root.lnrpc.Transaction();
            if (object.txHash != null)
                message.txHash = String(object.txHash);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.numConfirmations != null)
                message.numConfirmations = object.numConfirmations | 0;
            if (object.blockHash != null)
                message.blockHash = String(object.blockHash);
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight | 0;
            if (object.timeStamp != null)
                if ($util.Long)
                    (message.timeStamp = $util.Long.fromValue(object.timeStamp)).unsigned = false;
                else if (typeof object.timeStamp === "string")
                    message.timeStamp = parseInt(object.timeStamp, 10);
                else if (typeof object.timeStamp === "number")
                    message.timeStamp = object.timeStamp;
                else if (typeof object.timeStamp === "object")
                    message.timeStamp = new $util.LongBits(object.timeStamp.low >>> 0, object.timeStamp.high >>> 0).toNumber();
            if (object.totalFees != null)
                if ($util.Long)
                    (message.totalFees = $util.Long.fromValue(object.totalFees)).unsigned = false;
                else if (typeof object.totalFees === "string")
                    message.totalFees = parseInt(object.totalFees, 10);
                else if (typeof object.totalFees === "number")
                    message.totalFees = object.totalFees;
                else if (typeof object.totalFees === "object")
                    message.totalFees = new $util.LongBits(object.totalFees.low >>> 0, object.totalFees.high >>> 0).toNumber();
            if (object.destAddresses) {
                if (!Array.isArray(object.destAddresses))
                    throw TypeError(".lnrpc.Transaction.destAddresses: array expected");
                message.destAddresses = [];
                for (let i = 0; i < object.destAddresses.length; ++i)
                    message.destAddresses[i] = String(object.destAddresses[i]);
            }
            if (object.rawTxHex != null)
                message.rawTxHex = String(object.rawTxHex);
            return message;
        };

        /**
         * Creates a plain object from a Transaction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Transaction
         * @static
         * @param {lnrpc.Transaction} message Transaction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Transaction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.destAddresses = [];
            if (options.defaults) {
                object.txHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.numConfirmations = 0;
                object.blockHash = "";
                object.blockHeight = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timeStamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeStamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalFees = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFees = options.longs === String ? "0" : 0;
                object.rawTxHex = "";
            }
            if (message.txHash != null && message.hasOwnProperty("txHash"))
                object.txHash = message.txHash;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.numConfirmations != null && message.hasOwnProperty("numConfirmations"))
                object.numConfirmations = message.numConfirmations;
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = message.blockHash;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.timeStamp != null && message.hasOwnProperty("timeStamp"))
                if (typeof message.timeStamp === "number")
                    object.timeStamp = options.longs === String ? String(message.timeStamp) : message.timeStamp;
                else
                    object.timeStamp = options.longs === String ? $util.Long.prototype.toString.call(message.timeStamp) : options.longs === Number ? new $util.LongBits(message.timeStamp.low >>> 0, message.timeStamp.high >>> 0).toNumber() : message.timeStamp;
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (typeof message.totalFees === "number")
                    object.totalFees = options.longs === String ? String(message.totalFees) : message.totalFees;
                else
                    object.totalFees = options.longs === String ? $util.Long.prototype.toString.call(message.totalFees) : options.longs === Number ? new $util.LongBits(message.totalFees.low >>> 0, message.totalFees.high >>> 0).toNumber() : message.totalFees;
            if (message.destAddresses && message.destAddresses.length) {
                object.destAddresses = [];
                for (let j = 0; j < message.destAddresses.length; ++j)
                    object.destAddresses[j] = message.destAddresses[j];
            }
            if (message.rawTxHex != null && message.hasOwnProperty("rawTxHex"))
                object.rawTxHex = message.rawTxHex;
            return object;
        };

        /**
         * Converts this Transaction to JSON.
         * @function toJSON
         * @memberof lnrpc.Transaction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Transaction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Transaction;
    })();

    lnrpc.GetTransactionsRequest = (function() {

        /**
         * Properties of a GetTransactionsRequest.
         * @memberof lnrpc
         * @interface IGetTransactionsRequest
         */

        /**
         * Constructs a new GetTransactionsRequest.
         * @memberof lnrpc
         * @classdesc Represents a GetTransactionsRequest.
         * @implements IGetTransactionsRequest
         * @constructor
         * @param {lnrpc.IGetTransactionsRequest=} [properties] Properties to set
         */
        function GetTransactionsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetTransactionsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest=} [properties] Properties to set
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest instance
         */
        GetTransactionsRequest.create = function create(properties) {
            return new GetTransactionsRequest(properties);
        };

        /**
         * Encodes the specified GetTransactionsRequest message. Does not implicitly {@link lnrpc.GetTransactionsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest} message GetTransactionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransactionsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetTransactionsRequest message, length delimited. Does not implicitly {@link lnrpc.GetTransactionsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.IGetTransactionsRequest} message GetTransactionsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTransactionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTransactionsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransactionsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetTransactionsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTransactionsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTransactionsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTransactionsRequest message.
         * @function verify
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTransactionsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetTransactionsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetTransactionsRequest} GetTransactionsRequest
         */
        GetTransactionsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetTransactionsRequest)
                return object;
            return new $root.lnrpc.GetTransactionsRequest();
        };

        /**
         * Creates a plain object from a GetTransactionsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetTransactionsRequest
         * @static
         * @param {lnrpc.GetTransactionsRequest} message GetTransactionsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetTransactionsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetTransactionsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GetTransactionsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetTransactionsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetTransactionsRequest;
    })();

    lnrpc.TransactionDetails = (function() {

        /**
         * Properties of a TransactionDetails.
         * @memberof lnrpc
         * @interface ITransactionDetails
         * @property {Array.<lnrpc.ITransaction>|null} [transactions] The list of transactions relevant to the wallet.
         */

        /**
         * Constructs a new TransactionDetails.
         * @memberof lnrpc
         * @classdesc Represents a TransactionDetails.
         * @implements ITransactionDetails
         * @constructor
         * @param {lnrpc.ITransactionDetails=} [properties] Properties to set
         */
        function TransactionDetails(properties) {
            this.transactions = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of transactions relevant to the wallet.
         * @member {Array.<lnrpc.ITransaction>} transactions
         * @memberof lnrpc.TransactionDetails
         * @instance
         */
        TransactionDetails.prototype.transactions = $util.emptyArray;

        /**
         * Creates a new TransactionDetails instance using the specified properties.
         * @function create
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails=} [properties] Properties to set
         * @returns {lnrpc.TransactionDetails} TransactionDetails instance
         */
        TransactionDetails.create = function create(properties) {
            return new TransactionDetails(properties);
        };

        /**
         * Encodes the specified TransactionDetails message. Does not implicitly {@link lnrpc.TransactionDetails.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails} message TransactionDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionDetails.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.transactions != null && message.transactions.length)
                for (let i = 0; i < message.transactions.length; ++i)
                    $root.lnrpc.Transaction.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TransactionDetails message, length delimited. Does not implicitly {@link lnrpc.TransactionDetails.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.ITransactionDetails} message TransactionDetails message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransactionDetails.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransactionDetails message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionDetails.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.TransactionDetails();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.transactions && message.transactions.length))
                        message.transactions = [];
                    message.transactions.push($root.lnrpc.Transaction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransactionDetails message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransactionDetails.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransactionDetails message.
         * @function verify
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransactionDetails.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.transactions != null && message.hasOwnProperty("transactions")) {
                if (!Array.isArray(message.transactions))
                    return "transactions: array expected";
                for (let i = 0; i < message.transactions.length; ++i) {
                    let error = $root.lnrpc.Transaction.verify(message.transactions[i]);
                    if (error)
                        return "transactions." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TransactionDetails message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.TransactionDetails} TransactionDetails
         */
        TransactionDetails.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.TransactionDetails)
                return object;
            let message = new $root.lnrpc.TransactionDetails();
            if (object.transactions) {
                if (!Array.isArray(object.transactions))
                    throw TypeError(".lnrpc.TransactionDetails.transactions: array expected");
                message.transactions = [];
                for (let i = 0; i < object.transactions.length; ++i) {
                    if (typeof object.transactions[i] !== "object")
                        throw TypeError(".lnrpc.TransactionDetails.transactions: object expected");
                    message.transactions[i] = $root.lnrpc.Transaction.fromObject(object.transactions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TransactionDetails message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.TransactionDetails
         * @static
         * @param {lnrpc.TransactionDetails} message TransactionDetails
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TransactionDetails.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.transactions = [];
            if (message.transactions && message.transactions.length) {
                object.transactions = [];
                for (let j = 0; j < message.transactions.length; ++j)
                    object.transactions[j] = $root.lnrpc.Transaction.toObject(message.transactions[j], options);
            }
            return object;
        };

        /**
         * Converts this TransactionDetails to JSON.
         * @function toJSON
         * @memberof lnrpc.TransactionDetails
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TransactionDetails.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TransactionDetails;
    })();

    lnrpc.FeeLimit = (function() {

        /**
         * Properties of a FeeLimit.
         * @memberof lnrpc
         * @interface IFeeLimit
         * @property {number|Long|null} [fixed] The fee limit expressed as a fixed amount of satoshis.
         * @property {number|Long|null} [percent] The fee limit expressed as a percentage of the payment amount.
         */

        /**
         * Constructs a new FeeLimit.
         * @memberof lnrpc
         * @classdesc Represents a FeeLimit.
         * @implements IFeeLimit
         * @constructor
         * @param {lnrpc.IFeeLimit=} [properties] Properties to set
         */
        function FeeLimit(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The fee limit expressed as a fixed amount of satoshis.
         * @member {number|Long} fixed
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        FeeLimit.prototype.fixed = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The fee limit expressed as a percentage of the payment amount.
         * @member {number|Long} percent
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        FeeLimit.prototype.percent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * FeeLimit limit.
         * @member {"fixed"|"percent"|undefined} limit
         * @memberof lnrpc.FeeLimit
         * @instance
         */
        Object.defineProperty(FeeLimit.prototype, "limit", {
            get: $util.oneOfGetter($oneOfFields = ["fixed", "percent"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new FeeLimit instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit=} [properties] Properties to set
         * @returns {lnrpc.FeeLimit} FeeLimit instance
         */
        FeeLimit.create = function create(properties) {
            return new FeeLimit(properties);
        };

        /**
         * Encodes the specified FeeLimit message. Does not implicitly {@link lnrpc.FeeLimit.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit} message FeeLimit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeLimit.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fixed != null && message.hasOwnProperty("fixed"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.fixed);
            if (message.percent != null && message.hasOwnProperty("percent"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.percent);
            return writer;
        };

        /**
         * Encodes the specified FeeLimit message, length delimited. Does not implicitly {@link lnrpc.FeeLimit.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.IFeeLimit} message FeeLimit message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeLimit.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeLimit message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeLimit} FeeLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeLimit.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeLimit();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fixed = reader.int64();
                    break;
                case 2:
                    message.percent = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeLimit message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeLimit} FeeLimit
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeLimit.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeLimit message.
         * @function verify
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeLimit.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.fixed != null && message.hasOwnProperty("fixed")) {
                properties.limit = 1;
                if (!$util.isInteger(message.fixed) && !(message.fixed && $util.isInteger(message.fixed.low) && $util.isInteger(message.fixed.high)))
                    return "fixed: integer|Long expected";
            }
            if (message.percent != null && message.hasOwnProperty("percent")) {
                if (properties.limit === 1)
                    return "limit: multiple values";
                properties.limit = 1;
                if (!$util.isInteger(message.percent) && !(message.percent && $util.isInteger(message.percent.low) && $util.isInteger(message.percent.high)))
                    return "percent: integer|Long expected";
            }
            return null;
        };

        /**
         * Creates a FeeLimit message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeLimit} FeeLimit
         */
        FeeLimit.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeLimit)
                return object;
            let message = new $root.lnrpc.FeeLimit();
            if (object.fixed != null)
                if ($util.Long)
                    (message.fixed = $util.Long.fromValue(object.fixed)).unsigned = false;
                else if (typeof object.fixed === "string")
                    message.fixed = parseInt(object.fixed, 10);
                else if (typeof object.fixed === "number")
                    message.fixed = object.fixed;
                else if (typeof object.fixed === "object")
                    message.fixed = new $util.LongBits(object.fixed.low >>> 0, object.fixed.high >>> 0).toNumber();
            if (object.percent != null)
                if ($util.Long)
                    (message.percent = $util.Long.fromValue(object.percent)).unsigned = false;
                else if (typeof object.percent === "string")
                    message.percent = parseInt(object.percent, 10);
                else if (typeof object.percent === "number")
                    message.percent = object.percent;
                else if (typeof object.percent === "object")
                    message.percent = new $util.LongBits(object.percent.low >>> 0, object.percent.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a FeeLimit message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeLimit
         * @static
         * @param {lnrpc.FeeLimit} message FeeLimit
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeLimit.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.fixed != null && message.hasOwnProperty("fixed")) {
                if (typeof message.fixed === "number")
                    object.fixed = options.longs === String ? String(message.fixed) : message.fixed;
                else
                    object.fixed = options.longs === String ? $util.Long.prototype.toString.call(message.fixed) : options.longs === Number ? new $util.LongBits(message.fixed.low >>> 0, message.fixed.high >>> 0).toNumber() : message.fixed;
                if (options.oneofs)
                    object.limit = "fixed";
            }
            if (message.percent != null && message.hasOwnProperty("percent")) {
                if (typeof message.percent === "number")
                    object.percent = options.longs === String ? String(message.percent) : message.percent;
                else
                    object.percent = options.longs === String ? $util.Long.prototype.toString.call(message.percent) : options.longs === Number ? new $util.LongBits(message.percent.low >>> 0, message.percent.high >>> 0).toNumber() : message.percent;
                if (options.oneofs)
                    object.limit = "percent";
            }
            return object;
        };

        /**
         * Converts this FeeLimit to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeLimit
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeLimit.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeLimit;
    })();

    lnrpc.SendRequest = (function() {

        /**
         * Properties of a SendRequest.
         * @memberof lnrpc
         * @interface ISendRequest
         * @property {Uint8Array|null} [dest] The identity pubkey of the payment recipient
         * @property {string|null} [destString] The hex-encoded identity pubkey of the payment recipient
         * @property {number|Long|null} [amt] Number of satoshis to send.
         * @property {Uint8Array|null} [paymentHash] The hash to use within the payment's HTLC
         * @property {string|null} [paymentHashString] The hex-encoded hash to use within the payment's HTLC
         * @property {string|null} [paymentRequest] A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @property {number|null} [finalCltvDelta] The CLTV delta from the current height that should be used to set the
         * timelock for the final hop.
         * @property {lnrpc.IFeeLimit|null} [feeLimit] The maximum number of satoshis that will be paid as a fee of the payment.
         * This value can be represented either as a percentage of the amount being
         * sent, or as a fixed amount of the maximum fee the user is willing the pay to
         * send the payment.
         * @property {number|Long|null} [outgoingChanId] The channel id of the channel that must be taken to the first hop. If zero,
         * any channel may be used.
         * @property {number|null} [cltvLimit] An optional maximum total time lock for the route. If zero, there is no
         * maximum enforced.
         */

        /**
         * Constructs a new SendRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendRequest.
         * @implements ISendRequest
         * @constructor
         * @param {lnrpc.ISendRequest=} [properties] Properties to set
         */
        function SendRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The identity pubkey of the payment recipient
         * @member {Uint8Array} dest
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.dest = $util.newBuffer([]);

        /**
         * The hex-encoded identity pubkey of the payment recipient
         * @member {string} destString
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.destString = "";

        /**
         * Number of satoshis to send.
         * @member {number|Long} amt
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.amt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The hash to use within the payment's HTLC
         * @member {Uint8Array} paymentHash
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentHash = $util.newBuffer([]);

        /**
         * The hex-encoded hash to use within the payment's HTLC
         * @member {string} paymentHashString
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentHashString = "";

        /**
         * A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @member {string} paymentRequest
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.paymentRequest = "";

        /**
         * The CLTV delta from the current height that should be used to set the
         * timelock for the final hop.
         * @member {number} finalCltvDelta
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.finalCltvDelta = 0;

        /**
         * The maximum number of satoshis that will be paid as a fee of the payment.
         * This value can be represented either as a percentage of the amount being
         * sent, or as a fixed amount of the maximum fee the user is willing the pay to
         * send the payment.
         * @member {lnrpc.IFeeLimit|null|undefined} feeLimit
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.feeLimit = null;

        /**
         * The channel id of the channel that must be taken to the first hop. If zero,
         * any channel may be used.
         * @member {number|Long} outgoingChanId
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.outgoingChanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * An optional maximum total time lock for the route. If zero, there is no
         * maximum enforced.
         * @member {number} cltvLimit
         * @memberof lnrpc.SendRequest
         * @instance
         */
        SendRequest.prototype.cltvLimit = 0;

        /**
         * Creates a new SendRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest=} [properties] Properties to set
         * @returns {lnrpc.SendRequest} SendRequest instance
         */
        SendRequest.create = function create(properties) {
            return new SendRequest(properties);
        };

        /**
         * Encodes the specified SendRequest message. Does not implicitly {@link lnrpc.SendRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest} message SendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.dest != null && message.hasOwnProperty("dest"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.dest);
            if (message.destString != null && message.hasOwnProperty("destString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.destString);
            if (message.amt != null && message.hasOwnProperty("amt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amt);
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.paymentHash);
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.paymentHashString);
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.paymentRequest);
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.finalCltvDelta);
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                $root.lnrpc.FeeLimit.encode(message.feeLimit, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.outgoingChanId != null && message.hasOwnProperty("outgoingChanId"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.outgoingChanId);
            if (message.cltvLimit != null && message.hasOwnProperty("cltvLimit"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.cltvLimit);
            return writer;
        };

        /**
         * Encodes the specified SendRequest message, length delimited. Does not implicitly {@link lnrpc.SendRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.ISendRequest} message SendRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendRequest} SendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.dest = reader.bytes();
                    break;
                case 2:
                    message.destString = reader.string();
                    break;
                case 3:
                    message.amt = reader.int64();
                    break;
                case 4:
                    message.paymentHash = reader.bytes();
                    break;
                case 5:
                    message.paymentHashString = reader.string();
                    break;
                case 6:
                    message.paymentRequest = reader.string();
                    break;
                case 7:
                    message.finalCltvDelta = reader.int32();
                    break;
                case 8:
                    message.feeLimit = $root.lnrpc.FeeLimit.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.outgoingChanId = reader.uint64();
                    break;
                case 10:
                    message.cltvLimit = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendRequest} SendRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendRequest message.
         * @function verify
         * @memberof lnrpc.SendRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.dest != null && message.hasOwnProperty("dest"))
                if (!(message.dest && typeof message.dest.length === "number" || $util.isString(message.dest)))
                    return "dest: buffer expected";
            if (message.destString != null && message.hasOwnProperty("destString"))
                if (!$util.isString(message.destString))
                    return "destString: string expected";
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (!$util.isInteger(message.amt) && !(message.amt && $util.isInteger(message.amt.low) && $util.isInteger(message.amt.high)))
                    return "amt: integer|Long expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!(message.paymentHash && typeof message.paymentHash.length === "number" || $util.isString(message.paymentHash)))
                    return "paymentHash: buffer expected";
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                if (!$util.isString(message.paymentHashString))
                    return "paymentHashString: string expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                if (!$util.isInteger(message.finalCltvDelta))
                    return "finalCltvDelta: integer expected";
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit")) {
                let error = $root.lnrpc.FeeLimit.verify(message.feeLimit);
                if (error)
                    return "feeLimit." + error;
            }
            if (message.outgoingChanId != null && message.hasOwnProperty("outgoingChanId"))
                if (!$util.isInteger(message.outgoingChanId) && !(message.outgoingChanId && $util.isInteger(message.outgoingChanId.low) && $util.isInteger(message.outgoingChanId.high)))
                    return "outgoingChanId: integer|Long expected";
            if (message.cltvLimit != null && message.hasOwnProperty("cltvLimit"))
                if (!$util.isInteger(message.cltvLimit))
                    return "cltvLimit: integer expected";
            return null;
        };

        /**
         * Creates a SendRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendRequest} SendRequest
         */
        SendRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendRequest)
                return object;
            let message = new $root.lnrpc.SendRequest();
            if (object.dest != null)
                if (typeof object.dest === "string")
                    $util.base64.decode(object.dest, message.dest = $util.newBuffer($util.base64.length(object.dest)), 0);
                else if (object.dest.length)
                    message.dest = object.dest;
            if (object.destString != null)
                message.destString = String(object.destString);
            if (object.amt != null)
                if ($util.Long)
                    (message.amt = $util.Long.fromValue(object.amt)).unsigned = false;
                else if (typeof object.amt === "string")
                    message.amt = parseInt(object.amt, 10);
                else if (typeof object.amt === "number")
                    message.amt = object.amt;
                else if (typeof object.amt === "object")
                    message.amt = new $util.LongBits(object.amt.low >>> 0, object.amt.high >>> 0).toNumber();
            if (object.paymentHash != null)
                if (typeof object.paymentHash === "string")
                    $util.base64.decode(object.paymentHash, message.paymentHash = $util.newBuffer($util.base64.length(object.paymentHash)), 0);
                else if (object.paymentHash.length)
                    message.paymentHash = object.paymentHash;
            if (object.paymentHashString != null)
                message.paymentHashString = String(object.paymentHashString);
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.finalCltvDelta != null)
                message.finalCltvDelta = object.finalCltvDelta | 0;
            if (object.feeLimit != null) {
                if (typeof object.feeLimit !== "object")
                    throw TypeError(".lnrpc.SendRequest.feeLimit: object expected");
                message.feeLimit = $root.lnrpc.FeeLimit.fromObject(object.feeLimit);
            }
            if (object.outgoingChanId != null)
                if ($util.Long)
                    (message.outgoingChanId = $util.Long.fromValue(object.outgoingChanId)).unsigned = true;
                else if (typeof object.outgoingChanId === "string")
                    message.outgoingChanId = parseInt(object.outgoingChanId, 10);
                else if (typeof object.outgoingChanId === "number")
                    message.outgoingChanId = object.outgoingChanId;
                else if (typeof object.outgoingChanId === "object")
                    message.outgoingChanId = new $util.LongBits(object.outgoingChanId.low >>> 0, object.outgoingChanId.high >>> 0).toNumber(true);
            if (object.cltvLimit != null)
                message.cltvLimit = object.cltvLimit >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a SendRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendRequest
         * @static
         * @param {lnrpc.SendRequest} message SendRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.dest = "";
                else {
                    object.dest = [];
                    if (options.bytes !== Array)
                        object.dest = $util.newBuffer(object.dest);
                }
                object.destString = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amt = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.paymentHash = "";
                else {
                    object.paymentHash = [];
                    if (options.bytes !== Array)
                        object.paymentHash = $util.newBuffer(object.paymentHash);
                }
                object.paymentHashString = "";
                object.paymentRequest = "";
                object.finalCltvDelta = 0;
                object.feeLimit = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.outgoingChanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.outgoingChanId = options.longs === String ? "0" : 0;
                object.cltvLimit = 0;
            }
            if (message.dest != null && message.hasOwnProperty("dest"))
                object.dest = options.bytes === String ? $util.base64.encode(message.dest, 0, message.dest.length) : options.bytes === Array ? Array.prototype.slice.call(message.dest) : message.dest;
            if (message.destString != null && message.hasOwnProperty("destString"))
                object.destString = message.destString;
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (typeof message.amt === "number")
                    object.amt = options.longs === String ? String(message.amt) : message.amt;
                else
                    object.amt = options.longs === String ? $util.Long.prototype.toString.call(message.amt) : options.longs === Number ? new $util.LongBits(message.amt.low >>> 0, message.amt.high >>> 0).toNumber() : message.amt;
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = options.bytes === String ? $util.base64.encode(message.paymentHash, 0, message.paymentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentHash) : message.paymentHash;
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                object.paymentHashString = message.paymentHashString;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                object.finalCltvDelta = message.finalCltvDelta;
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                object.feeLimit = $root.lnrpc.FeeLimit.toObject(message.feeLimit, options);
            if (message.outgoingChanId != null && message.hasOwnProperty("outgoingChanId"))
                if (typeof message.outgoingChanId === "number")
                    object.outgoingChanId = options.longs === String ? String(message.outgoingChanId) : message.outgoingChanId;
                else
                    object.outgoingChanId = options.longs === String ? $util.Long.prototype.toString.call(message.outgoingChanId) : options.longs === Number ? new $util.LongBits(message.outgoingChanId.low >>> 0, message.outgoingChanId.high >>> 0).toNumber(true) : message.outgoingChanId;
            if (message.cltvLimit != null && message.hasOwnProperty("cltvLimit"))
                object.cltvLimit = message.cltvLimit;
            return object;
        };

        /**
         * Converts this SendRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendRequest;
    })();

    lnrpc.SendResponse = (function() {

        /**
         * Properties of a SendResponse.
         * @memberof lnrpc
         * @interface ISendResponse
         * @property {string|null} [paymentError] SendResponse paymentError
         * @property {Uint8Array|null} [paymentPreimage] SendResponse paymentPreimage
         * @property {lnrpc.IRoute|null} [paymentRoute] SendResponse paymentRoute
         * @property {Uint8Array|null} [paymentHash] SendResponse paymentHash
         */

        /**
         * Constructs a new SendResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendResponse.
         * @implements ISendResponse
         * @constructor
         * @param {lnrpc.ISendResponse=} [properties] Properties to set
         */
        function SendResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendResponse paymentError.
         * @member {string} paymentError
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentError = "";

        /**
         * SendResponse paymentPreimage.
         * @member {Uint8Array} paymentPreimage
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentPreimage = $util.newBuffer([]);

        /**
         * SendResponse paymentRoute.
         * @member {lnrpc.IRoute|null|undefined} paymentRoute
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentRoute = null;

        /**
         * SendResponse paymentHash.
         * @member {Uint8Array} paymentHash
         * @memberof lnrpc.SendResponse
         * @instance
         */
        SendResponse.prototype.paymentHash = $util.newBuffer([]);

        /**
         * Creates a new SendResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse=} [properties] Properties to set
         * @returns {lnrpc.SendResponse} SendResponse instance
         */
        SendResponse.create = function create(properties) {
            return new SendResponse(properties);
        };

        /**
         * Encodes the specified SendResponse message. Does not implicitly {@link lnrpc.SendResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse} message SendResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentError != null && message.hasOwnProperty("paymentError"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.paymentError);
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.paymentPreimage);
            if (message.paymentRoute != null && message.hasOwnProperty("paymentRoute"))
                $root.lnrpc.Route.encode(message.paymentRoute, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.paymentHash);
            return writer;
        };

        /**
         * Encodes the specified SendResponse message, length delimited. Does not implicitly {@link lnrpc.SendResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.ISendResponse} message SendResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendResponse} SendResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentError = reader.string();
                    break;
                case 2:
                    message.paymentPreimage = reader.bytes();
                    break;
                case 3:
                    message.paymentRoute = $root.lnrpc.Route.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.paymentHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendResponse} SendResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendResponse message.
         * @function verify
         * @memberof lnrpc.SendResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentError != null && message.hasOwnProperty("paymentError"))
                if (!$util.isString(message.paymentError))
                    return "paymentError: string expected";
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                if (!(message.paymentPreimage && typeof message.paymentPreimage.length === "number" || $util.isString(message.paymentPreimage)))
                    return "paymentPreimage: buffer expected";
            if (message.paymentRoute != null && message.hasOwnProperty("paymentRoute")) {
                let error = $root.lnrpc.Route.verify(message.paymentRoute);
                if (error)
                    return "paymentRoute." + error;
            }
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!(message.paymentHash && typeof message.paymentHash.length === "number" || $util.isString(message.paymentHash)))
                    return "paymentHash: buffer expected";
            return null;
        };

        /**
         * Creates a SendResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendResponse} SendResponse
         */
        SendResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendResponse)
                return object;
            let message = new $root.lnrpc.SendResponse();
            if (object.paymentError != null)
                message.paymentError = String(object.paymentError);
            if (object.paymentPreimage != null)
                if (typeof object.paymentPreimage === "string")
                    $util.base64.decode(object.paymentPreimage, message.paymentPreimage = $util.newBuffer($util.base64.length(object.paymentPreimage)), 0);
                else if (object.paymentPreimage.length)
                    message.paymentPreimage = object.paymentPreimage;
            if (object.paymentRoute != null) {
                if (typeof object.paymentRoute !== "object")
                    throw TypeError(".lnrpc.SendResponse.paymentRoute: object expected");
                message.paymentRoute = $root.lnrpc.Route.fromObject(object.paymentRoute);
            }
            if (object.paymentHash != null)
                if (typeof object.paymentHash === "string")
                    $util.base64.decode(object.paymentHash, message.paymentHash = $util.newBuffer($util.base64.length(object.paymentHash)), 0);
                else if (object.paymentHash.length)
                    message.paymentHash = object.paymentHash;
            return message;
        };

        /**
         * Creates a plain object from a SendResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendResponse
         * @static
         * @param {lnrpc.SendResponse} message SendResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.paymentError = "";
                if (options.bytes === String)
                    object.paymentPreimage = "";
                else {
                    object.paymentPreimage = [];
                    if (options.bytes !== Array)
                        object.paymentPreimage = $util.newBuffer(object.paymentPreimage);
                }
                object.paymentRoute = null;
                if (options.bytes === String)
                    object.paymentHash = "";
                else {
                    object.paymentHash = [];
                    if (options.bytes !== Array)
                        object.paymentHash = $util.newBuffer(object.paymentHash);
                }
            }
            if (message.paymentError != null && message.hasOwnProperty("paymentError"))
                object.paymentError = message.paymentError;
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                object.paymentPreimage = options.bytes === String ? $util.base64.encode(message.paymentPreimage, 0, message.paymentPreimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentPreimage) : message.paymentPreimage;
            if (message.paymentRoute != null && message.hasOwnProperty("paymentRoute"))
                object.paymentRoute = $root.lnrpc.Route.toObject(message.paymentRoute, options);
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = options.bytes === String ? $util.base64.encode(message.paymentHash, 0, message.paymentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentHash) : message.paymentHash;
            return object;
        };

        /**
         * Converts this SendResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendResponse;
    })();

    lnrpc.SendToRouteRequest = (function() {

        /**
         * Properties of a SendToRouteRequest.
         * @memberof lnrpc
         * @interface ISendToRouteRequest
         * @property {Uint8Array|null} [paymentHash] The payment hash to use for the HTLC.
         * @property {string|null} [paymentHashString] An optional hex-encoded payment hash to be used for the HTLC.
         * @property {lnrpc.IRoute|null} [route] Route that should be used to attempt to complete the payment.
         */

        /**
         * Constructs a new SendToRouteRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendToRouteRequest.
         * @implements ISendToRouteRequest
         * @constructor
         * @param {lnrpc.ISendToRouteRequest=} [properties] Properties to set
         */
        function SendToRouteRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The payment hash to use for the HTLC.
         * @member {Uint8Array} paymentHash
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.paymentHash = $util.newBuffer([]);

        /**
         * An optional hex-encoded payment hash to be used for the HTLC.
         * @member {string} paymentHashString
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.paymentHashString = "";

        /**
         * Route that should be used to attempt to complete the payment.
         * @member {lnrpc.IRoute|null|undefined} route
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         */
        SendToRouteRequest.prototype.route = null;

        /**
         * Creates a new SendToRouteRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest=} [properties] Properties to set
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest instance
         */
        SendToRouteRequest.create = function create(properties) {
            return new SendToRouteRequest(properties);
        };

        /**
         * Encodes the specified SendToRouteRequest message. Does not implicitly {@link lnrpc.SendToRouteRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest} message SendToRouteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendToRouteRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.paymentHash);
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentHashString);
            if (message.route != null && message.hasOwnProperty("route"))
                $root.lnrpc.Route.encode(message.route, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SendToRouteRequest message, length delimited. Does not implicitly {@link lnrpc.SendToRouteRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.ISendToRouteRequest} message SendToRouteRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendToRouteRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendToRouteRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendToRouteRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendToRouteRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentHash = reader.bytes();
                    break;
                case 2:
                    message.paymentHashString = reader.string();
                    break;
                case 4:
                    message.route = $root.lnrpc.Route.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendToRouteRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendToRouteRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendToRouteRequest message.
         * @function verify
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendToRouteRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!(message.paymentHash && typeof message.paymentHash.length === "number" || $util.isString(message.paymentHash)))
                    return "paymentHash: buffer expected";
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                if (!$util.isString(message.paymentHashString))
                    return "paymentHashString: string expected";
            if (message.route != null && message.hasOwnProperty("route")) {
                let error = $root.lnrpc.Route.verify(message.route);
                if (error)
                    return "route." + error;
            }
            return null;
        };

        /**
         * Creates a SendToRouteRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendToRouteRequest} SendToRouteRequest
         */
        SendToRouteRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendToRouteRequest)
                return object;
            let message = new $root.lnrpc.SendToRouteRequest();
            if (object.paymentHash != null)
                if (typeof object.paymentHash === "string")
                    $util.base64.decode(object.paymentHash, message.paymentHash = $util.newBuffer($util.base64.length(object.paymentHash)), 0);
                else if (object.paymentHash.length)
                    message.paymentHash = object.paymentHash;
            if (object.paymentHashString != null)
                message.paymentHashString = String(object.paymentHashString);
            if (object.route != null) {
                if (typeof object.route !== "object")
                    throw TypeError(".lnrpc.SendToRouteRequest.route: object expected");
                message.route = $root.lnrpc.Route.fromObject(object.route);
            }
            return message;
        };

        /**
         * Creates a plain object from a SendToRouteRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendToRouteRequest
         * @static
         * @param {lnrpc.SendToRouteRequest} message SendToRouteRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendToRouteRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.paymentHash = "";
                else {
                    object.paymentHash = [];
                    if (options.bytes !== Array)
                        object.paymentHash = $util.newBuffer(object.paymentHash);
                }
                object.paymentHashString = "";
                object.route = null;
            }
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = options.bytes === String ? $util.base64.encode(message.paymentHash, 0, message.paymentHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.paymentHash) : message.paymentHash;
            if (message.paymentHashString != null && message.hasOwnProperty("paymentHashString"))
                object.paymentHashString = message.paymentHashString;
            if (message.route != null && message.hasOwnProperty("route"))
                object.route = $root.lnrpc.Route.toObject(message.route, options);
            return object;
        };

        /**
         * Converts this SendToRouteRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendToRouteRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendToRouteRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendToRouteRequest;
    })();

    lnrpc.ChannelPoint = (function() {

        /**
         * Properties of a ChannelPoint.
         * @memberof lnrpc
         * @interface IChannelPoint
         * @property {Uint8Array|null} [fundingTxidBytes] Txid of the funding transaction
         * @property {string|null} [fundingTxidStr] Hex-encoded string representing the funding transaction
         * @property {number|null} [outputIndex] The index of the output of the funding transaction
         */

        /**
         * Constructs a new ChannelPoint.
         * @memberof lnrpc
         * @classdesc Represents a ChannelPoint.
         * @implements IChannelPoint
         * @constructor
         * @param {lnrpc.IChannelPoint=} [properties] Properties to set
         */
        function ChannelPoint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Txid of the funding transaction
         * @member {Uint8Array} fundingTxidBytes
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.fundingTxidBytes = $util.newBuffer([]);

        /**
         * Hex-encoded string representing the funding transaction
         * @member {string} fundingTxidStr
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.fundingTxidStr = "";

        /**
         * The index of the output of the funding transaction
         * @member {number} outputIndex
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        ChannelPoint.prototype.outputIndex = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ChannelPoint fundingTxid.
         * @member {"fundingTxidBytes"|"fundingTxidStr"|undefined} fundingTxid
         * @memberof lnrpc.ChannelPoint
         * @instance
         */
        Object.defineProperty(ChannelPoint.prototype, "fundingTxid", {
            get: $util.oneOfGetter($oneOfFields = ["fundingTxidBytes", "fundingTxidStr"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ChannelPoint instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint=} [properties] Properties to set
         * @returns {lnrpc.ChannelPoint} ChannelPoint instance
         */
        ChannelPoint.create = function create(properties) {
            return new ChannelPoint(properties);
        };

        /**
         * Encodes the specified ChannelPoint message. Does not implicitly {@link lnrpc.ChannelPoint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint} message ChannelPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.fundingTxidBytes != null && message.hasOwnProperty("fundingTxidBytes"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fundingTxidBytes);
            if (message.fundingTxidStr != null && message.hasOwnProperty("fundingTxidStr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fundingTxidStr);
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.outputIndex);
            return writer;
        };

        /**
         * Encodes the specified ChannelPoint message, length delimited. Does not implicitly {@link lnrpc.ChannelPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.IChannelPoint} message ChannelPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelPoint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelPoint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.fundingTxidBytes = reader.bytes();
                    break;
                case 2:
                    message.fundingTxidStr = reader.string();
                    break;
                case 3:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelPoint message.
         * @function verify
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.fundingTxidBytes != null && message.hasOwnProperty("fundingTxidBytes")) {
                properties.fundingTxid = 1;
                if (!(message.fundingTxidBytes && typeof message.fundingTxidBytes.length === "number" || $util.isString(message.fundingTxidBytes)))
                    return "fundingTxidBytes: buffer expected";
            }
            if (message.fundingTxidStr != null && message.hasOwnProperty("fundingTxidStr")) {
                if (properties.fundingTxid === 1)
                    return "fundingTxid: multiple values";
                properties.fundingTxid = 1;
                if (!$util.isString(message.fundingTxidStr))
                    return "fundingTxidStr: string expected";
            }
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                if (!$util.isInteger(message.outputIndex))
                    return "outputIndex: integer expected";
            return null;
        };

        /**
         * Creates a ChannelPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelPoint} ChannelPoint
         */
        ChannelPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelPoint)
                return object;
            let message = new $root.lnrpc.ChannelPoint();
            if (object.fundingTxidBytes != null)
                if (typeof object.fundingTxidBytes === "string")
                    $util.base64.decode(object.fundingTxidBytes, message.fundingTxidBytes = $util.newBuffer($util.base64.length(object.fundingTxidBytes)), 0);
                else if (object.fundingTxidBytes.length)
                    message.fundingTxidBytes = object.fundingTxidBytes;
            if (object.fundingTxidStr != null)
                message.fundingTxidStr = String(object.fundingTxidStr);
            if (object.outputIndex != null)
                message.outputIndex = object.outputIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ChannelPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelPoint
         * @static
         * @param {lnrpc.ChannelPoint} message ChannelPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.outputIndex = 0;
            if (message.fundingTxidBytes != null && message.hasOwnProperty("fundingTxidBytes")) {
                object.fundingTxidBytes = options.bytes === String ? $util.base64.encode(message.fundingTxidBytes, 0, message.fundingTxidBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.fundingTxidBytes) : message.fundingTxidBytes;
                if (options.oneofs)
                    object.fundingTxid = "fundingTxidBytes";
            }
            if (message.fundingTxidStr != null && message.hasOwnProperty("fundingTxidStr")) {
                object.fundingTxidStr = message.fundingTxidStr;
                if (options.oneofs)
                    object.fundingTxid = "fundingTxidStr";
            }
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                object.outputIndex = message.outputIndex;
            return object;
        };

        /**
         * Converts this ChannelPoint to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelPoint;
    })();

    lnrpc.OutPoint = (function() {

        /**
         * Properties of an OutPoint.
         * @memberof lnrpc
         * @interface IOutPoint
         * @property {Uint8Array|null} [txidBytes] Raw bytes representing the transaction id.
         * @property {string|null} [txidStr] Reversed, hex-encoded string representing the transaction id.
         * @property {number|null} [outputIndex] The index of the output on the transaction.
         */

        /**
         * Constructs a new OutPoint.
         * @memberof lnrpc
         * @classdesc Represents an OutPoint.
         * @implements IOutPoint
         * @constructor
         * @param {lnrpc.IOutPoint=} [properties] Properties to set
         */
        function OutPoint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Raw bytes representing the transaction id.
         * @member {Uint8Array} txidBytes
         * @memberof lnrpc.OutPoint
         * @instance
         */
        OutPoint.prototype.txidBytes = $util.newBuffer([]);

        /**
         * Reversed, hex-encoded string representing the transaction id.
         * @member {string} txidStr
         * @memberof lnrpc.OutPoint
         * @instance
         */
        OutPoint.prototype.txidStr = "";

        /**
         * The index of the output on the transaction.
         * @member {number} outputIndex
         * @memberof lnrpc.OutPoint
         * @instance
         */
        OutPoint.prototype.outputIndex = 0;

        /**
         * Creates a new OutPoint instance using the specified properties.
         * @function create
         * @memberof lnrpc.OutPoint
         * @static
         * @param {lnrpc.IOutPoint=} [properties] Properties to set
         * @returns {lnrpc.OutPoint} OutPoint instance
         */
        OutPoint.create = function create(properties) {
            return new OutPoint(properties);
        };

        /**
         * Encodes the specified OutPoint message. Does not implicitly {@link lnrpc.OutPoint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.OutPoint
         * @static
         * @param {lnrpc.IOutPoint} message OutPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutPoint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txidBytes != null && message.hasOwnProperty("txidBytes"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txidBytes);
            if (message.txidStr != null && message.hasOwnProperty("txidStr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.txidStr);
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.outputIndex);
            return writer;
        };

        /**
         * Encodes the specified OutPoint message, length delimited. Does not implicitly {@link lnrpc.OutPoint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.OutPoint
         * @static
         * @param {lnrpc.IOutPoint} message OutPoint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OutPoint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OutPoint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.OutPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.OutPoint} OutPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutPoint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.OutPoint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txidBytes = reader.bytes();
                    break;
                case 2:
                    message.txidStr = reader.string();
                    break;
                case 3:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OutPoint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.OutPoint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.OutPoint} OutPoint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OutPoint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OutPoint message.
         * @function verify
         * @memberof lnrpc.OutPoint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OutPoint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txidBytes != null && message.hasOwnProperty("txidBytes"))
                if (!(message.txidBytes && typeof message.txidBytes.length === "number" || $util.isString(message.txidBytes)))
                    return "txidBytes: buffer expected";
            if (message.txidStr != null && message.hasOwnProperty("txidStr"))
                if (!$util.isString(message.txidStr))
                    return "txidStr: string expected";
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                if (!$util.isInteger(message.outputIndex))
                    return "outputIndex: integer expected";
            return null;
        };

        /**
         * Creates an OutPoint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.OutPoint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.OutPoint} OutPoint
         */
        OutPoint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.OutPoint)
                return object;
            let message = new $root.lnrpc.OutPoint();
            if (object.txidBytes != null)
                if (typeof object.txidBytes === "string")
                    $util.base64.decode(object.txidBytes, message.txidBytes = $util.newBuffer($util.base64.length(object.txidBytes)), 0);
                else if (object.txidBytes.length)
                    message.txidBytes = object.txidBytes;
            if (object.txidStr != null)
                message.txidStr = String(object.txidStr);
            if (object.outputIndex != null)
                message.outputIndex = object.outputIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from an OutPoint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.OutPoint
         * @static
         * @param {lnrpc.OutPoint} message OutPoint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OutPoint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.txidBytes = "";
                else {
                    object.txidBytes = [];
                    if (options.bytes !== Array)
                        object.txidBytes = $util.newBuffer(object.txidBytes);
                }
                object.txidStr = "";
                object.outputIndex = 0;
            }
            if (message.txidBytes != null && message.hasOwnProperty("txidBytes"))
                object.txidBytes = options.bytes === String ? $util.base64.encode(message.txidBytes, 0, message.txidBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.txidBytes) : message.txidBytes;
            if (message.txidStr != null && message.hasOwnProperty("txidStr"))
                object.txidStr = message.txidStr;
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                object.outputIndex = message.outputIndex;
            return object;
        };

        /**
         * Converts this OutPoint to JSON.
         * @function toJSON
         * @memberof lnrpc.OutPoint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OutPoint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OutPoint;
    })();

    lnrpc.LightningAddress = (function() {

        /**
         * Properties of a LightningAddress.
         * @memberof lnrpc
         * @interface ILightningAddress
         * @property {string|null} [pubkey] The identity pubkey of the Lightning node
         * @property {string|null} [host] The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
         */

        /**
         * Constructs a new LightningAddress.
         * @memberof lnrpc
         * @classdesc Represents a LightningAddress.
         * @implements ILightningAddress
         * @constructor
         * @param {lnrpc.ILightningAddress=} [properties] Properties to set
         */
        function LightningAddress(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The identity pubkey of the Lightning node
         * @member {string} pubkey
         * @memberof lnrpc.LightningAddress
         * @instance
         */
        LightningAddress.prototype.pubkey = "";

        /**
         * The network location of the lightning node, e.g. `69.69.69.69:1337` or `localhost:10011`
         * @member {string} host
         * @memberof lnrpc.LightningAddress
         * @instance
         */
        LightningAddress.prototype.host = "";

        /**
         * Creates a new LightningAddress instance using the specified properties.
         * @function create
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress=} [properties] Properties to set
         * @returns {lnrpc.LightningAddress} LightningAddress instance
         */
        LightningAddress.create = function create(properties) {
            return new LightningAddress(properties);
        };

        /**
         * Encodes the specified LightningAddress message. Does not implicitly {@link lnrpc.LightningAddress.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress} message LightningAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubkey);
            if (message.host != null && message.hasOwnProperty("host"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.host);
            return writer;
        };

        /**
         * Encodes the specified LightningAddress message, length delimited. Does not implicitly {@link lnrpc.LightningAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.ILightningAddress} message LightningAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightningAddress message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.LightningAddress} LightningAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.LightningAddress();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubkey = reader.string();
                    break;
                case 2:
                    message.host = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LightningAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.LightningAddress} LightningAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightningAddress message.
         * @function verify
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightningAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                if (!$util.isString(message.pubkey))
                    return "pubkey: string expected";
            if (message.host != null && message.hasOwnProperty("host"))
                if (!$util.isString(message.host))
                    return "host: string expected";
            return null;
        };

        /**
         * Creates a LightningAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.LightningAddress} LightningAddress
         */
        LightningAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.LightningAddress)
                return object;
            let message = new $root.lnrpc.LightningAddress();
            if (object.pubkey != null)
                message.pubkey = String(object.pubkey);
            if (object.host != null)
                message.host = String(object.host);
            return message;
        };

        /**
         * Creates a plain object from a LightningAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.LightningAddress
         * @static
         * @param {lnrpc.LightningAddress} message LightningAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightningAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pubkey = "";
                object.host = "";
            }
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = message.pubkey;
            if (message.host != null && message.hasOwnProperty("host"))
                object.host = message.host;
            return object;
        };

        /**
         * Converts this LightningAddress to JSON.
         * @function toJSON
         * @memberof lnrpc.LightningAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightningAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightningAddress;
    })();

    lnrpc.EstimateFeeRequest = (function() {

        /**
         * Properties of an EstimateFeeRequest.
         * @memberof lnrpc
         * @interface IEstimateFeeRequest
         * @property {Object.<string,number|Long>|null} [AddrToAmount] The map from addresses to amounts for the transaction.
         * @property {number|null} [targetConf] The target number of blocks that this transaction should be confirmed by.
         */

        /**
         * Constructs a new EstimateFeeRequest.
         * @memberof lnrpc
         * @classdesc Represents an EstimateFeeRequest.
         * @implements IEstimateFeeRequest
         * @constructor
         * @param {lnrpc.IEstimateFeeRequest=} [properties] Properties to set
         */
        function EstimateFeeRequest(properties) {
            this.AddrToAmount = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The map from addresses to amounts for the transaction.
         * @member {Object.<string,number|Long>} AddrToAmount
         * @memberof lnrpc.EstimateFeeRequest
         * @instance
         */
        EstimateFeeRequest.prototype.AddrToAmount = $util.emptyObject;

        /**
         * The target number of blocks that this transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.EstimateFeeRequest
         * @instance
         */
        EstimateFeeRequest.prototype.targetConf = 0;

        /**
         * Creates a new EstimateFeeRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {lnrpc.IEstimateFeeRequest=} [properties] Properties to set
         * @returns {lnrpc.EstimateFeeRequest} EstimateFeeRequest instance
         */
        EstimateFeeRequest.create = function create(properties) {
            return new EstimateFeeRequest(properties);
        };

        /**
         * Encodes the specified EstimateFeeRequest message. Does not implicitly {@link lnrpc.EstimateFeeRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {lnrpc.IEstimateFeeRequest} message EstimateFeeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EstimateFeeRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AddrToAmount != null && message.hasOwnProperty("AddrToAmount"))
                for (let keys = Object.keys(message.AddrToAmount), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.AddrToAmount[keys[i]]).ldelim();
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.targetConf);
            return writer;
        };

        /**
         * Encodes the specified EstimateFeeRequest message, length delimited. Does not implicitly {@link lnrpc.EstimateFeeRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {lnrpc.IEstimateFeeRequest} message EstimateFeeRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EstimateFeeRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EstimateFeeRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.EstimateFeeRequest} EstimateFeeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EstimateFeeRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.EstimateFeeRequest(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.AddrToAmount === $util.emptyObject)
                        message.AddrToAmount = {};
                    key = reader.string();
                    reader.pos++;
                    message.AddrToAmount[key] = reader.int64();
                    break;
                case 2:
                    message.targetConf = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EstimateFeeRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.EstimateFeeRequest} EstimateFeeRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EstimateFeeRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EstimateFeeRequest message.
         * @function verify
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EstimateFeeRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AddrToAmount != null && message.hasOwnProperty("AddrToAmount")) {
                if (!$util.isObject(message.AddrToAmount))
                    return "AddrToAmount: object expected";
                let key = Object.keys(message.AddrToAmount);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.AddrToAmount[key[i]]) && !(message.AddrToAmount[key[i]] && $util.isInteger(message.AddrToAmount[key[i]].low) && $util.isInteger(message.AddrToAmount[key[i]].high)))
                        return "AddrToAmount: integer|Long{k:string} expected";
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            return null;
        };

        /**
         * Creates an EstimateFeeRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.EstimateFeeRequest} EstimateFeeRequest
         */
        EstimateFeeRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.EstimateFeeRequest)
                return object;
            let message = new $root.lnrpc.EstimateFeeRequest();
            if (object.AddrToAmount) {
                if (typeof object.AddrToAmount !== "object")
                    throw TypeError(".lnrpc.EstimateFeeRequest.AddrToAmount: object expected");
                message.AddrToAmount = {};
                for (let keys = Object.keys(object.AddrToAmount), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.AddrToAmount[keys[i]] = $util.Long.fromValue(object.AddrToAmount[keys[i]])).unsigned = false;
                    else if (typeof object.AddrToAmount[keys[i]] === "string")
                        message.AddrToAmount[keys[i]] = parseInt(object.AddrToAmount[keys[i]], 10);
                    else if (typeof object.AddrToAmount[keys[i]] === "number")
                        message.AddrToAmount[keys[i]] = object.AddrToAmount[keys[i]];
                    else if (typeof object.AddrToAmount[keys[i]] === "object")
                        message.AddrToAmount[keys[i]] = new $util.LongBits(object.AddrToAmount[keys[i]].low >>> 0, object.AddrToAmount[keys[i]].high >>> 0).toNumber();
            }
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            return message;
        };

        /**
         * Creates a plain object from an EstimateFeeRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.EstimateFeeRequest
         * @static
         * @param {lnrpc.EstimateFeeRequest} message EstimateFeeRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EstimateFeeRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.AddrToAmount = {};
            if (options.defaults)
                object.targetConf = 0;
            let keys2;
            if (message.AddrToAmount && (keys2 = Object.keys(message.AddrToAmount)).length) {
                object.AddrToAmount = {};
                for (let j = 0; j < keys2.length; ++j)
                    if (typeof message.AddrToAmount[keys2[j]] === "number")
                        object.AddrToAmount[keys2[j]] = options.longs === String ? String(message.AddrToAmount[keys2[j]]) : message.AddrToAmount[keys2[j]];
                    else
                        object.AddrToAmount[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.AddrToAmount[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.AddrToAmount[keys2[j]].low >>> 0, message.AddrToAmount[keys2[j]].high >>> 0).toNumber() : message.AddrToAmount[keys2[j]];
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            return object;
        };

        /**
         * Converts this EstimateFeeRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.EstimateFeeRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EstimateFeeRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EstimateFeeRequest;
    })();

    lnrpc.EstimateFeeResponse = (function() {

        /**
         * Properties of an EstimateFeeResponse.
         * @memberof lnrpc
         * @interface IEstimateFeeResponse
         * @property {number|Long|null} [feeSat] The total fee in satoshis.
         * @property {number|Long|null} [feerateSatPerByte] The fee rate in satoshi/byte.
         */

        /**
         * Constructs a new EstimateFeeResponse.
         * @memberof lnrpc
         * @classdesc Represents an EstimateFeeResponse.
         * @implements IEstimateFeeResponse
         * @constructor
         * @param {lnrpc.IEstimateFeeResponse=} [properties] Properties to set
         */
        function EstimateFeeResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The total fee in satoshis.
         * @member {number|Long} feeSat
         * @memberof lnrpc.EstimateFeeResponse
         * @instance
         */
        EstimateFeeResponse.prototype.feeSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The fee rate in satoshi/byte.
         * @member {number|Long} feerateSatPerByte
         * @memberof lnrpc.EstimateFeeResponse
         * @instance
         */
        EstimateFeeResponse.prototype.feerateSatPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new EstimateFeeResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {lnrpc.IEstimateFeeResponse=} [properties] Properties to set
         * @returns {lnrpc.EstimateFeeResponse} EstimateFeeResponse instance
         */
        EstimateFeeResponse.create = function create(properties) {
            return new EstimateFeeResponse(properties);
        };

        /**
         * Encodes the specified EstimateFeeResponse message. Does not implicitly {@link lnrpc.EstimateFeeResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {lnrpc.IEstimateFeeResponse} message EstimateFeeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EstimateFeeResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.feeSat);
            if (message.feerateSatPerByte != null && message.hasOwnProperty("feerateSatPerByte"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.feerateSatPerByte);
            return writer;
        };

        /**
         * Encodes the specified EstimateFeeResponse message, length delimited. Does not implicitly {@link lnrpc.EstimateFeeResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {lnrpc.IEstimateFeeResponse} message EstimateFeeResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EstimateFeeResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EstimateFeeResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.EstimateFeeResponse} EstimateFeeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EstimateFeeResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.EstimateFeeResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.feeSat = reader.int64();
                    break;
                case 2:
                    message.feerateSatPerByte = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EstimateFeeResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.EstimateFeeResponse} EstimateFeeResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EstimateFeeResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EstimateFeeResponse message.
         * @function verify
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EstimateFeeResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                if (!$util.isInteger(message.feeSat) && !(message.feeSat && $util.isInteger(message.feeSat.low) && $util.isInteger(message.feeSat.high)))
                    return "feeSat: integer|Long expected";
            if (message.feerateSatPerByte != null && message.hasOwnProperty("feerateSatPerByte"))
                if (!$util.isInteger(message.feerateSatPerByte) && !(message.feerateSatPerByte && $util.isInteger(message.feerateSatPerByte.low) && $util.isInteger(message.feerateSatPerByte.high)))
                    return "feerateSatPerByte: integer|Long expected";
            return null;
        };

        /**
         * Creates an EstimateFeeResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.EstimateFeeResponse} EstimateFeeResponse
         */
        EstimateFeeResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.EstimateFeeResponse)
                return object;
            let message = new $root.lnrpc.EstimateFeeResponse();
            if (object.feeSat != null)
                if ($util.Long)
                    (message.feeSat = $util.Long.fromValue(object.feeSat)).unsigned = false;
                else if (typeof object.feeSat === "string")
                    message.feeSat = parseInt(object.feeSat, 10);
                else if (typeof object.feeSat === "number")
                    message.feeSat = object.feeSat;
                else if (typeof object.feeSat === "object")
                    message.feeSat = new $util.LongBits(object.feeSat.low >>> 0, object.feeSat.high >>> 0).toNumber();
            if (object.feerateSatPerByte != null)
                if ($util.Long)
                    (message.feerateSatPerByte = $util.Long.fromValue(object.feerateSatPerByte)).unsigned = false;
                else if (typeof object.feerateSatPerByte === "string")
                    message.feerateSatPerByte = parseInt(object.feerateSatPerByte, 10);
                else if (typeof object.feerateSatPerByte === "number")
                    message.feerateSatPerByte = object.feerateSatPerByte;
                else if (typeof object.feerateSatPerByte === "object")
                    message.feerateSatPerByte = new $util.LongBits(object.feerateSatPerByte.low >>> 0, object.feerateSatPerByte.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an EstimateFeeResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.EstimateFeeResponse
         * @static
         * @param {lnrpc.EstimateFeeResponse} message EstimateFeeResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EstimateFeeResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feerateSatPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feerateSatPerByte = options.longs === String ? "0" : 0;
            }
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                if (typeof message.feeSat === "number")
                    object.feeSat = options.longs === String ? String(message.feeSat) : message.feeSat;
                else
                    object.feeSat = options.longs === String ? $util.Long.prototype.toString.call(message.feeSat) : options.longs === Number ? new $util.LongBits(message.feeSat.low >>> 0, message.feeSat.high >>> 0).toNumber() : message.feeSat;
            if (message.feerateSatPerByte != null && message.hasOwnProperty("feerateSatPerByte"))
                if (typeof message.feerateSatPerByte === "number")
                    object.feerateSatPerByte = options.longs === String ? String(message.feerateSatPerByte) : message.feerateSatPerByte;
                else
                    object.feerateSatPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.feerateSatPerByte) : options.longs === Number ? new $util.LongBits(message.feerateSatPerByte.low >>> 0, message.feerateSatPerByte.high >>> 0).toNumber() : message.feerateSatPerByte;
            return object;
        };

        /**
         * Converts this EstimateFeeResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.EstimateFeeResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EstimateFeeResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EstimateFeeResponse;
    })();

    lnrpc.SendManyRequest = (function() {

        /**
         * Properties of a SendManyRequest.
         * @memberof lnrpc
         * @interface ISendManyRequest
         * @property {Object.<string,number|Long>|null} [AddrToAmount] The map from addresses to amounts
         * @property {number|null} [targetConf] The target number of blocks that this transaction should be confirmed by.
         * @property {number|Long|null} [satPerByte] A manual fee rate set in sat/byte that should be used when crafting the transaction.
         */

        /**
         * Constructs a new SendManyRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendManyRequest.
         * @implements ISendManyRequest
         * @constructor
         * @param {lnrpc.ISendManyRequest=} [properties] Properties to set
         */
        function SendManyRequest(properties) {
            this.AddrToAmount = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The map from addresses to amounts
         * @member {Object.<string,number|Long>} AddrToAmount
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.AddrToAmount = $util.emptyObject;

        /**
         * The target number of blocks that this transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.targetConf = 0;

        /**
         * A manual fee rate set in sat/byte that should be used when crafting the transaction.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.SendManyRequest
         * @instance
         */
        SendManyRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new SendManyRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest=} [properties] Properties to set
         * @returns {lnrpc.SendManyRequest} SendManyRequest instance
         */
        SendManyRequest.create = function create(properties) {
            return new SendManyRequest(properties);
        };

        /**
         * Encodes the specified SendManyRequest message. Does not implicitly {@link lnrpc.SendManyRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest} message SendManyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AddrToAmount != null && message.hasOwnProperty("AddrToAmount"))
                for (let keys = Object.keys(message.AddrToAmount), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.AddrToAmount[keys[i]]).ldelim();
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.satPerByte);
            return writer;
        };

        /**
         * Encodes the specified SendManyRequest message, length delimited. Does not implicitly {@link lnrpc.SendManyRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.ISendManyRequest} message SendManyRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendManyRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendManyRequest(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    reader.skip().pos++;
                    if (message.AddrToAmount === $util.emptyObject)
                        message.AddrToAmount = {};
                    key = reader.string();
                    reader.pos++;
                    message.AddrToAmount[key] = reader.int64();
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 5:
                    message.satPerByte = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendManyRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendManyRequest message.
         * @function verify
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendManyRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AddrToAmount != null && message.hasOwnProperty("AddrToAmount")) {
                if (!$util.isObject(message.AddrToAmount))
                    return "AddrToAmount: object expected";
                let key = Object.keys(message.AddrToAmount);
                for (let i = 0; i < key.length; ++i)
                    if (!$util.isInteger(message.AddrToAmount[key[i]]) && !(message.AddrToAmount[key[i]] && $util.isInteger(message.AddrToAmount[key[i]].low) && $util.isInteger(message.AddrToAmount[key[i]].high)))
                        return "AddrToAmount: integer|Long{k:string} expected";
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            return null;
        };

        /**
         * Creates a SendManyRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendManyRequest} SendManyRequest
         */
        SendManyRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendManyRequest)
                return object;
            let message = new $root.lnrpc.SendManyRequest();
            if (object.AddrToAmount) {
                if (typeof object.AddrToAmount !== "object")
                    throw TypeError(".lnrpc.SendManyRequest.AddrToAmount: object expected");
                message.AddrToAmount = {};
                for (let keys = Object.keys(object.AddrToAmount), i = 0; i < keys.length; ++i)
                    if ($util.Long)
                        (message.AddrToAmount[keys[i]] = $util.Long.fromValue(object.AddrToAmount[keys[i]])).unsigned = false;
                    else if (typeof object.AddrToAmount[keys[i]] === "string")
                        message.AddrToAmount[keys[i]] = parseInt(object.AddrToAmount[keys[i]], 10);
                    else if (typeof object.AddrToAmount[keys[i]] === "number")
                        message.AddrToAmount[keys[i]] = object.AddrToAmount[keys[i]];
                    else if (typeof object.AddrToAmount[keys[i]] === "object")
                        message.AddrToAmount[keys[i]] = new $util.LongBits(object.AddrToAmount[keys[i]].low >>> 0, object.AddrToAmount[keys[i]].high >>> 0).toNumber();
            }
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a SendManyRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendManyRequest
         * @static
         * @param {lnrpc.SendManyRequest} message SendManyRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendManyRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.AddrToAmount = {};
            if (options.defaults) {
                object.targetConf = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
            }
            let keys2;
            if (message.AddrToAmount && (keys2 = Object.keys(message.AddrToAmount)).length) {
                object.AddrToAmount = {};
                for (let j = 0; j < keys2.length; ++j)
                    if (typeof message.AddrToAmount[keys2[j]] === "number")
                        object.AddrToAmount[keys2[j]] = options.longs === String ? String(message.AddrToAmount[keys2[j]]) : message.AddrToAmount[keys2[j]];
                    else
                        object.AddrToAmount[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.AddrToAmount[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.AddrToAmount[keys2[j]].low >>> 0, message.AddrToAmount[keys2[j]].high >>> 0).toNumber() : message.AddrToAmount[keys2[j]];
            }
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            return object;
        };

        /**
         * Converts this SendManyRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendManyRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendManyRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendManyRequest;
    })();

    lnrpc.SendManyResponse = (function() {

        /**
         * Properties of a SendManyResponse.
         * @memberof lnrpc
         * @interface ISendManyResponse
         * @property {string|null} [txid] The id of the transaction
         */

        /**
         * Constructs a new SendManyResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendManyResponse.
         * @implements ISendManyResponse
         * @constructor
         * @param {lnrpc.ISendManyResponse=} [properties] Properties to set
         */
        function SendManyResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The id of the transaction
         * @member {string} txid
         * @memberof lnrpc.SendManyResponse
         * @instance
         */
        SendManyResponse.prototype.txid = "";

        /**
         * Creates a new SendManyResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse=} [properties] Properties to set
         * @returns {lnrpc.SendManyResponse} SendManyResponse instance
         */
        SendManyResponse.create = function create(properties) {
            return new SendManyResponse(properties);
        };

        /**
         * Encodes the specified SendManyResponse message. Does not implicitly {@link lnrpc.SendManyResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse} message SendManyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && message.hasOwnProperty("txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
            return writer;
        };

        /**
         * Encodes the specified SendManyResponse message, length delimited. Does not implicitly {@link lnrpc.SendManyResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.ISendManyResponse} message SendManyResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendManyResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendManyResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendManyResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendManyResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendManyResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendManyResponse message.
         * @function verify
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendManyResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!$util.isString(message.txid))
                    return "txid: string expected";
            return null;
        };

        /**
         * Creates a SendManyResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendManyResponse} SendManyResponse
         */
        SendManyResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendManyResponse)
                return object;
            let message = new $root.lnrpc.SendManyResponse();
            if (object.txid != null)
                message.txid = String(object.txid);
            return message;
        };

        /**
         * Creates a plain object from a SendManyResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendManyResponse
         * @static
         * @param {lnrpc.SendManyResponse} message SendManyResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendManyResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.txid = "";
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = message.txid;
            return object;
        };

        /**
         * Converts this SendManyResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendManyResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendManyResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendManyResponse;
    })();

    lnrpc.SendCoinsRequest = (function() {

        /**
         * Properties of a SendCoinsRequest.
         * @memberof lnrpc
         * @interface ISendCoinsRequest
         * @property {string|null} [addr] The address to send coins to
         * @property {number|Long|null} [amount] The amount in satoshis to send
         * @property {number|null} [targetConf] The target number of blocks that this transaction should be confirmed by.
         * @property {number|Long|null} [satPerByte] A manual fee rate set in sat/byte that should be used when crafting the transaction.
         * @property {boolean|null} [sendAll] If set, then the amount field will be ignored, and lnd will attempt to
         * send all the coins under control of the internal wallet to the specified
         * address.
         */

        /**
         * Constructs a new SendCoinsRequest.
         * @memberof lnrpc
         * @classdesc Represents a SendCoinsRequest.
         * @implements ISendCoinsRequest
         * @constructor
         * @param {lnrpc.ISendCoinsRequest=} [properties] Properties to set
         */
        function SendCoinsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The address to send coins to
         * @member {string} addr
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.addr = "";

        /**
         * The amount in satoshis to send
         * @member {number|Long} amount
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The target number of blocks that this transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.targetConf = 0;

        /**
         * A manual fee rate set in sat/byte that should be used when crafting the transaction.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * If set, then the amount field will be ignored, and lnd will attempt to
         * send all the coins under control of the internal wallet to the specified
         * address.
         * @member {boolean} sendAll
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         */
        SendCoinsRequest.prototype.sendAll = false;

        /**
         * Creates a new SendCoinsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest=} [properties] Properties to set
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest instance
         */
        SendCoinsRequest.create = function create(properties) {
            return new SendCoinsRequest(properties);
        };

        /**
         * Encodes the specified SendCoinsRequest message. Does not implicitly {@link lnrpc.SendCoinsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest} message SendCoinsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addr != null && message.hasOwnProperty("addr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.addr);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.satPerByte);
            if (message.sendAll != null && message.hasOwnProperty("sendAll"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.sendAll);
            return writer;
        };

        /**
         * Encodes the specified SendCoinsRequest message, length delimited. Does not implicitly {@link lnrpc.SendCoinsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.ISendCoinsRequest} message SendCoinsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendCoinsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendCoinsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addr = reader.string();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 5:
                    message.satPerByte = reader.int64();
                    break;
                case 6:
                    message.sendAll = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendCoinsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendCoinsRequest message.
         * @function verify
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendCoinsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addr != null && message.hasOwnProperty("addr"))
                if (!$util.isString(message.addr))
                    return "addr: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            if (message.sendAll != null && message.hasOwnProperty("sendAll"))
                if (typeof message.sendAll !== "boolean")
                    return "sendAll: boolean expected";
            return null;
        };

        /**
         * Creates a SendCoinsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendCoinsRequest} SendCoinsRequest
         */
        SendCoinsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendCoinsRequest)
                return object;
            let message = new $root.lnrpc.SendCoinsRequest();
            if (object.addr != null)
                message.addr = String(object.addr);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            if (object.sendAll != null)
                message.sendAll = Boolean(object.sendAll);
            return message;
        };

        /**
         * Creates a plain object from a SendCoinsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendCoinsRequest
         * @static
         * @param {lnrpc.SendCoinsRequest} message SendCoinsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendCoinsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.addr = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.targetConf = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
                object.sendAll = false;
            }
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = message.addr;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            if (message.sendAll != null && message.hasOwnProperty("sendAll"))
                object.sendAll = message.sendAll;
            return object;
        };

        /**
         * Converts this SendCoinsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SendCoinsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendCoinsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendCoinsRequest;
    })();

    lnrpc.SendCoinsResponse = (function() {

        /**
         * Properties of a SendCoinsResponse.
         * @memberof lnrpc
         * @interface ISendCoinsResponse
         * @property {string|null} [txid] The transaction ID of the transaction
         */

        /**
         * Constructs a new SendCoinsResponse.
         * @memberof lnrpc
         * @classdesc Represents a SendCoinsResponse.
         * @implements ISendCoinsResponse
         * @constructor
         * @param {lnrpc.ISendCoinsResponse=} [properties] Properties to set
         */
        function SendCoinsResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The transaction ID of the transaction
         * @member {string} txid
         * @memberof lnrpc.SendCoinsResponse
         * @instance
         */
        SendCoinsResponse.prototype.txid = "";

        /**
         * Creates a new SendCoinsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse=} [properties] Properties to set
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse instance
         */
        SendCoinsResponse.create = function create(properties) {
            return new SendCoinsResponse(properties);
        };

        /**
         * Encodes the specified SendCoinsResponse message. Does not implicitly {@link lnrpc.SendCoinsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse} message SendCoinsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && message.hasOwnProperty("txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.txid);
            return writer;
        };

        /**
         * Encodes the specified SendCoinsResponse message, length delimited. Does not implicitly {@link lnrpc.SendCoinsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.ISendCoinsResponse} message SendCoinsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendCoinsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendCoinsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SendCoinsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendCoinsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendCoinsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendCoinsResponse message.
         * @function verify
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendCoinsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!$util.isString(message.txid))
                    return "txid: string expected";
            return null;
        };

        /**
         * Creates a SendCoinsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SendCoinsResponse} SendCoinsResponse
         */
        SendCoinsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SendCoinsResponse)
                return object;
            let message = new $root.lnrpc.SendCoinsResponse();
            if (object.txid != null)
                message.txid = String(object.txid);
            return message;
        };

        /**
         * Creates a plain object from a SendCoinsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SendCoinsResponse
         * @static
         * @param {lnrpc.SendCoinsResponse} message SendCoinsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SendCoinsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.txid = "";
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = message.txid;
            return object;
        };

        /**
         * Converts this SendCoinsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SendCoinsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SendCoinsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SendCoinsResponse;
    })();

    lnrpc.ListUnspentRequest = (function() {

        /**
         * Properties of a ListUnspentRequest.
         * @memberof lnrpc
         * @interface IListUnspentRequest
         * @property {number|null} [minConfs] The minimum number of confirmations to be included.
         * @property {number|null} [maxConfs] The maximum number of confirmations to be included.
         */

        /**
         * Constructs a new ListUnspentRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListUnspentRequest.
         * @implements IListUnspentRequest
         * @constructor
         * @param {lnrpc.IListUnspentRequest=} [properties] Properties to set
         */
        function ListUnspentRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The minimum number of confirmations to be included.
         * @member {number} minConfs
         * @memberof lnrpc.ListUnspentRequest
         * @instance
         */
        ListUnspentRequest.prototype.minConfs = 0;

        /**
         * The maximum number of confirmations to be included.
         * @member {number} maxConfs
         * @memberof lnrpc.ListUnspentRequest
         * @instance
         */
        ListUnspentRequest.prototype.maxConfs = 0;

        /**
         * Creates a new ListUnspentRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {lnrpc.IListUnspentRequest=} [properties] Properties to set
         * @returns {lnrpc.ListUnspentRequest} ListUnspentRequest instance
         */
        ListUnspentRequest.create = function create(properties) {
            return new ListUnspentRequest(properties);
        };

        /**
         * Encodes the specified ListUnspentRequest message. Does not implicitly {@link lnrpc.ListUnspentRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {lnrpc.IListUnspentRequest} message ListUnspentRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnspentRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.minConfs);
            if (message.maxConfs != null && message.hasOwnProperty("maxConfs"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxConfs);
            return writer;
        };

        /**
         * Encodes the specified ListUnspentRequest message, length delimited. Does not implicitly {@link lnrpc.ListUnspentRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {lnrpc.IListUnspentRequest} message ListUnspentRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnspentRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListUnspentRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListUnspentRequest} ListUnspentRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnspentRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListUnspentRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.minConfs = reader.int32();
                    break;
                case 2:
                    message.maxConfs = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListUnspentRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListUnspentRequest} ListUnspentRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnspentRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListUnspentRequest message.
         * @function verify
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListUnspentRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                if (!$util.isInteger(message.minConfs))
                    return "minConfs: integer expected";
            if (message.maxConfs != null && message.hasOwnProperty("maxConfs"))
                if (!$util.isInteger(message.maxConfs))
                    return "maxConfs: integer expected";
            return null;
        };

        /**
         * Creates a ListUnspentRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListUnspentRequest} ListUnspentRequest
         */
        ListUnspentRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListUnspentRequest)
                return object;
            let message = new $root.lnrpc.ListUnspentRequest();
            if (object.minConfs != null)
                message.minConfs = object.minConfs | 0;
            if (object.maxConfs != null)
                message.maxConfs = object.maxConfs | 0;
            return message;
        };

        /**
         * Creates a plain object from a ListUnspentRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListUnspentRequest
         * @static
         * @param {lnrpc.ListUnspentRequest} message ListUnspentRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListUnspentRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.minConfs = 0;
                object.maxConfs = 0;
            }
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                object.minConfs = message.minConfs;
            if (message.maxConfs != null && message.hasOwnProperty("maxConfs"))
                object.maxConfs = message.maxConfs;
            return object;
        };

        /**
         * Converts this ListUnspentRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListUnspentRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListUnspentRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListUnspentRequest;
    })();

    lnrpc.ListUnspentResponse = (function() {

        /**
         * Properties of a ListUnspentResponse.
         * @memberof lnrpc
         * @interface IListUnspentResponse
         * @property {Array.<lnrpc.IUtxo>|null} [utxos] A list of utxos
         */

        /**
         * Constructs a new ListUnspentResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListUnspentResponse.
         * @implements IListUnspentResponse
         * @constructor
         * @param {lnrpc.IListUnspentResponse=} [properties] Properties to set
         */
        function ListUnspentResponse(properties) {
            this.utxos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * A list of utxos
         * @member {Array.<lnrpc.IUtxo>} utxos
         * @memberof lnrpc.ListUnspentResponse
         * @instance
         */
        ListUnspentResponse.prototype.utxos = $util.emptyArray;

        /**
         * Creates a new ListUnspentResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {lnrpc.IListUnspentResponse=} [properties] Properties to set
         * @returns {lnrpc.ListUnspentResponse} ListUnspentResponse instance
         */
        ListUnspentResponse.create = function create(properties) {
            return new ListUnspentResponse(properties);
        };

        /**
         * Encodes the specified ListUnspentResponse message. Does not implicitly {@link lnrpc.ListUnspentResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {lnrpc.IListUnspentResponse} message ListUnspentResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnspentResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.utxos != null && message.utxos.length)
                for (let i = 0; i < message.utxos.length; ++i)
                    $root.lnrpc.Utxo.encode(message.utxos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListUnspentResponse message, length delimited. Does not implicitly {@link lnrpc.ListUnspentResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {lnrpc.IListUnspentResponse} message ListUnspentResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListUnspentResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListUnspentResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListUnspentResponse} ListUnspentResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnspentResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListUnspentResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.utxos && message.utxos.length))
                        message.utxos = [];
                    message.utxos.push($root.lnrpc.Utxo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListUnspentResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListUnspentResponse} ListUnspentResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListUnspentResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListUnspentResponse message.
         * @function verify
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListUnspentResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.utxos != null && message.hasOwnProperty("utxos")) {
                if (!Array.isArray(message.utxos))
                    return "utxos: array expected";
                for (let i = 0; i < message.utxos.length; ++i) {
                    let error = $root.lnrpc.Utxo.verify(message.utxos[i]);
                    if (error)
                        return "utxos." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListUnspentResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListUnspentResponse} ListUnspentResponse
         */
        ListUnspentResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListUnspentResponse)
                return object;
            let message = new $root.lnrpc.ListUnspentResponse();
            if (object.utxos) {
                if (!Array.isArray(object.utxos))
                    throw TypeError(".lnrpc.ListUnspentResponse.utxos: array expected");
                message.utxos = [];
                for (let i = 0; i < object.utxos.length; ++i) {
                    if (typeof object.utxos[i] !== "object")
                        throw TypeError(".lnrpc.ListUnspentResponse.utxos: object expected");
                    message.utxos[i] = $root.lnrpc.Utxo.fromObject(object.utxos[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListUnspentResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListUnspentResponse
         * @static
         * @param {lnrpc.ListUnspentResponse} message ListUnspentResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListUnspentResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.utxos = [];
            if (message.utxos && message.utxos.length) {
                object.utxos = [];
                for (let j = 0; j < message.utxos.length; ++j)
                    object.utxos[j] = $root.lnrpc.Utxo.toObject(message.utxos[j], options);
            }
            return object;
        };

        /**
         * Converts this ListUnspentResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListUnspentResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListUnspentResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListUnspentResponse;
    })();

    /**
     * `AddressType` has to be one of:
     * 
     * - `p2wkh`: Pay to witness key hash (`WITNESS_PUBKEY_HASH` = 0)
     * - `np2wkh`: Pay to nested witness key hash (`NESTED_PUBKEY_HASH` = 1)
     * @name lnrpc.AddressType
     * @enum {string}
     * @property {number} WITNESS_PUBKEY_HASH=0 WITNESS_PUBKEY_HASH value
     * @property {number} NESTED_PUBKEY_HASH=1 NESTED_PUBKEY_HASH value
     * @property {number} UNUSED_WITNESS_PUBKEY_HASH=2 UNUSED_WITNESS_PUBKEY_HASH value
     * @property {number} UNUSED_NESTED_PUBKEY_HASH=3 UNUSED_NESTED_PUBKEY_HASH value
     */
    lnrpc.AddressType = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "WITNESS_PUBKEY_HASH"] = 0;
        values[valuesById[1] = "NESTED_PUBKEY_HASH"] = 1;
        values[valuesById[2] = "UNUSED_WITNESS_PUBKEY_HASH"] = 2;
        values[valuesById[3] = "UNUSED_NESTED_PUBKEY_HASH"] = 3;
        return values;
    })();

    lnrpc.NewAddressRequest = (function() {

        /**
         * Properties of a NewAddressRequest.
         * @memberof lnrpc
         * @interface INewAddressRequest
         * @property {lnrpc.AddressType|null} [type] The address type
         */

        /**
         * Constructs a new NewAddressRequest.
         * @memberof lnrpc
         * @classdesc Represents a NewAddressRequest.
         * @implements INewAddressRequest
         * @constructor
         * @param {lnrpc.INewAddressRequest=} [properties] Properties to set
         */
        function NewAddressRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The address type
         * @member {lnrpc.AddressType} type
         * @memberof lnrpc.NewAddressRequest
         * @instance
         */
        NewAddressRequest.prototype.type = 0;

        /**
         * Creates a new NewAddressRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest=} [properties] Properties to set
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest instance
         */
        NewAddressRequest.create = function create(properties) {
            return new NewAddressRequest(properties);
        };

        /**
         * Encodes the specified NewAddressRequest message. Does not implicitly {@link lnrpc.NewAddressRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest} message NewAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified NewAddressRequest message, length delimited. Does not implicitly {@link lnrpc.NewAddressRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.INewAddressRequest} message NewAddressRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewAddressRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NewAddressRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewAddressRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewAddressRequest message.
         * @function verify
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewAddressRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a NewAddressRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NewAddressRequest} NewAddressRequest
         */
        NewAddressRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NewAddressRequest)
                return object;
            let message = new $root.lnrpc.NewAddressRequest();
            switch (object.type) {
            case "WITNESS_PUBKEY_HASH":
            case 0:
                message.type = 0;
                break;
            case "NESTED_PUBKEY_HASH":
            case 1:
                message.type = 1;
                break;
            case "UNUSED_WITNESS_PUBKEY_HASH":
            case 2:
                message.type = 2;
                break;
            case "UNUSED_NESTED_PUBKEY_HASH":
            case 3:
                message.type = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a NewAddressRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NewAddressRequest
         * @static
         * @param {lnrpc.NewAddressRequest} message NewAddressRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewAddressRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.type = options.enums === String ? "WITNESS_PUBKEY_HASH" : 0;
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.lnrpc.AddressType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this NewAddressRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NewAddressRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewAddressRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewAddressRequest;
    })();

    lnrpc.NewAddressResponse = (function() {

        /**
         * Properties of a NewAddressResponse.
         * @memberof lnrpc
         * @interface INewAddressResponse
         * @property {string|null} [address] The newly generated wallet address
         */

        /**
         * Constructs a new NewAddressResponse.
         * @memberof lnrpc
         * @classdesc Represents a NewAddressResponse.
         * @implements INewAddressResponse
         * @constructor
         * @param {lnrpc.INewAddressResponse=} [properties] Properties to set
         */
        function NewAddressResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The newly generated wallet address
         * @member {string} address
         * @memberof lnrpc.NewAddressResponse
         * @instance
         */
        NewAddressResponse.prototype.address = "";

        /**
         * Creates a new NewAddressResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse=} [properties] Properties to set
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse instance
         */
        NewAddressResponse.create = function create(properties) {
            return new NewAddressResponse(properties);
        };

        /**
         * Encodes the specified NewAddressResponse message. Does not implicitly {@link lnrpc.NewAddressResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse} message NewAddressResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);
            return writer;
        };

        /**
         * Encodes the specified NewAddressResponse message, length delimited. Does not implicitly {@link lnrpc.NewAddressResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.INewAddressResponse} message NewAddressResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewAddressResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewAddressResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NewAddressResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.address = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewAddressResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewAddressResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewAddressResponse message.
         * @function verify
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewAddressResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            return null;
        };

        /**
         * Creates a NewAddressResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NewAddressResponse} NewAddressResponse
         */
        NewAddressResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NewAddressResponse)
                return object;
            let message = new $root.lnrpc.NewAddressResponse();
            if (object.address != null)
                message.address = String(object.address);
            return message;
        };

        /**
         * Creates a plain object from a NewAddressResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NewAddressResponse
         * @static
         * @param {lnrpc.NewAddressResponse} message NewAddressResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NewAddressResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.address = "";
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            return object;
        };

        /**
         * Converts this NewAddressResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.NewAddressResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NewAddressResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NewAddressResponse;
    })();

    lnrpc.SignMessageRequest = (function() {

        /**
         * Properties of a SignMessageRequest.
         * @memberof lnrpc
         * @interface ISignMessageRequest
         * @property {Uint8Array|null} [msg] The message to be signed
         */

        /**
         * Constructs a new SignMessageRequest.
         * @memberof lnrpc
         * @classdesc Represents a SignMessageRequest.
         * @implements ISignMessageRequest
         * @constructor
         * @param {lnrpc.ISignMessageRequest=} [properties] Properties to set
         */
        function SignMessageRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The message to be signed
         * @member {Uint8Array} msg
         * @memberof lnrpc.SignMessageRequest
         * @instance
         */
        SignMessageRequest.prototype.msg = $util.newBuffer([]);

        /**
         * Creates a new SignMessageRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest=} [properties] Properties to set
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest instance
         */
        SignMessageRequest.create = function create(properties) {
            return new SignMessageRequest(properties);
        };

        /**
         * Encodes the specified SignMessageRequest message. Does not implicitly {@link lnrpc.SignMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest} message SignMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && message.hasOwnProperty("msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msg);
            return writer;
        };

        /**
         * Encodes the specified SignMessageRequest message, length delimited. Does not implicitly {@link lnrpc.SignMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.ISignMessageRequest} message SignMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SignMessageRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignMessageRequest message.
         * @function verify
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!(message.msg && typeof message.msg.length === "number" || $util.isString(message.msg)))
                    return "msg: buffer expected";
            return null;
        };

        /**
         * Creates a SignMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SignMessageRequest} SignMessageRequest
         */
        SignMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SignMessageRequest)
                return object;
            let message = new $root.lnrpc.SignMessageRequest();
            if (object.msg != null)
                if (typeof object.msg === "string")
                    $util.base64.decode(object.msg, message.msg = $util.newBuffer($util.base64.length(object.msg)), 0);
                else if (object.msg.length)
                    message.msg = object.msg;
            return message;
        };

        /**
         * Creates a plain object from a SignMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SignMessageRequest
         * @static
         * @param {lnrpc.SignMessageRequest} message SignMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.msg = "";
                else {
                    object.msg = [];
                    if (options.bytes !== Array)
                        object.msg = $util.newBuffer(object.msg);
                }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = options.bytes === String ? $util.base64.encode(message.msg, 0, message.msg.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg) : message.msg;
            return object;
        };

        /**
         * Converts this SignMessageRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SignMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignMessageRequest;
    })();

    lnrpc.SignMessageResponse = (function() {

        /**
         * Properties of a SignMessageResponse.
         * @memberof lnrpc
         * @interface ISignMessageResponse
         * @property {string|null} [signature] The signature for the given message
         */

        /**
         * Constructs a new SignMessageResponse.
         * @memberof lnrpc
         * @classdesc Represents a SignMessageResponse.
         * @implements ISignMessageResponse
         * @constructor
         * @param {lnrpc.ISignMessageResponse=} [properties] Properties to set
         */
        function SignMessageResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The signature for the given message
         * @member {string} signature
         * @memberof lnrpc.SignMessageResponse
         * @instance
         */
        SignMessageResponse.prototype.signature = "";

        /**
         * Creates a new SignMessageResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse=} [properties] Properties to set
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse instance
         */
        SignMessageResponse.create = function create(properties) {
            return new SignMessageResponse(properties);
        };

        /**
         * Encodes the specified SignMessageResponse message. Does not implicitly {@link lnrpc.SignMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse} message SignMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.signature);
            return writer;
        };

        /**
         * Encodes the specified SignMessageResponse message, length delimited. Does not implicitly {@link lnrpc.SignMessageResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.ISignMessageResponse} message SignMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SignMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SignMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SignMessageResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.signature = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SignMessageResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SignMessageResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SignMessageResponse message.
         * @function verify
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SignMessageResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            return null;
        };

        /**
         * Creates a SignMessageResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SignMessageResponse} SignMessageResponse
         */
        SignMessageResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SignMessageResponse)
                return object;
            let message = new $root.lnrpc.SignMessageResponse();
            if (object.signature != null)
                message.signature = String(object.signature);
            return message;
        };

        /**
         * Creates a plain object from a SignMessageResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SignMessageResponse
         * @static
         * @param {lnrpc.SignMessageResponse} message SignMessageResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SignMessageResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.signature = "";
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            return object;
        };

        /**
         * Converts this SignMessageResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SignMessageResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SignMessageResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SignMessageResponse;
    })();

    lnrpc.VerifyMessageRequest = (function() {

        /**
         * Properties of a VerifyMessageRequest.
         * @memberof lnrpc
         * @interface IVerifyMessageRequest
         * @property {Uint8Array|null} [msg] The message over which the signature is to be verified
         * @property {string|null} [signature] The signature to be verified over the given message
         */

        /**
         * Constructs a new VerifyMessageRequest.
         * @memberof lnrpc
         * @classdesc Represents a VerifyMessageRequest.
         * @implements IVerifyMessageRequest
         * @constructor
         * @param {lnrpc.IVerifyMessageRequest=} [properties] Properties to set
         */
        function VerifyMessageRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The message over which the signature is to be verified
         * @member {Uint8Array} msg
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         */
        VerifyMessageRequest.prototype.msg = $util.newBuffer([]);

        /**
         * The signature to be verified over the given message
         * @member {string} signature
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         */
        VerifyMessageRequest.prototype.signature = "";

        /**
         * Creates a new VerifyMessageRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest=} [properties] Properties to set
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest instance
         */
        VerifyMessageRequest.create = function create(properties) {
            return new VerifyMessageRequest(properties);
        };

        /**
         * Encodes the specified VerifyMessageRequest message. Does not implicitly {@link lnrpc.VerifyMessageRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest} message VerifyMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && message.hasOwnProperty("msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.msg);
            if (message.signature != null && message.hasOwnProperty("signature"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.signature);
            return writer;
        };

        /**
         * Encodes the specified VerifyMessageRequest message, length delimited. Does not implicitly {@link lnrpc.VerifyMessageRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.IVerifyMessageRequest} message VerifyMessageRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyMessageRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.VerifyMessageRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = reader.bytes();
                    break;
                case 2:
                    message.signature = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyMessageRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyMessageRequest message.
         * @function verify
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyMessageRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg"))
                if (!(message.msg && typeof message.msg.length === "number" || $util.isString(message.msg)))
                    return "msg: buffer expected";
            if (message.signature != null && message.hasOwnProperty("signature"))
                if (!$util.isString(message.signature))
                    return "signature: string expected";
            return null;
        };

        /**
         * Creates a VerifyMessageRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.VerifyMessageRequest} VerifyMessageRequest
         */
        VerifyMessageRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.VerifyMessageRequest)
                return object;
            let message = new $root.lnrpc.VerifyMessageRequest();
            if (object.msg != null)
                if (typeof object.msg === "string")
                    $util.base64.decode(object.msg, message.msg = $util.newBuffer($util.base64.length(object.msg)), 0);
                else if (object.msg.length)
                    message.msg = object.msg;
            if (object.signature != null)
                message.signature = String(object.signature);
            return message;
        };

        /**
         * Creates a plain object from a VerifyMessageRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.VerifyMessageRequest
         * @static
         * @param {lnrpc.VerifyMessageRequest} message VerifyMessageRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyMessageRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.msg = "";
                else {
                    object.msg = [];
                    if (options.bytes !== Array)
                        object.msg = $util.newBuffer(object.msg);
                }
                object.signature = "";
            }
            if (message.msg != null && message.hasOwnProperty("msg"))
                object.msg = options.bytes === String ? $util.base64.encode(message.msg, 0, message.msg.length) : options.bytes === Array ? Array.prototype.slice.call(message.msg) : message.msg;
            if (message.signature != null && message.hasOwnProperty("signature"))
                object.signature = message.signature;
            return object;
        };

        /**
         * Converts this VerifyMessageRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.VerifyMessageRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyMessageRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyMessageRequest;
    })();

    lnrpc.VerifyMessageResponse = (function() {

        /**
         * Properties of a VerifyMessageResponse.
         * @memberof lnrpc
         * @interface IVerifyMessageResponse
         * @property {boolean|null} [valid] Whether the signature was valid over the given message
         * @property {string|null} [pubkey] The pubkey recovered from the signature
         */

        /**
         * Constructs a new VerifyMessageResponse.
         * @memberof lnrpc
         * @classdesc Represents a VerifyMessageResponse.
         * @implements IVerifyMessageResponse
         * @constructor
         * @param {lnrpc.IVerifyMessageResponse=} [properties] Properties to set
         */
        function VerifyMessageResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Whether the signature was valid over the given message
         * @member {boolean} valid
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         */
        VerifyMessageResponse.prototype.valid = false;

        /**
         * The pubkey recovered from the signature
         * @member {string} pubkey
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         */
        VerifyMessageResponse.prototype.pubkey = "";

        /**
         * Creates a new VerifyMessageResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse=} [properties] Properties to set
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse instance
         */
        VerifyMessageResponse.create = function create(properties) {
            return new VerifyMessageResponse(properties);
        };

        /**
         * Encodes the specified VerifyMessageResponse message. Does not implicitly {@link lnrpc.VerifyMessageResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse} message VerifyMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.valid != null && message.hasOwnProperty("valid"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.valid);
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pubkey);
            return writer;
        };

        /**
         * Encodes the specified VerifyMessageResponse message, length delimited. Does not implicitly {@link lnrpc.VerifyMessageResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.IVerifyMessageResponse} message VerifyMessageResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyMessageResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.VerifyMessageResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.valid = reader.bool();
                    break;
                case 2:
                    message.pubkey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyMessageResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyMessageResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyMessageResponse message.
         * @function verify
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyMessageResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.valid != null && message.hasOwnProperty("valid"))
                if (typeof message.valid !== "boolean")
                    return "valid: boolean expected";
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                if (!$util.isString(message.pubkey))
                    return "pubkey: string expected";
            return null;
        };

        /**
         * Creates a VerifyMessageResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.VerifyMessageResponse} VerifyMessageResponse
         */
        VerifyMessageResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.VerifyMessageResponse)
                return object;
            let message = new $root.lnrpc.VerifyMessageResponse();
            if (object.valid != null)
                message.valid = Boolean(object.valid);
            if (object.pubkey != null)
                message.pubkey = String(object.pubkey);
            return message;
        };

        /**
         * Creates a plain object from a VerifyMessageResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.VerifyMessageResponse
         * @static
         * @param {lnrpc.VerifyMessageResponse} message VerifyMessageResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyMessageResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.valid = false;
                object.pubkey = "";
            }
            if (message.valid != null && message.hasOwnProperty("valid"))
                object.valid = message.valid;
            if (message.pubkey != null && message.hasOwnProperty("pubkey"))
                object.pubkey = message.pubkey;
            return object;
        };

        /**
         * Converts this VerifyMessageResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.VerifyMessageResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyMessageResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyMessageResponse;
    })();

    lnrpc.ConnectPeerRequest = (function() {

        /**
         * Properties of a ConnectPeerRequest.
         * @memberof lnrpc
         * @interface IConnectPeerRequest
         * @property {lnrpc.ILightningAddress|null} [addr] Lightning address of the peer, in the format `<pubkey>@host`
         * @property {boolean|null} [perm] If set, the daemon will attempt to persistently connect to the target
         * peer.  Otherwise, the call will be synchronous.
         */

        /**
         * Constructs a new ConnectPeerRequest.
         * @memberof lnrpc
         * @classdesc Represents a ConnectPeerRequest.
         * @implements IConnectPeerRequest
         * @constructor
         * @param {lnrpc.IConnectPeerRequest=} [properties] Properties to set
         */
        function ConnectPeerRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Lightning address of the peer, in the format `<pubkey>@host`
         * @member {lnrpc.ILightningAddress|null|undefined} addr
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         */
        ConnectPeerRequest.prototype.addr = null;

        /**
         * If set, the daemon will attempt to persistently connect to the target
         * peer.  Otherwise, the call will be synchronous.
         * @member {boolean} perm
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         */
        ConnectPeerRequest.prototype.perm = false;

        /**
         * Creates a new ConnectPeerRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest=} [properties] Properties to set
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest instance
         */
        ConnectPeerRequest.create = function create(properties) {
            return new ConnectPeerRequest(properties);
        };

        /**
         * Encodes the specified ConnectPeerRequest message. Does not implicitly {@link lnrpc.ConnectPeerRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest} message ConnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addr != null && message.hasOwnProperty("addr"))
                $root.lnrpc.LightningAddress.encode(message.addr, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.perm != null && message.hasOwnProperty("perm"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.perm);
            return writer;
        };

        /**
         * Encodes the specified ConnectPeerRequest message, length delimited. Does not implicitly {@link lnrpc.ConnectPeerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.IConnectPeerRequest} message ConnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectPeerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConnectPeerRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addr = $root.lnrpc.LightningAddress.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.perm = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectPeerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectPeerRequest message.
         * @function verify
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectPeerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addr != null && message.hasOwnProperty("addr")) {
                let error = $root.lnrpc.LightningAddress.verify(message.addr);
                if (error)
                    return "addr." + error;
            }
            if (message.perm != null && message.hasOwnProperty("perm"))
                if (typeof message.perm !== "boolean")
                    return "perm: boolean expected";
            return null;
        };

        /**
         * Creates a ConnectPeerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConnectPeerRequest} ConnectPeerRequest
         */
        ConnectPeerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConnectPeerRequest)
                return object;
            let message = new $root.lnrpc.ConnectPeerRequest();
            if (object.addr != null) {
                if (typeof object.addr !== "object")
                    throw TypeError(".lnrpc.ConnectPeerRequest.addr: object expected");
                message.addr = $root.lnrpc.LightningAddress.fromObject(object.addr);
            }
            if (object.perm != null)
                message.perm = Boolean(object.perm);
            return message;
        };

        /**
         * Creates a plain object from a ConnectPeerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConnectPeerRequest
         * @static
         * @param {lnrpc.ConnectPeerRequest} message ConnectPeerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectPeerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.addr = null;
                object.perm = false;
            }
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = $root.lnrpc.LightningAddress.toObject(message.addr, options);
            if (message.perm != null && message.hasOwnProperty("perm"))
                object.perm = message.perm;
            return object;
        };

        /**
         * Converts this ConnectPeerRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ConnectPeerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectPeerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectPeerRequest;
    })();

    lnrpc.ConnectPeerResponse = (function() {

        /**
         * Properties of a ConnectPeerResponse.
         * @memberof lnrpc
         * @interface IConnectPeerResponse
         */

        /**
         * Constructs a new ConnectPeerResponse.
         * @memberof lnrpc
         * @classdesc Represents a ConnectPeerResponse.
         * @implements IConnectPeerResponse
         * @constructor
         * @param {lnrpc.IConnectPeerResponse=} [properties] Properties to set
         */
        function ConnectPeerResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ConnectPeerResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse=} [properties] Properties to set
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse instance
         */
        ConnectPeerResponse.create = function create(properties) {
            return new ConnectPeerResponse(properties);
        };

        /**
         * Encodes the specified ConnectPeerResponse message. Does not implicitly {@link lnrpc.ConnectPeerResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse} message ConnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ConnectPeerResponse message, length delimited. Does not implicitly {@link lnrpc.ConnectPeerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.IConnectPeerResponse} message ConnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConnectPeerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConnectPeerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConnectPeerResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConnectPeerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConnectPeerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConnectPeerResponse message.
         * @function verify
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConnectPeerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ConnectPeerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConnectPeerResponse} ConnectPeerResponse
         */
        ConnectPeerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConnectPeerResponse)
                return object;
            return new $root.lnrpc.ConnectPeerResponse();
        };

        /**
         * Creates a plain object from a ConnectPeerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConnectPeerResponse
         * @static
         * @param {lnrpc.ConnectPeerResponse} message ConnectPeerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConnectPeerResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ConnectPeerResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ConnectPeerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConnectPeerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConnectPeerResponse;
    })();

    lnrpc.DisconnectPeerRequest = (function() {

        /**
         * Properties of a DisconnectPeerRequest.
         * @memberof lnrpc
         * @interface IDisconnectPeerRequest
         * @property {string|null} [pubKey] The pubkey of the node to disconnect from
         */

        /**
         * Constructs a new DisconnectPeerRequest.
         * @memberof lnrpc
         * @classdesc Represents a DisconnectPeerRequest.
         * @implements IDisconnectPeerRequest
         * @constructor
         * @param {lnrpc.IDisconnectPeerRequest=} [properties] Properties to set
         */
        function DisconnectPeerRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The pubkey of the node to disconnect from
         * @member {string} pubKey
         * @memberof lnrpc.DisconnectPeerRequest
         * @instance
         */
        DisconnectPeerRequest.prototype.pubKey = "";

        /**
         * Creates a new DisconnectPeerRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest=} [properties] Properties to set
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest instance
         */
        DisconnectPeerRequest.create = function create(properties) {
            return new DisconnectPeerRequest(properties);
        };

        /**
         * Encodes the specified DisconnectPeerRequest message. Does not implicitly {@link lnrpc.DisconnectPeerRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest} message DisconnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            return writer;
        };

        /**
         * Encodes the specified DisconnectPeerRequest message, length delimited. Does not implicitly {@link lnrpc.DisconnectPeerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.IDisconnectPeerRequest} message DisconnectPeerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisconnectPeerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DisconnectPeerRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisconnectPeerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisconnectPeerRequest message.
         * @function verify
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectPeerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            return null;
        };

        /**
         * Creates a DisconnectPeerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DisconnectPeerRequest} DisconnectPeerRequest
         */
        DisconnectPeerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DisconnectPeerRequest)
                return object;
            let message = new $root.lnrpc.DisconnectPeerRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            return message;
        };

        /**
         * Creates a plain object from a DisconnectPeerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DisconnectPeerRequest
         * @static
         * @param {lnrpc.DisconnectPeerRequest} message DisconnectPeerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectPeerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.pubKey = "";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            return object;
        };

        /**
         * Converts this DisconnectPeerRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DisconnectPeerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectPeerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisconnectPeerRequest;
    })();

    lnrpc.DisconnectPeerResponse = (function() {

        /**
         * Properties of a DisconnectPeerResponse.
         * @memberof lnrpc
         * @interface IDisconnectPeerResponse
         */

        /**
         * Constructs a new DisconnectPeerResponse.
         * @memberof lnrpc
         * @classdesc Represents a DisconnectPeerResponse.
         * @implements IDisconnectPeerResponse
         * @constructor
         * @param {lnrpc.IDisconnectPeerResponse=} [properties] Properties to set
         */
        function DisconnectPeerResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DisconnectPeerResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse=} [properties] Properties to set
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse instance
         */
        DisconnectPeerResponse.create = function create(properties) {
            return new DisconnectPeerResponse(properties);
        };

        /**
         * Encodes the specified DisconnectPeerResponse message. Does not implicitly {@link lnrpc.DisconnectPeerResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse} message DisconnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DisconnectPeerResponse message, length delimited. Does not implicitly {@link lnrpc.DisconnectPeerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.IDisconnectPeerResponse} message DisconnectPeerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisconnectPeerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisconnectPeerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DisconnectPeerResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisconnectPeerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisconnectPeerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisconnectPeerResponse message.
         * @function verify
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisconnectPeerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DisconnectPeerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DisconnectPeerResponse} DisconnectPeerResponse
         */
        DisconnectPeerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DisconnectPeerResponse)
                return object;
            return new $root.lnrpc.DisconnectPeerResponse();
        };

        /**
         * Creates a plain object from a DisconnectPeerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DisconnectPeerResponse
         * @static
         * @param {lnrpc.DisconnectPeerResponse} message DisconnectPeerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DisconnectPeerResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DisconnectPeerResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DisconnectPeerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DisconnectPeerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DisconnectPeerResponse;
    })();

    lnrpc.HTLC = (function() {

        /**
         * Properties of a HTLC.
         * @memberof lnrpc
         * @interface IHTLC
         * @property {boolean|null} [incoming] HTLC incoming
         * @property {number|Long|null} [amount] HTLC amount
         * @property {Uint8Array|null} [hashLock] HTLC hashLock
         * @property {number|null} [expirationHeight] HTLC expirationHeight
         */

        /**
         * Constructs a new HTLC.
         * @memberof lnrpc
         * @classdesc Represents a HTLC.
         * @implements IHTLC
         * @constructor
         * @param {lnrpc.IHTLC=} [properties] Properties to set
         */
        function HTLC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HTLC incoming.
         * @member {boolean} incoming
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.incoming = false;

        /**
         * HTLC amount.
         * @member {number|Long} amount
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * HTLC hashLock.
         * @member {Uint8Array} hashLock
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.hashLock = $util.newBuffer([]);

        /**
         * HTLC expirationHeight.
         * @member {number} expirationHeight
         * @memberof lnrpc.HTLC
         * @instance
         */
        HTLC.prototype.expirationHeight = 0;

        /**
         * Creates a new HTLC instance using the specified properties.
         * @function create
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC=} [properties] Properties to set
         * @returns {lnrpc.HTLC} HTLC instance
         */
        HTLC.create = function create(properties) {
            return new HTLC(properties);
        };

        /**
         * Encodes the specified HTLC message. Does not implicitly {@link lnrpc.HTLC.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC} message HTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTLC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.incoming);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.hashLock != null && message.hasOwnProperty("hashLock"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.hashLock);
            if (message.expirationHeight != null && message.hasOwnProperty("expirationHeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.expirationHeight);
            return writer;
        };

        /**
         * Encodes the specified HTLC message, length delimited. Does not implicitly {@link lnrpc.HTLC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.IHTLC} message HTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HTLC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HTLC message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.HTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.HTLC} HTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTLC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.HTLC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incoming = reader.bool();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.hashLock = reader.bytes();
                    break;
                case 4:
                    message.expirationHeight = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HTLC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.HTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.HTLC} HTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HTLC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HTLC message.
         * @function verify
         * @memberof lnrpc.HTLC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HTLC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                if (typeof message.incoming !== "boolean")
                    return "incoming: boolean expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.hashLock != null && message.hasOwnProperty("hashLock"))
                if (!(message.hashLock && typeof message.hashLock.length === "number" || $util.isString(message.hashLock)))
                    return "hashLock: buffer expected";
            if (message.expirationHeight != null && message.hasOwnProperty("expirationHeight"))
                if (!$util.isInteger(message.expirationHeight))
                    return "expirationHeight: integer expected";
            return null;
        };

        /**
         * Creates a HTLC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.HTLC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.HTLC} HTLC
         */
        HTLC.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.HTLC)
                return object;
            let message = new $root.lnrpc.HTLC();
            if (object.incoming != null)
                message.incoming = Boolean(object.incoming);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.hashLock != null)
                if (typeof object.hashLock === "string")
                    $util.base64.decode(object.hashLock, message.hashLock = $util.newBuffer($util.base64.length(object.hashLock)), 0);
                else if (object.hashLock.length)
                    message.hashLock = object.hashLock;
            if (object.expirationHeight != null)
                message.expirationHeight = object.expirationHeight >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HTLC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.HTLC
         * @static
         * @param {lnrpc.HTLC} message HTLC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HTLC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.incoming = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.hashLock = "";
                else {
                    object.hashLock = [];
                    if (options.bytes !== Array)
                        object.hashLock = $util.newBuffer(object.hashLock);
                }
                object.expirationHeight = 0;
            }
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                object.incoming = message.incoming;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.hashLock != null && message.hasOwnProperty("hashLock"))
                object.hashLock = options.bytes === String ? $util.base64.encode(message.hashLock, 0, message.hashLock.length) : options.bytes === Array ? Array.prototype.slice.call(message.hashLock) : message.hashLock;
            if (message.expirationHeight != null && message.hasOwnProperty("expirationHeight"))
                object.expirationHeight = message.expirationHeight;
            return object;
        };

        /**
         * Converts this HTLC to JSON.
         * @function toJSON
         * @memberof lnrpc.HTLC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HTLC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HTLC;
    })();

    lnrpc.Channel = (function() {

        /**
         * Properties of a Channel.
         * @memberof lnrpc
         * @interface IChannel
         * @property {boolean|null} [active] Whether this channel is active or not
         * @property {string|null} [remotePubkey] The identity pubkey of the remote node
         * @property {string|null} [channelPoint] The outpoint (txid:index) of the funding transaction. With this value, Bob
         * will be able to generate a signature for Alice's version of the commitment
         * transaction.
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {number|Long|null} [capacity] The total amount of funds held in this channel
         * @property {number|Long|null} [localBalance] This node's current balance in this channel
         * @property {number|Long|null} [remoteBalance] The counterparty's current balance in this channel
         * @property {number|Long|null} [commitFee] The amount calculated to be paid in fees for the current set of commitment
         * transactions. The fee amount is persisted with the channel in order to
         * allow the fee amount to be removed and recalculated with each channel state
         * update, including updates that happen after a system restart.
         * @property {number|Long|null} [commitWeight] The weight of the commitment transaction
         * @property {number|Long|null} [feePerKw] The required number of satoshis per kilo-weight that the requester will pay
         * at all times, for both the funding transaction and commitment transaction.
         * This value can later be updated once the channel is open.
         * @property {number|Long|null} [unsettledBalance] The unsettled balance in this channel
         * @property {number|Long|null} [totalSatoshisSent] The total number of satoshis we've sent within this channel.
         * @property {number|Long|null} [totalSatoshisReceived] The total number of satoshis we've received within this channel.
         * @property {number|Long|null} [numUpdates] The total number of updates conducted within this channel.
         * @property {Array.<lnrpc.IHTLC>|null} [pendingHtlcs] The list of active, uncleared HTLCs currently pending within the channel.
         * @property {number|null} [csvDelay] The CSV delay expressed in relative blocks. If the channel is force closed,
         * we will need to wait for this many blocks before we can regain our funds.
         * @property {boolean|null} ["private"] Whether this channel is advertised to the network or not.
         * @property {boolean|null} [initiator] True if we were the ones that created the channel.
         * @property {string|null} [chanStatusFlags] A set of flags showing the current state of the channel.
         * @property {number|Long|null} [localChanReserveSat] The minimum satoshis this node is required to reserve in its balance.
         * @property {number|Long|null} [remoteChanReserveSat] The minimum satoshis the other node is required to reserve in its balance.
         */

        /**
         * Constructs a new Channel.
         * @memberof lnrpc
         * @classdesc Represents a Channel.
         * @implements IChannel
         * @constructor
         * @param {lnrpc.IChannel=} [properties] Properties to set
         */
        function Channel(properties) {
            this.pendingHtlcs = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Whether this channel is active or not
         * @member {boolean} active
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.active = false;

        /**
         * The identity pubkey of the remote node
         * @member {string} remotePubkey
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remotePubkey = "";

        /**
         * The outpoint (txid:index) of the funding transaction. With this value, Bob
         * will be able to generate a signature for Alice's version of the commitment
         * transaction.
         * @member {string} channelPoint
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.channelPoint = "";

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount of funds held in this channel
         * @member {number|Long} capacity
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * This node's current balance in this channel
         * @member {number|Long} localBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.localBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The counterparty's current balance in this channel
         * @member {number|Long} remoteBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remoteBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The amount calculated to be paid in fees for the current set of commitment
         * transactions. The fee amount is persisted with the channel in order to
         * allow the fee amount to be removed and recalculated with each channel state
         * update, including updates that happen after a system restart.
         * @member {number|Long} commitFee
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.commitFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The weight of the commitment transaction
         * @member {number|Long} commitWeight
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.commitWeight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The required number of satoshis per kilo-weight that the requester will pay
         * at all times, for both the funding transaction and commitment transaction.
         * This value can later be updated once the channel is open.
         * @member {number|Long} feePerKw
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.feePerKw = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The unsettled balance in this channel
         * @member {number|Long} unsettledBalance
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.unsettledBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total number of satoshis we've sent within this channel.
         * @member {number|Long} totalSatoshisSent
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.totalSatoshisSent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total number of satoshis we've received within this channel.
         * @member {number|Long} totalSatoshisReceived
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.totalSatoshisReceived = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total number of updates conducted within this channel.
         * @member {number|Long} numUpdates
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.numUpdates = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The list of active, uncleared HTLCs currently pending within the channel.
         * @member {Array.<lnrpc.IHTLC>} pendingHtlcs
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.pendingHtlcs = $util.emptyArray;

        /**
         * The CSV delay expressed in relative blocks. If the channel is force closed,
         * we will need to wait for this many blocks before we can regain our funds.
         * @member {number} csvDelay
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.csvDelay = 0;

        /**
         * Whether this channel is advertised to the network or not.
         * @member {boolean} private
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype["private"] = false;

        /**
         * True if we were the ones that created the channel.
         * @member {boolean} initiator
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.initiator = false;

        /**
         * A set of flags showing the current state of the channel.
         * @member {string} chanStatusFlags
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.chanStatusFlags = "";

        /**
         * The minimum satoshis this node is required to reserve in its balance.
         * @member {number|Long} localChanReserveSat
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.localChanReserveSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The minimum satoshis the other node is required to reserve in its balance.
         * @member {number|Long} remoteChanReserveSat
         * @memberof lnrpc.Channel
         * @instance
         */
        Channel.prototype.remoteChanReserveSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Channel instance using the specified properties.
         * @function create
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel=} [properties] Properties to set
         * @returns {lnrpc.Channel} Channel instance
         */
        Channel.create = function create(properties) {
            return new Channel(properties);
        };

        /**
         * Encodes the specified Channel message. Does not implicitly {@link lnrpc.Channel.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel} message Channel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Channel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.active);
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.remotePubkey);
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.channelPoint);
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.chanId);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.capacity);
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.localBalance);
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.remoteBalance);
            if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.commitFee);
            if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.commitWeight);
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.feePerKw);
            if (message.unsettledBalance != null && message.hasOwnProperty("unsettledBalance"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.unsettledBalance);
            if (message.totalSatoshisSent != null && message.hasOwnProperty("totalSatoshisSent"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.totalSatoshisSent);
            if (message.totalSatoshisReceived != null && message.hasOwnProperty("totalSatoshisReceived"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.totalSatoshisReceived);
            if (message.numUpdates != null && message.hasOwnProperty("numUpdates"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint64(message.numUpdates);
            if (message.pendingHtlcs != null && message.pendingHtlcs.length)
                for (let i = 0; i < message.pendingHtlcs.length; ++i)
                    $root.lnrpc.HTLC.encode(message.pendingHtlcs[i], writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.csvDelay);
            if (message["private"] != null && message.hasOwnProperty("private"))
                writer.uint32(/* id 17, wireType 0 =*/136).bool(message["private"]);
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                writer.uint32(/* id 18, wireType 0 =*/144).bool(message.initiator);
            if (message.chanStatusFlags != null && message.hasOwnProperty("chanStatusFlags"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.chanStatusFlags);
            if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.localChanReserveSat);
            if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                writer.uint32(/* id 21, wireType 0 =*/168).int64(message.remoteChanReserveSat);
            return writer;
        };

        /**
         * Encodes the specified Channel message, length delimited. Does not implicitly {@link lnrpc.Channel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.IChannel} message Channel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Channel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Channel message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Channel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Channel} Channel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Channel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Channel();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.active = reader.bool();
                    break;
                case 2:
                    message.remotePubkey = reader.string();
                    break;
                case 3:
                    message.channelPoint = reader.string();
                    break;
                case 4:
                    message.chanId = reader.uint64();
                    break;
                case 5:
                    message.capacity = reader.int64();
                    break;
                case 6:
                    message.localBalance = reader.int64();
                    break;
                case 7:
                    message.remoteBalance = reader.int64();
                    break;
                case 8:
                    message.commitFee = reader.int64();
                    break;
                case 9:
                    message.commitWeight = reader.int64();
                    break;
                case 10:
                    message.feePerKw = reader.int64();
                    break;
                case 11:
                    message.unsettledBalance = reader.int64();
                    break;
                case 12:
                    message.totalSatoshisSent = reader.int64();
                    break;
                case 13:
                    message.totalSatoshisReceived = reader.int64();
                    break;
                case 14:
                    message.numUpdates = reader.uint64();
                    break;
                case 15:
                    if (!(message.pendingHtlcs && message.pendingHtlcs.length))
                        message.pendingHtlcs = [];
                    message.pendingHtlcs.push($root.lnrpc.HTLC.decode(reader, reader.uint32()));
                    break;
                case 16:
                    message.csvDelay = reader.uint32();
                    break;
                case 17:
                    message["private"] = reader.bool();
                    break;
                case 18:
                    message.initiator = reader.bool();
                    break;
                case 19:
                    message.chanStatusFlags = reader.string();
                    break;
                case 20:
                    message.localChanReserveSat = reader.int64();
                    break;
                case 21:
                    message.remoteChanReserveSat = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Channel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Channel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Channel} Channel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Channel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Channel message.
         * @function verify
         * @memberof lnrpc.Channel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Channel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                if (!$util.isString(message.remotePubkey))
                    return "remotePubkey: string expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                if (!$util.isString(message.channelPoint))
                    return "channelPoint: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                if (!$util.isInteger(message.localBalance) && !(message.localBalance && $util.isInteger(message.localBalance.low) && $util.isInteger(message.localBalance.high)))
                    return "localBalance: integer|Long expected";
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                if (!$util.isInteger(message.remoteBalance) && !(message.remoteBalance && $util.isInteger(message.remoteBalance.low) && $util.isInteger(message.remoteBalance.high)))
                    return "remoteBalance: integer|Long expected";
            if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                if (!$util.isInteger(message.commitFee) && !(message.commitFee && $util.isInteger(message.commitFee.low) && $util.isInteger(message.commitFee.high)))
                    return "commitFee: integer|Long expected";
            if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                if (!$util.isInteger(message.commitWeight) && !(message.commitWeight && $util.isInteger(message.commitWeight.low) && $util.isInteger(message.commitWeight.high)))
                    return "commitWeight: integer|Long expected";
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                if (!$util.isInteger(message.feePerKw) && !(message.feePerKw && $util.isInteger(message.feePerKw.low) && $util.isInteger(message.feePerKw.high)))
                    return "feePerKw: integer|Long expected";
            if (message.unsettledBalance != null && message.hasOwnProperty("unsettledBalance"))
                if (!$util.isInteger(message.unsettledBalance) && !(message.unsettledBalance && $util.isInteger(message.unsettledBalance.low) && $util.isInteger(message.unsettledBalance.high)))
                    return "unsettledBalance: integer|Long expected";
            if (message.totalSatoshisSent != null && message.hasOwnProperty("totalSatoshisSent"))
                if (!$util.isInteger(message.totalSatoshisSent) && !(message.totalSatoshisSent && $util.isInteger(message.totalSatoshisSent.low) && $util.isInteger(message.totalSatoshisSent.high)))
                    return "totalSatoshisSent: integer|Long expected";
            if (message.totalSatoshisReceived != null && message.hasOwnProperty("totalSatoshisReceived"))
                if (!$util.isInteger(message.totalSatoshisReceived) && !(message.totalSatoshisReceived && $util.isInteger(message.totalSatoshisReceived.low) && $util.isInteger(message.totalSatoshisReceived.high)))
                    return "totalSatoshisReceived: integer|Long expected";
            if (message.numUpdates != null && message.hasOwnProperty("numUpdates"))
                if (!$util.isInteger(message.numUpdates) && !(message.numUpdates && $util.isInteger(message.numUpdates.low) && $util.isInteger(message.numUpdates.high)))
                    return "numUpdates: integer|Long expected";
            if (message.pendingHtlcs != null && message.hasOwnProperty("pendingHtlcs")) {
                if (!Array.isArray(message.pendingHtlcs))
                    return "pendingHtlcs: array expected";
                for (let i = 0; i < message.pendingHtlcs.length; ++i) {
                    let error = $root.lnrpc.HTLC.verify(message.pendingHtlcs[i]);
                    if (error)
                        return "pendingHtlcs." + error;
                }
            }
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                if (!$util.isInteger(message.csvDelay))
                    return "csvDelay: integer expected";
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                if (typeof message.initiator !== "boolean")
                    return "initiator: boolean expected";
            if (message.chanStatusFlags != null && message.hasOwnProperty("chanStatusFlags"))
                if (!$util.isString(message.chanStatusFlags))
                    return "chanStatusFlags: string expected";
            if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                if (!$util.isInteger(message.localChanReserveSat) && !(message.localChanReserveSat && $util.isInteger(message.localChanReserveSat.low) && $util.isInteger(message.localChanReserveSat.high)))
                    return "localChanReserveSat: integer|Long expected";
            if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                if (!$util.isInteger(message.remoteChanReserveSat) && !(message.remoteChanReserveSat && $util.isInteger(message.remoteChanReserveSat.low) && $util.isInteger(message.remoteChanReserveSat.high)))
                    return "remoteChanReserveSat: integer|Long expected";
            return null;
        };

        /**
         * Creates a Channel message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Channel
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Channel} Channel
         */
        Channel.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Channel)
                return object;
            let message = new $root.lnrpc.Channel();
            if (object.active != null)
                message.active = Boolean(object.active);
            if (object.remotePubkey != null)
                message.remotePubkey = String(object.remotePubkey);
            if (object.channelPoint != null)
                message.channelPoint = String(object.channelPoint);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.localBalance != null)
                if ($util.Long)
                    (message.localBalance = $util.Long.fromValue(object.localBalance)).unsigned = false;
                else if (typeof object.localBalance === "string")
                    message.localBalance = parseInt(object.localBalance, 10);
                else if (typeof object.localBalance === "number")
                    message.localBalance = object.localBalance;
                else if (typeof object.localBalance === "object")
                    message.localBalance = new $util.LongBits(object.localBalance.low >>> 0, object.localBalance.high >>> 0).toNumber();
            if (object.remoteBalance != null)
                if ($util.Long)
                    (message.remoteBalance = $util.Long.fromValue(object.remoteBalance)).unsigned = false;
                else if (typeof object.remoteBalance === "string")
                    message.remoteBalance = parseInt(object.remoteBalance, 10);
                else if (typeof object.remoteBalance === "number")
                    message.remoteBalance = object.remoteBalance;
                else if (typeof object.remoteBalance === "object")
                    message.remoteBalance = new $util.LongBits(object.remoteBalance.low >>> 0, object.remoteBalance.high >>> 0).toNumber();
            if (object.commitFee != null)
                if ($util.Long)
                    (message.commitFee = $util.Long.fromValue(object.commitFee)).unsigned = false;
                else if (typeof object.commitFee === "string")
                    message.commitFee = parseInt(object.commitFee, 10);
                else if (typeof object.commitFee === "number")
                    message.commitFee = object.commitFee;
                else if (typeof object.commitFee === "object")
                    message.commitFee = new $util.LongBits(object.commitFee.low >>> 0, object.commitFee.high >>> 0).toNumber();
            if (object.commitWeight != null)
                if ($util.Long)
                    (message.commitWeight = $util.Long.fromValue(object.commitWeight)).unsigned = false;
                else if (typeof object.commitWeight === "string")
                    message.commitWeight = parseInt(object.commitWeight, 10);
                else if (typeof object.commitWeight === "number")
                    message.commitWeight = object.commitWeight;
                else if (typeof object.commitWeight === "object")
                    message.commitWeight = new $util.LongBits(object.commitWeight.low >>> 0, object.commitWeight.high >>> 0).toNumber();
            if (object.feePerKw != null)
                if ($util.Long)
                    (message.feePerKw = $util.Long.fromValue(object.feePerKw)).unsigned = false;
                else if (typeof object.feePerKw === "string")
                    message.feePerKw = parseInt(object.feePerKw, 10);
                else if (typeof object.feePerKw === "number")
                    message.feePerKw = object.feePerKw;
                else if (typeof object.feePerKw === "object")
                    message.feePerKw = new $util.LongBits(object.feePerKw.low >>> 0, object.feePerKw.high >>> 0).toNumber();
            if (object.unsettledBalance != null)
                if ($util.Long)
                    (message.unsettledBalance = $util.Long.fromValue(object.unsettledBalance)).unsigned = false;
                else if (typeof object.unsettledBalance === "string")
                    message.unsettledBalance = parseInt(object.unsettledBalance, 10);
                else if (typeof object.unsettledBalance === "number")
                    message.unsettledBalance = object.unsettledBalance;
                else if (typeof object.unsettledBalance === "object")
                    message.unsettledBalance = new $util.LongBits(object.unsettledBalance.low >>> 0, object.unsettledBalance.high >>> 0).toNumber();
            if (object.totalSatoshisSent != null)
                if ($util.Long)
                    (message.totalSatoshisSent = $util.Long.fromValue(object.totalSatoshisSent)).unsigned = false;
                else if (typeof object.totalSatoshisSent === "string")
                    message.totalSatoshisSent = parseInt(object.totalSatoshisSent, 10);
                else if (typeof object.totalSatoshisSent === "number")
                    message.totalSatoshisSent = object.totalSatoshisSent;
                else if (typeof object.totalSatoshisSent === "object")
                    message.totalSatoshisSent = new $util.LongBits(object.totalSatoshisSent.low >>> 0, object.totalSatoshisSent.high >>> 0).toNumber();
            if (object.totalSatoshisReceived != null)
                if ($util.Long)
                    (message.totalSatoshisReceived = $util.Long.fromValue(object.totalSatoshisReceived)).unsigned = false;
                else if (typeof object.totalSatoshisReceived === "string")
                    message.totalSatoshisReceived = parseInt(object.totalSatoshisReceived, 10);
                else if (typeof object.totalSatoshisReceived === "number")
                    message.totalSatoshisReceived = object.totalSatoshisReceived;
                else if (typeof object.totalSatoshisReceived === "object")
                    message.totalSatoshisReceived = new $util.LongBits(object.totalSatoshisReceived.low >>> 0, object.totalSatoshisReceived.high >>> 0).toNumber();
            if (object.numUpdates != null)
                if ($util.Long)
                    (message.numUpdates = $util.Long.fromValue(object.numUpdates)).unsigned = true;
                else if (typeof object.numUpdates === "string")
                    message.numUpdates = parseInt(object.numUpdates, 10);
                else if (typeof object.numUpdates === "number")
                    message.numUpdates = object.numUpdates;
                else if (typeof object.numUpdates === "object")
                    message.numUpdates = new $util.LongBits(object.numUpdates.low >>> 0, object.numUpdates.high >>> 0).toNumber(true);
            if (object.pendingHtlcs) {
                if (!Array.isArray(object.pendingHtlcs))
                    throw TypeError(".lnrpc.Channel.pendingHtlcs: array expected");
                message.pendingHtlcs = [];
                for (let i = 0; i < object.pendingHtlcs.length; ++i) {
                    if (typeof object.pendingHtlcs[i] !== "object")
                        throw TypeError(".lnrpc.Channel.pendingHtlcs: object expected");
                    message.pendingHtlcs[i] = $root.lnrpc.HTLC.fromObject(object.pendingHtlcs[i]);
                }
            }
            if (object.csvDelay != null)
                message.csvDelay = object.csvDelay >>> 0;
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            if (object.initiator != null)
                message.initiator = Boolean(object.initiator);
            if (object.chanStatusFlags != null)
                message.chanStatusFlags = String(object.chanStatusFlags);
            if (object.localChanReserveSat != null)
                if ($util.Long)
                    (message.localChanReserveSat = $util.Long.fromValue(object.localChanReserveSat)).unsigned = false;
                else if (typeof object.localChanReserveSat === "string")
                    message.localChanReserveSat = parseInt(object.localChanReserveSat, 10);
                else if (typeof object.localChanReserveSat === "number")
                    message.localChanReserveSat = object.localChanReserveSat;
                else if (typeof object.localChanReserveSat === "object")
                    message.localChanReserveSat = new $util.LongBits(object.localChanReserveSat.low >>> 0, object.localChanReserveSat.high >>> 0).toNumber();
            if (object.remoteChanReserveSat != null)
                if ($util.Long)
                    (message.remoteChanReserveSat = $util.Long.fromValue(object.remoteChanReserveSat)).unsigned = false;
                else if (typeof object.remoteChanReserveSat === "string")
                    message.remoteChanReserveSat = parseInt(object.remoteChanReserveSat, 10);
                else if (typeof object.remoteChanReserveSat === "number")
                    message.remoteChanReserveSat = object.remoteChanReserveSat;
                else if (typeof object.remoteChanReserveSat === "object")
                    message.remoteChanReserveSat = new $util.LongBits(object.remoteChanReserveSat.low >>> 0, object.remoteChanReserveSat.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Channel message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Channel
         * @static
         * @param {lnrpc.Channel} message Channel
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Channel.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.pendingHtlcs = [];
            if (options.defaults) {
                object.active = false;
                object.remotePubkey = "";
                object.channelPoint = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.localBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.localBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.remoteBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.remoteBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.commitFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commitFee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.commitWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.commitWeight = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feePerKw = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feePerKw = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.unsettledBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unsettledBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalSatoshisSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalSatoshisSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalSatoshisReceived = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalSatoshisReceived = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.numUpdates = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numUpdates = options.longs === String ? "0" : 0;
                object.csvDelay = 0;
                object["private"] = false;
                object.initiator = false;
                object.chanStatusFlags = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.localChanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.localChanReserveSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.remoteChanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.remoteChanReserveSat = options.longs === String ? "0" : 0;
            }
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                object.remotePubkey = message.remotePubkey;
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = message.channelPoint;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                if (typeof message.localBalance === "number")
                    object.localBalance = options.longs === String ? String(message.localBalance) : message.localBalance;
                else
                    object.localBalance = options.longs === String ? $util.Long.prototype.toString.call(message.localBalance) : options.longs === Number ? new $util.LongBits(message.localBalance.low >>> 0, message.localBalance.high >>> 0).toNumber() : message.localBalance;
            if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                if (typeof message.remoteBalance === "number")
                    object.remoteBalance = options.longs === String ? String(message.remoteBalance) : message.remoteBalance;
                else
                    object.remoteBalance = options.longs === String ? $util.Long.prototype.toString.call(message.remoteBalance) : options.longs === Number ? new $util.LongBits(message.remoteBalance.low >>> 0, message.remoteBalance.high >>> 0).toNumber() : message.remoteBalance;
            if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                if (typeof message.commitFee === "number")
                    object.commitFee = options.longs === String ? String(message.commitFee) : message.commitFee;
                else
                    object.commitFee = options.longs === String ? $util.Long.prototype.toString.call(message.commitFee) : options.longs === Number ? new $util.LongBits(message.commitFee.low >>> 0, message.commitFee.high >>> 0).toNumber() : message.commitFee;
            if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                if (typeof message.commitWeight === "number")
                    object.commitWeight = options.longs === String ? String(message.commitWeight) : message.commitWeight;
                else
                    object.commitWeight = options.longs === String ? $util.Long.prototype.toString.call(message.commitWeight) : options.longs === Number ? new $util.LongBits(message.commitWeight.low >>> 0, message.commitWeight.high >>> 0).toNumber() : message.commitWeight;
            if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                if (typeof message.feePerKw === "number")
                    object.feePerKw = options.longs === String ? String(message.feePerKw) : message.feePerKw;
                else
                    object.feePerKw = options.longs === String ? $util.Long.prototype.toString.call(message.feePerKw) : options.longs === Number ? new $util.LongBits(message.feePerKw.low >>> 0, message.feePerKw.high >>> 0).toNumber() : message.feePerKw;
            if (message.unsettledBalance != null && message.hasOwnProperty("unsettledBalance"))
                if (typeof message.unsettledBalance === "number")
                    object.unsettledBalance = options.longs === String ? String(message.unsettledBalance) : message.unsettledBalance;
                else
                    object.unsettledBalance = options.longs === String ? $util.Long.prototype.toString.call(message.unsettledBalance) : options.longs === Number ? new $util.LongBits(message.unsettledBalance.low >>> 0, message.unsettledBalance.high >>> 0).toNumber() : message.unsettledBalance;
            if (message.totalSatoshisSent != null && message.hasOwnProperty("totalSatoshisSent"))
                if (typeof message.totalSatoshisSent === "number")
                    object.totalSatoshisSent = options.longs === String ? String(message.totalSatoshisSent) : message.totalSatoshisSent;
                else
                    object.totalSatoshisSent = options.longs === String ? $util.Long.prototype.toString.call(message.totalSatoshisSent) : options.longs === Number ? new $util.LongBits(message.totalSatoshisSent.low >>> 0, message.totalSatoshisSent.high >>> 0).toNumber() : message.totalSatoshisSent;
            if (message.totalSatoshisReceived != null && message.hasOwnProperty("totalSatoshisReceived"))
                if (typeof message.totalSatoshisReceived === "number")
                    object.totalSatoshisReceived = options.longs === String ? String(message.totalSatoshisReceived) : message.totalSatoshisReceived;
                else
                    object.totalSatoshisReceived = options.longs === String ? $util.Long.prototype.toString.call(message.totalSatoshisReceived) : options.longs === Number ? new $util.LongBits(message.totalSatoshisReceived.low >>> 0, message.totalSatoshisReceived.high >>> 0).toNumber() : message.totalSatoshisReceived;
            if (message.numUpdates != null && message.hasOwnProperty("numUpdates"))
                if (typeof message.numUpdates === "number")
                    object.numUpdates = options.longs === String ? String(message.numUpdates) : message.numUpdates;
                else
                    object.numUpdates = options.longs === String ? $util.Long.prototype.toString.call(message.numUpdates) : options.longs === Number ? new $util.LongBits(message.numUpdates.low >>> 0, message.numUpdates.high >>> 0).toNumber(true) : message.numUpdates;
            if (message.pendingHtlcs && message.pendingHtlcs.length) {
                object.pendingHtlcs = [];
                for (let j = 0; j < message.pendingHtlcs.length; ++j)
                    object.pendingHtlcs[j] = $root.lnrpc.HTLC.toObject(message.pendingHtlcs[j], options);
            }
            if (message.csvDelay != null && message.hasOwnProperty("csvDelay"))
                object.csvDelay = message.csvDelay;
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                object.initiator = message.initiator;
            if (message.chanStatusFlags != null && message.hasOwnProperty("chanStatusFlags"))
                object.chanStatusFlags = message.chanStatusFlags;
            if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                if (typeof message.localChanReserveSat === "number")
                    object.localChanReserveSat = options.longs === String ? String(message.localChanReserveSat) : message.localChanReserveSat;
                else
                    object.localChanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.localChanReserveSat) : options.longs === Number ? new $util.LongBits(message.localChanReserveSat.low >>> 0, message.localChanReserveSat.high >>> 0).toNumber() : message.localChanReserveSat;
            if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                if (typeof message.remoteChanReserveSat === "number")
                    object.remoteChanReserveSat = options.longs === String ? String(message.remoteChanReserveSat) : message.remoteChanReserveSat;
                else
                    object.remoteChanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.remoteChanReserveSat) : options.longs === Number ? new $util.LongBits(message.remoteChanReserveSat.low >>> 0, message.remoteChanReserveSat.high >>> 0).toNumber() : message.remoteChanReserveSat;
            return object;
        };

        /**
         * Converts this Channel to JSON.
         * @function toJSON
         * @memberof lnrpc.Channel
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Channel.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Channel;
    })();

    lnrpc.ListChannelsRequest = (function() {

        /**
         * Properties of a ListChannelsRequest.
         * @memberof lnrpc
         * @interface IListChannelsRequest
         * @property {boolean|null} [activeOnly] ListChannelsRequest activeOnly
         * @property {boolean|null} [inactiveOnly] ListChannelsRequest inactiveOnly
         * @property {boolean|null} [publicOnly] ListChannelsRequest publicOnly
         * @property {boolean|null} [privateOnly] ListChannelsRequest privateOnly
         */

        /**
         * Constructs a new ListChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListChannelsRequest.
         * @implements IListChannelsRequest
         * @constructor
         * @param {lnrpc.IListChannelsRequest=} [properties] Properties to set
         */
        function ListChannelsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ListChannelsRequest activeOnly.
         * @member {boolean} activeOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.activeOnly = false;

        /**
         * ListChannelsRequest inactiveOnly.
         * @member {boolean} inactiveOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.inactiveOnly = false;

        /**
         * ListChannelsRequest publicOnly.
         * @member {boolean} publicOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.publicOnly = false;

        /**
         * ListChannelsRequest privateOnly.
         * @member {boolean} privateOnly
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         */
        ListChannelsRequest.prototype.privateOnly = false;

        /**
         * Creates a new ListChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest instance
         */
        ListChannelsRequest.create = function create(properties) {
            return new ListChannelsRequest(properties);
        };

        /**
         * Encodes the specified ListChannelsRequest message. Does not implicitly {@link lnrpc.ListChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest} message ListChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.activeOnly != null && message.hasOwnProperty("activeOnly"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.activeOnly);
            if (message.inactiveOnly != null && message.hasOwnProperty("inactiveOnly"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.inactiveOnly);
            if (message.publicOnly != null && message.hasOwnProperty("publicOnly"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.publicOnly);
            if (message.privateOnly != null && message.hasOwnProperty("privateOnly"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.privateOnly);
            return writer;
        };

        /**
         * Encodes the specified ListChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.ListChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.IListChannelsRequest} message ListChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListChannelsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.activeOnly = reader.bool();
                    break;
                case 2:
                    message.inactiveOnly = reader.bool();
                    break;
                case 3:
                    message.publicOnly = reader.bool();
                    break;
                case 4:
                    message.privateOnly = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListChannelsRequest message.
         * @function verify
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.activeOnly != null && message.hasOwnProperty("activeOnly"))
                if (typeof message.activeOnly !== "boolean")
                    return "activeOnly: boolean expected";
            if (message.inactiveOnly != null && message.hasOwnProperty("inactiveOnly"))
                if (typeof message.inactiveOnly !== "boolean")
                    return "inactiveOnly: boolean expected";
            if (message.publicOnly != null && message.hasOwnProperty("publicOnly"))
                if (typeof message.publicOnly !== "boolean")
                    return "publicOnly: boolean expected";
            if (message.privateOnly != null && message.hasOwnProperty("privateOnly"))
                if (typeof message.privateOnly !== "boolean")
                    return "privateOnly: boolean expected";
            return null;
        };

        /**
         * Creates a ListChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListChannelsRequest} ListChannelsRequest
         */
        ListChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListChannelsRequest)
                return object;
            let message = new $root.lnrpc.ListChannelsRequest();
            if (object.activeOnly != null)
                message.activeOnly = Boolean(object.activeOnly);
            if (object.inactiveOnly != null)
                message.inactiveOnly = Boolean(object.inactiveOnly);
            if (object.publicOnly != null)
                message.publicOnly = Boolean(object.publicOnly);
            if (object.privateOnly != null)
                message.privateOnly = Boolean(object.privateOnly);
            return message;
        };

        /**
         * Creates a plain object from a ListChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListChannelsRequest
         * @static
         * @param {lnrpc.ListChannelsRequest} message ListChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListChannelsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.activeOnly = false;
                object.inactiveOnly = false;
                object.publicOnly = false;
                object.privateOnly = false;
            }
            if (message.activeOnly != null && message.hasOwnProperty("activeOnly"))
                object.activeOnly = message.activeOnly;
            if (message.inactiveOnly != null && message.hasOwnProperty("inactiveOnly"))
                object.inactiveOnly = message.inactiveOnly;
            if (message.publicOnly != null && message.hasOwnProperty("publicOnly"))
                object.publicOnly = message.publicOnly;
            if (message.privateOnly != null && message.hasOwnProperty("privateOnly"))
                object.privateOnly = message.privateOnly;
            return object;
        };

        /**
         * Converts this ListChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListChannelsRequest;
    })();

    lnrpc.ListChannelsResponse = (function() {

        /**
         * Properties of a ListChannelsResponse.
         * @memberof lnrpc
         * @interface IListChannelsResponse
         * @property {Array.<lnrpc.IChannel>|null} [channels] The list of active channels
         */

        /**
         * Constructs a new ListChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListChannelsResponse.
         * @implements IListChannelsResponse
         * @constructor
         * @param {lnrpc.IListChannelsResponse=} [properties] Properties to set
         */
        function ListChannelsResponse(properties) {
            this.channels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of active channels
         * @member {Array.<lnrpc.IChannel>} channels
         * @memberof lnrpc.ListChannelsResponse
         * @instance
         */
        ListChannelsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ListChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse instance
         */
        ListChannelsResponse.create = function create(properties) {
            return new ListChannelsResponse(properties);
        };

        /**
         * Encodes the specified ListChannelsResponse message. Does not implicitly {@link lnrpc.ListChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse} message ListChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (let i = 0; i < message.channels.length; ++i)
                    $root.lnrpc.Channel.encode(message.channels[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.ListChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.IListChannelsResponse} message ListChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListChannelsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 11:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.lnrpc.Channel.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListChannelsResponse message.
         * @function verify
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (let i = 0; i < message.channels.length; ++i) {
                    let error = $root.lnrpc.Channel.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListChannelsResponse} ListChannelsResponse
         */
        ListChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListChannelsResponse)
                return object;
            let message = new $root.lnrpc.ListChannelsResponse();
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".lnrpc.ListChannelsResponse.channels: array expected");
                message.channels = [];
                for (let i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".lnrpc.ListChannelsResponse.channels: object expected");
                    message.channels[i] = $root.lnrpc.Channel.fromObject(object.channels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListChannelsResponse
         * @static
         * @param {lnrpc.ListChannelsResponse} message ListChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.channels = [];
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (let j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.lnrpc.Channel.toObject(message.channels[j], options);
            }
            return object;
        };

        /**
         * Converts this ListChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListChannelsResponse;
    })();

    lnrpc.ChannelCloseSummary = (function() {

        /**
         * Properties of a ChannelCloseSummary.
         * @memberof lnrpc
         * @interface IChannelCloseSummary
         * @property {string|null} [channelPoint] The outpoint (txid:index) of the funding transaction.
         * @property {number|Long|null} [chanId] The unique channel ID for the channel.
         * @property {string|null} [chainHash] The hash of the genesis block that this channel resides within.
         * @property {string|null} [closingTxHash] The txid of the transaction which ultimately closed this channel.
         * @property {string|null} [remotePubkey] Public key of the remote peer that we formerly had a channel with.
         * @property {number|Long|null} [capacity] Total capacity of the channel.
         * @property {number|null} [closeHeight] Height at which the funding transaction was spent.
         * @property {number|Long|null} [settledBalance] Settled balance at the time of channel closure
         * @property {number|Long|null} [timeLockedBalance] The sum of all the time-locked outputs at the time of channel closure
         * @property {lnrpc.ChannelCloseSummary.ClosureType|null} [closeType] Details on how the channel was closed.
         */

        /**
         * Constructs a new ChannelCloseSummary.
         * @memberof lnrpc
         * @classdesc Represents a ChannelCloseSummary.
         * @implements IChannelCloseSummary
         * @constructor
         * @param {lnrpc.IChannelCloseSummary=} [properties] Properties to set
         */
        function ChannelCloseSummary(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The outpoint (txid:index) of the funding transaction.
         * @member {string} channelPoint
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.channelPoint = "";

        /**
         * The unique channel ID for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The hash of the genesis block that this channel resides within.
         * @member {string} chainHash
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.chainHash = "";

        /**
         * The txid of the transaction which ultimately closed this channel.
         * @member {string} closingTxHash
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closingTxHash = "";

        /**
         * Public key of the remote peer that we formerly had a channel with.
         * @member {string} remotePubkey
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.remotePubkey = "";

        /**
         * Total capacity of the channel.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Height at which the funding transaction was spent.
         * @member {number} closeHeight
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closeHeight = 0;

        /**
         * Settled balance at the time of channel closure
         * @member {number|Long} settledBalance
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.settledBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The sum of all the time-locked outputs at the time of channel closure
         * @member {number|Long} timeLockedBalance
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.timeLockedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Details on how the channel was closed.
         * @member {lnrpc.ChannelCloseSummary.ClosureType} closeType
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         */
        ChannelCloseSummary.prototype.closeType = 0;

        /**
         * Creates a new ChannelCloseSummary instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary=} [properties] Properties to set
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary instance
         */
        ChannelCloseSummary.create = function create(properties) {
            return new ChannelCloseSummary(properties);
        };

        /**
         * Encodes the specified ChannelCloseSummary message. Does not implicitly {@link lnrpc.ChannelCloseSummary.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary} message ChannelCloseSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseSummary.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.channelPoint);
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanId);
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.chainHash);
            if (message.closingTxHash != null && message.hasOwnProperty("closingTxHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.closingTxHash);
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.remotePubkey);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.capacity);
            if (message.closeHeight != null && message.hasOwnProperty("closeHeight"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.closeHeight);
            if (message.settledBalance != null && message.hasOwnProperty("settledBalance"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.settledBalance);
            if (message.timeLockedBalance != null && message.hasOwnProperty("timeLockedBalance"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.timeLockedBalance);
            if (message.closeType != null && message.hasOwnProperty("closeType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.closeType);
            return writer;
        };

        /**
         * Encodes the specified ChannelCloseSummary message, length delimited. Does not implicitly {@link lnrpc.ChannelCloseSummary.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.IChannelCloseSummary} message ChannelCloseSummary message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseSummary.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelCloseSummary message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseSummary.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelCloseSummary();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = reader.string();
                    break;
                case 2:
                    message.chanId = reader.uint64();
                    break;
                case 3:
                    message.chainHash = reader.string();
                    break;
                case 4:
                    message.closingTxHash = reader.string();
                    break;
                case 5:
                    message.remotePubkey = reader.string();
                    break;
                case 6:
                    message.capacity = reader.int64();
                    break;
                case 7:
                    message.closeHeight = reader.uint32();
                    break;
                case 8:
                    message.settledBalance = reader.int64();
                    break;
                case 9:
                    message.timeLockedBalance = reader.int64();
                    break;
                case 10:
                    message.closeType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelCloseSummary message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseSummary.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelCloseSummary message.
         * @function verify
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelCloseSummary.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                if (!$util.isString(message.channelPoint))
                    return "channelPoint: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                if (!$util.isString(message.chainHash))
                    return "chainHash: string expected";
            if (message.closingTxHash != null && message.hasOwnProperty("closingTxHash"))
                if (!$util.isString(message.closingTxHash))
                    return "closingTxHash: string expected";
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                if (!$util.isString(message.remotePubkey))
                    return "remotePubkey: string expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.closeHeight != null && message.hasOwnProperty("closeHeight"))
                if (!$util.isInteger(message.closeHeight))
                    return "closeHeight: integer expected";
            if (message.settledBalance != null && message.hasOwnProperty("settledBalance"))
                if (!$util.isInteger(message.settledBalance) && !(message.settledBalance && $util.isInteger(message.settledBalance.low) && $util.isInteger(message.settledBalance.high)))
                    return "settledBalance: integer|Long expected";
            if (message.timeLockedBalance != null && message.hasOwnProperty("timeLockedBalance"))
                if (!$util.isInteger(message.timeLockedBalance) && !(message.timeLockedBalance && $util.isInteger(message.timeLockedBalance.low) && $util.isInteger(message.timeLockedBalance.high)))
                    return "timeLockedBalance: integer|Long expected";
            if (message.closeType != null && message.hasOwnProperty("closeType"))
                switch (message.closeType) {
                default:
                    return "closeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            return null;
        };

        /**
         * Creates a ChannelCloseSummary message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelCloseSummary} ChannelCloseSummary
         */
        ChannelCloseSummary.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelCloseSummary)
                return object;
            let message = new $root.lnrpc.ChannelCloseSummary();
            if (object.channelPoint != null)
                message.channelPoint = String(object.channelPoint);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chainHash != null)
                message.chainHash = String(object.chainHash);
            if (object.closingTxHash != null)
                message.closingTxHash = String(object.closingTxHash);
            if (object.remotePubkey != null)
                message.remotePubkey = String(object.remotePubkey);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.closeHeight != null)
                message.closeHeight = object.closeHeight >>> 0;
            if (object.settledBalance != null)
                if ($util.Long)
                    (message.settledBalance = $util.Long.fromValue(object.settledBalance)).unsigned = false;
                else if (typeof object.settledBalance === "string")
                    message.settledBalance = parseInt(object.settledBalance, 10);
                else if (typeof object.settledBalance === "number")
                    message.settledBalance = object.settledBalance;
                else if (typeof object.settledBalance === "object")
                    message.settledBalance = new $util.LongBits(object.settledBalance.low >>> 0, object.settledBalance.high >>> 0).toNumber();
            if (object.timeLockedBalance != null)
                if ($util.Long)
                    (message.timeLockedBalance = $util.Long.fromValue(object.timeLockedBalance)).unsigned = false;
                else if (typeof object.timeLockedBalance === "string")
                    message.timeLockedBalance = parseInt(object.timeLockedBalance, 10);
                else if (typeof object.timeLockedBalance === "number")
                    message.timeLockedBalance = object.timeLockedBalance;
                else if (typeof object.timeLockedBalance === "object")
                    message.timeLockedBalance = new $util.LongBits(object.timeLockedBalance.low >>> 0, object.timeLockedBalance.high >>> 0).toNumber();
            switch (object.closeType) {
            case "COOPERATIVE_CLOSE":
            case 0:
                message.closeType = 0;
                break;
            case "LOCAL_FORCE_CLOSE":
            case 1:
                message.closeType = 1;
                break;
            case "REMOTE_FORCE_CLOSE":
            case 2:
                message.closeType = 2;
                break;
            case "BREACH_CLOSE":
            case 3:
                message.closeType = 3;
                break;
            case "FUNDING_CANCELED":
            case 4:
                message.closeType = 4;
                break;
            case "ABANDONED":
            case 5:
                message.closeType = 5;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelCloseSummary message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelCloseSummary
         * @static
         * @param {lnrpc.ChannelCloseSummary} message ChannelCloseSummary
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelCloseSummary.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.channelPoint = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.chainHash = "";
                object.closingTxHash = "";
                object.remotePubkey = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.closeHeight = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.settledBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settledBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timeLockedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timeLockedBalance = options.longs === String ? "0" : 0;
                object.closeType = options.enums === String ? "COOPERATIVE_CLOSE" : 0;
            }
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = message.channelPoint;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chainHash != null && message.hasOwnProperty("chainHash"))
                object.chainHash = message.chainHash;
            if (message.closingTxHash != null && message.hasOwnProperty("closingTxHash"))
                object.closingTxHash = message.closingTxHash;
            if (message.remotePubkey != null && message.hasOwnProperty("remotePubkey"))
                object.remotePubkey = message.remotePubkey;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.closeHeight != null && message.hasOwnProperty("closeHeight"))
                object.closeHeight = message.closeHeight;
            if (message.settledBalance != null && message.hasOwnProperty("settledBalance"))
                if (typeof message.settledBalance === "number")
                    object.settledBalance = options.longs === String ? String(message.settledBalance) : message.settledBalance;
                else
                    object.settledBalance = options.longs === String ? $util.Long.prototype.toString.call(message.settledBalance) : options.longs === Number ? new $util.LongBits(message.settledBalance.low >>> 0, message.settledBalance.high >>> 0).toNumber() : message.settledBalance;
            if (message.timeLockedBalance != null && message.hasOwnProperty("timeLockedBalance"))
                if (typeof message.timeLockedBalance === "number")
                    object.timeLockedBalance = options.longs === String ? String(message.timeLockedBalance) : message.timeLockedBalance;
                else
                    object.timeLockedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.timeLockedBalance) : options.longs === Number ? new $util.LongBits(message.timeLockedBalance.low >>> 0, message.timeLockedBalance.high >>> 0).toNumber() : message.timeLockedBalance;
            if (message.closeType != null && message.hasOwnProperty("closeType"))
                object.closeType = options.enums === String ? $root.lnrpc.ChannelCloseSummary.ClosureType[message.closeType] : message.closeType;
            return object;
        };

        /**
         * Converts this ChannelCloseSummary to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelCloseSummary
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelCloseSummary.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * ClosureType enum.
         * @name lnrpc.ChannelCloseSummary.ClosureType
         * @enum {string}
         * @property {number} COOPERATIVE_CLOSE=0 COOPERATIVE_CLOSE value
         * @property {number} LOCAL_FORCE_CLOSE=1 LOCAL_FORCE_CLOSE value
         * @property {number} REMOTE_FORCE_CLOSE=2 REMOTE_FORCE_CLOSE value
         * @property {number} BREACH_CLOSE=3 BREACH_CLOSE value
         * @property {number} FUNDING_CANCELED=4 FUNDING_CANCELED value
         * @property {number} ABANDONED=5 ABANDONED value
         */
        ChannelCloseSummary.ClosureType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COOPERATIVE_CLOSE"] = 0;
            values[valuesById[1] = "LOCAL_FORCE_CLOSE"] = 1;
            values[valuesById[2] = "REMOTE_FORCE_CLOSE"] = 2;
            values[valuesById[3] = "BREACH_CLOSE"] = 3;
            values[valuesById[4] = "FUNDING_CANCELED"] = 4;
            values[valuesById[5] = "ABANDONED"] = 5;
            return values;
        })();

        return ChannelCloseSummary;
    })();

    lnrpc.ClosedChannelsRequest = (function() {

        /**
         * Properties of a ClosedChannelsRequest.
         * @memberof lnrpc
         * @interface IClosedChannelsRequest
         * @property {boolean|null} [cooperative] ClosedChannelsRequest cooperative
         * @property {boolean|null} [localForce] ClosedChannelsRequest localForce
         * @property {boolean|null} [remoteForce] ClosedChannelsRequest remoteForce
         * @property {boolean|null} [breach] ClosedChannelsRequest breach
         * @property {boolean|null} [fundingCanceled] ClosedChannelsRequest fundingCanceled
         * @property {boolean|null} [abandoned] ClosedChannelsRequest abandoned
         */

        /**
         * Constructs a new ClosedChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelsRequest.
         * @implements IClosedChannelsRequest
         * @constructor
         * @param {lnrpc.IClosedChannelsRequest=} [properties] Properties to set
         */
        function ClosedChannelsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClosedChannelsRequest cooperative.
         * @member {boolean} cooperative
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.cooperative = false;

        /**
         * ClosedChannelsRequest localForce.
         * @member {boolean} localForce
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.localForce = false;

        /**
         * ClosedChannelsRequest remoteForce.
         * @member {boolean} remoteForce
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.remoteForce = false;

        /**
         * ClosedChannelsRequest breach.
         * @member {boolean} breach
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.breach = false;

        /**
         * ClosedChannelsRequest fundingCanceled.
         * @member {boolean} fundingCanceled
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.fundingCanceled = false;

        /**
         * ClosedChannelsRequest abandoned.
         * @member {boolean} abandoned
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         */
        ClosedChannelsRequest.prototype.abandoned = false;

        /**
         * Creates a new ClosedChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest instance
         */
        ClosedChannelsRequest.create = function create(properties) {
            return new ClosedChannelsRequest(properties);
        };

        /**
         * Encodes the specified ClosedChannelsRequest message. Does not implicitly {@link lnrpc.ClosedChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest} message ClosedChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cooperative != null && message.hasOwnProperty("cooperative"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.cooperative);
            if (message.localForce != null && message.hasOwnProperty("localForce"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.localForce);
            if (message.remoteForce != null && message.hasOwnProperty("remoteForce"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.remoteForce);
            if (message.breach != null && message.hasOwnProperty("breach"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.breach);
            if (message.fundingCanceled != null && message.hasOwnProperty("fundingCanceled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.fundingCanceled);
            if (message.abandoned != null && message.hasOwnProperty("abandoned"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.abandoned);
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.IClosedChannelsRequest} message ClosedChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cooperative = reader.bool();
                    break;
                case 2:
                    message.localForce = reader.bool();
                    break;
                case 3:
                    message.remoteForce = reader.bool();
                    break;
                case 4:
                    message.breach = reader.bool();
                    break;
                case 5:
                    message.fundingCanceled = reader.bool();
                    break;
                case 6:
                    message.abandoned = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelsRequest message.
         * @function verify
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cooperative != null && message.hasOwnProperty("cooperative"))
                if (typeof message.cooperative !== "boolean")
                    return "cooperative: boolean expected";
            if (message.localForce != null && message.hasOwnProperty("localForce"))
                if (typeof message.localForce !== "boolean")
                    return "localForce: boolean expected";
            if (message.remoteForce != null && message.hasOwnProperty("remoteForce"))
                if (typeof message.remoteForce !== "boolean")
                    return "remoteForce: boolean expected";
            if (message.breach != null && message.hasOwnProperty("breach"))
                if (typeof message.breach !== "boolean")
                    return "breach: boolean expected";
            if (message.fundingCanceled != null && message.hasOwnProperty("fundingCanceled"))
                if (typeof message.fundingCanceled !== "boolean")
                    return "fundingCanceled: boolean expected";
            if (message.abandoned != null && message.hasOwnProperty("abandoned"))
                if (typeof message.abandoned !== "boolean")
                    return "abandoned: boolean expected";
            return null;
        };

        /**
         * Creates a ClosedChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelsRequest} ClosedChannelsRequest
         */
        ClosedChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelsRequest)
                return object;
            let message = new $root.lnrpc.ClosedChannelsRequest();
            if (object.cooperative != null)
                message.cooperative = Boolean(object.cooperative);
            if (object.localForce != null)
                message.localForce = Boolean(object.localForce);
            if (object.remoteForce != null)
                message.remoteForce = Boolean(object.remoteForce);
            if (object.breach != null)
                message.breach = Boolean(object.breach);
            if (object.fundingCanceled != null)
                message.fundingCanceled = Boolean(object.fundingCanceled);
            if (object.abandoned != null)
                message.abandoned = Boolean(object.abandoned);
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelsRequest
         * @static
         * @param {lnrpc.ClosedChannelsRequest} message ClosedChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.cooperative = false;
                object.localForce = false;
                object.remoteForce = false;
                object.breach = false;
                object.fundingCanceled = false;
                object.abandoned = false;
            }
            if (message.cooperative != null && message.hasOwnProperty("cooperative"))
                object.cooperative = message.cooperative;
            if (message.localForce != null && message.hasOwnProperty("localForce"))
                object.localForce = message.localForce;
            if (message.remoteForce != null && message.hasOwnProperty("remoteForce"))
                object.remoteForce = message.remoteForce;
            if (message.breach != null && message.hasOwnProperty("breach"))
                object.breach = message.breach;
            if (message.fundingCanceled != null && message.hasOwnProperty("fundingCanceled"))
                object.fundingCanceled = message.fundingCanceled;
            if (message.abandoned != null && message.hasOwnProperty("abandoned"))
                object.abandoned = message.abandoned;
            return object;
        };

        /**
         * Converts this ClosedChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelsRequest;
    })();

    lnrpc.ClosedChannelsResponse = (function() {

        /**
         * Properties of a ClosedChannelsResponse.
         * @memberof lnrpc
         * @interface IClosedChannelsResponse
         * @property {Array.<lnrpc.IChannelCloseSummary>|null} [channels] ClosedChannelsResponse channels
         */

        /**
         * Constructs a new ClosedChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelsResponse.
         * @implements IClosedChannelsResponse
         * @constructor
         * @param {lnrpc.IClosedChannelsResponse=} [properties] Properties to set
         */
        function ClosedChannelsResponse(properties) {
            this.channels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClosedChannelsResponse channels.
         * @member {Array.<lnrpc.IChannelCloseSummary>} channels
         * @memberof lnrpc.ClosedChannelsResponse
         * @instance
         */
        ClosedChannelsResponse.prototype.channels = $util.emptyArray;

        /**
         * Creates a new ClosedChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse instance
         */
        ClosedChannelsResponse.create = function create(properties) {
            return new ClosedChannelsResponse(properties);
        };

        /**
         * Encodes the specified ClosedChannelsResponse message. Does not implicitly {@link lnrpc.ClosedChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse} message ClosedChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channels != null && message.channels.length)
                for (let i = 0; i < message.channels.length; ++i)
                    $root.lnrpc.ChannelCloseSummary.encode(message.channels[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.IClosedChannelsResponse} message ClosedChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.lnrpc.ChannelCloseSummary.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelsResponse message.
         * @function verify
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (let i = 0; i < message.channels.length; ++i) {
                    let error = $root.lnrpc.ChannelCloseSummary.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClosedChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelsResponse} ClosedChannelsResponse
         */
        ClosedChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelsResponse)
                return object;
            let message = new $root.lnrpc.ClosedChannelsResponse();
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".lnrpc.ClosedChannelsResponse.channels: array expected");
                message.channels = [];
                for (let i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".lnrpc.ClosedChannelsResponse.channels: object expected");
                    message.channels[i] = $root.lnrpc.ChannelCloseSummary.fromObject(object.channels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelsResponse
         * @static
         * @param {lnrpc.ClosedChannelsResponse} message ClosedChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.channels = [];
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (let j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.lnrpc.ChannelCloseSummary.toObject(message.channels[j], options);
            }
            return object;
        };

        /**
         * Converts this ClosedChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelsResponse;
    })();

    lnrpc.Peer = (function() {

        /**
         * Properties of a Peer.
         * @memberof lnrpc
         * @interface IPeer
         * @property {string|null} [pubKey] The identity pubkey of the peer
         * @property {string|null} [address] Network address of the peer; eg `127.0.0.1:10011`
         * @property {number|Long|null} [bytesSent] Bytes of data transmitted to this peer
         * @property {number|Long|null} [bytesRecv] Bytes of data transmitted from this peer
         * @property {number|Long|null} [satSent] Satoshis sent to this peer
         * @property {number|Long|null} [satRecv] Satoshis received from this peer
         * @property {boolean|null} [inbound] A channel is inbound if the counterparty initiated the channel
         * @property {number|Long|null} [pingTime] Ping time to this peer
         * @property {lnrpc.Peer.SyncType|null} [syncType] Peer syncType
         */

        /**
         * Constructs a new Peer.
         * @memberof lnrpc
         * @classdesc Represents a Peer.
         * @implements IPeer
         * @constructor
         * @param {lnrpc.IPeer=} [properties] Properties to set
         */
        function Peer(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The identity pubkey of the peer
         * @member {string} pubKey
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.pubKey = "";

        /**
         * Network address of the peer; eg `127.0.0.1:10011`
         * @member {string} address
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.address = "";

        /**
         * Bytes of data transmitted to this peer
         * @member {number|Long} bytesSent
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.bytesSent = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Bytes of data transmitted from this peer
         * @member {number|Long} bytesRecv
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.bytesRecv = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Satoshis sent to this peer
         * @member {number|Long} satSent
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.satSent = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Satoshis received from this peer
         * @member {number|Long} satRecv
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.satRecv = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A channel is inbound if the counterparty initiated the channel
         * @member {boolean} inbound
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.inbound = false;

        /**
         * Ping time to this peer
         * @member {number|Long} pingTime
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.pingTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Peer syncType.
         * @member {lnrpc.Peer.SyncType} syncType
         * @memberof lnrpc.Peer
         * @instance
         */
        Peer.prototype.syncType = 0;

        /**
         * Creates a new Peer instance using the specified properties.
         * @function create
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer=} [properties] Properties to set
         * @returns {lnrpc.Peer} Peer instance
         */
        Peer.create = function create(properties) {
            return new Peer(properties);
        };

        /**
         * Encodes the specified Peer message. Does not implicitly {@link lnrpc.Peer.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer} message Peer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Peer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.address != null && message.hasOwnProperty("address"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.address);
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.bytesSent);
            if (message.bytesRecv != null && message.hasOwnProperty("bytesRecv"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.bytesRecv);
            if (message.satSent != null && message.hasOwnProperty("satSent"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.satSent);
            if (message.satRecv != null && message.hasOwnProperty("satRecv"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.satRecv);
            if (message.inbound != null && message.hasOwnProperty("inbound"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.inbound);
            if (message.pingTime != null && message.hasOwnProperty("pingTime"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.pingTime);
            if (message.syncType != null && message.hasOwnProperty("syncType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.syncType);
            return writer;
        };

        /**
         * Encodes the specified Peer message, length delimited. Does not implicitly {@link lnrpc.Peer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.IPeer} message Peer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Peer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Peer message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Peer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Peer} Peer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Peer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Peer();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 3:
                    message.address = reader.string();
                    break;
                case 4:
                    message.bytesSent = reader.uint64();
                    break;
                case 5:
                    message.bytesRecv = reader.uint64();
                    break;
                case 6:
                    message.satSent = reader.int64();
                    break;
                case 7:
                    message.satRecv = reader.int64();
                    break;
                case 8:
                    message.inbound = reader.bool();
                    break;
                case 9:
                    message.pingTime = reader.int64();
                    break;
                case 10:
                    message.syncType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Peer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Peer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Peer} Peer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Peer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Peer message.
         * @function verify
         * @memberof lnrpc.Peer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Peer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.address != null && message.hasOwnProperty("address"))
                if (!$util.isString(message.address))
                    return "address: string expected";
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                if (!$util.isInteger(message.bytesSent) && !(message.bytesSent && $util.isInteger(message.bytesSent.low) && $util.isInteger(message.bytesSent.high)))
                    return "bytesSent: integer|Long expected";
            if (message.bytesRecv != null && message.hasOwnProperty("bytesRecv"))
                if (!$util.isInteger(message.bytesRecv) && !(message.bytesRecv && $util.isInteger(message.bytesRecv.low) && $util.isInteger(message.bytesRecv.high)))
                    return "bytesRecv: integer|Long expected";
            if (message.satSent != null && message.hasOwnProperty("satSent"))
                if (!$util.isInteger(message.satSent) && !(message.satSent && $util.isInteger(message.satSent.low) && $util.isInteger(message.satSent.high)))
                    return "satSent: integer|Long expected";
            if (message.satRecv != null && message.hasOwnProperty("satRecv"))
                if (!$util.isInteger(message.satRecv) && !(message.satRecv && $util.isInteger(message.satRecv.low) && $util.isInteger(message.satRecv.high)))
                    return "satRecv: integer|Long expected";
            if (message.inbound != null && message.hasOwnProperty("inbound"))
                if (typeof message.inbound !== "boolean")
                    return "inbound: boolean expected";
            if (message.pingTime != null && message.hasOwnProperty("pingTime"))
                if (!$util.isInteger(message.pingTime) && !(message.pingTime && $util.isInteger(message.pingTime.low) && $util.isInteger(message.pingTime.high)))
                    return "pingTime: integer|Long expected";
            if (message.syncType != null && message.hasOwnProperty("syncType"))
                switch (message.syncType) {
                default:
                    return "syncType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Peer message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Peer
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Peer} Peer
         */
        Peer.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Peer)
                return object;
            let message = new $root.lnrpc.Peer();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.address != null)
                message.address = String(object.address);
            if (object.bytesSent != null)
                if ($util.Long)
                    (message.bytesSent = $util.Long.fromValue(object.bytesSent)).unsigned = true;
                else if (typeof object.bytesSent === "string")
                    message.bytesSent = parseInt(object.bytesSent, 10);
                else if (typeof object.bytesSent === "number")
                    message.bytesSent = object.bytesSent;
                else if (typeof object.bytesSent === "object")
                    message.bytesSent = new $util.LongBits(object.bytesSent.low >>> 0, object.bytesSent.high >>> 0).toNumber(true);
            if (object.bytesRecv != null)
                if ($util.Long)
                    (message.bytesRecv = $util.Long.fromValue(object.bytesRecv)).unsigned = true;
                else if (typeof object.bytesRecv === "string")
                    message.bytesRecv = parseInt(object.bytesRecv, 10);
                else if (typeof object.bytesRecv === "number")
                    message.bytesRecv = object.bytesRecv;
                else if (typeof object.bytesRecv === "object")
                    message.bytesRecv = new $util.LongBits(object.bytesRecv.low >>> 0, object.bytesRecv.high >>> 0).toNumber(true);
            if (object.satSent != null)
                if ($util.Long)
                    (message.satSent = $util.Long.fromValue(object.satSent)).unsigned = false;
                else if (typeof object.satSent === "string")
                    message.satSent = parseInt(object.satSent, 10);
                else if (typeof object.satSent === "number")
                    message.satSent = object.satSent;
                else if (typeof object.satSent === "object")
                    message.satSent = new $util.LongBits(object.satSent.low >>> 0, object.satSent.high >>> 0).toNumber();
            if (object.satRecv != null)
                if ($util.Long)
                    (message.satRecv = $util.Long.fromValue(object.satRecv)).unsigned = false;
                else if (typeof object.satRecv === "string")
                    message.satRecv = parseInt(object.satRecv, 10);
                else if (typeof object.satRecv === "number")
                    message.satRecv = object.satRecv;
                else if (typeof object.satRecv === "object")
                    message.satRecv = new $util.LongBits(object.satRecv.low >>> 0, object.satRecv.high >>> 0).toNumber();
            if (object.inbound != null)
                message.inbound = Boolean(object.inbound);
            if (object.pingTime != null)
                if ($util.Long)
                    (message.pingTime = $util.Long.fromValue(object.pingTime)).unsigned = false;
                else if (typeof object.pingTime === "string")
                    message.pingTime = parseInt(object.pingTime, 10);
                else if (typeof object.pingTime === "number")
                    message.pingTime = object.pingTime;
                else if (typeof object.pingTime === "object")
                    message.pingTime = new $util.LongBits(object.pingTime.low >>> 0, object.pingTime.high >>> 0).toNumber();
            switch (object.syncType) {
            case "UNKNOWN_SYNC":
            case 0:
                message.syncType = 0;
                break;
            case "ACTIVE_SYNC":
            case 1:
                message.syncType = 1;
                break;
            case "PASSIVE_SYNC":
            case 2:
                message.syncType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Peer message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Peer
         * @static
         * @param {lnrpc.Peer} message Peer
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Peer.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pubKey = "";
                object.address = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.bytesSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.bytesRecv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bytesRecv = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satSent = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satSent = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satRecv = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satRecv = options.longs === String ? "0" : 0;
                object.inbound = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.pingTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pingTime = options.longs === String ? "0" : 0;
                object.syncType = options.enums === String ? "UNKNOWN_SYNC" : 0;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.address != null && message.hasOwnProperty("address"))
                object.address = message.address;
            if (message.bytesSent != null && message.hasOwnProperty("bytesSent"))
                if (typeof message.bytesSent === "number")
                    object.bytesSent = options.longs === String ? String(message.bytesSent) : message.bytesSent;
                else
                    object.bytesSent = options.longs === String ? $util.Long.prototype.toString.call(message.bytesSent) : options.longs === Number ? new $util.LongBits(message.bytesSent.low >>> 0, message.bytesSent.high >>> 0).toNumber(true) : message.bytesSent;
            if (message.bytesRecv != null && message.hasOwnProperty("bytesRecv"))
                if (typeof message.bytesRecv === "number")
                    object.bytesRecv = options.longs === String ? String(message.bytesRecv) : message.bytesRecv;
                else
                    object.bytesRecv = options.longs === String ? $util.Long.prototype.toString.call(message.bytesRecv) : options.longs === Number ? new $util.LongBits(message.bytesRecv.low >>> 0, message.bytesRecv.high >>> 0).toNumber(true) : message.bytesRecv;
            if (message.satSent != null && message.hasOwnProperty("satSent"))
                if (typeof message.satSent === "number")
                    object.satSent = options.longs === String ? String(message.satSent) : message.satSent;
                else
                    object.satSent = options.longs === String ? $util.Long.prototype.toString.call(message.satSent) : options.longs === Number ? new $util.LongBits(message.satSent.low >>> 0, message.satSent.high >>> 0).toNumber() : message.satSent;
            if (message.satRecv != null && message.hasOwnProperty("satRecv"))
                if (typeof message.satRecv === "number")
                    object.satRecv = options.longs === String ? String(message.satRecv) : message.satRecv;
                else
                    object.satRecv = options.longs === String ? $util.Long.prototype.toString.call(message.satRecv) : options.longs === Number ? new $util.LongBits(message.satRecv.low >>> 0, message.satRecv.high >>> 0).toNumber() : message.satRecv;
            if (message.inbound != null && message.hasOwnProperty("inbound"))
                object.inbound = message.inbound;
            if (message.pingTime != null && message.hasOwnProperty("pingTime"))
                if (typeof message.pingTime === "number")
                    object.pingTime = options.longs === String ? String(message.pingTime) : message.pingTime;
                else
                    object.pingTime = options.longs === String ? $util.Long.prototype.toString.call(message.pingTime) : options.longs === Number ? new $util.LongBits(message.pingTime.low >>> 0, message.pingTime.high >>> 0).toNumber() : message.pingTime;
            if (message.syncType != null && message.hasOwnProperty("syncType"))
                object.syncType = options.enums === String ? $root.lnrpc.Peer.SyncType[message.syncType] : message.syncType;
            return object;
        };

        /**
         * Converts this Peer to JSON.
         * @function toJSON
         * @memberof lnrpc.Peer
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Peer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * SyncType enum.
         * @name lnrpc.Peer.SyncType
         * @enum {string}
         * @property {number} UNKNOWN_SYNC=0 Denotes that we cannot determine the peer's current sync type.
         * @property {number} ACTIVE_SYNC=1 Denotes that we are actively receiving new graph updates from the peer.
         * @property {number} PASSIVE_SYNC=2 Denotes that we are not receiving new graph updates from the peer.
         */
        Peer.SyncType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_SYNC"] = 0;
            values[valuesById[1] = "ACTIVE_SYNC"] = 1;
            values[valuesById[2] = "PASSIVE_SYNC"] = 2;
            return values;
        })();

        return Peer;
    })();

    lnrpc.ListPeersRequest = (function() {

        /**
         * Properties of a ListPeersRequest.
         * @memberof lnrpc
         * @interface IListPeersRequest
         */

        /**
         * Constructs a new ListPeersRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListPeersRequest.
         * @implements IListPeersRequest
         * @constructor
         * @param {lnrpc.IListPeersRequest=} [properties] Properties to set
         */
        function ListPeersRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ListPeersRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest=} [properties] Properties to set
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest instance
         */
        ListPeersRequest.create = function create(properties) {
            return new ListPeersRequest(properties);
        };

        /**
         * Encodes the specified ListPeersRequest message. Does not implicitly {@link lnrpc.ListPeersRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest} message ListPeersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ListPeersRequest message, length delimited. Does not implicitly {@link lnrpc.ListPeersRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.IListPeersRequest} message ListPeersRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPeersRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPeersRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPeersRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPeersRequest message.
         * @function verify
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPeersRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ListPeersRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPeersRequest} ListPeersRequest
         */
        ListPeersRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPeersRequest)
                return object;
            return new $root.lnrpc.ListPeersRequest();
        };

        /**
         * Creates a plain object from a ListPeersRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPeersRequest
         * @static
         * @param {lnrpc.ListPeersRequest} message ListPeersRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPeersRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ListPeersRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPeersRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPeersRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPeersRequest;
    })();

    lnrpc.ListPeersResponse = (function() {

        /**
         * Properties of a ListPeersResponse.
         * @memberof lnrpc
         * @interface IListPeersResponse
         * @property {Array.<lnrpc.IPeer>|null} [peers] The list of currently connected peers
         */

        /**
         * Constructs a new ListPeersResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListPeersResponse.
         * @implements IListPeersResponse
         * @constructor
         * @param {lnrpc.IListPeersResponse=} [properties] Properties to set
         */
        function ListPeersResponse(properties) {
            this.peers = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of currently connected peers
         * @member {Array.<lnrpc.IPeer>} peers
         * @memberof lnrpc.ListPeersResponse
         * @instance
         */
        ListPeersResponse.prototype.peers = $util.emptyArray;

        /**
         * Creates a new ListPeersResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse=} [properties] Properties to set
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse instance
         */
        ListPeersResponse.create = function create(properties) {
            return new ListPeersResponse(properties);
        };

        /**
         * Encodes the specified ListPeersResponse message. Does not implicitly {@link lnrpc.ListPeersResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse} message ListPeersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.peers != null && message.peers.length)
                for (let i = 0; i < message.peers.length; ++i)
                    $root.lnrpc.Peer.encode(message.peers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListPeersResponse message, length delimited. Does not implicitly {@link lnrpc.ListPeersResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.IListPeersResponse} message ListPeersResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPeersResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPeersResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPeersResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.peers && message.peers.length))
                        message.peers = [];
                    message.peers.push($root.lnrpc.Peer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPeersResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPeersResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPeersResponse message.
         * @function verify
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPeersResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.peers != null && message.hasOwnProperty("peers")) {
                if (!Array.isArray(message.peers))
                    return "peers: array expected";
                for (let i = 0; i < message.peers.length; ++i) {
                    let error = $root.lnrpc.Peer.verify(message.peers[i]);
                    if (error)
                        return "peers." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListPeersResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPeersResponse} ListPeersResponse
         */
        ListPeersResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPeersResponse)
                return object;
            let message = new $root.lnrpc.ListPeersResponse();
            if (object.peers) {
                if (!Array.isArray(object.peers))
                    throw TypeError(".lnrpc.ListPeersResponse.peers: array expected");
                message.peers = [];
                for (let i = 0; i < object.peers.length; ++i) {
                    if (typeof object.peers[i] !== "object")
                        throw TypeError(".lnrpc.ListPeersResponse.peers: object expected");
                    message.peers[i] = $root.lnrpc.Peer.fromObject(object.peers[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListPeersResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPeersResponse
         * @static
         * @param {lnrpc.ListPeersResponse} message ListPeersResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPeersResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.peers = [];
            if (message.peers && message.peers.length) {
                object.peers = [];
                for (let j = 0; j < message.peers.length; ++j)
                    object.peers[j] = $root.lnrpc.Peer.toObject(message.peers[j], options);
            }
            return object;
        };

        /**
         * Converts this ListPeersResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPeersResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPeersResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPeersResponse;
    })();

    lnrpc.GetInfoRequest = (function() {

        /**
         * Properties of a GetInfoRequest.
         * @memberof lnrpc
         * @interface IGetInfoRequest
         */

        /**
         * Constructs a new GetInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a GetInfoRequest.
         * @implements IGetInfoRequest
         * @constructor
         * @param {lnrpc.IGetInfoRequest=} [properties] Properties to set
         */
        function GetInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest instance
         */
        GetInfoRequest.create = function create(properties) {
            return new GetInfoRequest(properties);
        };

        /**
         * Encodes the specified GetInfoRequest message. Does not implicitly {@link lnrpc.GetInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest} message GetInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetInfoRequest message, length delimited. Does not implicitly {@link lnrpc.GetInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.IGetInfoRequest} message GetInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetInfoRequest message.
         * @function verify
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GetInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetInfoRequest} GetInfoRequest
         */
        GetInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetInfoRequest)
                return object;
            return new $root.lnrpc.GetInfoRequest();
        };

        /**
         * Creates a plain object from a GetInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetInfoRequest
         * @static
         * @param {lnrpc.GetInfoRequest} message GetInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetInfoRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GetInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.GetInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetInfoRequest;
    })();

    lnrpc.GetInfoResponse = (function() {

        /**
         * Properties of a GetInfoResponse.
         * @memberof lnrpc
         * @interface IGetInfoResponse
         * @property {string|null} [identityPubkey] The identity pubkey of the current node.
         * @property {string|null} [alias] If applicable, the alias of the current node, e.g. "bob"
         * @property {number|null} [numPendingChannels] Number of pending channels
         * @property {number|null} [numActiveChannels] Number of active channels
         * @property {number|null} [numPeers] Number of peers
         * @property {number|null} [blockHeight] The node's current view of the height of the best block
         * @property {string|null} [blockHash] The node's current view of the hash of the best block
         * @property {boolean|null} [syncedToChain] Whether the wallet's view is synced to the main chain
         * @property {boolean|null} [testnet] Whether the current node is connected to testnet. This field is
         * deprecated and the network field should be used instead
         * @property {Array.<string>|null} [uris] The URIs of the current node.
         * @property {number|Long|null} [bestHeaderTimestamp] Timestamp of the block best known to the wallet
         * @property {string|null} [version] The version of the LND software that the node is running.
         * @property {number|null} [numInactiveChannels] Number of inactive channels
         * @property {Array.<lnrpc.IChain>|null} [chains] A list of active chains the node is connected to
         * @property {string|null} [color] The color of the current node in hex code format
         */

        /**
         * Constructs a new GetInfoResponse.
         * @memberof lnrpc
         * @classdesc Represents a GetInfoResponse.
         * @implements IGetInfoResponse
         * @constructor
         * @param {lnrpc.IGetInfoResponse=} [properties] Properties to set
         */
        function GetInfoResponse(properties) {
            this.uris = [];
            this.chains = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The identity pubkey of the current node.
         * @member {string} identityPubkey
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.identityPubkey = "";

        /**
         * If applicable, the alias of the current node, e.g. "bob"
         * @member {string} alias
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.alias = "";

        /**
         * Number of pending channels
         * @member {number} numPendingChannels
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numPendingChannels = 0;

        /**
         * Number of active channels
         * @member {number} numActiveChannels
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numActiveChannels = 0;

        /**
         * Number of peers
         * @member {number} numPeers
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numPeers = 0;

        /**
         * The node's current view of the height of the best block
         * @member {number} blockHeight
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.blockHeight = 0;

        /**
         * The node's current view of the hash of the best block
         * @member {string} blockHash
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.blockHash = "";

        /**
         * Whether the wallet's view is synced to the main chain
         * @member {boolean} syncedToChain
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.syncedToChain = false;

        /**
         * Whether the current node is connected to testnet. This field is
         * deprecated and the network field should be used instead
         * @member {boolean} testnet
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.testnet = false;

        /**
         * The URIs of the current node.
         * @member {Array.<string>} uris
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.uris = $util.emptyArray;

        /**
         * Timestamp of the block best known to the wallet
         * @member {number|Long} bestHeaderTimestamp
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.bestHeaderTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The version of the LND software that the node is running.
         * @member {string} version
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.version = "";

        /**
         * Number of inactive channels
         * @member {number} numInactiveChannels
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.numInactiveChannels = 0;

        /**
         * A list of active chains the node is connected to
         * @member {Array.<lnrpc.IChain>} chains
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.chains = $util.emptyArray;

        /**
         * The color of the current node in hex code format
         * @member {string} color
         * @memberof lnrpc.GetInfoResponse
         * @instance
         */
        GetInfoResponse.prototype.color = "";

        /**
         * Creates a new GetInfoResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse=} [properties] Properties to set
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse instance
         */
        GetInfoResponse.create = function create(properties) {
            return new GetInfoResponse(properties);
        };

        /**
         * Encodes the specified GetInfoResponse message. Does not implicitly {@link lnrpc.GetInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse} message GetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.identityPubkey != null && message.hasOwnProperty("identityPubkey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.identityPubkey);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.alias);
            if (message.numPendingChannels != null && message.hasOwnProperty("numPendingChannels"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numPendingChannels);
            if (message.numActiveChannels != null && message.hasOwnProperty("numActiveChannels"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numActiveChannels);
            if (message.numPeers != null && message.hasOwnProperty("numPeers"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numPeers);
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.blockHeight);
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.blockHash);
            if (message.syncedToChain != null && message.hasOwnProperty("syncedToChain"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.syncedToChain);
            if (message.testnet != null && message.hasOwnProperty("testnet"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.testnet);
            if (message.uris != null && message.uris.length)
                for (let i = 0; i < message.uris.length; ++i)
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.uris[i]);
            if (message.bestHeaderTimestamp != null && message.hasOwnProperty("bestHeaderTimestamp"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.bestHeaderTimestamp);
            if (message.version != null && message.hasOwnProperty("version"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.version);
            if (message.numInactiveChannels != null && message.hasOwnProperty("numInactiveChannels"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.numInactiveChannels);
            if (message.chains != null && message.chains.length)
                for (let i = 0; i < message.chains.length; ++i)
                    $root.lnrpc.Chain.encode(message.chains[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.color != null && message.hasOwnProperty("color"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.color);
            return writer;
        };

        /**
         * Encodes the specified GetInfoResponse message, length delimited. Does not implicitly {@link lnrpc.GetInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.IGetInfoResponse} message GetInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GetInfoResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.identityPubkey = reader.string();
                    break;
                case 2:
                    message.alias = reader.string();
                    break;
                case 3:
                    message.numPendingChannels = reader.uint32();
                    break;
                case 4:
                    message.numActiveChannels = reader.uint32();
                    break;
                case 5:
                    message.numPeers = reader.uint32();
                    break;
                case 6:
                    message.blockHeight = reader.uint32();
                    break;
                case 8:
                    message.blockHash = reader.string();
                    break;
                case 9:
                    message.syncedToChain = reader.bool();
                    break;
                case 10:
                    message.testnet = reader.bool();
                    break;
                case 12:
                    if (!(message.uris && message.uris.length))
                        message.uris = [];
                    message.uris.push(reader.string());
                    break;
                case 13:
                    message.bestHeaderTimestamp = reader.int64();
                    break;
                case 14:
                    message.version = reader.string();
                    break;
                case 15:
                    message.numInactiveChannels = reader.uint32();
                    break;
                case 16:
                    if (!(message.chains && message.chains.length))
                        message.chains = [];
                    message.chains.push($root.lnrpc.Chain.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetInfoResponse message.
         * @function verify
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.identityPubkey != null && message.hasOwnProperty("identityPubkey"))
                if (!$util.isString(message.identityPubkey))
                    return "identityPubkey: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.numPendingChannels != null && message.hasOwnProperty("numPendingChannels"))
                if (!$util.isInteger(message.numPendingChannels))
                    return "numPendingChannels: integer expected";
            if (message.numActiveChannels != null && message.hasOwnProperty("numActiveChannels"))
                if (!$util.isInteger(message.numActiveChannels))
                    return "numActiveChannels: integer expected";
            if (message.numPeers != null && message.hasOwnProperty("numPeers"))
                if (!$util.isInteger(message.numPeers))
                    return "numPeers: integer expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                if (!$util.isString(message.blockHash))
                    return "blockHash: string expected";
            if (message.syncedToChain != null && message.hasOwnProperty("syncedToChain"))
                if (typeof message.syncedToChain !== "boolean")
                    return "syncedToChain: boolean expected";
            if (message.testnet != null && message.hasOwnProperty("testnet"))
                if (typeof message.testnet !== "boolean")
                    return "testnet: boolean expected";
            if (message.uris != null && message.hasOwnProperty("uris")) {
                if (!Array.isArray(message.uris))
                    return "uris: array expected";
                for (let i = 0; i < message.uris.length; ++i)
                    if (!$util.isString(message.uris[i]))
                        return "uris: string[] expected";
            }
            if (message.bestHeaderTimestamp != null && message.hasOwnProperty("bestHeaderTimestamp"))
                if (!$util.isInteger(message.bestHeaderTimestamp) && !(message.bestHeaderTimestamp && $util.isInteger(message.bestHeaderTimestamp.low) && $util.isInteger(message.bestHeaderTimestamp.high)))
                    return "bestHeaderTimestamp: integer|Long expected";
            if (message.version != null && message.hasOwnProperty("version"))
                if (!$util.isString(message.version))
                    return "version: string expected";
            if (message.numInactiveChannels != null && message.hasOwnProperty("numInactiveChannels"))
                if (!$util.isInteger(message.numInactiveChannels))
                    return "numInactiveChannels: integer expected";
            if (message.chains != null && message.hasOwnProperty("chains")) {
                if (!Array.isArray(message.chains))
                    return "chains: array expected";
                for (let i = 0; i < message.chains.length; ++i) {
                    let error = $root.lnrpc.Chain.verify(message.chains[i]);
                    if (error)
                        return "chains." + error;
                }
            }
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            return null;
        };

        /**
         * Creates a GetInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GetInfoResponse} GetInfoResponse
         */
        GetInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GetInfoResponse)
                return object;
            let message = new $root.lnrpc.GetInfoResponse();
            if (object.identityPubkey != null)
                message.identityPubkey = String(object.identityPubkey);
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.numPendingChannels != null)
                message.numPendingChannels = object.numPendingChannels >>> 0;
            if (object.numActiveChannels != null)
                message.numActiveChannels = object.numActiveChannels >>> 0;
            if (object.numPeers != null)
                message.numPeers = object.numPeers >>> 0;
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight >>> 0;
            if (object.blockHash != null)
                message.blockHash = String(object.blockHash);
            if (object.syncedToChain != null)
                message.syncedToChain = Boolean(object.syncedToChain);
            if (object.testnet != null)
                message.testnet = Boolean(object.testnet);
            if (object.uris) {
                if (!Array.isArray(object.uris))
                    throw TypeError(".lnrpc.GetInfoResponse.uris: array expected");
                message.uris = [];
                for (let i = 0; i < object.uris.length; ++i)
                    message.uris[i] = String(object.uris[i]);
            }
            if (object.bestHeaderTimestamp != null)
                if ($util.Long)
                    (message.bestHeaderTimestamp = $util.Long.fromValue(object.bestHeaderTimestamp)).unsigned = false;
                else if (typeof object.bestHeaderTimestamp === "string")
                    message.bestHeaderTimestamp = parseInt(object.bestHeaderTimestamp, 10);
                else if (typeof object.bestHeaderTimestamp === "number")
                    message.bestHeaderTimestamp = object.bestHeaderTimestamp;
                else if (typeof object.bestHeaderTimestamp === "object")
                    message.bestHeaderTimestamp = new $util.LongBits(object.bestHeaderTimestamp.low >>> 0, object.bestHeaderTimestamp.high >>> 0).toNumber();
            if (object.version != null)
                message.version = String(object.version);
            if (object.numInactiveChannels != null)
                message.numInactiveChannels = object.numInactiveChannels >>> 0;
            if (object.chains) {
                if (!Array.isArray(object.chains))
                    throw TypeError(".lnrpc.GetInfoResponse.chains: array expected");
                message.chains = [];
                for (let i = 0; i < object.chains.length; ++i) {
                    if (typeof object.chains[i] !== "object")
                        throw TypeError(".lnrpc.GetInfoResponse.chains: object expected");
                    message.chains[i] = $root.lnrpc.Chain.fromObject(object.chains[i]);
                }
            }
            if (object.color != null)
                message.color = String(object.color);
            return message;
        };

        /**
         * Creates a plain object from a GetInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GetInfoResponse
         * @static
         * @param {lnrpc.GetInfoResponse} message GetInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GetInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.uris = [];
                object.chains = [];
            }
            if (options.defaults) {
                object.identityPubkey = "";
                object.alias = "";
                object.numPendingChannels = 0;
                object.numActiveChannels = 0;
                object.numPeers = 0;
                object.blockHeight = 0;
                object.blockHash = "";
                object.syncedToChain = false;
                object.testnet = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.bestHeaderTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.bestHeaderTimestamp = options.longs === String ? "0" : 0;
                object.version = "";
                object.numInactiveChannels = 0;
                object.color = "";
            }
            if (message.identityPubkey != null && message.hasOwnProperty("identityPubkey"))
                object.identityPubkey = message.identityPubkey;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.numPendingChannels != null && message.hasOwnProperty("numPendingChannels"))
                object.numPendingChannels = message.numPendingChannels;
            if (message.numActiveChannels != null && message.hasOwnProperty("numActiveChannels"))
                object.numActiveChannels = message.numActiveChannels;
            if (message.numPeers != null && message.hasOwnProperty("numPeers"))
                object.numPeers = message.numPeers;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.blockHash != null && message.hasOwnProperty("blockHash"))
                object.blockHash = message.blockHash;
            if (message.syncedToChain != null && message.hasOwnProperty("syncedToChain"))
                object.syncedToChain = message.syncedToChain;
            if (message.testnet != null && message.hasOwnProperty("testnet"))
                object.testnet = message.testnet;
            if (message.uris && message.uris.length) {
                object.uris = [];
                for (let j = 0; j < message.uris.length; ++j)
                    object.uris[j] = message.uris[j];
            }
            if (message.bestHeaderTimestamp != null && message.hasOwnProperty("bestHeaderTimestamp"))
                if (typeof message.bestHeaderTimestamp === "number")
                    object.bestHeaderTimestamp = options.longs === String ? String(message.bestHeaderTimestamp) : message.bestHeaderTimestamp;
                else
                    object.bestHeaderTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.bestHeaderTimestamp) : options.longs === Number ? new $util.LongBits(message.bestHeaderTimestamp.low >>> 0, message.bestHeaderTimestamp.high >>> 0).toNumber() : message.bestHeaderTimestamp;
            if (message.version != null && message.hasOwnProperty("version"))
                object.version = message.version;
            if (message.numInactiveChannels != null && message.hasOwnProperty("numInactiveChannels"))
                object.numInactiveChannels = message.numInactiveChannels;
            if (message.chains && message.chains.length) {
                object.chains = [];
                for (let j = 0; j < message.chains.length; ++j)
                    object.chains[j] = $root.lnrpc.Chain.toObject(message.chains[j], options);
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            return object;
        };

        /**
         * Converts this GetInfoResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.GetInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GetInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GetInfoResponse;
    })();

    lnrpc.Chain = (function() {

        /**
         * Properties of a Chain.
         * @memberof lnrpc
         * @interface IChain
         * @property {string|null} [chain] The blockchain the node is on (eg bitcoin, litecoin)
         * @property {string|null} [network] The network the node is on (eg regtest, testnet, mainnet)
         */

        /**
         * Constructs a new Chain.
         * @memberof lnrpc
         * @classdesc Represents a Chain.
         * @implements IChain
         * @constructor
         * @param {lnrpc.IChain=} [properties] Properties to set
         */
        function Chain(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The blockchain the node is on (eg bitcoin, litecoin)
         * @member {string} chain
         * @memberof lnrpc.Chain
         * @instance
         */
        Chain.prototype.chain = "";

        /**
         * The network the node is on (eg regtest, testnet, mainnet)
         * @member {string} network
         * @memberof lnrpc.Chain
         * @instance
         */
        Chain.prototype.network = "";

        /**
         * Creates a new Chain instance using the specified properties.
         * @function create
         * @memberof lnrpc.Chain
         * @static
         * @param {lnrpc.IChain=} [properties] Properties to set
         * @returns {lnrpc.Chain} Chain instance
         */
        Chain.create = function create(properties) {
            return new Chain(properties);
        };

        /**
         * Encodes the specified Chain message. Does not implicitly {@link lnrpc.Chain.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Chain
         * @static
         * @param {lnrpc.IChain} message Chain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chain.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chain != null && message.hasOwnProperty("chain"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chain);
            if (message.network != null && message.hasOwnProperty("network"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.network);
            return writer;
        };

        /**
         * Encodes the specified Chain message, length delimited. Does not implicitly {@link lnrpc.Chain.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Chain
         * @static
         * @param {lnrpc.IChain} message Chain message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chain.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Chain message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Chain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Chain} Chain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chain.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Chain();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chain = reader.string();
                    break;
                case 2:
                    message.network = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Chain message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Chain
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Chain} Chain
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chain.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Chain message.
         * @function verify
         * @memberof lnrpc.Chain
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Chain.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chain != null && message.hasOwnProperty("chain"))
                if (!$util.isString(message.chain))
                    return "chain: string expected";
            if (message.network != null && message.hasOwnProperty("network"))
                if (!$util.isString(message.network))
                    return "network: string expected";
            return null;
        };

        /**
         * Creates a Chain message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Chain
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Chain} Chain
         */
        Chain.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Chain)
                return object;
            let message = new $root.lnrpc.Chain();
            if (object.chain != null)
                message.chain = String(object.chain);
            if (object.network != null)
                message.network = String(object.network);
            return message;
        };

        /**
         * Creates a plain object from a Chain message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Chain
         * @static
         * @param {lnrpc.Chain} message Chain
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Chain.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chain = "";
                object.network = "";
            }
            if (message.chain != null && message.hasOwnProperty("chain"))
                object.chain = message.chain;
            if (message.network != null && message.hasOwnProperty("network"))
                object.network = message.network;
            return object;
        };

        /**
         * Converts this Chain to JSON.
         * @function toJSON
         * @memberof lnrpc.Chain
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Chain.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Chain;
    })();

    lnrpc.ConfirmationUpdate = (function() {

        /**
         * Properties of a ConfirmationUpdate.
         * @memberof lnrpc
         * @interface IConfirmationUpdate
         * @property {Uint8Array|null} [blockSha] ConfirmationUpdate blockSha
         * @property {number|null} [blockHeight] ConfirmationUpdate blockHeight
         * @property {number|null} [numConfsLeft] ConfirmationUpdate numConfsLeft
         */

        /**
         * Constructs a new ConfirmationUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ConfirmationUpdate.
         * @implements IConfirmationUpdate
         * @constructor
         * @param {lnrpc.IConfirmationUpdate=} [properties] Properties to set
         */
        function ConfirmationUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ConfirmationUpdate blockSha.
         * @member {Uint8Array} blockSha
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.blockSha = $util.newBuffer([]);

        /**
         * ConfirmationUpdate blockHeight.
         * @member {number} blockHeight
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.blockHeight = 0;

        /**
         * ConfirmationUpdate numConfsLeft.
         * @member {number} numConfsLeft
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         */
        ConfirmationUpdate.prototype.numConfsLeft = 0;

        /**
         * Creates a new ConfirmationUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate=} [properties] Properties to set
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate instance
         */
        ConfirmationUpdate.create = function create(properties) {
            return new ConfirmationUpdate(properties);
        };

        /**
         * Encodes the specified ConfirmationUpdate message. Does not implicitly {@link lnrpc.ConfirmationUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate} message ConfirmationUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfirmationUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.blockSha != null && message.hasOwnProperty("blockSha"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.blockSha);
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.blockHeight);
            if (message.numConfsLeft != null && message.hasOwnProperty("numConfsLeft"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.numConfsLeft);
            return writer;
        };

        /**
         * Encodes the specified ConfirmationUpdate message, length delimited. Does not implicitly {@link lnrpc.ConfirmationUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.IConfirmationUpdate} message ConfirmationUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ConfirmationUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ConfirmationUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfirmationUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ConfirmationUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.blockSha = reader.bytes();
                    break;
                case 2:
                    message.blockHeight = reader.int32();
                    break;
                case 3:
                    message.numConfsLeft = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ConfirmationUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ConfirmationUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ConfirmationUpdate message.
         * @function verify
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ConfirmationUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.blockSha != null && message.hasOwnProperty("blockSha"))
                if (!(message.blockSha && typeof message.blockSha.length === "number" || $util.isString(message.blockSha)))
                    return "blockSha: buffer expected";
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                if (!$util.isInteger(message.blockHeight))
                    return "blockHeight: integer expected";
            if (message.numConfsLeft != null && message.hasOwnProperty("numConfsLeft"))
                if (!$util.isInteger(message.numConfsLeft))
                    return "numConfsLeft: integer expected";
            return null;
        };

        /**
         * Creates a ConfirmationUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ConfirmationUpdate} ConfirmationUpdate
         */
        ConfirmationUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ConfirmationUpdate)
                return object;
            let message = new $root.lnrpc.ConfirmationUpdate();
            if (object.blockSha != null)
                if (typeof object.blockSha === "string")
                    $util.base64.decode(object.blockSha, message.blockSha = $util.newBuffer($util.base64.length(object.blockSha)), 0);
                else if (object.blockSha.length)
                    message.blockSha = object.blockSha;
            if (object.blockHeight != null)
                message.blockHeight = object.blockHeight | 0;
            if (object.numConfsLeft != null)
                message.numConfsLeft = object.numConfsLeft >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ConfirmationUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ConfirmationUpdate
         * @static
         * @param {lnrpc.ConfirmationUpdate} message ConfirmationUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ConfirmationUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.blockSha = "";
                else {
                    object.blockSha = [];
                    if (options.bytes !== Array)
                        object.blockSha = $util.newBuffer(object.blockSha);
                }
                object.blockHeight = 0;
                object.numConfsLeft = 0;
            }
            if (message.blockSha != null && message.hasOwnProperty("blockSha"))
                object.blockSha = options.bytes === String ? $util.base64.encode(message.blockSha, 0, message.blockSha.length) : options.bytes === Array ? Array.prototype.slice.call(message.blockSha) : message.blockSha;
            if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                object.blockHeight = message.blockHeight;
            if (message.numConfsLeft != null && message.hasOwnProperty("numConfsLeft"))
                object.numConfsLeft = message.numConfsLeft;
            return object;
        };

        /**
         * Converts this ConfirmationUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ConfirmationUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ConfirmationUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ConfirmationUpdate;
    })();

    lnrpc.ChannelOpenUpdate = (function() {

        /**
         * Properties of a ChannelOpenUpdate.
         * @memberof lnrpc
         * @interface IChannelOpenUpdate
         * @property {lnrpc.IChannelPoint|null} [channelPoint] ChannelOpenUpdate channelPoint
         */

        /**
         * Constructs a new ChannelOpenUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelOpenUpdate.
         * @implements IChannelOpenUpdate
         * @constructor
         * @param {lnrpc.IChannelOpenUpdate=} [properties] Properties to set
         */
        function ChannelOpenUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelOpenUpdate channelPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} channelPoint
         * @memberof lnrpc.ChannelOpenUpdate
         * @instance
         */
        ChannelOpenUpdate.prototype.channelPoint = null;

        /**
         * Creates a new ChannelOpenUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate instance
         */
        ChannelOpenUpdate.create = function create(properties) {
            return new ChannelOpenUpdate(properties);
        };

        /**
         * Encodes the specified ChannelOpenUpdate message. Does not implicitly {@link lnrpc.ChannelOpenUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate} message ChannelOpenUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelOpenUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                $root.lnrpc.ChannelPoint.encode(message.channelPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelOpenUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelOpenUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.IChannelOpenUpdate} message ChannelOpenUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelOpenUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelOpenUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelOpenUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelOpenUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelOpenUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelOpenUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelOpenUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelOpenUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.channelPoint);
                if (error)
                    return "channelPoint." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelOpenUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelOpenUpdate} ChannelOpenUpdate
         */
        ChannelOpenUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelOpenUpdate)
                return object;
            let message = new $root.lnrpc.ChannelOpenUpdate();
            if (object.channelPoint != null) {
                if (typeof object.channelPoint !== "object")
                    throw TypeError(".lnrpc.ChannelOpenUpdate.channelPoint: object expected");
                message.channelPoint = $root.lnrpc.ChannelPoint.fromObject(object.channelPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelOpenUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelOpenUpdate
         * @static
         * @param {lnrpc.ChannelOpenUpdate} message ChannelOpenUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelOpenUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.channelPoint = null;
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = $root.lnrpc.ChannelPoint.toObject(message.channelPoint, options);
            return object;
        };

        /**
         * Converts this ChannelOpenUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelOpenUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelOpenUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelOpenUpdate;
    })();

    lnrpc.ChannelCloseUpdate = (function() {

        /**
         * Properties of a ChannelCloseUpdate.
         * @memberof lnrpc
         * @interface IChannelCloseUpdate
         * @property {Uint8Array|null} [closingTxid] ChannelCloseUpdate closingTxid
         * @property {boolean|null} [success] ChannelCloseUpdate success
         */

        /**
         * Constructs a new ChannelCloseUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelCloseUpdate.
         * @implements IChannelCloseUpdate
         * @constructor
         * @param {lnrpc.IChannelCloseUpdate=} [properties] Properties to set
         */
        function ChannelCloseUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelCloseUpdate closingTxid.
         * @member {Uint8Array} closingTxid
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         */
        ChannelCloseUpdate.prototype.closingTxid = $util.newBuffer([]);

        /**
         * ChannelCloseUpdate success.
         * @member {boolean} success
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         */
        ChannelCloseUpdate.prototype.success = false;

        /**
         * Creates a new ChannelCloseUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate instance
         */
        ChannelCloseUpdate.create = function create(properties) {
            return new ChannelCloseUpdate(properties);
        };

        /**
         * Encodes the specified ChannelCloseUpdate message. Does not implicitly {@link lnrpc.ChannelCloseUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate} message ChannelCloseUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.closingTxid);
            if (message.success != null && message.hasOwnProperty("success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.success);
            return writer;
        };

        /**
         * Encodes the specified ChannelCloseUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelCloseUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.IChannelCloseUpdate} message ChannelCloseUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelCloseUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelCloseUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelCloseUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.closingTxid = reader.bytes();
                    break;
                case 2:
                    message.success = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelCloseUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelCloseUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelCloseUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelCloseUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                if (!(message.closingTxid && typeof message.closingTxid.length === "number" || $util.isString(message.closingTxid)))
                    return "closingTxid: buffer expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };

        /**
         * Creates a ChannelCloseUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelCloseUpdate} ChannelCloseUpdate
         */
        ChannelCloseUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelCloseUpdate)
                return object;
            let message = new $root.lnrpc.ChannelCloseUpdate();
            if (object.closingTxid != null)
                if (typeof object.closingTxid === "string")
                    $util.base64.decode(object.closingTxid, message.closingTxid = $util.newBuffer($util.base64.length(object.closingTxid)), 0);
                else if (object.closingTxid.length)
                    message.closingTxid = object.closingTxid;
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };

        /**
         * Creates a plain object from a ChannelCloseUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelCloseUpdate
         * @static
         * @param {lnrpc.ChannelCloseUpdate} message ChannelCloseUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelCloseUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.closingTxid = "";
                else {
                    object.closingTxid = [];
                    if (options.bytes !== Array)
                        object.closingTxid = $util.newBuffer(object.closingTxid);
                }
                object.success = false;
            }
            if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                object.closingTxid = options.bytes === String ? $util.base64.encode(message.closingTxid, 0, message.closingTxid.length) : options.bytes === Array ? Array.prototype.slice.call(message.closingTxid) : message.closingTxid;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };

        /**
         * Converts this ChannelCloseUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelCloseUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelCloseUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelCloseUpdate;
    })();

    lnrpc.CloseChannelRequest = (function() {

        /**
         * Properties of a CloseChannelRequest.
         * @memberof lnrpc
         * @interface ICloseChannelRequest
         * @property {lnrpc.IChannelPoint|null} [channelPoint] The outpoint (txid:index) of the funding transaction. With this value, Bob
         * will be able to generate a signature for Alice's version of the commitment
         * transaction.
         * @property {boolean|null} [force] If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
         * @property {number|null} [targetConf] The target number of blocks that the closure transaction should be confirmed by.
         * @property {number|Long|null} [satPerByte] A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
         */

        /**
         * Constructs a new CloseChannelRequest.
         * @memberof lnrpc
         * @classdesc Represents a CloseChannelRequest.
         * @implements ICloseChannelRequest
         * @constructor
         * @param {lnrpc.ICloseChannelRequest=} [properties] Properties to set
         */
        function CloseChannelRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The outpoint (txid:index) of the funding transaction. With this value, Bob
         * will be able to generate a signature for Alice's version of the commitment
         * transaction.
         * @member {lnrpc.IChannelPoint|null|undefined} channelPoint
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.channelPoint = null;

        /**
         * If true, then the channel will be closed forcibly. This means the current commitment transaction will be signed and broadcast.
         * @member {boolean} force
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.force = false;

        /**
         * The target number of blocks that the closure transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.targetConf = 0;

        /**
         * A manual fee rate set in sat/byte that should be used when crafting the closure transaction.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         */
        CloseChannelRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CloseChannelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest=} [properties] Properties to set
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest instance
         */
        CloseChannelRequest.create = function create(properties) {
            return new CloseChannelRequest(properties);
        };

        /**
         * Encodes the specified CloseChannelRequest message. Does not implicitly {@link lnrpc.CloseChannelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest} message CloseChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseChannelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                $root.lnrpc.ChannelPoint.encode(message.channelPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.force != null && message.hasOwnProperty("force"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.force);
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.targetConf);
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.satPerByte);
            return writer;
        };

        /**
         * Encodes the specified CloseChannelRequest message, length delimited. Does not implicitly {@link lnrpc.CloseChannelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.ICloseChannelRequest} message CloseChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseChannelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseChannelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseChannelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.CloseChannelRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.force = reader.bool();
                    break;
                case 3:
                    message.targetConf = reader.int32();
                    break;
                case 4:
                    message.satPerByte = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseChannelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseChannelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseChannelRequest message.
         * @function verify
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseChannelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.channelPoint);
                if (error)
                    return "channelPoint." + error;
            }
            if (message.force != null && message.hasOwnProperty("force"))
                if (typeof message.force !== "boolean")
                    return "force: boolean expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            return null;
        };

        /**
         * Creates a CloseChannelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.CloseChannelRequest} CloseChannelRequest
         */
        CloseChannelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.CloseChannelRequest)
                return object;
            let message = new $root.lnrpc.CloseChannelRequest();
            if (object.channelPoint != null) {
                if (typeof object.channelPoint !== "object")
                    throw TypeError(".lnrpc.CloseChannelRequest.channelPoint: object expected");
                message.channelPoint = $root.lnrpc.ChannelPoint.fromObject(object.channelPoint);
            }
            if (object.force != null)
                message.force = Boolean(object.force);
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CloseChannelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.CloseChannelRequest
         * @static
         * @param {lnrpc.CloseChannelRequest} message CloseChannelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseChannelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.channelPoint = null;
                object.force = false;
                object.targetConf = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
            }
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = $root.lnrpc.ChannelPoint.toObject(message.channelPoint, options);
            if (message.force != null && message.hasOwnProperty("force"))
                object.force = message.force;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            return object;
        };

        /**
         * Converts this CloseChannelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.CloseChannelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseChannelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CloseChannelRequest;
    })();

    lnrpc.CloseStatusUpdate = (function() {

        /**
         * Properties of a CloseStatusUpdate.
         * @memberof lnrpc
         * @interface ICloseStatusUpdate
         * @property {lnrpc.IPendingUpdate|null} [closePending] CloseStatusUpdate closePending
         * @property {lnrpc.IChannelCloseUpdate|null} [chanClose] CloseStatusUpdate chanClose
         */

        /**
         * Constructs a new CloseStatusUpdate.
         * @memberof lnrpc
         * @classdesc Represents a CloseStatusUpdate.
         * @implements ICloseStatusUpdate
         * @constructor
         * @param {lnrpc.ICloseStatusUpdate=} [properties] Properties to set
         */
        function CloseStatusUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CloseStatusUpdate closePending.
         * @member {lnrpc.IPendingUpdate|null|undefined} closePending
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        CloseStatusUpdate.prototype.closePending = null;

        /**
         * CloseStatusUpdate chanClose.
         * @member {lnrpc.IChannelCloseUpdate|null|undefined} chanClose
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        CloseStatusUpdate.prototype.chanClose = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * CloseStatusUpdate update.
         * @member {"closePending"|"chanClose"|undefined} update
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         */
        Object.defineProperty(CloseStatusUpdate.prototype, "update", {
            get: $util.oneOfGetter($oneOfFields = ["closePending", "chanClose"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new CloseStatusUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate=} [properties] Properties to set
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate instance
         */
        CloseStatusUpdate.create = function create(properties) {
            return new CloseStatusUpdate(properties);
        };

        /**
         * Encodes the specified CloseStatusUpdate message. Does not implicitly {@link lnrpc.CloseStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate} message CloseStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.closePending != null && message.hasOwnProperty("closePending"))
                $root.lnrpc.PendingUpdate.encode(message.closePending, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.chanClose != null && message.hasOwnProperty("chanClose"))
                $root.lnrpc.ChannelCloseUpdate.encode(message.chanClose, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CloseStatusUpdate message, length delimited. Does not implicitly {@link lnrpc.CloseStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.ICloseStatusUpdate} message CloseStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CloseStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CloseStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.CloseStatusUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.closePending = $root.lnrpc.PendingUpdate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chanClose = $root.lnrpc.ChannelCloseUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CloseStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CloseStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CloseStatusUpdate message.
         * @function verify
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CloseStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.closePending != null && message.hasOwnProperty("closePending")) {
                properties.update = 1;
                {
                    let error = $root.lnrpc.PendingUpdate.verify(message.closePending);
                    if (error)
                        return "closePending." + error;
                }
            }
            if (message.chanClose != null && message.hasOwnProperty("chanClose")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    let error = $root.lnrpc.ChannelCloseUpdate.verify(message.chanClose);
                    if (error)
                        return "chanClose." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CloseStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.CloseStatusUpdate} CloseStatusUpdate
         */
        CloseStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.CloseStatusUpdate)
                return object;
            let message = new $root.lnrpc.CloseStatusUpdate();
            if (object.closePending != null) {
                if (typeof object.closePending !== "object")
                    throw TypeError(".lnrpc.CloseStatusUpdate.closePending: object expected");
                message.closePending = $root.lnrpc.PendingUpdate.fromObject(object.closePending);
            }
            if (object.chanClose != null) {
                if (typeof object.chanClose !== "object")
                    throw TypeError(".lnrpc.CloseStatusUpdate.chanClose: object expected");
                message.chanClose = $root.lnrpc.ChannelCloseUpdate.fromObject(object.chanClose);
            }
            return message;
        };

        /**
         * Creates a plain object from a CloseStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.CloseStatusUpdate
         * @static
         * @param {lnrpc.CloseStatusUpdate} message CloseStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CloseStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.closePending != null && message.hasOwnProperty("closePending")) {
                object.closePending = $root.lnrpc.PendingUpdate.toObject(message.closePending, options);
                if (options.oneofs)
                    object.update = "closePending";
            }
            if (message.chanClose != null && message.hasOwnProperty("chanClose")) {
                object.chanClose = $root.lnrpc.ChannelCloseUpdate.toObject(message.chanClose, options);
                if (options.oneofs)
                    object.update = "chanClose";
            }
            return object;
        };

        /**
         * Converts this CloseStatusUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.CloseStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CloseStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return CloseStatusUpdate;
    })();

    lnrpc.PendingUpdate = (function() {

        /**
         * Properties of a PendingUpdate.
         * @memberof lnrpc
         * @interface IPendingUpdate
         * @property {Uint8Array|null} [txid] PendingUpdate txid
         * @property {number|null} [outputIndex] PendingUpdate outputIndex
         */

        /**
         * Constructs a new PendingUpdate.
         * @memberof lnrpc
         * @classdesc Represents a PendingUpdate.
         * @implements IPendingUpdate
         * @constructor
         * @param {lnrpc.IPendingUpdate=} [properties] Properties to set
         */
        function PendingUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PendingUpdate txid.
         * @member {Uint8Array} txid
         * @memberof lnrpc.PendingUpdate
         * @instance
         */
        PendingUpdate.prototype.txid = $util.newBuffer([]);

        /**
         * PendingUpdate outputIndex.
         * @member {number} outputIndex
         * @memberof lnrpc.PendingUpdate
         * @instance
         */
        PendingUpdate.prototype.outputIndex = 0;

        /**
         * Creates a new PendingUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate=} [properties] Properties to set
         * @returns {lnrpc.PendingUpdate} PendingUpdate instance
         */
        PendingUpdate.create = function create(properties) {
            return new PendingUpdate(properties);
        };

        /**
         * Encodes the specified PendingUpdate message. Does not implicitly {@link lnrpc.PendingUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate} message PendingUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.txid != null && message.hasOwnProperty("txid"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.txid);
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.outputIndex);
            return writer;
        };

        /**
         * Encodes the specified PendingUpdate message, length delimited. Does not implicitly {@link lnrpc.PendingUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.IPendingUpdate} message PendingUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.txid = reader.bytes();
                    break;
                case 2:
                    message.outputIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingUpdate message.
         * @function verify
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.txid != null && message.hasOwnProperty("txid"))
                if (!(message.txid && typeof message.txid.length === "number" || $util.isString(message.txid)))
                    return "txid: buffer expected";
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                if (!$util.isInteger(message.outputIndex))
                    return "outputIndex: integer expected";
            return null;
        };

        /**
         * Creates a PendingUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingUpdate} PendingUpdate
         */
        PendingUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingUpdate)
                return object;
            let message = new $root.lnrpc.PendingUpdate();
            if (object.txid != null)
                if (typeof object.txid === "string")
                    $util.base64.decode(object.txid, message.txid = $util.newBuffer($util.base64.length(object.txid)), 0);
                else if (object.txid.length)
                    message.txid = object.txid;
            if (object.outputIndex != null)
                message.outputIndex = object.outputIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PendingUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingUpdate
         * @static
         * @param {lnrpc.PendingUpdate} message PendingUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.txid = "";
                else {
                    object.txid = [];
                    if (options.bytes !== Array)
                        object.txid = $util.newBuffer(object.txid);
                }
                object.outputIndex = 0;
            }
            if (message.txid != null && message.hasOwnProperty("txid"))
                object.txid = options.bytes === String ? $util.base64.encode(message.txid, 0, message.txid.length) : options.bytes === Array ? Array.prototype.slice.call(message.txid) : message.txid;
            if (message.outputIndex != null && message.hasOwnProperty("outputIndex"))
                object.outputIndex = message.outputIndex;
            return object;
        };

        /**
         * Converts this PendingUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingUpdate;
    })();

    lnrpc.OpenChannelRequest = (function() {

        /**
         * Properties of an OpenChannelRequest.
         * @memberof lnrpc
         * @interface IOpenChannelRequest
         * @property {Uint8Array|null} [nodePubkey] The pubkey of the node to open a channel with
         * @property {string|null} [nodePubkeyString] The hex encoded pubkey of the node to open a channel with
         * @property {number|Long|null} [localFundingAmount] The number of satoshis the wallet should commit to the channel
         * @property {number|Long|null} [pushSat] The number of satoshis to push to the remote side as part of the initial commitment state
         * @property {number|null} [targetConf] The target number of blocks that the funding transaction should be confirmed by.
         * @property {number|Long|null} [satPerByte] A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
         * @property {boolean|null} ["private"] Whether this channel should be private, not announced to the greater network.
         * @property {number|Long|null} [minHtlcMsat] The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
         * @property {number|null} [remoteCsvDelay] The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
         * @property {number|null} [minConfs] The minimum number of confirmations each one of your outputs used for the funding transaction must satisfy.
         * @property {boolean|null} [spendUnconfirmed] Whether unconfirmed outputs should be used as inputs for the funding transaction.
         */

        /**
         * Constructs a new OpenChannelRequest.
         * @memberof lnrpc
         * @classdesc Represents an OpenChannelRequest.
         * @implements IOpenChannelRequest
         * @constructor
         * @param {lnrpc.IOpenChannelRequest=} [properties] Properties to set
         */
        function OpenChannelRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The pubkey of the node to open a channel with
         * @member {Uint8Array} nodePubkey
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.nodePubkey = $util.newBuffer([]);

        /**
         * The hex encoded pubkey of the node to open a channel with
         * @member {string} nodePubkeyString
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.nodePubkeyString = "";

        /**
         * The number of satoshis the wallet should commit to the channel
         * @member {number|Long} localFundingAmount
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.localFundingAmount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The number of satoshis to push to the remote side as part of the initial commitment state
         * @member {number|Long} pushSat
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.pushSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The target number of blocks that the funding transaction should be confirmed by.
         * @member {number} targetConf
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.targetConf = 0;

        /**
         * A manual fee rate set in sat/byte that should be used when crafting the funding transaction.
         * @member {number|Long} satPerByte
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.satPerByte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Whether this channel should be private, not announced to the greater network.
         * @member {boolean} private
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype["private"] = false;

        /**
         * The minimum value in millisatoshi we will require for incoming HTLCs on the channel.
         * @member {number|Long} minHtlcMsat
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.minHtlcMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The delay we require on the remote's commitment transaction. If this is not set, it will be scaled automatically with the channel size.
         * @member {number} remoteCsvDelay
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.remoteCsvDelay = 0;

        /**
         * The minimum number of confirmations each one of your outputs used for the funding transaction must satisfy.
         * @member {number} minConfs
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.minConfs = 0;

        /**
         * Whether unconfirmed outputs should be used as inputs for the funding transaction.
         * @member {boolean} spendUnconfirmed
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         */
        OpenChannelRequest.prototype.spendUnconfirmed = false;

        /**
         * Creates a new OpenChannelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest=} [properties] Properties to set
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest instance
         */
        OpenChannelRequest.create = function create(properties) {
            return new OpenChannelRequest(properties);
        };

        /**
         * Encodes the specified OpenChannelRequest message. Does not implicitly {@link lnrpc.OpenChannelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest} message OpenChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenChannelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.nodePubkey);
            if (message.nodePubkeyString != null && message.hasOwnProperty("nodePubkeyString"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.nodePubkeyString);
            if (message.localFundingAmount != null && message.hasOwnProperty("localFundingAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.localFundingAmount);
            if (message.pushSat != null && message.hasOwnProperty("pushSat"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.pushSat);
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.targetConf);
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.satPerByte);
            if (message["private"] != null && message.hasOwnProperty("private"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message["private"]);
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.minHtlcMsat);
            if (message.remoteCsvDelay != null && message.hasOwnProperty("remoteCsvDelay"))
                writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.remoteCsvDelay);
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.minConfs);
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.spendUnconfirmed);
            return writer;
        };

        /**
         * Encodes the specified OpenChannelRequest message, length delimited. Does not implicitly {@link lnrpc.OpenChannelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.IOpenChannelRequest} message OpenChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenChannelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenChannelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenChannelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.OpenChannelRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.nodePubkey = reader.bytes();
                    break;
                case 3:
                    message.nodePubkeyString = reader.string();
                    break;
                case 4:
                    message.localFundingAmount = reader.int64();
                    break;
                case 5:
                    message.pushSat = reader.int64();
                    break;
                case 6:
                    message.targetConf = reader.int32();
                    break;
                case 7:
                    message.satPerByte = reader.int64();
                    break;
                case 8:
                    message["private"] = reader.bool();
                    break;
                case 9:
                    message.minHtlcMsat = reader.int64();
                    break;
                case 10:
                    message.remoteCsvDelay = reader.uint32();
                    break;
                case 11:
                    message.minConfs = reader.int32();
                    break;
                case 12:
                    message.spendUnconfirmed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenChannelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenChannelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenChannelRequest message.
         * @function verify
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenChannelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                if (!(message.nodePubkey && typeof message.nodePubkey.length === "number" || $util.isString(message.nodePubkey)))
                    return "nodePubkey: buffer expected";
            if (message.nodePubkeyString != null && message.hasOwnProperty("nodePubkeyString"))
                if (!$util.isString(message.nodePubkeyString))
                    return "nodePubkeyString: string expected";
            if (message.localFundingAmount != null && message.hasOwnProperty("localFundingAmount"))
                if (!$util.isInteger(message.localFundingAmount) && !(message.localFundingAmount && $util.isInteger(message.localFundingAmount.low) && $util.isInteger(message.localFundingAmount.high)))
                    return "localFundingAmount: integer|Long expected";
            if (message.pushSat != null && message.hasOwnProperty("pushSat"))
                if (!$util.isInteger(message.pushSat) && !(message.pushSat && $util.isInteger(message.pushSat.low) && $util.isInteger(message.pushSat.high)))
                    return "pushSat: integer|Long expected";
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                if (!$util.isInteger(message.targetConf))
                    return "targetConf: integer expected";
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (!$util.isInteger(message.satPerByte) && !(message.satPerByte && $util.isInteger(message.satPerByte.low) && $util.isInteger(message.satPerByte.high)))
                    return "satPerByte: integer|Long expected";
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (!$util.isInteger(message.minHtlcMsat) && !(message.minHtlcMsat && $util.isInteger(message.minHtlcMsat.low) && $util.isInteger(message.minHtlcMsat.high)))
                    return "minHtlcMsat: integer|Long expected";
            if (message.remoteCsvDelay != null && message.hasOwnProperty("remoteCsvDelay"))
                if (!$util.isInteger(message.remoteCsvDelay))
                    return "remoteCsvDelay: integer expected";
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                if (!$util.isInteger(message.minConfs))
                    return "minConfs: integer expected";
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                if (typeof message.spendUnconfirmed !== "boolean")
                    return "spendUnconfirmed: boolean expected";
            return null;
        };

        /**
         * Creates an OpenChannelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.OpenChannelRequest} OpenChannelRequest
         */
        OpenChannelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.OpenChannelRequest)
                return object;
            let message = new $root.lnrpc.OpenChannelRequest();
            if (object.nodePubkey != null)
                if (typeof object.nodePubkey === "string")
                    $util.base64.decode(object.nodePubkey, message.nodePubkey = $util.newBuffer($util.base64.length(object.nodePubkey)), 0);
                else if (object.nodePubkey.length)
                    message.nodePubkey = object.nodePubkey;
            if (object.nodePubkeyString != null)
                message.nodePubkeyString = String(object.nodePubkeyString);
            if (object.localFundingAmount != null)
                if ($util.Long)
                    (message.localFundingAmount = $util.Long.fromValue(object.localFundingAmount)).unsigned = false;
                else if (typeof object.localFundingAmount === "string")
                    message.localFundingAmount = parseInt(object.localFundingAmount, 10);
                else if (typeof object.localFundingAmount === "number")
                    message.localFundingAmount = object.localFundingAmount;
                else if (typeof object.localFundingAmount === "object")
                    message.localFundingAmount = new $util.LongBits(object.localFundingAmount.low >>> 0, object.localFundingAmount.high >>> 0).toNumber();
            if (object.pushSat != null)
                if ($util.Long)
                    (message.pushSat = $util.Long.fromValue(object.pushSat)).unsigned = false;
                else if (typeof object.pushSat === "string")
                    message.pushSat = parseInt(object.pushSat, 10);
                else if (typeof object.pushSat === "number")
                    message.pushSat = object.pushSat;
                else if (typeof object.pushSat === "object")
                    message.pushSat = new $util.LongBits(object.pushSat.low >>> 0, object.pushSat.high >>> 0).toNumber();
            if (object.targetConf != null)
                message.targetConf = object.targetConf | 0;
            if (object.satPerByte != null)
                if ($util.Long)
                    (message.satPerByte = $util.Long.fromValue(object.satPerByte)).unsigned = false;
                else if (typeof object.satPerByte === "string")
                    message.satPerByte = parseInt(object.satPerByte, 10);
                else if (typeof object.satPerByte === "number")
                    message.satPerByte = object.satPerByte;
                else if (typeof object.satPerByte === "object")
                    message.satPerByte = new $util.LongBits(object.satPerByte.low >>> 0, object.satPerByte.high >>> 0).toNumber();
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            if (object.minHtlcMsat != null)
                if ($util.Long)
                    (message.minHtlcMsat = $util.Long.fromValue(object.minHtlcMsat)).unsigned = false;
                else if (typeof object.minHtlcMsat === "string")
                    message.minHtlcMsat = parseInt(object.minHtlcMsat, 10);
                else if (typeof object.minHtlcMsat === "number")
                    message.minHtlcMsat = object.minHtlcMsat;
                else if (typeof object.minHtlcMsat === "object")
                    message.minHtlcMsat = new $util.LongBits(object.minHtlcMsat.low >>> 0, object.minHtlcMsat.high >>> 0).toNumber();
            if (object.remoteCsvDelay != null)
                message.remoteCsvDelay = object.remoteCsvDelay >>> 0;
            if (object.minConfs != null)
                message.minConfs = object.minConfs | 0;
            if (object.spendUnconfirmed != null)
                message.spendUnconfirmed = Boolean(object.spendUnconfirmed);
            return message;
        };

        /**
         * Creates a plain object from an OpenChannelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.OpenChannelRequest
         * @static
         * @param {lnrpc.OpenChannelRequest} message OpenChannelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenChannelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.nodePubkey = "";
                else {
                    object.nodePubkey = [];
                    if (options.bytes !== Array)
                        object.nodePubkey = $util.newBuffer(object.nodePubkey);
                }
                object.nodePubkeyString = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.localFundingAmount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.localFundingAmount = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.pushSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pushSat = options.longs === String ? "0" : 0;
                object.targetConf = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.satPerByte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.satPerByte = options.longs === String ? "0" : 0;
                object["private"] = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.minHtlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlcMsat = options.longs === String ? "0" : 0;
                object.remoteCsvDelay = 0;
                object.minConfs = 0;
                object.spendUnconfirmed = false;
            }
            if (message.nodePubkey != null && message.hasOwnProperty("nodePubkey"))
                object.nodePubkey = options.bytes === String ? $util.base64.encode(message.nodePubkey, 0, message.nodePubkey.length) : options.bytes === Array ? Array.prototype.slice.call(message.nodePubkey) : message.nodePubkey;
            if (message.nodePubkeyString != null && message.hasOwnProperty("nodePubkeyString"))
                object.nodePubkeyString = message.nodePubkeyString;
            if (message.localFundingAmount != null && message.hasOwnProperty("localFundingAmount"))
                if (typeof message.localFundingAmount === "number")
                    object.localFundingAmount = options.longs === String ? String(message.localFundingAmount) : message.localFundingAmount;
                else
                    object.localFundingAmount = options.longs === String ? $util.Long.prototype.toString.call(message.localFundingAmount) : options.longs === Number ? new $util.LongBits(message.localFundingAmount.low >>> 0, message.localFundingAmount.high >>> 0).toNumber() : message.localFundingAmount;
            if (message.pushSat != null && message.hasOwnProperty("pushSat"))
                if (typeof message.pushSat === "number")
                    object.pushSat = options.longs === String ? String(message.pushSat) : message.pushSat;
                else
                    object.pushSat = options.longs === String ? $util.Long.prototype.toString.call(message.pushSat) : options.longs === Number ? new $util.LongBits(message.pushSat.low >>> 0, message.pushSat.high >>> 0).toNumber() : message.pushSat;
            if (message.targetConf != null && message.hasOwnProperty("targetConf"))
                object.targetConf = message.targetConf;
            if (message.satPerByte != null && message.hasOwnProperty("satPerByte"))
                if (typeof message.satPerByte === "number")
                    object.satPerByte = options.longs === String ? String(message.satPerByte) : message.satPerByte;
                else
                    object.satPerByte = options.longs === String ? $util.Long.prototype.toString.call(message.satPerByte) : options.longs === Number ? new $util.LongBits(message.satPerByte.low >>> 0, message.satPerByte.high >>> 0).toNumber() : message.satPerByte;
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            if (message.minHtlcMsat != null && message.hasOwnProperty("minHtlcMsat"))
                if (typeof message.minHtlcMsat === "number")
                    object.minHtlcMsat = options.longs === String ? String(message.minHtlcMsat) : message.minHtlcMsat;
                else
                    object.minHtlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlcMsat) : options.longs === Number ? new $util.LongBits(message.minHtlcMsat.low >>> 0, message.minHtlcMsat.high >>> 0).toNumber() : message.minHtlcMsat;
            if (message.remoteCsvDelay != null && message.hasOwnProperty("remoteCsvDelay"))
                object.remoteCsvDelay = message.remoteCsvDelay;
            if (message.minConfs != null && message.hasOwnProperty("minConfs"))
                object.minConfs = message.minConfs;
            if (message.spendUnconfirmed != null && message.hasOwnProperty("spendUnconfirmed"))
                object.spendUnconfirmed = message.spendUnconfirmed;
            return object;
        };

        /**
         * Converts this OpenChannelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.OpenChannelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenChannelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpenChannelRequest;
    })();

    lnrpc.OpenStatusUpdate = (function() {

        /**
         * Properties of an OpenStatusUpdate.
         * @memberof lnrpc
         * @interface IOpenStatusUpdate
         * @property {lnrpc.IPendingUpdate|null} [chanPending] OpenStatusUpdate chanPending
         * @property {lnrpc.IChannelOpenUpdate|null} [chanOpen] OpenStatusUpdate chanOpen
         */

        /**
         * Constructs a new OpenStatusUpdate.
         * @memberof lnrpc
         * @classdesc Represents an OpenStatusUpdate.
         * @implements IOpenStatusUpdate
         * @constructor
         * @param {lnrpc.IOpenStatusUpdate=} [properties] Properties to set
         */
        function OpenStatusUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenStatusUpdate chanPending.
         * @member {lnrpc.IPendingUpdate|null|undefined} chanPending
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.chanPending = null;

        /**
         * OpenStatusUpdate chanOpen.
         * @member {lnrpc.IChannelOpenUpdate|null|undefined} chanOpen
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        OpenStatusUpdate.prototype.chanOpen = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * OpenStatusUpdate update.
         * @member {"chanPending"|"chanOpen"|undefined} update
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         */
        Object.defineProperty(OpenStatusUpdate.prototype, "update", {
            get: $util.oneOfGetter($oneOfFields = ["chanPending", "chanOpen"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new OpenStatusUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate=} [properties] Properties to set
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate instance
         */
        OpenStatusUpdate.create = function create(properties) {
            return new OpenStatusUpdate(properties);
        };

        /**
         * Encodes the specified OpenStatusUpdate message. Does not implicitly {@link lnrpc.OpenStatusUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate} message OpenStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenStatusUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPending != null && message.hasOwnProperty("chanPending"))
                $root.lnrpc.PendingUpdate.encode(message.chanPending, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.chanOpen != null && message.hasOwnProperty("chanOpen"))
                $root.lnrpc.ChannelOpenUpdate.encode(message.chanOpen, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpenStatusUpdate message, length delimited. Does not implicitly {@link lnrpc.OpenStatusUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.IOpenStatusUpdate} message OpenStatusUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenStatusUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenStatusUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenStatusUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.OpenStatusUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPending = $root.lnrpc.PendingUpdate.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.chanOpen = $root.lnrpc.ChannelOpenUpdate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenStatusUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenStatusUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenStatusUpdate message.
         * @function verify
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenStatusUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.chanPending != null && message.hasOwnProperty("chanPending")) {
                properties.update = 1;
                {
                    let error = $root.lnrpc.PendingUpdate.verify(message.chanPending);
                    if (error)
                        return "chanPending." + error;
                }
            }
            if (message.chanOpen != null && message.hasOwnProperty("chanOpen")) {
                if (properties.update === 1)
                    return "update: multiple values";
                properties.update = 1;
                {
                    let error = $root.lnrpc.ChannelOpenUpdate.verify(message.chanOpen);
                    if (error)
                        return "chanOpen." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OpenStatusUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.OpenStatusUpdate} OpenStatusUpdate
         */
        OpenStatusUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.OpenStatusUpdate)
                return object;
            let message = new $root.lnrpc.OpenStatusUpdate();
            if (object.chanPending != null) {
                if (typeof object.chanPending !== "object")
                    throw TypeError(".lnrpc.OpenStatusUpdate.chanPending: object expected");
                message.chanPending = $root.lnrpc.PendingUpdate.fromObject(object.chanPending);
            }
            if (object.chanOpen != null) {
                if (typeof object.chanOpen !== "object")
                    throw TypeError(".lnrpc.OpenStatusUpdate.chanOpen: object expected");
                message.chanOpen = $root.lnrpc.ChannelOpenUpdate.fromObject(object.chanOpen);
            }
            return message;
        };

        /**
         * Creates a plain object from an OpenStatusUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.OpenStatusUpdate
         * @static
         * @param {lnrpc.OpenStatusUpdate} message OpenStatusUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OpenStatusUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.chanPending != null && message.hasOwnProperty("chanPending")) {
                object.chanPending = $root.lnrpc.PendingUpdate.toObject(message.chanPending, options);
                if (options.oneofs)
                    object.update = "chanPending";
            }
            if (message.chanOpen != null && message.hasOwnProperty("chanOpen")) {
                object.chanOpen = $root.lnrpc.ChannelOpenUpdate.toObject(message.chanOpen, options);
                if (options.oneofs)
                    object.update = "chanOpen";
            }
            return object;
        };

        /**
         * Converts this OpenStatusUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.OpenStatusUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OpenStatusUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return OpenStatusUpdate;
    })();

    lnrpc.PendingHTLC = (function() {

        /**
         * Properties of a PendingHTLC.
         * @memberof lnrpc
         * @interface IPendingHTLC
         * @property {boolean|null} [incoming] The direction within the channel that the htlc was sent
         * @property {number|Long|null} [amount] The total value of the htlc
         * @property {string|null} [outpoint] The final output to be swept back to the user's wallet
         * @property {number|null} [maturityHeight] The next block height at which we can spend the current stage
         * @property {number|null} [blocksTilMaturity] The number of blocks remaining until the current stage can be swept.
         * Negative values indicate how many blocks have passed since becoming
         * mature.
         * @property {number|null} [stage] Indicates whether the htlc is in its first or second stage of recovery
         */

        /**
         * Constructs a new PendingHTLC.
         * @memberof lnrpc
         * @classdesc Represents a PendingHTLC.
         * @implements IPendingHTLC
         * @constructor
         * @param {lnrpc.IPendingHTLC=} [properties] Properties to set
         */
        function PendingHTLC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The direction within the channel that the htlc was sent
         * @member {boolean} incoming
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.incoming = false;

        /**
         * The total value of the htlc
         * @member {number|Long} amount
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The final output to be swept back to the user's wallet
         * @member {string} outpoint
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.outpoint = "";

        /**
         * The next block height at which we can spend the current stage
         * @member {number} maturityHeight
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.maturityHeight = 0;

        /**
         * The number of blocks remaining until the current stage can be swept.
         * Negative values indicate how many blocks have passed since becoming
         * mature.
         * @member {number} blocksTilMaturity
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.blocksTilMaturity = 0;

        /**
         * Indicates whether the htlc is in its first or second stage of recovery
         * @member {number} stage
         * @memberof lnrpc.PendingHTLC
         * @instance
         */
        PendingHTLC.prototype.stage = 0;

        /**
         * Creates a new PendingHTLC instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC=} [properties] Properties to set
         * @returns {lnrpc.PendingHTLC} PendingHTLC instance
         */
        PendingHTLC.create = function create(properties) {
            return new PendingHTLC(properties);
        };

        /**
         * Encodes the specified PendingHTLC message. Does not implicitly {@link lnrpc.PendingHTLC.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC} message PendingHTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingHTLC.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.incoming);
            if (message.amount != null && message.hasOwnProperty("amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amount);
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.outpoint);
            if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maturityHeight);
            if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blocksTilMaturity);
            if (message.stage != null && message.hasOwnProperty("stage"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.stage);
            return writer;
        };

        /**
         * Encodes the specified PendingHTLC message, length delimited. Does not implicitly {@link lnrpc.PendingHTLC.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.IPendingHTLC} message PendingHTLC message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingHTLC.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingHTLC message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingHTLC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingHTLC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.incoming = reader.bool();
                    break;
                case 2:
                    message.amount = reader.int64();
                    break;
                case 3:
                    message.outpoint = reader.string();
                    break;
                case 4:
                    message.maturityHeight = reader.uint32();
                    break;
                case 5:
                    message.blocksTilMaturity = reader.int32();
                    break;
                case 6:
                    message.stage = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingHTLC message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingHTLC.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingHTLC message.
         * @function verify
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingHTLC.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                if (typeof message.incoming !== "boolean")
                    return "incoming: boolean expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                    return "amount: integer|Long expected";
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                if (!$util.isString(message.outpoint))
                    return "outpoint: string expected";
            if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                if (!$util.isInteger(message.maturityHeight))
                    return "maturityHeight: integer expected";
            if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                if (!$util.isInteger(message.blocksTilMaturity))
                    return "blocksTilMaturity: integer expected";
            if (message.stage != null && message.hasOwnProperty("stage"))
                if (!$util.isInteger(message.stage))
                    return "stage: integer expected";
            return null;
        };

        /**
         * Creates a PendingHTLC message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingHTLC} PendingHTLC
         */
        PendingHTLC.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingHTLC)
                return object;
            let message = new $root.lnrpc.PendingHTLC();
            if (object.incoming != null)
                message.incoming = Boolean(object.incoming);
            if (object.amount != null)
                if ($util.Long)
                    (message.amount = $util.Long.fromValue(object.amount)).unsigned = false;
                else if (typeof object.amount === "string")
                    message.amount = parseInt(object.amount, 10);
                else if (typeof object.amount === "number")
                    message.amount = object.amount;
                else if (typeof object.amount === "object")
                    message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber();
            if (object.outpoint != null)
                message.outpoint = String(object.outpoint);
            if (object.maturityHeight != null)
                message.maturityHeight = object.maturityHeight >>> 0;
            if (object.blocksTilMaturity != null)
                message.blocksTilMaturity = object.blocksTilMaturity | 0;
            if (object.stage != null)
                message.stage = object.stage >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PendingHTLC message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingHTLC
         * @static
         * @param {lnrpc.PendingHTLC} message PendingHTLC
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingHTLC.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.incoming = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amount = options.longs === String ? "0" : 0;
                object.outpoint = "";
                object.maturityHeight = 0;
                object.blocksTilMaturity = 0;
                object.stage = 0;
            }
            if (message.incoming != null && message.hasOwnProperty("incoming"))
                object.incoming = message.incoming;
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (typeof message.amount === "number")
                    object.amount = options.longs === String ? String(message.amount) : message.amount;
                else
                    object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber() : message.amount;
            if (message.outpoint != null && message.hasOwnProperty("outpoint"))
                object.outpoint = message.outpoint;
            if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                object.maturityHeight = message.maturityHeight;
            if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                object.blocksTilMaturity = message.blocksTilMaturity;
            if (message.stage != null && message.hasOwnProperty("stage"))
                object.stage = message.stage;
            return object;
        };

        /**
         * Converts this PendingHTLC to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingHTLC
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingHTLC.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingHTLC;
    })();

    lnrpc.PendingChannelsRequest = (function() {

        /**
         * Properties of a PendingChannelsRequest.
         * @memberof lnrpc
         * @interface IPendingChannelsRequest
         */

        /**
         * Constructs a new PendingChannelsRequest.
         * @memberof lnrpc
         * @classdesc Represents a PendingChannelsRequest.
         * @implements IPendingChannelsRequest
         * @constructor
         * @param {lnrpc.IPendingChannelsRequest=} [properties] Properties to set
         */
        function PendingChannelsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PendingChannelsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest=} [properties] Properties to set
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest instance
         */
        PendingChannelsRequest.create = function create(properties) {
            return new PendingChannelsRequest(properties);
        };

        /**
         * Encodes the specified PendingChannelsRequest message. Does not implicitly {@link lnrpc.PendingChannelsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest} message PendingChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PendingChannelsRequest message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.IPendingChannelsRequest} message PendingChannelsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingChannelsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingChannelsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingChannelsRequest message.
         * @function verify
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingChannelsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PendingChannelsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingChannelsRequest} PendingChannelsRequest
         */
        PendingChannelsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingChannelsRequest)
                return object;
            return new $root.lnrpc.PendingChannelsRequest();
        };

        /**
         * Creates a plain object from a PendingChannelsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingChannelsRequest
         * @static
         * @param {lnrpc.PendingChannelsRequest} message PendingChannelsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingChannelsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PendingChannelsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingChannelsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingChannelsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PendingChannelsRequest;
    })();

    lnrpc.PendingChannelsResponse = (function() {

        /**
         * Properties of a PendingChannelsResponse.
         * @memberof lnrpc
         * @interface IPendingChannelsResponse
         * @property {number|Long|null} [totalLimboBalance] The balance in satoshis encumbered in pending channels
         * @property {Array.<lnrpc.PendingChannelsResponse.IPendingOpenChannel>|null} [pendingOpenChannels] Channels pending opening
         * @property {Array.<lnrpc.PendingChannelsResponse.IClosedChannel>|null} [pendingClosingChannels] Channels pending closing
         * @property {Array.<lnrpc.PendingChannelsResponse.IForceClosedChannel>|null} [pendingForceClosingChannels] Channels pending force closing
         * @property {Array.<lnrpc.PendingChannelsResponse.IWaitingCloseChannel>|null} [waitingCloseChannels] Channels waiting for closing tx to confirm
         */

        /**
         * Constructs a new PendingChannelsResponse.
         * @memberof lnrpc
         * @classdesc Represents a PendingChannelsResponse.
         * @implements IPendingChannelsResponse
         * @constructor
         * @param {lnrpc.IPendingChannelsResponse=} [properties] Properties to set
         */
        function PendingChannelsResponse(properties) {
            this.pendingOpenChannels = [];
            this.pendingClosingChannels = [];
            this.pendingForceClosingChannels = [];
            this.waitingCloseChannels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The balance in satoshis encumbered in pending channels
         * @member {number|Long} totalLimboBalance
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.totalLimboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Channels pending opening
         * @member {Array.<lnrpc.PendingChannelsResponse.IPendingOpenChannel>} pendingOpenChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingOpenChannels = $util.emptyArray;

        /**
         * Channels pending closing
         * @member {Array.<lnrpc.PendingChannelsResponse.IClosedChannel>} pendingClosingChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingClosingChannels = $util.emptyArray;

        /**
         * Channels pending force closing
         * @member {Array.<lnrpc.PendingChannelsResponse.IForceClosedChannel>} pendingForceClosingChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.pendingForceClosingChannels = $util.emptyArray;

        /**
         * Channels waiting for closing tx to confirm
         * @member {Array.<lnrpc.PendingChannelsResponse.IWaitingCloseChannel>} waitingCloseChannels
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         */
        PendingChannelsResponse.prototype.waitingCloseChannels = $util.emptyArray;

        /**
         * Creates a new PendingChannelsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse=} [properties] Properties to set
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse instance
         */
        PendingChannelsResponse.create = function create(properties) {
            return new PendingChannelsResponse(properties);
        };

        /**
         * Encodes the specified PendingChannelsResponse message. Does not implicitly {@link lnrpc.PendingChannelsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse} message PendingChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalLimboBalance != null && message.hasOwnProperty("totalLimboBalance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalLimboBalance);
            if (message.pendingOpenChannels != null && message.pendingOpenChannels.length)
                for (let i = 0; i < message.pendingOpenChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.encode(message.pendingOpenChannels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.pendingClosingChannels != null && message.pendingClosingChannels.length)
                for (let i = 0; i < message.pendingClosingChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.ClosedChannel.encode(message.pendingClosingChannels[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.pendingForceClosingChannels != null && message.pendingForceClosingChannels.length)
                for (let i = 0; i < message.pendingForceClosingChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.encode(message.pendingForceClosingChannels[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.waitingCloseChannels != null && message.waitingCloseChannels.length)
                for (let i = 0; i < message.waitingCloseChannels.length; ++i)
                    $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.encode(message.waitingCloseChannels[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PendingChannelsResponse message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.IPendingChannelsResponse} message PendingChannelsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PendingChannelsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PendingChannelsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalLimboBalance = reader.int64();
                    break;
                case 2:
                    if (!(message.pendingOpenChannels && message.pendingOpenChannels.length))
                        message.pendingOpenChannels = [];
                    message.pendingOpenChannels.push($root.lnrpc.PendingChannelsResponse.PendingOpenChannel.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.pendingClosingChannels && message.pendingClosingChannels.length))
                        message.pendingClosingChannels = [];
                    message.pendingClosingChannels.push($root.lnrpc.PendingChannelsResponse.ClosedChannel.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.pendingForceClosingChannels && message.pendingForceClosingChannels.length))
                        message.pendingForceClosingChannels = [];
                    message.pendingForceClosingChannels.push($root.lnrpc.PendingChannelsResponse.ForceClosedChannel.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.waitingCloseChannels && message.waitingCloseChannels.length))
                        message.waitingCloseChannels = [];
                    message.waitingCloseChannels.push($root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PendingChannelsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PendingChannelsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PendingChannelsResponse message.
         * @function verify
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PendingChannelsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalLimboBalance != null && message.hasOwnProperty("totalLimboBalance"))
                if (!$util.isInteger(message.totalLimboBalance) && !(message.totalLimboBalance && $util.isInteger(message.totalLimboBalance.low) && $util.isInteger(message.totalLimboBalance.high)))
                    return "totalLimboBalance: integer|Long expected";
            if (message.pendingOpenChannels != null && message.hasOwnProperty("pendingOpenChannels")) {
                if (!Array.isArray(message.pendingOpenChannels))
                    return "pendingOpenChannels: array expected";
                for (let i = 0; i < message.pendingOpenChannels.length; ++i) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.verify(message.pendingOpenChannels[i]);
                    if (error)
                        return "pendingOpenChannels." + error;
                }
            }
            if (message.pendingClosingChannels != null && message.hasOwnProperty("pendingClosingChannels")) {
                if (!Array.isArray(message.pendingClosingChannels))
                    return "pendingClosingChannels: array expected";
                for (let i = 0; i < message.pendingClosingChannels.length; ++i) {
                    let error = $root.lnrpc.PendingChannelsResponse.ClosedChannel.verify(message.pendingClosingChannels[i]);
                    if (error)
                        return "pendingClosingChannels." + error;
                }
            }
            if (message.pendingForceClosingChannels != null && message.hasOwnProperty("pendingForceClosingChannels")) {
                if (!Array.isArray(message.pendingForceClosingChannels))
                    return "pendingForceClosingChannels: array expected";
                for (let i = 0; i < message.pendingForceClosingChannels.length; ++i) {
                    let error = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.verify(message.pendingForceClosingChannels[i]);
                    if (error)
                        return "pendingForceClosingChannels." + error;
                }
            }
            if (message.waitingCloseChannels != null && message.hasOwnProperty("waitingCloseChannels")) {
                if (!Array.isArray(message.waitingCloseChannels))
                    return "waitingCloseChannels: array expected";
                for (let i = 0; i < message.waitingCloseChannels.length; ++i) {
                    let error = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify(message.waitingCloseChannels[i]);
                    if (error)
                        return "waitingCloseChannels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PendingChannelsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PendingChannelsResponse} PendingChannelsResponse
         */
        PendingChannelsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PendingChannelsResponse)
                return object;
            let message = new $root.lnrpc.PendingChannelsResponse();
            if (object.totalLimboBalance != null)
                if ($util.Long)
                    (message.totalLimboBalance = $util.Long.fromValue(object.totalLimboBalance)).unsigned = false;
                else if (typeof object.totalLimboBalance === "string")
                    message.totalLimboBalance = parseInt(object.totalLimboBalance, 10);
                else if (typeof object.totalLimboBalance === "number")
                    message.totalLimboBalance = object.totalLimboBalance;
                else if (typeof object.totalLimboBalance === "object")
                    message.totalLimboBalance = new $util.LongBits(object.totalLimboBalance.low >>> 0, object.totalLimboBalance.high >>> 0).toNumber();
            if (object.pendingOpenChannels) {
                if (!Array.isArray(object.pendingOpenChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingOpenChannels: array expected");
                message.pendingOpenChannels = [];
                for (let i = 0; i < object.pendingOpenChannels.length; ++i) {
                    if (typeof object.pendingOpenChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingOpenChannels: object expected");
                    message.pendingOpenChannels[i] = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.fromObject(object.pendingOpenChannels[i]);
                }
            }
            if (object.pendingClosingChannels) {
                if (!Array.isArray(object.pendingClosingChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingClosingChannels: array expected");
                message.pendingClosingChannels = [];
                for (let i = 0; i < object.pendingClosingChannels.length; ++i) {
                    if (typeof object.pendingClosingChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingClosingChannels: object expected");
                    message.pendingClosingChannels[i] = $root.lnrpc.PendingChannelsResponse.ClosedChannel.fromObject(object.pendingClosingChannels[i]);
                }
            }
            if (object.pendingForceClosingChannels) {
                if (!Array.isArray(object.pendingForceClosingChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.pendingForceClosingChannels: array expected");
                message.pendingForceClosingChannels = [];
                for (let i = 0; i < object.pendingForceClosingChannels.length; ++i) {
                    if (typeof object.pendingForceClosingChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.pendingForceClosingChannels: object expected");
                    message.pendingForceClosingChannels[i] = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.fromObject(object.pendingForceClosingChannels[i]);
                }
            }
            if (object.waitingCloseChannels) {
                if (!Array.isArray(object.waitingCloseChannels))
                    throw TypeError(".lnrpc.PendingChannelsResponse.waitingCloseChannels: array expected");
                message.waitingCloseChannels = [];
                for (let i = 0; i < object.waitingCloseChannels.length; ++i) {
                    if (typeof object.waitingCloseChannels[i] !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.waitingCloseChannels: object expected");
                    message.waitingCloseChannels[i] = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.fromObject(object.waitingCloseChannels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PendingChannelsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PendingChannelsResponse
         * @static
         * @param {lnrpc.PendingChannelsResponse} message PendingChannelsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PendingChannelsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.pendingOpenChannels = [];
                object.pendingClosingChannels = [];
                object.pendingForceClosingChannels = [];
                object.waitingCloseChannels = [];
            }
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalLimboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalLimboBalance = options.longs === String ? "0" : 0;
            if (message.totalLimboBalance != null && message.hasOwnProperty("totalLimboBalance"))
                if (typeof message.totalLimboBalance === "number")
                    object.totalLimboBalance = options.longs === String ? String(message.totalLimboBalance) : message.totalLimboBalance;
                else
                    object.totalLimboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.totalLimboBalance) : options.longs === Number ? new $util.LongBits(message.totalLimboBalance.low >>> 0, message.totalLimboBalance.high >>> 0).toNumber() : message.totalLimboBalance;
            if (message.pendingOpenChannels && message.pendingOpenChannels.length) {
                object.pendingOpenChannels = [];
                for (let j = 0; j < message.pendingOpenChannels.length; ++j)
                    object.pendingOpenChannels[j] = $root.lnrpc.PendingChannelsResponse.PendingOpenChannel.toObject(message.pendingOpenChannels[j], options);
            }
            if (message.pendingClosingChannels && message.pendingClosingChannels.length) {
                object.pendingClosingChannels = [];
                for (let j = 0; j < message.pendingClosingChannels.length; ++j)
                    object.pendingClosingChannels[j] = $root.lnrpc.PendingChannelsResponse.ClosedChannel.toObject(message.pendingClosingChannels[j], options);
            }
            if (message.pendingForceClosingChannels && message.pendingForceClosingChannels.length) {
                object.pendingForceClosingChannels = [];
                for (let j = 0; j < message.pendingForceClosingChannels.length; ++j)
                    object.pendingForceClosingChannels[j] = $root.lnrpc.PendingChannelsResponse.ForceClosedChannel.toObject(message.pendingForceClosingChannels[j], options);
            }
            if (message.waitingCloseChannels && message.waitingCloseChannels.length) {
                object.waitingCloseChannels = [];
                for (let j = 0; j < message.waitingCloseChannels.length; ++j)
                    object.waitingCloseChannels[j] = $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel.toObject(message.waitingCloseChannels[j], options);
            }
            return object;
        };

        /**
         * Converts this PendingChannelsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.PendingChannelsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PendingChannelsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        PendingChannelsResponse.PendingChannel = (function() {

            /**
             * Properties of a PendingChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IPendingChannel
             * @property {string|null} [remoteNodePub] PendingChannel remoteNodePub
             * @property {string|null} [channelPoint] PendingChannel channelPoint
             * @property {number|Long|null} [capacity] PendingChannel capacity
             * @property {number|Long|null} [localBalance] PendingChannel localBalance
             * @property {number|Long|null} [remoteBalance] PendingChannel remoteBalance
             * @property {number|Long|null} [localChanReserveSat] The minimum satoshis this node is required to reserve in its balance.
             * @property {number|Long|null} [remoteChanReserveSat] The minimum satoshis the other node is required to reserve in its
             * balance.
             */

            /**
             * Constructs a new PendingChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a PendingChannel.
             * @implements IPendingChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel=} [properties] Properties to set
             */
            function PendingChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PendingChannel remoteNodePub.
             * @member {string} remoteNodePub
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.remoteNodePub = "";

            /**
             * PendingChannel channelPoint.
             * @member {string} channelPoint
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.channelPoint = "";

            /**
             * PendingChannel capacity.
             * @member {number|Long} capacity
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel localBalance.
             * @member {number|Long} localBalance
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.localBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * PendingChannel remoteBalance.
             * @member {number|Long} remoteBalance
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.remoteBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The minimum satoshis this node is required to reserve in its balance.
             * @member {number|Long} localChanReserveSat
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.localChanReserveSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The minimum satoshis the other node is required to reserve in its
             * balance.
             * @member {number|Long} remoteChanReserveSat
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             */
            PendingChannel.prototype.remoteChanReserveSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PendingChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel instance
             */
            PendingChannel.create = function create(properties) {
                return new PendingChannel(properties);
            };

            /**
             * Encodes the specified PendingChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel} message PendingChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.remoteNodePub != null && message.hasOwnProperty("remoteNodePub"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.remoteNodePub);
                if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelPoint);
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.capacity);
                if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.localBalance);
                if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.remoteBalance);
                if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.localChanReserveSat);
                if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.remoteChanReserveSat);
                return writer;
            };

            /**
             * Encodes the specified PendingChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingChannel} message PendingChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PendingChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.PendingChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.remoteNodePub = reader.string();
                        break;
                    case 2:
                        message.channelPoint = reader.string();
                        break;
                    case 3:
                        message.capacity = reader.int64();
                        break;
                    case 4:
                        message.localBalance = reader.int64();
                        break;
                    case 5:
                        message.remoteBalance = reader.int64();
                        break;
                    case 6:
                        message.localChanReserveSat = reader.int64();
                        break;
                    case 7:
                        message.remoteChanReserveSat = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PendingChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PendingChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PendingChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.remoteNodePub != null && message.hasOwnProperty("remoteNodePub"))
                    if (!$util.isString(message.remoteNodePub))
                        return "remoteNodePub: string expected";
                if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                    if (!$util.isString(message.channelPoint))
                        return "channelPoint: string expected";
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                        return "capacity: integer|Long expected";
                if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                    if (!$util.isInteger(message.localBalance) && !(message.localBalance && $util.isInteger(message.localBalance.low) && $util.isInteger(message.localBalance.high)))
                        return "localBalance: integer|Long expected";
                if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                    if (!$util.isInteger(message.remoteBalance) && !(message.remoteBalance && $util.isInteger(message.remoteBalance.low) && $util.isInteger(message.remoteBalance.high)))
                        return "remoteBalance: integer|Long expected";
                if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                    if (!$util.isInteger(message.localChanReserveSat) && !(message.localChanReserveSat && $util.isInteger(message.localChanReserveSat.low) && $util.isInteger(message.localChanReserveSat.high)))
                        return "localChanReserveSat: integer|Long expected";
                if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                    if (!$util.isInteger(message.remoteChanReserveSat) && !(message.remoteChanReserveSat && $util.isInteger(message.remoteChanReserveSat.low) && $util.isInteger(message.remoteChanReserveSat.high)))
                        return "remoteChanReserveSat: integer|Long expected";
                return null;
            };

            /**
             * Creates a PendingChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.PendingChannel} PendingChannel
             */
            PendingChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.PendingChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.PendingChannel();
                if (object.remoteNodePub != null)
                    message.remoteNodePub = String(object.remoteNodePub);
                if (object.channelPoint != null)
                    message.channelPoint = String(object.channelPoint);
                if (object.capacity != null)
                    if ($util.Long)
                        (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                    else if (typeof object.capacity === "string")
                        message.capacity = parseInt(object.capacity, 10);
                    else if (typeof object.capacity === "number")
                        message.capacity = object.capacity;
                    else if (typeof object.capacity === "object")
                        message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
                if (object.localBalance != null)
                    if ($util.Long)
                        (message.localBalance = $util.Long.fromValue(object.localBalance)).unsigned = false;
                    else if (typeof object.localBalance === "string")
                        message.localBalance = parseInt(object.localBalance, 10);
                    else if (typeof object.localBalance === "number")
                        message.localBalance = object.localBalance;
                    else if (typeof object.localBalance === "object")
                        message.localBalance = new $util.LongBits(object.localBalance.low >>> 0, object.localBalance.high >>> 0).toNumber();
                if (object.remoteBalance != null)
                    if ($util.Long)
                        (message.remoteBalance = $util.Long.fromValue(object.remoteBalance)).unsigned = false;
                    else if (typeof object.remoteBalance === "string")
                        message.remoteBalance = parseInt(object.remoteBalance, 10);
                    else if (typeof object.remoteBalance === "number")
                        message.remoteBalance = object.remoteBalance;
                    else if (typeof object.remoteBalance === "object")
                        message.remoteBalance = new $util.LongBits(object.remoteBalance.low >>> 0, object.remoteBalance.high >>> 0).toNumber();
                if (object.localChanReserveSat != null)
                    if ($util.Long)
                        (message.localChanReserveSat = $util.Long.fromValue(object.localChanReserveSat)).unsigned = false;
                    else if (typeof object.localChanReserveSat === "string")
                        message.localChanReserveSat = parseInt(object.localChanReserveSat, 10);
                    else if (typeof object.localChanReserveSat === "number")
                        message.localChanReserveSat = object.localChanReserveSat;
                    else if (typeof object.localChanReserveSat === "object")
                        message.localChanReserveSat = new $util.LongBits(object.localChanReserveSat.low >>> 0, object.localChanReserveSat.high >>> 0).toNumber();
                if (object.remoteChanReserveSat != null)
                    if ($util.Long)
                        (message.remoteChanReserveSat = $util.Long.fromValue(object.remoteChanReserveSat)).unsigned = false;
                    else if (typeof object.remoteChanReserveSat === "string")
                        message.remoteChanReserveSat = parseInt(object.remoteChanReserveSat, 10);
                    else if (typeof object.remoteChanReserveSat === "number")
                        message.remoteChanReserveSat = object.remoteChanReserveSat;
                    else if (typeof object.remoteChanReserveSat === "object")
                        message.remoteChanReserveSat = new $util.LongBits(object.remoteChanReserveSat.low >>> 0, object.remoteChanReserveSat.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a PendingChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.PendingChannel} message PendingChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PendingChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.remoteNodePub = "";
                    object.channelPoint = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.capacity = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.localBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.localBalance = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.remoteBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remoteBalance = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.localChanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.localChanReserveSat = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.remoteChanReserveSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.remoteChanReserveSat = options.longs === String ? "0" : 0;
                }
                if (message.remoteNodePub != null && message.hasOwnProperty("remoteNodePub"))
                    object.remoteNodePub = message.remoteNodePub;
                if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                    object.channelPoint = message.channelPoint;
                if (message.capacity != null && message.hasOwnProperty("capacity"))
                    if (typeof message.capacity === "number")
                        object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                    else
                        object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
                if (message.localBalance != null && message.hasOwnProperty("localBalance"))
                    if (typeof message.localBalance === "number")
                        object.localBalance = options.longs === String ? String(message.localBalance) : message.localBalance;
                    else
                        object.localBalance = options.longs === String ? $util.Long.prototype.toString.call(message.localBalance) : options.longs === Number ? new $util.LongBits(message.localBalance.low >>> 0, message.localBalance.high >>> 0).toNumber() : message.localBalance;
                if (message.remoteBalance != null && message.hasOwnProperty("remoteBalance"))
                    if (typeof message.remoteBalance === "number")
                        object.remoteBalance = options.longs === String ? String(message.remoteBalance) : message.remoteBalance;
                    else
                        object.remoteBalance = options.longs === String ? $util.Long.prototype.toString.call(message.remoteBalance) : options.longs === Number ? new $util.LongBits(message.remoteBalance.low >>> 0, message.remoteBalance.high >>> 0).toNumber() : message.remoteBalance;
                if (message.localChanReserveSat != null && message.hasOwnProperty("localChanReserveSat"))
                    if (typeof message.localChanReserveSat === "number")
                        object.localChanReserveSat = options.longs === String ? String(message.localChanReserveSat) : message.localChanReserveSat;
                    else
                        object.localChanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.localChanReserveSat) : options.longs === Number ? new $util.LongBits(message.localChanReserveSat.low >>> 0, message.localChanReserveSat.high >>> 0).toNumber() : message.localChanReserveSat;
                if (message.remoteChanReserveSat != null && message.hasOwnProperty("remoteChanReserveSat"))
                    if (typeof message.remoteChanReserveSat === "number")
                        object.remoteChanReserveSat = options.longs === String ? String(message.remoteChanReserveSat) : message.remoteChanReserveSat;
                    else
                        object.remoteChanReserveSat = options.longs === String ? $util.Long.prototype.toString.call(message.remoteChanReserveSat) : options.longs === Number ? new $util.LongBits(message.remoteChanReserveSat.low >>> 0, message.remoteChanReserveSat.high >>> 0).toNumber() : message.remoteChanReserveSat;
                return object;
            };

            /**
             * Converts this PendingChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.PendingChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PendingChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PendingChannel;
        })();

        PendingChannelsResponse.PendingOpenChannel = (function() {

            /**
             * Properties of a PendingOpenChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IPendingOpenChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] The pending channel
             * @property {number|null} [confirmationHeight] The height at which this channel will be confirmed
             * @property {number|Long|null} [commitFee] The amount calculated to be paid in fees for the current set of
             * commitment transactions. The fee amount is persisted with the channel
             * in order to allow the fee amount to be removed and recalculated with
             * each channel state update, including updates that happen after a system
             * restart.
             * @property {number|Long|null} [commitWeight] The weight of the commitment transaction
             * @property {number|Long|null} [feePerKw] The required number of satoshis per kilo-weight that the requester will
             * pay at all times, for both the funding transaction and commitment
             * transaction. This value can later be updated once the channel is open.
             */

            /**
             * Constructs a new PendingOpenChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a PendingOpenChannel.
             * @implements IPendingOpenChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel=} [properties] Properties to set
             */
            function PendingOpenChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pending channel
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.channel = null;

            /**
             * The height at which this channel will be confirmed
             * @member {number} confirmationHeight
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.confirmationHeight = 0;

            /**
             * The amount calculated to be paid in fees for the current set of
             * commitment transactions. The fee amount is persisted with the channel
             * in order to allow the fee amount to be removed and recalculated with
             * each channel state update, including updates that happen after a system
             * restart.
             * @member {number|Long} commitFee
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.commitFee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The weight of the commitment transaction
             * @member {number|Long} commitWeight
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.commitWeight = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The required number of satoshis per kilo-weight that the requester will
             * pay at all times, for both the funding transaction and commitment
             * transaction. This value can later be updated once the channel is open.
             * @member {number|Long} feePerKw
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             */
            PendingOpenChannel.prototype.feePerKw = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new PendingOpenChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel instance
             */
            PendingOpenChannel.create = function create(properties) {
                return new PendingOpenChannel(properties);
            };

            /**
             * Encodes the specified PendingOpenChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingOpenChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel} message PendingOpenChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingOpenChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.confirmationHeight != null && message.hasOwnProperty("confirmationHeight"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.confirmationHeight);
                if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.commitFee);
                if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.commitWeight);
                if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.feePerKw);
                return writer;
            };

            /**
             * Encodes the specified PendingOpenChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.PendingOpenChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IPendingOpenChannel} message PendingOpenChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PendingOpenChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PendingOpenChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingOpenChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.PendingOpenChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.confirmationHeight = reader.uint32();
                        break;
                    case 4:
                        message.commitFee = reader.int64();
                        break;
                    case 5:
                        message.commitWeight = reader.int64();
                        break;
                    case 6:
                        message.feePerKw = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PendingOpenChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PendingOpenChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PendingOpenChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PendingOpenChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.confirmationHeight != null && message.hasOwnProperty("confirmationHeight"))
                    if (!$util.isInteger(message.confirmationHeight))
                        return "confirmationHeight: integer expected";
                if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                    if (!$util.isInteger(message.commitFee) && !(message.commitFee && $util.isInteger(message.commitFee.low) && $util.isInteger(message.commitFee.high)))
                        return "commitFee: integer|Long expected";
                if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                    if (!$util.isInteger(message.commitWeight) && !(message.commitWeight && $util.isInteger(message.commitWeight.low) && $util.isInteger(message.commitWeight.high)))
                        return "commitWeight: integer|Long expected";
                if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                    if (!$util.isInteger(message.feePerKw) && !(message.feePerKw && $util.isInteger(message.feePerKw.low) && $util.isInteger(message.feePerKw.high)))
                        return "feePerKw: integer|Long expected";
                return null;
            };

            /**
             * Creates a PendingOpenChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.PendingOpenChannel} PendingOpenChannel
             */
            PendingOpenChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.PendingOpenChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.PendingOpenChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.PendingOpenChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.confirmationHeight != null)
                    message.confirmationHeight = object.confirmationHeight >>> 0;
                if (object.commitFee != null)
                    if ($util.Long)
                        (message.commitFee = $util.Long.fromValue(object.commitFee)).unsigned = false;
                    else if (typeof object.commitFee === "string")
                        message.commitFee = parseInt(object.commitFee, 10);
                    else if (typeof object.commitFee === "number")
                        message.commitFee = object.commitFee;
                    else if (typeof object.commitFee === "object")
                        message.commitFee = new $util.LongBits(object.commitFee.low >>> 0, object.commitFee.high >>> 0).toNumber();
                if (object.commitWeight != null)
                    if ($util.Long)
                        (message.commitWeight = $util.Long.fromValue(object.commitWeight)).unsigned = false;
                    else if (typeof object.commitWeight === "string")
                        message.commitWeight = parseInt(object.commitWeight, 10);
                    else if (typeof object.commitWeight === "number")
                        message.commitWeight = object.commitWeight;
                    else if (typeof object.commitWeight === "object")
                        message.commitWeight = new $util.LongBits(object.commitWeight.low >>> 0, object.commitWeight.high >>> 0).toNumber();
                if (object.feePerKw != null)
                    if ($util.Long)
                        (message.feePerKw = $util.Long.fromValue(object.feePerKw)).unsigned = false;
                    else if (typeof object.feePerKw === "string")
                        message.feePerKw = parseInt(object.feePerKw, 10);
                    else if (typeof object.feePerKw === "number")
                        message.feePerKw = object.feePerKw;
                    else if (typeof object.feePerKw === "object")
                        message.feePerKw = new $util.LongBits(object.feePerKw.low >>> 0, object.feePerKw.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a PendingOpenChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.PendingOpenChannel} message PendingOpenChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PendingOpenChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.channel = null;
                    object.confirmationHeight = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.commitFee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.commitFee = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.commitWeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.commitWeight = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.feePerKw = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.feePerKw = options.longs === String ? "0" : 0;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.confirmationHeight != null && message.hasOwnProperty("confirmationHeight"))
                    object.confirmationHeight = message.confirmationHeight;
                if (message.commitFee != null && message.hasOwnProperty("commitFee"))
                    if (typeof message.commitFee === "number")
                        object.commitFee = options.longs === String ? String(message.commitFee) : message.commitFee;
                    else
                        object.commitFee = options.longs === String ? $util.Long.prototype.toString.call(message.commitFee) : options.longs === Number ? new $util.LongBits(message.commitFee.low >>> 0, message.commitFee.high >>> 0).toNumber() : message.commitFee;
                if (message.commitWeight != null && message.hasOwnProperty("commitWeight"))
                    if (typeof message.commitWeight === "number")
                        object.commitWeight = options.longs === String ? String(message.commitWeight) : message.commitWeight;
                    else
                        object.commitWeight = options.longs === String ? $util.Long.prototype.toString.call(message.commitWeight) : options.longs === Number ? new $util.LongBits(message.commitWeight.low >>> 0, message.commitWeight.high >>> 0).toNumber() : message.commitWeight;
                if (message.feePerKw != null && message.hasOwnProperty("feePerKw"))
                    if (typeof message.feePerKw === "number")
                        object.feePerKw = options.longs === String ? String(message.feePerKw) : message.feePerKw;
                    else
                        object.feePerKw = options.longs === String ? $util.Long.prototype.toString.call(message.feePerKw) : options.longs === Number ? new $util.LongBits(message.feePerKw.low >>> 0, message.feePerKw.high >>> 0).toNumber() : message.feePerKw;
                return object;
            };

            /**
             * Converts this PendingOpenChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.PendingOpenChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PendingOpenChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return PendingOpenChannel;
        })();

        PendingChannelsResponse.WaitingCloseChannel = (function() {

            /**
             * Properties of a WaitingCloseChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IWaitingCloseChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] The pending channel waiting for closing tx to confirm
             * @property {number|Long|null} [limboBalance] The balance in satoshis encumbered in this channel
             */

            /**
             * Constructs a new WaitingCloseChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a WaitingCloseChannel.
             * @implements IWaitingCloseChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel=} [properties] Properties to set
             */
            function WaitingCloseChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pending channel waiting for closing tx to confirm
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             */
            WaitingCloseChannel.prototype.channel = null;

            /**
             * The balance in satoshis encumbered in this channel
             * @member {number|Long} limboBalance
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             */
            WaitingCloseChannel.prototype.limboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new WaitingCloseChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel instance
             */
            WaitingCloseChannel.create = function create(properties) {
                return new WaitingCloseChannel(properties);
            };

            /**
             * Encodes the specified WaitingCloseChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel} message WaitingCloseChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitingCloseChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.limboBalance);
                return writer;
            };

            /**
             * Encodes the specified WaitingCloseChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.WaitingCloseChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IWaitingCloseChannel} message WaitingCloseChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WaitingCloseChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WaitingCloseChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitingCloseChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.limboBalance = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WaitingCloseChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WaitingCloseChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WaitingCloseChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WaitingCloseChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (!$util.isInteger(message.limboBalance) && !(message.limboBalance && $util.isInteger(message.limboBalance.low) && $util.isInteger(message.limboBalance.high)))
                        return "limboBalance: integer|Long expected";
                return null;
            };

            /**
             * Creates a WaitingCloseChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.WaitingCloseChannel} WaitingCloseChannel
             */
            WaitingCloseChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.WaitingCloseChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.WaitingCloseChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.limboBalance != null)
                    if ($util.Long)
                        (message.limboBalance = $util.Long.fromValue(object.limboBalance)).unsigned = false;
                    else if (typeof object.limboBalance === "string")
                        message.limboBalance = parseInt(object.limboBalance, 10);
                    else if (typeof object.limboBalance === "number")
                        message.limboBalance = object.limboBalance;
                    else if (typeof object.limboBalance === "object")
                        message.limboBalance = new $util.LongBits(object.limboBalance.low >>> 0, object.limboBalance.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a WaitingCloseChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.WaitingCloseChannel} message WaitingCloseChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WaitingCloseChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.channel = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.limboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limboBalance = options.longs === String ? "0" : 0;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (typeof message.limboBalance === "number")
                        object.limboBalance = options.longs === String ? String(message.limboBalance) : message.limboBalance;
                    else
                        object.limboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.limboBalance) : options.longs === Number ? new $util.LongBits(message.limboBalance.low >>> 0, message.limboBalance.high >>> 0).toNumber() : message.limboBalance;
                return object;
            };

            /**
             * Converts this WaitingCloseChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.WaitingCloseChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WaitingCloseChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return WaitingCloseChannel;
        })();

        PendingChannelsResponse.ClosedChannel = (function() {

            /**
             * Properties of a ClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IClosedChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] The pending channel to be closed
             * @property {string|null} [closingTxid] The transaction id of the closing transaction
             */

            /**
             * Constructs a new ClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a ClosedChannel.
             * @implements IClosedChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel=} [properties] Properties to set
             */
            function ClosedChannel(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pending channel to be closed
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             */
            ClosedChannel.prototype.channel = null;

            /**
             * The transaction id of the closing transaction
             * @member {string} closingTxid
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             */
            ClosedChannel.prototype.closingTxid = "";

            /**
             * Creates a new ClosedChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel instance
             */
            ClosedChannel.create = function create(properties) {
                return new ClosedChannel(properties);
            };

            /**
             * Encodes the specified ClosedChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.ClosedChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel} message ClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClosedChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.closingTxid);
                return writer;
            };

            /**
             * Encodes the specified ClosedChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.ClosedChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IClosedChannel} message ClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClosedChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClosedChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClosedChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.ClosedChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.closingTxid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClosedChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClosedChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClosedChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClosedChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    if (!$util.isString(message.closingTxid))
                        return "closingTxid: string expected";
                return null;
            };

            /**
             * Creates a ClosedChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.ClosedChannel} ClosedChannel
             */
            ClosedChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.ClosedChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.ClosedChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.ClosedChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.closingTxid != null)
                    message.closingTxid = String(object.closingTxid);
                return message;
            };

            /**
             * Creates a plain object from a ClosedChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.ClosedChannel} message ClosedChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClosedChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.channel = null;
                    object.closingTxid = "";
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    object.closingTxid = message.closingTxid;
                return object;
            };

            /**
             * Converts this ClosedChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.ClosedChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClosedChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ClosedChannel;
        })();

        PendingChannelsResponse.ForceClosedChannel = (function() {

            /**
             * Properties of a ForceClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @interface IForceClosedChannel
             * @property {lnrpc.PendingChannelsResponse.IPendingChannel|null} [channel] The pending channel to be force closed
             * @property {string|null} [closingTxid] The transaction id of the closing transaction
             * @property {number|Long|null} [limboBalance] The balance in satoshis encumbered in this pending channel
             * @property {number|null} [maturityHeight] The height at which funds can be swept into the wallet
             * @property {number|null} [blocksTilMaturity] ForceClosedChannel blocksTilMaturity
             * @property {number|Long|null} [recoveredBalance] The total value of funds successfully recovered from this channel
             * @property {Array.<lnrpc.IPendingHTLC>|null} [pendingHtlcs] ForceClosedChannel pendingHtlcs
             */

            /**
             * Constructs a new ForceClosedChannel.
             * @memberof lnrpc.PendingChannelsResponse
             * @classdesc Represents a ForceClosedChannel.
             * @implements IForceClosedChannel
             * @constructor
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel=} [properties] Properties to set
             */
            function ForceClosedChannel(properties) {
                this.pendingHtlcs = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * The pending channel to be force closed
             * @member {lnrpc.PendingChannelsResponse.IPendingChannel|null|undefined} channel
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.channel = null;

            /**
             * The transaction id of the closing transaction
             * @member {string} closingTxid
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.closingTxid = "";

            /**
             * The balance in satoshis encumbered in this pending channel
             * @member {number|Long} limboBalance
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.limboBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * The height at which funds can be swept into the wallet
             * @member {number} maturityHeight
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.maturityHeight = 0;

            /**
             * ForceClosedChannel blocksTilMaturity.
             * @member {number} blocksTilMaturity
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.blocksTilMaturity = 0;

            /**
             * The total value of funds successfully recovered from this channel
             * @member {number|Long} recoveredBalance
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.recoveredBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * ForceClosedChannel pendingHtlcs.
             * @member {Array.<lnrpc.IPendingHTLC>} pendingHtlcs
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             */
            ForceClosedChannel.prototype.pendingHtlcs = $util.emptyArray;

            /**
             * Creates a new ForceClosedChannel instance using the specified properties.
             * @function create
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel=} [properties] Properties to set
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel instance
             */
            ForceClosedChannel.create = function create(properties) {
                return new ForceClosedChannel(properties);
            };

            /**
             * Encodes the specified ForceClosedChannel message. Does not implicitly {@link lnrpc.PendingChannelsResponse.ForceClosedChannel.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel} message ForceClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceClosedChannel.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && message.hasOwnProperty("channel"))
                    $root.lnrpc.PendingChannelsResponse.PendingChannel.encode(message.channel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.closingTxid);
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.limboBalance);
                if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maturityHeight);
                if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.blocksTilMaturity);
                if (message.recoveredBalance != null && message.hasOwnProperty("recoveredBalance"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.recoveredBalance);
                if (message.pendingHtlcs != null && message.pendingHtlcs.length)
                    for (let i = 0; i < message.pendingHtlcs.length; ++i)
                        $root.lnrpc.PendingHTLC.encode(message.pendingHtlcs[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ForceClosedChannel message, length delimited. Does not implicitly {@link lnrpc.PendingChannelsResponse.ForceClosedChannel.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.IForceClosedChannel} message ForceClosedChannel message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceClosedChannel.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForceClosedChannel message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceClosedChannel.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PendingChannelsResponse.ForceClosedChannel();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.closingTxid = reader.string();
                        break;
                    case 3:
                        message.limboBalance = reader.int64();
                        break;
                    case 4:
                        message.maturityHeight = reader.uint32();
                        break;
                    case 5:
                        message.blocksTilMaturity = reader.int32();
                        break;
                    case 6:
                        message.recoveredBalance = reader.int64();
                        break;
                    case 8:
                        if (!(message.pendingHtlcs && message.pendingHtlcs.length))
                            message.pendingHtlcs = [];
                        message.pendingHtlcs.push($root.lnrpc.PendingHTLC.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForceClosedChannel message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceClosedChannel.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForceClosedChannel message.
             * @function verify
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForceClosedChannel.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channel != null && message.hasOwnProperty("channel")) {
                    let error = $root.lnrpc.PendingChannelsResponse.PendingChannel.verify(message.channel);
                    if (error)
                        return "channel." + error;
                }
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    if (!$util.isString(message.closingTxid))
                        return "closingTxid: string expected";
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (!$util.isInteger(message.limboBalance) && !(message.limboBalance && $util.isInteger(message.limboBalance.low) && $util.isInteger(message.limboBalance.high)))
                        return "limboBalance: integer|Long expected";
                if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                    if (!$util.isInteger(message.maturityHeight))
                        return "maturityHeight: integer expected";
                if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                    if (!$util.isInteger(message.blocksTilMaturity))
                        return "blocksTilMaturity: integer expected";
                if (message.recoveredBalance != null && message.hasOwnProperty("recoveredBalance"))
                    if (!$util.isInteger(message.recoveredBalance) && !(message.recoveredBalance && $util.isInteger(message.recoveredBalance.low) && $util.isInteger(message.recoveredBalance.high)))
                        return "recoveredBalance: integer|Long expected";
                if (message.pendingHtlcs != null && message.hasOwnProperty("pendingHtlcs")) {
                    if (!Array.isArray(message.pendingHtlcs))
                        return "pendingHtlcs: array expected";
                    for (let i = 0; i < message.pendingHtlcs.length; ++i) {
                        let error = $root.lnrpc.PendingHTLC.verify(message.pendingHtlcs[i]);
                        if (error)
                            return "pendingHtlcs." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ForceClosedChannel message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.PendingChannelsResponse.ForceClosedChannel} ForceClosedChannel
             */
            ForceClosedChannel.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.PendingChannelsResponse.ForceClosedChannel)
                    return object;
                let message = new $root.lnrpc.PendingChannelsResponse.ForceClosedChannel();
                if (object.channel != null) {
                    if (typeof object.channel !== "object")
                        throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.channel: object expected");
                    message.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.fromObject(object.channel);
                }
                if (object.closingTxid != null)
                    message.closingTxid = String(object.closingTxid);
                if (object.limboBalance != null)
                    if ($util.Long)
                        (message.limboBalance = $util.Long.fromValue(object.limboBalance)).unsigned = false;
                    else if (typeof object.limboBalance === "string")
                        message.limboBalance = parseInt(object.limboBalance, 10);
                    else if (typeof object.limboBalance === "number")
                        message.limboBalance = object.limboBalance;
                    else if (typeof object.limboBalance === "object")
                        message.limboBalance = new $util.LongBits(object.limboBalance.low >>> 0, object.limboBalance.high >>> 0).toNumber();
                if (object.maturityHeight != null)
                    message.maturityHeight = object.maturityHeight >>> 0;
                if (object.blocksTilMaturity != null)
                    message.blocksTilMaturity = object.blocksTilMaturity | 0;
                if (object.recoveredBalance != null)
                    if ($util.Long)
                        (message.recoveredBalance = $util.Long.fromValue(object.recoveredBalance)).unsigned = false;
                    else if (typeof object.recoveredBalance === "string")
                        message.recoveredBalance = parseInt(object.recoveredBalance, 10);
                    else if (typeof object.recoveredBalance === "number")
                        message.recoveredBalance = object.recoveredBalance;
                    else if (typeof object.recoveredBalance === "object")
                        message.recoveredBalance = new $util.LongBits(object.recoveredBalance.low >>> 0, object.recoveredBalance.high >>> 0).toNumber();
                if (object.pendingHtlcs) {
                    if (!Array.isArray(object.pendingHtlcs))
                        throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.pendingHtlcs: array expected");
                    message.pendingHtlcs = [];
                    for (let i = 0; i < object.pendingHtlcs.length; ++i) {
                        if (typeof object.pendingHtlcs[i] !== "object")
                            throw TypeError(".lnrpc.PendingChannelsResponse.ForceClosedChannel.pendingHtlcs: object expected");
                        message.pendingHtlcs[i] = $root.lnrpc.PendingHTLC.fromObject(object.pendingHtlcs[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ForceClosedChannel message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @static
             * @param {lnrpc.PendingChannelsResponse.ForceClosedChannel} message ForceClosedChannel
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForceClosedChannel.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.pendingHtlcs = [];
                if (options.defaults) {
                    object.channel = null;
                    object.closingTxid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.limboBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limboBalance = options.longs === String ? "0" : 0;
                    object.maturityHeight = 0;
                    object.blocksTilMaturity = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.recoveredBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.recoveredBalance = options.longs === String ? "0" : 0;
                }
                if (message.channel != null && message.hasOwnProperty("channel"))
                    object.channel = $root.lnrpc.PendingChannelsResponse.PendingChannel.toObject(message.channel, options);
                if (message.closingTxid != null && message.hasOwnProperty("closingTxid"))
                    object.closingTxid = message.closingTxid;
                if (message.limboBalance != null && message.hasOwnProperty("limboBalance"))
                    if (typeof message.limboBalance === "number")
                        object.limboBalance = options.longs === String ? String(message.limboBalance) : message.limboBalance;
                    else
                        object.limboBalance = options.longs === String ? $util.Long.prototype.toString.call(message.limboBalance) : options.longs === Number ? new $util.LongBits(message.limboBalance.low >>> 0, message.limboBalance.high >>> 0).toNumber() : message.limboBalance;
                if (message.maturityHeight != null && message.hasOwnProperty("maturityHeight"))
                    object.maturityHeight = message.maturityHeight;
                if (message.blocksTilMaturity != null && message.hasOwnProperty("blocksTilMaturity"))
                    object.blocksTilMaturity = message.blocksTilMaturity;
                if (message.recoveredBalance != null && message.hasOwnProperty("recoveredBalance"))
                    if (typeof message.recoveredBalance === "number")
                        object.recoveredBalance = options.longs === String ? String(message.recoveredBalance) : message.recoveredBalance;
                    else
                        object.recoveredBalance = options.longs === String ? $util.Long.prototype.toString.call(message.recoveredBalance) : options.longs === Number ? new $util.LongBits(message.recoveredBalance.low >>> 0, message.recoveredBalance.high >>> 0).toNumber() : message.recoveredBalance;
                if (message.pendingHtlcs && message.pendingHtlcs.length) {
                    object.pendingHtlcs = [];
                    for (let j = 0; j < message.pendingHtlcs.length; ++j)
                        object.pendingHtlcs[j] = $root.lnrpc.PendingHTLC.toObject(message.pendingHtlcs[j], options);
                }
                return object;
            };

            /**
             * Converts this ForceClosedChannel to JSON.
             * @function toJSON
             * @memberof lnrpc.PendingChannelsResponse.ForceClosedChannel
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForceClosedChannel.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ForceClosedChannel;
        })();

        return PendingChannelsResponse;
    })();

    lnrpc.ChannelEventSubscription = (function() {

        /**
         * Properties of a ChannelEventSubscription.
         * @memberof lnrpc
         * @interface IChannelEventSubscription
         */

        /**
         * Constructs a new ChannelEventSubscription.
         * @memberof lnrpc
         * @classdesc Represents a ChannelEventSubscription.
         * @implements IChannelEventSubscription
         * @constructor
         * @param {lnrpc.IChannelEventSubscription=} [properties] Properties to set
         */
        function ChannelEventSubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelEventSubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {lnrpc.IChannelEventSubscription=} [properties] Properties to set
         * @returns {lnrpc.ChannelEventSubscription} ChannelEventSubscription instance
         */
        ChannelEventSubscription.create = function create(properties) {
            return new ChannelEventSubscription(properties);
        };

        /**
         * Encodes the specified ChannelEventSubscription message. Does not implicitly {@link lnrpc.ChannelEventSubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {lnrpc.IChannelEventSubscription} message ChannelEventSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEventSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelEventSubscription message, length delimited. Does not implicitly {@link lnrpc.ChannelEventSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {lnrpc.IChannelEventSubscription} message ChannelEventSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEventSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEventSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEventSubscription} ChannelEventSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEventSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEventSubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEventSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEventSubscription} ChannelEventSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEventSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEventSubscription message.
         * @function verify
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEventSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelEventSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEventSubscription} ChannelEventSubscription
         */
        ChannelEventSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEventSubscription)
                return object;
            return new $root.lnrpc.ChannelEventSubscription();
        };

        /**
         * Creates a plain object from a ChannelEventSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEventSubscription
         * @static
         * @param {lnrpc.ChannelEventSubscription} message ChannelEventSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEventSubscription.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelEventSubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEventSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEventSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelEventSubscription;
    })();

    lnrpc.ChannelEventUpdate = (function() {

        /**
         * Properties of a ChannelEventUpdate.
         * @memberof lnrpc
         * @interface IChannelEventUpdate
         * @property {lnrpc.IChannel|null} [openChannel] ChannelEventUpdate openChannel
         * @property {lnrpc.IChannelCloseSummary|null} [closedChannel] ChannelEventUpdate closedChannel
         * @property {lnrpc.IChannelPoint|null} [activeChannel] ChannelEventUpdate activeChannel
         * @property {lnrpc.IChannelPoint|null} [inactiveChannel] ChannelEventUpdate inactiveChannel
         * @property {lnrpc.ChannelEventUpdate.UpdateType|null} [type] ChannelEventUpdate type
         */

        /**
         * Constructs a new ChannelEventUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelEventUpdate.
         * @implements IChannelEventUpdate
         * @constructor
         * @param {lnrpc.IChannelEventUpdate=} [properties] Properties to set
         */
        function ChannelEventUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChannelEventUpdate openChannel.
         * @member {lnrpc.IChannel|null|undefined} openChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.openChannel = null;

        /**
         * ChannelEventUpdate closedChannel.
         * @member {lnrpc.IChannelCloseSummary|null|undefined} closedChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.closedChannel = null;

        /**
         * ChannelEventUpdate activeChannel.
         * @member {lnrpc.IChannelPoint|null|undefined} activeChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.activeChannel = null;

        /**
         * ChannelEventUpdate inactiveChannel.
         * @member {lnrpc.IChannelPoint|null|undefined} inactiveChannel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.inactiveChannel = null;

        /**
         * ChannelEventUpdate type.
         * @member {lnrpc.ChannelEventUpdate.UpdateType} type
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        ChannelEventUpdate.prototype.type = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ChannelEventUpdate channel.
         * @member {"openChannel"|"closedChannel"|"activeChannel"|"inactiveChannel"|undefined} channel
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         */
        Object.defineProperty(ChannelEventUpdate.prototype, "channel", {
            get: $util.oneOfGetter($oneOfFields = ["openChannel", "closedChannel", "activeChannel", "inactiveChannel"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ChannelEventUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {lnrpc.IChannelEventUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelEventUpdate} ChannelEventUpdate instance
         */
        ChannelEventUpdate.create = function create(properties) {
            return new ChannelEventUpdate(properties);
        };

        /**
         * Encodes the specified ChannelEventUpdate message. Does not implicitly {@link lnrpc.ChannelEventUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {lnrpc.IChannelEventUpdate} message ChannelEventUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEventUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.openChannel != null && message.hasOwnProperty("openChannel"))
                $root.lnrpc.Channel.encode(message.openChannel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.closedChannel != null && message.hasOwnProperty("closedChannel"))
                $root.lnrpc.ChannelCloseSummary.encode(message.closedChannel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.activeChannel != null && message.hasOwnProperty("activeChannel"))
                $root.lnrpc.ChannelPoint.encode(message.activeChannel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.inactiveChannel != null && message.hasOwnProperty("inactiveChannel"))
                $root.lnrpc.ChannelPoint.encode(message.inactiveChannel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified ChannelEventUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelEventUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {lnrpc.IChannelEventUpdate} message ChannelEventUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEventUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEventUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEventUpdate} ChannelEventUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEventUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEventUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.openChannel = $root.lnrpc.Channel.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.closedChannel = $root.lnrpc.ChannelCloseSummary.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.activeChannel = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.inactiveChannel = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEventUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEventUpdate} ChannelEventUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEventUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEventUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEventUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.openChannel != null && message.hasOwnProperty("openChannel")) {
                properties.channel = 1;
                {
                    let error = $root.lnrpc.Channel.verify(message.openChannel);
                    if (error)
                        return "openChannel." + error;
                }
            }
            if (message.closedChannel != null && message.hasOwnProperty("closedChannel")) {
                if (properties.channel === 1)
                    return "channel: multiple values";
                properties.channel = 1;
                {
                    let error = $root.lnrpc.ChannelCloseSummary.verify(message.closedChannel);
                    if (error)
                        return "closedChannel." + error;
                }
            }
            if (message.activeChannel != null && message.hasOwnProperty("activeChannel")) {
                if (properties.channel === 1)
                    return "channel: multiple values";
                properties.channel = 1;
                {
                    let error = $root.lnrpc.ChannelPoint.verify(message.activeChannel);
                    if (error)
                        return "activeChannel." + error;
                }
            }
            if (message.inactiveChannel != null && message.hasOwnProperty("inactiveChannel")) {
                if (properties.channel === 1)
                    return "channel: multiple values";
                properties.channel = 1;
                {
                    let error = $root.lnrpc.ChannelPoint.verify(message.inactiveChannel);
                    if (error)
                        return "inactiveChannel." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a ChannelEventUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEventUpdate} ChannelEventUpdate
         */
        ChannelEventUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEventUpdate)
                return object;
            let message = new $root.lnrpc.ChannelEventUpdate();
            if (object.openChannel != null) {
                if (typeof object.openChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.openChannel: object expected");
                message.openChannel = $root.lnrpc.Channel.fromObject(object.openChannel);
            }
            if (object.closedChannel != null) {
                if (typeof object.closedChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.closedChannel: object expected");
                message.closedChannel = $root.lnrpc.ChannelCloseSummary.fromObject(object.closedChannel);
            }
            if (object.activeChannel != null) {
                if (typeof object.activeChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.activeChannel: object expected");
                message.activeChannel = $root.lnrpc.ChannelPoint.fromObject(object.activeChannel);
            }
            if (object.inactiveChannel != null) {
                if (typeof object.inactiveChannel !== "object")
                    throw TypeError(".lnrpc.ChannelEventUpdate.inactiveChannel: object expected");
                message.inactiveChannel = $root.lnrpc.ChannelPoint.fromObject(object.inactiveChannel);
            }
            switch (object.type) {
            case "OPEN_CHANNEL":
            case 0:
                message.type = 0;
                break;
            case "CLOSED_CHANNEL":
            case 1:
                message.type = 1;
                break;
            case "ACTIVE_CHANNEL":
            case 2:
                message.type = 2;
                break;
            case "INACTIVE_CHANNEL":
            case 3:
                message.type = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelEventUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEventUpdate
         * @static
         * @param {lnrpc.ChannelEventUpdate} message ChannelEventUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEventUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.type = options.enums === String ? "OPEN_CHANNEL" : 0;
            if (message.openChannel != null && message.hasOwnProperty("openChannel")) {
                object.openChannel = $root.lnrpc.Channel.toObject(message.openChannel, options);
                if (options.oneofs)
                    object.channel = "openChannel";
            }
            if (message.closedChannel != null && message.hasOwnProperty("closedChannel")) {
                object.closedChannel = $root.lnrpc.ChannelCloseSummary.toObject(message.closedChannel, options);
                if (options.oneofs)
                    object.channel = "closedChannel";
            }
            if (message.activeChannel != null && message.hasOwnProperty("activeChannel")) {
                object.activeChannel = $root.lnrpc.ChannelPoint.toObject(message.activeChannel, options);
                if (options.oneofs)
                    object.channel = "activeChannel";
            }
            if (message.inactiveChannel != null && message.hasOwnProperty("inactiveChannel")) {
                object.inactiveChannel = $root.lnrpc.ChannelPoint.toObject(message.inactiveChannel, options);
                if (options.oneofs)
                    object.channel = "inactiveChannel";
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.lnrpc.ChannelEventUpdate.UpdateType[message.type] : message.type;
            return object;
        };

        /**
         * Converts this ChannelEventUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEventUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEventUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * UpdateType enum.
         * @name lnrpc.ChannelEventUpdate.UpdateType
         * @enum {string}
         * @property {number} OPEN_CHANNEL=0 OPEN_CHANNEL value
         * @property {number} CLOSED_CHANNEL=1 CLOSED_CHANNEL value
         * @property {number} ACTIVE_CHANNEL=2 ACTIVE_CHANNEL value
         * @property {number} INACTIVE_CHANNEL=3 INACTIVE_CHANNEL value
         */
        ChannelEventUpdate.UpdateType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OPEN_CHANNEL"] = 0;
            values[valuesById[1] = "CLOSED_CHANNEL"] = 1;
            values[valuesById[2] = "ACTIVE_CHANNEL"] = 2;
            values[valuesById[3] = "INACTIVE_CHANNEL"] = 3;
            return values;
        })();

        return ChannelEventUpdate;
    })();

    lnrpc.WalletBalanceRequest = (function() {

        /**
         * Properties of a WalletBalanceRequest.
         * @memberof lnrpc
         * @interface IWalletBalanceRequest
         */

        /**
         * Constructs a new WalletBalanceRequest.
         * @memberof lnrpc
         * @classdesc Represents a WalletBalanceRequest.
         * @implements IWalletBalanceRequest
         * @constructor
         * @param {lnrpc.IWalletBalanceRequest=} [properties] Properties to set
         */
        function WalletBalanceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WalletBalanceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest=} [properties] Properties to set
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest instance
         */
        WalletBalanceRequest.create = function create(properties) {
            return new WalletBalanceRequest(properties);
        };

        /**
         * Encodes the specified WalletBalanceRequest message. Does not implicitly {@link lnrpc.WalletBalanceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest} message WalletBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WalletBalanceRequest message, length delimited. Does not implicitly {@link lnrpc.WalletBalanceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.IWalletBalanceRequest} message WalletBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WalletBalanceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.WalletBalanceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WalletBalanceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WalletBalanceRequest message.
         * @function verify
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WalletBalanceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a WalletBalanceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.WalletBalanceRequest} WalletBalanceRequest
         */
        WalletBalanceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.WalletBalanceRequest)
                return object;
            return new $root.lnrpc.WalletBalanceRequest();
        };

        /**
         * Creates a plain object from a WalletBalanceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.WalletBalanceRequest
         * @static
         * @param {lnrpc.WalletBalanceRequest} message WalletBalanceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WalletBalanceRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this WalletBalanceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.WalletBalanceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WalletBalanceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WalletBalanceRequest;
    })();

    lnrpc.WalletBalanceResponse = (function() {

        /**
         * Properties of a WalletBalanceResponse.
         * @memberof lnrpc
         * @interface IWalletBalanceResponse
         * @property {number|Long|null} [totalBalance] The balance of the wallet
         * @property {number|Long|null} [confirmedBalance] The confirmed balance of a wallet(with >= 1 confirmations)
         * @property {number|Long|null} [unconfirmedBalance] The unconfirmed balance of a wallet(with 0 confirmations)
         */

        /**
         * Constructs a new WalletBalanceResponse.
         * @memberof lnrpc
         * @classdesc Represents a WalletBalanceResponse.
         * @implements IWalletBalanceResponse
         * @constructor
         * @param {lnrpc.IWalletBalanceResponse=} [properties] Properties to set
         */
        function WalletBalanceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The balance of the wallet
         * @member {number|Long} totalBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.totalBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The confirmed balance of a wallet(with >= 1 confirmations)
         * @member {number|Long} confirmedBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.confirmedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The unconfirmed balance of a wallet(with 0 confirmations)
         * @member {number|Long} unconfirmedBalance
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         */
        WalletBalanceResponse.prototype.unconfirmedBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new WalletBalanceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse=} [properties] Properties to set
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse instance
         */
        WalletBalanceResponse.create = function create(properties) {
            return new WalletBalanceResponse(properties);
        };

        /**
         * Encodes the specified WalletBalanceResponse message. Does not implicitly {@link lnrpc.WalletBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse} message WalletBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalBalance != null && message.hasOwnProperty("totalBalance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalBalance);
            if (message.confirmedBalance != null && message.hasOwnProperty("confirmedBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.confirmedBalance);
            if (message.unconfirmedBalance != null && message.hasOwnProperty("unconfirmedBalance"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.unconfirmedBalance);
            return writer;
        };

        /**
         * Encodes the specified WalletBalanceResponse message, length delimited. Does not implicitly {@link lnrpc.WalletBalanceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.IWalletBalanceResponse} message WalletBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WalletBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WalletBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.WalletBalanceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalBalance = reader.int64();
                    break;
                case 2:
                    message.confirmedBalance = reader.int64();
                    break;
                case 3:
                    message.unconfirmedBalance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WalletBalanceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WalletBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WalletBalanceResponse message.
         * @function verify
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WalletBalanceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalBalance != null && message.hasOwnProperty("totalBalance"))
                if (!$util.isInteger(message.totalBalance) && !(message.totalBalance && $util.isInteger(message.totalBalance.low) && $util.isInteger(message.totalBalance.high)))
                    return "totalBalance: integer|Long expected";
            if (message.confirmedBalance != null && message.hasOwnProperty("confirmedBalance"))
                if (!$util.isInteger(message.confirmedBalance) && !(message.confirmedBalance && $util.isInteger(message.confirmedBalance.low) && $util.isInteger(message.confirmedBalance.high)))
                    return "confirmedBalance: integer|Long expected";
            if (message.unconfirmedBalance != null && message.hasOwnProperty("unconfirmedBalance"))
                if (!$util.isInteger(message.unconfirmedBalance) && !(message.unconfirmedBalance && $util.isInteger(message.unconfirmedBalance.low) && $util.isInteger(message.unconfirmedBalance.high)))
                    return "unconfirmedBalance: integer|Long expected";
            return null;
        };

        /**
         * Creates a WalletBalanceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.WalletBalanceResponse} WalletBalanceResponse
         */
        WalletBalanceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.WalletBalanceResponse)
                return object;
            let message = new $root.lnrpc.WalletBalanceResponse();
            if (object.totalBalance != null)
                if ($util.Long)
                    (message.totalBalance = $util.Long.fromValue(object.totalBalance)).unsigned = false;
                else if (typeof object.totalBalance === "string")
                    message.totalBalance = parseInt(object.totalBalance, 10);
                else if (typeof object.totalBalance === "number")
                    message.totalBalance = object.totalBalance;
                else if (typeof object.totalBalance === "object")
                    message.totalBalance = new $util.LongBits(object.totalBalance.low >>> 0, object.totalBalance.high >>> 0).toNumber();
            if (object.confirmedBalance != null)
                if ($util.Long)
                    (message.confirmedBalance = $util.Long.fromValue(object.confirmedBalance)).unsigned = false;
                else if (typeof object.confirmedBalance === "string")
                    message.confirmedBalance = parseInt(object.confirmedBalance, 10);
                else if (typeof object.confirmedBalance === "number")
                    message.confirmedBalance = object.confirmedBalance;
                else if (typeof object.confirmedBalance === "object")
                    message.confirmedBalance = new $util.LongBits(object.confirmedBalance.low >>> 0, object.confirmedBalance.high >>> 0).toNumber();
            if (object.unconfirmedBalance != null)
                if ($util.Long)
                    (message.unconfirmedBalance = $util.Long.fromValue(object.unconfirmedBalance)).unsigned = false;
                else if (typeof object.unconfirmedBalance === "string")
                    message.unconfirmedBalance = parseInt(object.unconfirmedBalance, 10);
                else if (typeof object.unconfirmedBalance === "number")
                    message.unconfirmedBalance = object.unconfirmedBalance;
                else if (typeof object.unconfirmedBalance === "object")
                    message.unconfirmedBalance = new $util.LongBits(object.unconfirmedBalance.low >>> 0, object.unconfirmedBalance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a WalletBalanceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.WalletBalanceResponse
         * @static
         * @param {lnrpc.WalletBalanceResponse} message WalletBalanceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        WalletBalanceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.confirmedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.confirmedBalance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.unconfirmedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.unconfirmedBalance = options.longs === String ? "0" : 0;
            }
            if (message.totalBalance != null && message.hasOwnProperty("totalBalance"))
                if (typeof message.totalBalance === "number")
                    object.totalBalance = options.longs === String ? String(message.totalBalance) : message.totalBalance;
                else
                    object.totalBalance = options.longs === String ? $util.Long.prototype.toString.call(message.totalBalance) : options.longs === Number ? new $util.LongBits(message.totalBalance.low >>> 0, message.totalBalance.high >>> 0).toNumber() : message.totalBalance;
            if (message.confirmedBalance != null && message.hasOwnProperty("confirmedBalance"))
                if (typeof message.confirmedBalance === "number")
                    object.confirmedBalance = options.longs === String ? String(message.confirmedBalance) : message.confirmedBalance;
                else
                    object.confirmedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.confirmedBalance) : options.longs === Number ? new $util.LongBits(message.confirmedBalance.low >>> 0, message.confirmedBalance.high >>> 0).toNumber() : message.confirmedBalance;
            if (message.unconfirmedBalance != null && message.hasOwnProperty("unconfirmedBalance"))
                if (typeof message.unconfirmedBalance === "number")
                    object.unconfirmedBalance = options.longs === String ? String(message.unconfirmedBalance) : message.unconfirmedBalance;
                else
                    object.unconfirmedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.unconfirmedBalance) : options.longs === Number ? new $util.LongBits(message.unconfirmedBalance.low >>> 0, message.unconfirmedBalance.high >>> 0).toNumber() : message.unconfirmedBalance;
            return object;
        };

        /**
         * Converts this WalletBalanceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.WalletBalanceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        WalletBalanceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return WalletBalanceResponse;
    })();

    lnrpc.ChannelBalanceRequest = (function() {

        /**
         * Properties of a ChannelBalanceRequest.
         * @memberof lnrpc
         * @interface IChannelBalanceRequest
         */

        /**
         * Constructs a new ChannelBalanceRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBalanceRequest.
         * @implements IChannelBalanceRequest
         * @constructor
         * @param {lnrpc.IChannelBalanceRequest=} [properties] Properties to set
         */
        function ChannelBalanceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelBalanceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest=} [properties] Properties to set
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest instance
         */
        ChannelBalanceRequest.create = function create(properties) {
            return new ChannelBalanceRequest(properties);
        };

        /**
         * Encodes the specified ChannelBalanceRequest message. Does not implicitly {@link lnrpc.ChannelBalanceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest} message ChannelBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelBalanceRequest message, length delimited. Does not implicitly {@link lnrpc.ChannelBalanceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.IChannelBalanceRequest} message ChannelBalanceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBalanceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBalanceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBalanceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBalanceRequest message.
         * @function verify
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBalanceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelBalanceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBalanceRequest} ChannelBalanceRequest
         */
        ChannelBalanceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBalanceRequest)
                return object;
            return new $root.lnrpc.ChannelBalanceRequest();
        };

        /**
         * Creates a plain object from a ChannelBalanceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBalanceRequest
         * @static
         * @param {lnrpc.ChannelBalanceRequest} message ChannelBalanceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBalanceRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelBalanceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBalanceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBalanceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBalanceRequest;
    })();

    lnrpc.ChannelBalanceResponse = (function() {

        /**
         * Properties of a ChannelBalanceResponse.
         * @memberof lnrpc
         * @interface IChannelBalanceResponse
         * @property {number|Long|null} [balance] Sum of channels balances denominated in satoshis
         * @property {number|Long|null} [pendingOpenBalance] Sum of channels pending balances denominated in satoshis
         */

        /**
         * Constructs a new ChannelBalanceResponse.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBalanceResponse.
         * @implements IChannelBalanceResponse
         * @constructor
         * @param {lnrpc.IChannelBalanceResponse=} [properties] Properties to set
         */
        function ChannelBalanceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Sum of channels balances denominated in satoshis
         * @member {number|Long} balance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Sum of channels pending balances denominated in satoshis
         * @member {number|Long} pendingOpenBalance
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         */
        ChannelBalanceResponse.prototype.pendingOpenBalance = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ChannelBalanceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse=} [properties] Properties to set
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse instance
         */
        ChannelBalanceResponse.create = function create(properties) {
            return new ChannelBalanceResponse(properties);
        };

        /**
         * Encodes the specified ChannelBalanceResponse message. Does not implicitly {@link lnrpc.ChannelBalanceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse} message ChannelBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.balance != null && message.hasOwnProperty("balance"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.balance);
            if (message.pendingOpenBalance != null && message.hasOwnProperty("pendingOpenBalance"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.pendingOpenBalance);
            return writer;
        };

        /**
         * Encodes the specified ChannelBalanceResponse message, length delimited. Does not implicitly {@link lnrpc.ChannelBalanceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.IChannelBalanceResponse} message ChannelBalanceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBalanceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBalanceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBalanceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.balance = reader.int64();
                    break;
                case 2:
                    message.pendingOpenBalance = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBalanceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBalanceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBalanceResponse message.
         * @function verify
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBalanceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                    return "balance: integer|Long expected";
            if (message.pendingOpenBalance != null && message.hasOwnProperty("pendingOpenBalance"))
                if (!$util.isInteger(message.pendingOpenBalance) && !(message.pendingOpenBalance && $util.isInteger(message.pendingOpenBalance.low) && $util.isInteger(message.pendingOpenBalance.high)))
                    return "pendingOpenBalance: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChannelBalanceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBalanceResponse} ChannelBalanceResponse
         */
        ChannelBalanceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBalanceResponse)
                return object;
            let message = new $root.lnrpc.ChannelBalanceResponse();
            if (object.balance != null)
                if ($util.Long)
                    (message.balance = $util.Long.fromValue(object.balance)).unsigned = false;
                else if (typeof object.balance === "string")
                    message.balance = parseInt(object.balance, 10);
                else if (typeof object.balance === "number")
                    message.balance = object.balance;
                else if (typeof object.balance === "object")
                    message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber();
            if (object.pendingOpenBalance != null)
                if ($util.Long)
                    (message.pendingOpenBalance = $util.Long.fromValue(object.pendingOpenBalance)).unsigned = false;
                else if (typeof object.pendingOpenBalance === "string")
                    message.pendingOpenBalance = parseInt(object.pendingOpenBalance, 10);
                else if (typeof object.pendingOpenBalance === "number")
                    message.pendingOpenBalance = object.pendingOpenBalance;
                else if (typeof object.pendingOpenBalance === "object")
                    message.pendingOpenBalance = new $util.LongBits(object.pendingOpenBalance.low >>> 0, object.pendingOpenBalance.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ChannelBalanceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBalanceResponse
         * @static
         * @param {lnrpc.ChannelBalanceResponse} message ChannelBalanceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBalanceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.balance = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.pendingOpenBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.pendingOpenBalance = options.longs === String ? "0" : 0;
            }
            if (message.balance != null && message.hasOwnProperty("balance"))
                if (typeof message.balance === "number")
                    object.balance = options.longs === String ? String(message.balance) : message.balance;
                else
                    object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber() : message.balance;
            if (message.pendingOpenBalance != null && message.hasOwnProperty("pendingOpenBalance"))
                if (typeof message.pendingOpenBalance === "number")
                    object.pendingOpenBalance = options.longs === String ? String(message.pendingOpenBalance) : message.pendingOpenBalance;
                else
                    object.pendingOpenBalance = options.longs === String ? $util.Long.prototype.toString.call(message.pendingOpenBalance) : options.longs === Number ? new $util.LongBits(message.pendingOpenBalance.low >>> 0, message.pendingOpenBalance.high >>> 0).toNumber() : message.pendingOpenBalance;
            return object;
        };

        /**
         * Converts this ChannelBalanceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBalanceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBalanceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBalanceResponse;
    })();

    lnrpc.QueryRoutesRequest = (function() {

        /**
         * Properties of a QueryRoutesRequest.
         * @memberof lnrpc
         * @interface IQueryRoutesRequest
         * @property {string|null} [pubKey] The 33-byte hex-encoded public key for the payment destination
         * @property {number|Long|null} [amt] The amount to send expressed in satoshis
         * @property {number|null} [finalCltvDelta] An optional CLTV delta from the current height that should be used for the timelock of the final hop
         * @property {lnrpc.IFeeLimit|null} [feeLimit] The maximum number of satoshis that will be paid as a fee of the payment.
         * This value can be represented either as a percentage of the amount being
         * sent, or as a fixed amount of the maximum fee the user is willing the pay to
         * send the payment.
         * @property {Array.<Uint8Array>|null} [ignoredNodes] A list of nodes to ignore during path finding.
         * @property {Array.<lnrpc.IEdgeLocator>|null} [ignoredEdges] A list of edges to ignore during path finding.
         * @property {string|null} [sourcePubKey] The source node where the request route should originated from. If empty,
         * self is assumed.
         * @property {boolean|null} [useMissionControl] If set to true, edge probabilities from mission control will be used to get
         * the optimal route.
         */

        /**
         * Constructs a new QueryRoutesRequest.
         * @memberof lnrpc
         * @classdesc Represents a QueryRoutesRequest.
         * @implements IQueryRoutesRequest
         * @constructor
         * @param {lnrpc.IQueryRoutesRequest=} [properties] Properties to set
         */
        function QueryRoutesRequest(properties) {
            this.ignoredNodes = [];
            this.ignoredEdges = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The 33-byte hex-encoded public key for the payment destination
         * @member {string} pubKey
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.pubKey = "";

        /**
         * The amount to send expressed in satoshis
         * @member {number|Long} amt
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.amt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An optional CLTV delta from the current height that should be used for the timelock of the final hop
         * @member {number} finalCltvDelta
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.finalCltvDelta = 0;

        /**
         * The maximum number of satoshis that will be paid as a fee of the payment.
         * This value can be represented either as a percentage of the amount being
         * sent, or as a fixed amount of the maximum fee the user is willing the pay to
         * send the payment.
         * @member {lnrpc.IFeeLimit|null|undefined} feeLimit
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.feeLimit = null;

        /**
         * A list of nodes to ignore during path finding.
         * @member {Array.<Uint8Array>} ignoredNodes
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.ignoredNodes = $util.emptyArray;

        /**
         * A list of edges to ignore during path finding.
         * @member {Array.<lnrpc.IEdgeLocator>} ignoredEdges
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.ignoredEdges = $util.emptyArray;

        /**
         * The source node where the request route should originated from. If empty,
         * self is assumed.
         * @member {string} sourcePubKey
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.sourcePubKey = "";

        /**
         * If set to true, edge probabilities from mission control will be used to get
         * the optimal route.
         * @member {boolean} useMissionControl
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         */
        QueryRoutesRequest.prototype.useMissionControl = false;

        /**
         * Creates a new QueryRoutesRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest=} [properties] Properties to set
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest instance
         */
        QueryRoutesRequest.create = function create(properties) {
            return new QueryRoutesRequest(properties);
        };

        /**
         * Encodes the specified QueryRoutesRequest message. Does not implicitly {@link lnrpc.QueryRoutesRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest} message QueryRoutesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.amt != null && message.hasOwnProperty("amt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.amt);
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.finalCltvDelta);
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                $root.lnrpc.FeeLimit.encode(message.feeLimit, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.ignoredNodes != null && message.ignoredNodes.length)
                for (let i = 0; i < message.ignoredNodes.length; ++i)
                    writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.ignoredNodes[i]);
            if (message.ignoredEdges != null && message.ignoredEdges.length)
                for (let i = 0; i < message.ignoredEdges.length; ++i)
                    $root.lnrpc.EdgeLocator.encode(message.ignoredEdges[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.sourcePubKey != null && message.hasOwnProperty("sourcePubKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.sourcePubKey);
            if (message.useMissionControl != null && message.hasOwnProperty("useMissionControl"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.useMissionControl);
            return writer;
        };

        /**
         * Encodes the specified QueryRoutesRequest message, length delimited. Does not implicitly {@link lnrpc.QueryRoutesRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.IQueryRoutesRequest} message QueryRoutesRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRoutesRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryRoutesRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 2:
                    message.amt = reader.int64();
                    break;
                case 4:
                    message.finalCltvDelta = reader.int32();
                    break;
                case 5:
                    message.feeLimit = $root.lnrpc.FeeLimit.decode(reader, reader.uint32());
                    break;
                case 6:
                    if (!(message.ignoredNodes && message.ignoredNodes.length))
                        message.ignoredNodes = [];
                    message.ignoredNodes.push(reader.bytes());
                    break;
                case 7:
                    if (!(message.ignoredEdges && message.ignoredEdges.length))
                        message.ignoredEdges = [];
                    message.ignoredEdges.push($root.lnrpc.EdgeLocator.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.sourcePubKey = reader.string();
                    break;
                case 9:
                    message.useMissionControl = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryRoutesRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRoutesRequest message.
         * @function verify
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRoutesRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (!$util.isInteger(message.amt) && !(message.amt && $util.isInteger(message.amt.low) && $util.isInteger(message.amt.high)))
                    return "amt: integer|Long expected";
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                if (!$util.isInteger(message.finalCltvDelta))
                    return "finalCltvDelta: integer expected";
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit")) {
                let error = $root.lnrpc.FeeLimit.verify(message.feeLimit);
                if (error)
                    return "feeLimit." + error;
            }
            if (message.ignoredNodes != null && message.hasOwnProperty("ignoredNodes")) {
                if (!Array.isArray(message.ignoredNodes))
                    return "ignoredNodes: array expected";
                for (let i = 0; i < message.ignoredNodes.length; ++i)
                    if (!(message.ignoredNodes[i] && typeof message.ignoredNodes[i].length === "number" || $util.isString(message.ignoredNodes[i])))
                        return "ignoredNodes: buffer[] expected";
            }
            if (message.ignoredEdges != null && message.hasOwnProperty("ignoredEdges")) {
                if (!Array.isArray(message.ignoredEdges))
                    return "ignoredEdges: array expected";
                for (let i = 0; i < message.ignoredEdges.length; ++i) {
                    let error = $root.lnrpc.EdgeLocator.verify(message.ignoredEdges[i]);
                    if (error)
                        return "ignoredEdges." + error;
                }
            }
            if (message.sourcePubKey != null && message.hasOwnProperty("sourcePubKey"))
                if (!$util.isString(message.sourcePubKey))
                    return "sourcePubKey: string expected";
            if (message.useMissionControl != null && message.hasOwnProperty("useMissionControl"))
                if (typeof message.useMissionControl !== "boolean")
                    return "useMissionControl: boolean expected";
            return null;
        };

        /**
         * Creates a QueryRoutesRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.QueryRoutesRequest} QueryRoutesRequest
         */
        QueryRoutesRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.QueryRoutesRequest)
                return object;
            let message = new $root.lnrpc.QueryRoutesRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.amt != null)
                if ($util.Long)
                    (message.amt = $util.Long.fromValue(object.amt)).unsigned = false;
                else if (typeof object.amt === "string")
                    message.amt = parseInt(object.amt, 10);
                else if (typeof object.amt === "number")
                    message.amt = object.amt;
                else if (typeof object.amt === "object")
                    message.amt = new $util.LongBits(object.amt.low >>> 0, object.amt.high >>> 0).toNumber();
            if (object.finalCltvDelta != null)
                message.finalCltvDelta = object.finalCltvDelta | 0;
            if (object.feeLimit != null) {
                if (typeof object.feeLimit !== "object")
                    throw TypeError(".lnrpc.QueryRoutesRequest.feeLimit: object expected");
                message.feeLimit = $root.lnrpc.FeeLimit.fromObject(object.feeLimit);
            }
            if (object.ignoredNodes) {
                if (!Array.isArray(object.ignoredNodes))
                    throw TypeError(".lnrpc.QueryRoutesRequest.ignoredNodes: array expected");
                message.ignoredNodes = [];
                for (let i = 0; i < object.ignoredNodes.length; ++i)
                    if (typeof object.ignoredNodes[i] === "string")
                        $util.base64.decode(object.ignoredNodes[i], message.ignoredNodes[i] = $util.newBuffer($util.base64.length(object.ignoredNodes[i])), 0);
                    else if (object.ignoredNodes[i].length)
                        message.ignoredNodes[i] = object.ignoredNodes[i];
            }
            if (object.ignoredEdges) {
                if (!Array.isArray(object.ignoredEdges))
                    throw TypeError(".lnrpc.QueryRoutesRequest.ignoredEdges: array expected");
                message.ignoredEdges = [];
                for (let i = 0; i < object.ignoredEdges.length; ++i) {
                    if (typeof object.ignoredEdges[i] !== "object")
                        throw TypeError(".lnrpc.QueryRoutesRequest.ignoredEdges: object expected");
                    message.ignoredEdges[i] = $root.lnrpc.EdgeLocator.fromObject(object.ignoredEdges[i]);
                }
            }
            if (object.sourcePubKey != null)
                message.sourcePubKey = String(object.sourcePubKey);
            if (object.useMissionControl != null)
                message.useMissionControl = Boolean(object.useMissionControl);
            return message;
        };

        /**
         * Creates a plain object from a QueryRoutesRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.QueryRoutesRequest
         * @static
         * @param {lnrpc.QueryRoutesRequest} message QueryRoutesRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRoutesRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.ignoredNodes = [];
                object.ignoredEdges = [];
            }
            if (options.defaults) {
                object.pubKey = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amt = options.longs === String ? "0" : 0;
                object.finalCltvDelta = 0;
                object.feeLimit = null;
                object.sourcePubKey = "";
                object.useMissionControl = false;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.amt != null && message.hasOwnProperty("amt"))
                if (typeof message.amt === "number")
                    object.amt = options.longs === String ? String(message.amt) : message.amt;
                else
                    object.amt = options.longs === String ? $util.Long.prototype.toString.call(message.amt) : options.longs === Number ? new $util.LongBits(message.amt.low >>> 0, message.amt.high >>> 0).toNumber() : message.amt;
            if (message.finalCltvDelta != null && message.hasOwnProperty("finalCltvDelta"))
                object.finalCltvDelta = message.finalCltvDelta;
            if (message.feeLimit != null && message.hasOwnProperty("feeLimit"))
                object.feeLimit = $root.lnrpc.FeeLimit.toObject(message.feeLimit, options);
            if (message.ignoredNodes && message.ignoredNodes.length) {
                object.ignoredNodes = [];
                for (let j = 0; j < message.ignoredNodes.length; ++j)
                    object.ignoredNodes[j] = options.bytes === String ? $util.base64.encode(message.ignoredNodes[j], 0, message.ignoredNodes[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.ignoredNodes[j]) : message.ignoredNodes[j];
            }
            if (message.ignoredEdges && message.ignoredEdges.length) {
                object.ignoredEdges = [];
                for (let j = 0; j < message.ignoredEdges.length; ++j)
                    object.ignoredEdges[j] = $root.lnrpc.EdgeLocator.toObject(message.ignoredEdges[j], options);
            }
            if (message.sourcePubKey != null && message.hasOwnProperty("sourcePubKey"))
                object.sourcePubKey = message.sourcePubKey;
            if (message.useMissionControl != null && message.hasOwnProperty("useMissionControl"))
                object.useMissionControl = message.useMissionControl;
            return object;
        };

        /**
         * Converts this QueryRoutesRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.QueryRoutesRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRoutesRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRoutesRequest;
    })();

    lnrpc.EdgeLocator = (function() {

        /**
         * Properties of an EdgeLocator.
         * @memberof lnrpc
         * @interface IEdgeLocator
         * @property {number|Long|null} [channelId] The short channel id of this edge.
         * @property {boolean|null} [directionReverse] The direction of this edge. If direction_reverse is false, the direction
         * of this edge is from the channel endpoint with the lexicographically smaller
         * pub key to the endpoint with the larger pub key. If direction_reverse is
         * is true, the edge goes the other way.
         */

        /**
         * Constructs a new EdgeLocator.
         * @memberof lnrpc
         * @classdesc Represents an EdgeLocator.
         * @implements IEdgeLocator
         * @constructor
         * @param {lnrpc.IEdgeLocator=} [properties] Properties to set
         */
        function EdgeLocator(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The short channel id of this edge.
         * @member {number|Long} channelId
         * @memberof lnrpc.EdgeLocator
         * @instance
         */
        EdgeLocator.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The direction of this edge. If direction_reverse is false, the direction
         * of this edge is from the channel endpoint with the lexicographically smaller
         * pub key to the endpoint with the larger pub key. If direction_reverse is
         * is true, the edge goes the other way.
         * @member {boolean} directionReverse
         * @memberof lnrpc.EdgeLocator
         * @instance
         */
        EdgeLocator.prototype.directionReverse = false;

        /**
         * Creates a new EdgeLocator instance using the specified properties.
         * @function create
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {lnrpc.IEdgeLocator=} [properties] Properties to set
         * @returns {lnrpc.EdgeLocator} EdgeLocator instance
         */
        EdgeLocator.create = function create(properties) {
            return new EdgeLocator(properties);
        };

        /**
         * Encodes the specified EdgeLocator message. Does not implicitly {@link lnrpc.EdgeLocator.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {lnrpc.IEdgeLocator} message EdgeLocator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EdgeLocator.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.directionReverse != null && message.hasOwnProperty("directionReverse"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.directionReverse);
            return writer;
        };

        /**
         * Encodes the specified EdgeLocator message, length delimited. Does not implicitly {@link lnrpc.EdgeLocator.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {lnrpc.IEdgeLocator} message EdgeLocator message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EdgeLocator.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EdgeLocator message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.EdgeLocator} EdgeLocator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EdgeLocator.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.EdgeLocator();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.directionReverse = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EdgeLocator message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.EdgeLocator} EdgeLocator
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EdgeLocator.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EdgeLocator message.
         * @function verify
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EdgeLocator.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.directionReverse != null && message.hasOwnProperty("directionReverse"))
                if (typeof message.directionReverse !== "boolean")
                    return "directionReverse: boolean expected";
            return null;
        };

        /**
         * Creates an EdgeLocator message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.EdgeLocator} EdgeLocator
         */
        EdgeLocator.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.EdgeLocator)
                return object;
            let message = new $root.lnrpc.EdgeLocator();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.directionReverse != null)
                message.directionReverse = Boolean(object.directionReverse);
            return message;
        };

        /**
         * Creates a plain object from an EdgeLocator message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.EdgeLocator
         * @static
         * @param {lnrpc.EdgeLocator} message EdgeLocator
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EdgeLocator.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.directionReverse = false;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.directionReverse != null && message.hasOwnProperty("directionReverse"))
                object.directionReverse = message.directionReverse;
            return object;
        };

        /**
         * Converts this EdgeLocator to JSON.
         * @function toJSON
         * @memberof lnrpc.EdgeLocator
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EdgeLocator.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EdgeLocator;
    })();

    lnrpc.QueryRoutesResponse = (function() {

        /**
         * Properties of a QueryRoutesResponse.
         * @memberof lnrpc
         * @interface IQueryRoutesResponse
         * @property {Array.<lnrpc.IRoute>|null} [routes] QueryRoutesResponse routes
         */

        /**
         * Constructs a new QueryRoutesResponse.
         * @memberof lnrpc
         * @classdesc Represents a QueryRoutesResponse.
         * @implements IQueryRoutesResponse
         * @constructor
         * @param {lnrpc.IQueryRoutesResponse=} [properties] Properties to set
         */
        function QueryRoutesResponse(properties) {
            this.routes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRoutesResponse routes.
         * @member {Array.<lnrpc.IRoute>} routes
         * @memberof lnrpc.QueryRoutesResponse
         * @instance
         */
        QueryRoutesResponse.prototype.routes = $util.emptyArray;

        /**
         * Creates a new QueryRoutesResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse=} [properties] Properties to set
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse instance
         */
        QueryRoutesResponse.create = function create(properties) {
            return new QueryRoutesResponse(properties);
        };

        /**
         * Encodes the specified QueryRoutesResponse message. Does not implicitly {@link lnrpc.QueryRoutesResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse} message QueryRoutesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.routes != null && message.routes.length)
                for (let i = 0; i < message.routes.length; ++i)
                    $root.lnrpc.Route.encode(message.routes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryRoutesResponse message, length delimited. Does not implicitly {@link lnrpc.QueryRoutesResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.IQueryRoutesResponse} message QueryRoutesResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoutesResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRoutesResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryRoutesResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.routes && message.routes.length))
                        message.routes = [];
                    message.routes.push($root.lnrpc.Route.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryRoutesResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoutesResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRoutesResponse message.
         * @function verify
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRoutesResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.routes != null && message.hasOwnProperty("routes")) {
                if (!Array.isArray(message.routes))
                    return "routes: array expected";
                for (let i = 0; i < message.routes.length; ++i) {
                    let error = $root.lnrpc.Route.verify(message.routes[i]);
                    if (error)
                        return "routes." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QueryRoutesResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.QueryRoutesResponse} QueryRoutesResponse
         */
        QueryRoutesResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.QueryRoutesResponse)
                return object;
            let message = new $root.lnrpc.QueryRoutesResponse();
            if (object.routes) {
                if (!Array.isArray(object.routes))
                    throw TypeError(".lnrpc.QueryRoutesResponse.routes: array expected");
                message.routes = [];
                for (let i = 0; i < object.routes.length; ++i) {
                    if (typeof object.routes[i] !== "object")
                        throw TypeError(".lnrpc.QueryRoutesResponse.routes: object expected");
                    message.routes[i] = $root.lnrpc.Route.fromObject(object.routes[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryRoutesResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.QueryRoutesResponse
         * @static
         * @param {lnrpc.QueryRoutesResponse} message QueryRoutesResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryRoutesResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.routes = [];
            if (message.routes && message.routes.length) {
                object.routes = [];
                for (let j = 0; j < message.routes.length; ++j)
                    object.routes[j] = $root.lnrpc.Route.toObject(message.routes[j], options);
            }
            return object;
        };

        /**
         * Converts this QueryRoutesResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.QueryRoutesResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryRoutesResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryRoutesResponse;
    })();

    lnrpc.Hop = (function() {

        /**
         * Properties of a Hop.
         * @memberof lnrpc
         * @interface IHop
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {number|Long|null} [chanCapacity] Hop chanCapacity
         * @property {number|Long|null} [amtToForward] Hop amtToForward
         * @property {number|Long|null} [fee] Hop fee
         * @property {number|null} [expiry] Hop expiry
         * @property {number|Long|null} [amtToForwardMsat] Hop amtToForwardMsat
         * @property {number|Long|null} [feeMsat] Hop feeMsat
         * @property {string|null} [pubKey] An optional public key of the hop. If the public key is given, the payment
         * can be executed without relying on a copy of the channel graph.
         */

        /**
         * Constructs a new Hop.
         * @memberof lnrpc
         * @classdesc Represents a Hop.
         * @implements IHop
         * @constructor
         * @param {lnrpc.IHop=} [properties] Properties to set
         */
        function Hop(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Hop chanCapacity.
         * @member {number|Long} chanCapacity
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.chanCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop amtToForward.
         * @member {number|Long} amtToForward
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.amtToForward = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop fee.
         * @member {number|Long} fee
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop expiry.
         * @member {number} expiry
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.expiry = 0;

        /**
         * Hop amtToForwardMsat.
         * @member {number|Long} amtToForwardMsat
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.amtToForwardMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Hop feeMsat.
         * @member {number|Long} feeMsat
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.feeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * An optional public key of the hop. If the public key is given, the payment
         * can be executed without relying on a copy of the channel graph.
         * @member {string} pubKey
         * @memberof lnrpc.Hop
         * @instance
         */
        Hop.prototype.pubKey = "";

        /**
         * Creates a new Hop instance using the specified properties.
         * @function create
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop=} [properties] Properties to set
         * @returns {lnrpc.Hop} Hop instance
         */
        Hop.create = function create(properties) {
            return new Hop(properties);
        };

        /**
         * Encodes the specified Hop message. Does not implicitly {@link lnrpc.Hop.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop} message Hop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.chanCapacity != null && message.hasOwnProperty("chanCapacity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.chanCapacity);
            if (message.amtToForward != null && message.hasOwnProperty("amtToForward"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.amtToForward);
            if (message.fee != null && message.hasOwnProperty("fee"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.fee);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.expiry);
            if (message.amtToForwardMsat != null && message.hasOwnProperty("amtToForwardMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.amtToForwardMsat);
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.feeMsat);
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.pubKey);
            return writer;
        };

        /**
         * Encodes the specified Hop message, length delimited. Does not implicitly {@link lnrpc.Hop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.IHop} message Hop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hop message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Hop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Hop} Hop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Hop();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.chanCapacity = reader.int64();
                    break;
                case 3:
                    message.amtToForward = reader.int64();
                    break;
                case 4:
                    message.fee = reader.int64();
                    break;
                case 5:
                    message.expiry = reader.uint32();
                    break;
                case 6:
                    message.amtToForwardMsat = reader.int64();
                    break;
                case 7:
                    message.feeMsat = reader.int64();
                    break;
                case 8:
                    message.pubKey = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Hop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Hop} Hop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hop message.
         * @function verify
         * @memberof lnrpc.Hop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chanCapacity != null && message.hasOwnProperty("chanCapacity"))
                if (!$util.isInteger(message.chanCapacity) && !(message.chanCapacity && $util.isInteger(message.chanCapacity.low) && $util.isInteger(message.chanCapacity.high)))
                    return "chanCapacity: integer|Long expected";
            if (message.amtToForward != null && message.hasOwnProperty("amtToForward"))
                if (!$util.isInteger(message.amtToForward) && !(message.amtToForward && $util.isInteger(message.amtToForward.low) && $util.isInteger(message.amtToForward.high)))
                    return "amtToForward: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry))
                    return "expiry: integer expected";
            if (message.amtToForwardMsat != null && message.hasOwnProperty("amtToForwardMsat"))
                if (!$util.isInteger(message.amtToForwardMsat) && !(message.amtToForwardMsat && $util.isInteger(message.amtToForwardMsat.low) && $util.isInteger(message.amtToForwardMsat.high)))
                    return "amtToForwardMsat: integer|Long expected";
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (!$util.isInteger(message.feeMsat) && !(message.feeMsat && $util.isInteger(message.feeMsat.low) && $util.isInteger(message.feeMsat.high)))
                    return "feeMsat: integer|Long expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            return null;
        };

        /**
         * Creates a Hop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Hop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Hop} Hop
         */
        Hop.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Hop)
                return object;
            let message = new $root.lnrpc.Hop();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chanCapacity != null)
                if ($util.Long)
                    (message.chanCapacity = $util.Long.fromValue(object.chanCapacity)).unsigned = false;
                else if (typeof object.chanCapacity === "string")
                    message.chanCapacity = parseInt(object.chanCapacity, 10);
                else if (typeof object.chanCapacity === "number")
                    message.chanCapacity = object.chanCapacity;
                else if (typeof object.chanCapacity === "object")
                    message.chanCapacity = new $util.LongBits(object.chanCapacity.low >>> 0, object.chanCapacity.high >>> 0).toNumber();
            if (object.amtToForward != null)
                if ($util.Long)
                    (message.amtToForward = $util.Long.fromValue(object.amtToForward)).unsigned = false;
                else if (typeof object.amtToForward === "string")
                    message.amtToForward = parseInt(object.amtToForward, 10);
                else if (typeof object.amtToForward === "number")
                    message.amtToForward = object.amtToForward;
                else if (typeof object.amtToForward === "object")
                    message.amtToForward = new $util.LongBits(object.amtToForward.low >>> 0, object.amtToForward.high >>> 0).toNumber();
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.expiry != null)
                message.expiry = object.expiry >>> 0;
            if (object.amtToForwardMsat != null)
                if ($util.Long)
                    (message.amtToForwardMsat = $util.Long.fromValue(object.amtToForwardMsat)).unsigned = false;
                else if (typeof object.amtToForwardMsat === "string")
                    message.amtToForwardMsat = parseInt(object.amtToForwardMsat, 10);
                else if (typeof object.amtToForwardMsat === "number")
                    message.amtToForwardMsat = object.amtToForwardMsat;
                else if (typeof object.amtToForwardMsat === "object")
                    message.amtToForwardMsat = new $util.LongBits(object.amtToForwardMsat.low >>> 0, object.amtToForwardMsat.high >>> 0).toNumber();
            if (object.feeMsat != null)
                if ($util.Long)
                    (message.feeMsat = $util.Long.fromValue(object.feeMsat)).unsigned = false;
                else if (typeof object.feeMsat === "string")
                    message.feeMsat = parseInt(object.feeMsat, 10);
                else if (typeof object.feeMsat === "number")
                    message.feeMsat = object.feeMsat;
                else if (typeof object.feeMsat === "object")
                    message.feeMsat = new $util.LongBits(object.feeMsat.low >>> 0, object.feeMsat.high >>> 0).toNumber();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            return message;
        };

        /**
         * Creates a plain object from a Hop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Hop
         * @static
         * @param {lnrpc.Hop} message Hop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Hop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.chanCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanCapacity = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtToForward = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtToForward = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.expiry = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtToForwardMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtToForwardMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeMsat = options.longs === String ? "0" : 0;
                object.pubKey = "";
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chanCapacity != null && message.hasOwnProperty("chanCapacity"))
                if (typeof message.chanCapacity === "number")
                    object.chanCapacity = options.longs === String ? String(message.chanCapacity) : message.chanCapacity;
                else
                    object.chanCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.chanCapacity) : options.longs === Number ? new $util.LongBits(message.chanCapacity.low >>> 0, message.chanCapacity.high >>> 0).toNumber() : message.chanCapacity;
            if (message.amtToForward != null && message.hasOwnProperty("amtToForward"))
                if (typeof message.amtToForward === "number")
                    object.amtToForward = options.longs === String ? String(message.amtToForward) : message.amtToForward;
                else
                    object.amtToForward = options.longs === String ? $util.Long.prototype.toString.call(message.amtToForward) : options.longs === Number ? new $util.LongBits(message.amtToForward.low >>> 0, message.amtToForward.high >>> 0).toNumber() : message.amtToForward;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                object.expiry = message.expiry;
            if (message.amtToForwardMsat != null && message.hasOwnProperty("amtToForwardMsat"))
                if (typeof message.amtToForwardMsat === "number")
                    object.amtToForwardMsat = options.longs === String ? String(message.amtToForwardMsat) : message.amtToForwardMsat;
                else
                    object.amtToForwardMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtToForwardMsat) : options.longs === Number ? new $util.LongBits(message.amtToForwardMsat.low >>> 0, message.amtToForwardMsat.high >>> 0).toNumber() : message.amtToForwardMsat;
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (typeof message.feeMsat === "number")
                    object.feeMsat = options.longs === String ? String(message.feeMsat) : message.feeMsat;
                else
                    object.feeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeMsat) : options.longs === Number ? new $util.LongBits(message.feeMsat.low >>> 0, message.feeMsat.high >>> 0).toNumber() : message.feeMsat;
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            return object;
        };

        /**
         * Converts this Hop to JSON.
         * @function toJSON
         * @memberof lnrpc.Hop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Hop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Hop;
    })();

    lnrpc.Route = (function() {

        /**
         * Properties of a Route.
         * @memberof lnrpc
         * @interface IRoute
         * @property {number|null} [totalTimeLock] The cumulative (final) time lock across the entire route.  This is the CLTV
         * value that should be extended to the first hop in the route. All other hops
         * will decrement the time-lock as advertised, leaving enough time for all
         * hops to wait for or present the payment preimage to complete the payment.
         * @property {number|Long|null} [totalFees] The sum of the fees paid at each hop within the final route.  In the case
         * of a one-hop payment, this value will be zero as we don't need to pay a fee
         * to ourselves.
         * @property {number|Long|null} [totalAmt] The total amount of funds required to complete a payment over this route.
         * This value includes the cumulative fees at each hop. As a result, the HTLC
         * extended to the first-hop in the route will need to have at least this many
         * satoshis, otherwise the route will fail at an intermediate node due to an
         * insufficient amount of fees.
         * @property {Array.<lnrpc.IHop>|null} [hops] Contains details concerning the specific forwarding details at each hop.
         * @property {number|Long|null} [totalFeesMsat] The total fees in millisatoshis.
         * @property {number|Long|null} [totalAmtMsat] The total amount in millisatoshis.
         */

        /**
         * Constructs a new Route.
         * @memberof lnrpc
         * @classdesc A path through the channel graph which runs over one or more channels in
         * succession. This struct carries all the information required to craft the
         * Sphinx onion packet, and send the payment along the first hop in the path. A
         * route is only selected as valid if all the channels have sufficient capacity to
         * carry the initial payment amount after fees are accounted for.
         * @implements IRoute
         * @constructor
         * @param {lnrpc.IRoute=} [properties] Properties to set
         */
        function Route(properties) {
            this.hops = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The cumulative (final) time lock across the entire route.  This is the CLTV
         * value that should be extended to the first hop in the route. All other hops
         * will decrement the time-lock as advertised, leaving enough time for all
         * hops to wait for or present the payment preimage to complete the payment.
         * @member {number} totalTimeLock
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalTimeLock = 0;

        /**
         * The sum of the fees paid at each hop within the final route.  In the case
         * of a one-hop payment, this value will be zero as we don't need to pay a fee
         * to ourselves.
         * @member {number|Long} totalFees
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalFees = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total amount of funds required to complete a payment over this route.
         * This value includes the cumulative fees at each hop. As a result, the HTLC
         * extended to the first-hop in the route will need to have at least this many
         * satoshis, otherwise the route will fail at an intermediate node due to an
         * insufficient amount of fees.
         * @member {number|Long} totalAmt
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalAmt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Contains details concerning the specific forwarding details at each hop.
         * @member {Array.<lnrpc.IHop>} hops
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.hops = $util.emptyArray;

        /**
         * The total fees in millisatoshis.
         * @member {number|Long} totalFeesMsat
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalFeesMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The total amount in millisatoshis.
         * @member {number|Long} totalAmtMsat
         * @memberof lnrpc.Route
         * @instance
         */
        Route.prototype.totalAmtMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Route instance using the specified properties.
         * @function create
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute=} [properties] Properties to set
         * @returns {lnrpc.Route} Route instance
         */
        Route.create = function create(properties) {
            return new Route(properties);
        };

        /**
         * Encodes the specified Route message. Does not implicitly {@link lnrpc.Route.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute} message Route message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Route.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalTimeLock != null && message.hasOwnProperty("totalTimeLock"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.totalTimeLock);
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalFees);
            if (message.totalAmt != null && message.hasOwnProperty("totalAmt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalAmt);
            if (message.hops != null && message.hops.length)
                for (let i = 0; i < message.hops.length; ++i)
                    $root.lnrpc.Hop.encode(message.hops[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.totalFeesMsat != null && message.hasOwnProperty("totalFeesMsat"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.totalFeesMsat);
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.totalAmtMsat);
            return writer;
        };

        /**
         * Encodes the specified Route message, length delimited. Does not implicitly {@link lnrpc.Route.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.IRoute} message Route message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Route.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Route message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Route
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Route} Route
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Route.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Route();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.totalTimeLock = reader.uint32();
                    break;
                case 2:
                    message.totalFees = reader.int64();
                    break;
                case 3:
                    message.totalAmt = reader.int64();
                    break;
                case 4:
                    if (!(message.hops && message.hops.length))
                        message.hops = [];
                    message.hops.push($root.lnrpc.Hop.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.totalFeesMsat = reader.int64();
                    break;
                case 6:
                    message.totalAmtMsat = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Route message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Route
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Route} Route
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Route.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Route message.
         * @function verify
         * @memberof lnrpc.Route
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Route.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalTimeLock != null && message.hasOwnProperty("totalTimeLock"))
                if (!$util.isInteger(message.totalTimeLock))
                    return "totalTimeLock: integer expected";
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (!$util.isInteger(message.totalFees) && !(message.totalFees && $util.isInteger(message.totalFees.low) && $util.isInteger(message.totalFees.high)))
                    return "totalFees: integer|Long expected";
            if (message.totalAmt != null && message.hasOwnProperty("totalAmt"))
                if (!$util.isInteger(message.totalAmt) && !(message.totalAmt && $util.isInteger(message.totalAmt.low) && $util.isInteger(message.totalAmt.high)))
                    return "totalAmt: integer|Long expected";
            if (message.hops != null && message.hasOwnProperty("hops")) {
                if (!Array.isArray(message.hops))
                    return "hops: array expected";
                for (let i = 0; i < message.hops.length; ++i) {
                    let error = $root.lnrpc.Hop.verify(message.hops[i]);
                    if (error)
                        return "hops." + error;
                }
            }
            if (message.totalFeesMsat != null && message.hasOwnProperty("totalFeesMsat"))
                if (!$util.isInteger(message.totalFeesMsat) && !(message.totalFeesMsat && $util.isInteger(message.totalFeesMsat.low) && $util.isInteger(message.totalFeesMsat.high)))
                    return "totalFeesMsat: integer|Long expected";
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                if (!$util.isInteger(message.totalAmtMsat) && !(message.totalAmtMsat && $util.isInteger(message.totalAmtMsat.low) && $util.isInteger(message.totalAmtMsat.high)))
                    return "totalAmtMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a Route message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Route
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Route} Route
         */
        Route.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Route)
                return object;
            let message = new $root.lnrpc.Route();
            if (object.totalTimeLock != null)
                message.totalTimeLock = object.totalTimeLock >>> 0;
            if (object.totalFees != null)
                if ($util.Long)
                    (message.totalFees = $util.Long.fromValue(object.totalFees)).unsigned = false;
                else if (typeof object.totalFees === "string")
                    message.totalFees = parseInt(object.totalFees, 10);
                else if (typeof object.totalFees === "number")
                    message.totalFees = object.totalFees;
                else if (typeof object.totalFees === "object")
                    message.totalFees = new $util.LongBits(object.totalFees.low >>> 0, object.totalFees.high >>> 0).toNumber();
            if (object.totalAmt != null)
                if ($util.Long)
                    (message.totalAmt = $util.Long.fromValue(object.totalAmt)).unsigned = false;
                else if (typeof object.totalAmt === "string")
                    message.totalAmt = parseInt(object.totalAmt, 10);
                else if (typeof object.totalAmt === "number")
                    message.totalAmt = object.totalAmt;
                else if (typeof object.totalAmt === "object")
                    message.totalAmt = new $util.LongBits(object.totalAmt.low >>> 0, object.totalAmt.high >>> 0).toNumber();
            if (object.hops) {
                if (!Array.isArray(object.hops))
                    throw TypeError(".lnrpc.Route.hops: array expected");
                message.hops = [];
                for (let i = 0; i < object.hops.length; ++i) {
                    if (typeof object.hops[i] !== "object")
                        throw TypeError(".lnrpc.Route.hops: object expected");
                    message.hops[i] = $root.lnrpc.Hop.fromObject(object.hops[i]);
                }
            }
            if (object.totalFeesMsat != null)
                if ($util.Long)
                    (message.totalFeesMsat = $util.Long.fromValue(object.totalFeesMsat)).unsigned = false;
                else if (typeof object.totalFeesMsat === "string")
                    message.totalFeesMsat = parseInt(object.totalFeesMsat, 10);
                else if (typeof object.totalFeesMsat === "number")
                    message.totalFeesMsat = object.totalFeesMsat;
                else if (typeof object.totalFeesMsat === "object")
                    message.totalFeesMsat = new $util.LongBits(object.totalFeesMsat.low >>> 0, object.totalFeesMsat.high >>> 0).toNumber();
            if (object.totalAmtMsat != null)
                if ($util.Long)
                    (message.totalAmtMsat = $util.Long.fromValue(object.totalAmtMsat)).unsigned = false;
                else if (typeof object.totalAmtMsat === "string")
                    message.totalAmtMsat = parseInt(object.totalAmtMsat, 10);
                else if (typeof object.totalAmtMsat === "number")
                    message.totalAmtMsat = object.totalAmtMsat;
                else if (typeof object.totalAmtMsat === "object")
                    message.totalAmtMsat = new $util.LongBits(object.totalAmtMsat.low >>> 0, object.totalAmtMsat.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Route message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Route
         * @static
         * @param {lnrpc.Route} message Route
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Route.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.hops = [];
            if (options.defaults) {
                object.totalTimeLock = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalFees = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFees = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalAmt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAmt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalFeesMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalFeesMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalAmtMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalAmtMsat = options.longs === String ? "0" : 0;
            }
            if (message.totalTimeLock != null && message.hasOwnProperty("totalTimeLock"))
                object.totalTimeLock = message.totalTimeLock;
            if (message.totalFees != null && message.hasOwnProperty("totalFees"))
                if (typeof message.totalFees === "number")
                    object.totalFees = options.longs === String ? String(message.totalFees) : message.totalFees;
                else
                    object.totalFees = options.longs === String ? $util.Long.prototype.toString.call(message.totalFees) : options.longs === Number ? new $util.LongBits(message.totalFees.low >>> 0, message.totalFees.high >>> 0).toNumber() : message.totalFees;
            if (message.totalAmt != null && message.hasOwnProperty("totalAmt"))
                if (typeof message.totalAmt === "number")
                    object.totalAmt = options.longs === String ? String(message.totalAmt) : message.totalAmt;
                else
                    object.totalAmt = options.longs === String ? $util.Long.prototype.toString.call(message.totalAmt) : options.longs === Number ? new $util.LongBits(message.totalAmt.low >>> 0, message.totalAmt.high >>> 0).toNumber() : message.totalAmt;
            if (message.hops && message.hops.length) {
                object.hops = [];
                for (let j = 0; j < message.hops.length; ++j)
                    object.hops[j] = $root.lnrpc.Hop.toObject(message.hops[j], options);
            }
            if (message.totalFeesMsat != null && message.hasOwnProperty("totalFeesMsat"))
                if (typeof message.totalFeesMsat === "number")
                    object.totalFeesMsat = options.longs === String ? String(message.totalFeesMsat) : message.totalFeesMsat;
                else
                    object.totalFeesMsat = options.longs === String ? $util.Long.prototype.toString.call(message.totalFeesMsat) : options.longs === Number ? new $util.LongBits(message.totalFeesMsat.low >>> 0, message.totalFeesMsat.high >>> 0).toNumber() : message.totalFeesMsat;
            if (message.totalAmtMsat != null && message.hasOwnProperty("totalAmtMsat"))
                if (typeof message.totalAmtMsat === "number")
                    object.totalAmtMsat = options.longs === String ? String(message.totalAmtMsat) : message.totalAmtMsat;
                else
                    object.totalAmtMsat = options.longs === String ? $util.Long.prototype.toString.call(message.totalAmtMsat) : options.longs === Number ? new $util.LongBits(message.totalAmtMsat.low >>> 0, message.totalAmtMsat.high >>> 0).toNumber() : message.totalAmtMsat;
            return object;
        };

        /**
         * Converts this Route to JSON.
         * @function toJSON
         * @memberof lnrpc.Route
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Route.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Route;
    })();

    lnrpc.NodeInfoRequest = (function() {

        /**
         * Properties of a NodeInfoRequest.
         * @memberof lnrpc
         * @interface INodeInfoRequest
         * @property {string|null} [pubKey] The 33-byte hex-encoded compressed public of the target node
         * @property {boolean|null} [includeChannels] If true, will include all known channels associated with the node.
         */

        /**
         * Constructs a new NodeInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a NodeInfoRequest.
         * @implements INodeInfoRequest
         * @constructor
         * @param {lnrpc.INodeInfoRequest=} [properties] Properties to set
         */
        function NodeInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The 33-byte hex-encoded compressed public of the target node
         * @member {string} pubKey
         * @memberof lnrpc.NodeInfoRequest
         * @instance
         */
        NodeInfoRequest.prototype.pubKey = "";

        /**
         * If true, will include all known channels associated with the node.
         * @member {boolean} includeChannels
         * @memberof lnrpc.NodeInfoRequest
         * @instance
         */
        NodeInfoRequest.prototype.includeChannels = false;

        /**
         * Creates a new NodeInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest instance
         */
        NodeInfoRequest.create = function create(properties) {
            return new NodeInfoRequest(properties);
        };

        /**
         * Encodes the specified NodeInfoRequest message. Does not implicitly {@link lnrpc.NodeInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest} message NodeInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubKey);
            if (message.includeChannels != null && message.hasOwnProperty("includeChannels"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.includeChannels);
            return writer;
        };

        /**
         * Encodes the specified NodeInfoRequest message, length delimited. Does not implicitly {@link lnrpc.NodeInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.INodeInfoRequest} message NodeInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pubKey = reader.string();
                    break;
                case 2:
                    message.includeChannels = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfoRequest message.
         * @function verify
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.includeChannels != null && message.hasOwnProperty("includeChannels"))
                if (typeof message.includeChannels !== "boolean")
                    return "includeChannels: boolean expected";
            return null;
        };

        /**
         * Creates a NodeInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeInfoRequest} NodeInfoRequest
         */
        NodeInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeInfoRequest)
                return object;
            let message = new $root.lnrpc.NodeInfoRequest();
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.includeChannels != null)
                message.includeChannels = Boolean(object.includeChannels);
            return message;
        };

        /**
         * Creates a plain object from a NodeInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeInfoRequest
         * @static
         * @param {lnrpc.NodeInfoRequest} message NodeInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pubKey = "";
                object.includeChannels = false;
            }
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.includeChannels != null && message.hasOwnProperty("includeChannels"))
                object.includeChannels = message.includeChannels;
            return object;
        };

        /**
         * Converts this NodeInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeInfoRequest;
    })();

    lnrpc.NodeInfo = (function() {

        /**
         * Properties of a NodeInfo.
         * @memberof lnrpc
         * @interface INodeInfo
         * @property {lnrpc.ILightningNode|null} [node] An individual vertex/node within the channel graph. A node is
         * connected to other nodes by one or more channel edges emanating from it. As
         * the graph is directed, a node will also have an incoming edge attached to
         * it for each outgoing edge.
         * @property {number|null} [numChannels] The total number of channels for the node.
         * @property {number|Long|null} [totalCapacity] The sum of all channels capacity for the node, denominated in satoshis.
         * @property {Array.<lnrpc.IChannelEdge>|null} [channels] A list of all public channels for the node.
         */

        /**
         * Constructs a new NodeInfo.
         * @memberof lnrpc
         * @classdesc Represents a NodeInfo.
         * @implements INodeInfo
         * @constructor
         * @param {lnrpc.INodeInfo=} [properties] Properties to set
         */
        function NodeInfo(properties) {
            this.channels = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * An individual vertex/node within the channel graph. A node is
         * connected to other nodes by one or more channel edges emanating from it. As
         * the graph is directed, a node will also have an incoming edge attached to
         * it for each outgoing edge.
         * @member {lnrpc.ILightningNode|null|undefined} node
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.node = null;

        /**
         * The total number of channels for the node.
         * @member {number} numChannels
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.numChannels = 0;

        /**
         * The sum of all channels capacity for the node, denominated in satoshis.
         * @member {number|Long} totalCapacity
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.totalCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A list of all public channels for the node.
         * @member {Array.<lnrpc.IChannelEdge>} channels
         * @memberof lnrpc.NodeInfo
         * @instance
         */
        NodeInfo.prototype.channels = $util.emptyArray;

        /**
         * Creates a new NodeInfo instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo=} [properties] Properties to set
         * @returns {lnrpc.NodeInfo} NodeInfo instance
         */
        NodeInfo.create = function create(properties) {
            return new NodeInfo(properties);
        };

        /**
         * Encodes the specified NodeInfo message. Does not implicitly {@link lnrpc.NodeInfo.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.node != null && message.hasOwnProperty("node"))
                $root.lnrpc.LightningNode.encode(message.node, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.numChannels);
            if (message.totalCapacity != null && message.hasOwnProperty("totalCapacity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.totalCapacity);
            if (message.channels != null && message.channels.length)
                for (let i = 0; i < message.channels.length; ++i)
                    $root.lnrpc.ChannelEdge.encode(message.channels[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NodeInfo message, length delimited. Does not implicitly {@link lnrpc.NodeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.INodeInfo} message NodeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.node = $root.lnrpc.LightningNode.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.numChannels = reader.uint32();
                    break;
                case 3:
                    message.totalCapacity = reader.int64();
                    break;
                case 4:
                    if (!(message.channels && message.channels.length))
                        message.channels = [];
                    message.channels.push($root.lnrpc.ChannelEdge.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeInfo} NodeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeInfo message.
         * @function verify
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.node != null && message.hasOwnProperty("node")) {
                let error = $root.lnrpc.LightningNode.verify(message.node);
                if (error)
                    return "node." + error;
            }
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                if (!$util.isInteger(message.numChannels))
                    return "numChannels: integer expected";
            if (message.totalCapacity != null && message.hasOwnProperty("totalCapacity"))
                if (!$util.isInteger(message.totalCapacity) && !(message.totalCapacity && $util.isInteger(message.totalCapacity.low) && $util.isInteger(message.totalCapacity.high)))
                    return "totalCapacity: integer|Long expected";
            if (message.channels != null && message.hasOwnProperty("channels")) {
                if (!Array.isArray(message.channels))
                    return "channels: array expected";
                for (let i = 0; i < message.channels.length; ++i) {
                    let error = $root.lnrpc.ChannelEdge.verify(message.channels[i]);
                    if (error)
                        return "channels." + error;
                }
            }
            return null;
        };

        /**
         * Creates a NodeInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeInfo} NodeInfo
         */
        NodeInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeInfo)
                return object;
            let message = new $root.lnrpc.NodeInfo();
            if (object.node != null) {
                if (typeof object.node !== "object")
                    throw TypeError(".lnrpc.NodeInfo.node: object expected");
                message.node = $root.lnrpc.LightningNode.fromObject(object.node);
            }
            if (object.numChannels != null)
                message.numChannels = object.numChannels >>> 0;
            if (object.totalCapacity != null)
                if ($util.Long)
                    (message.totalCapacity = $util.Long.fromValue(object.totalCapacity)).unsigned = false;
                else if (typeof object.totalCapacity === "string")
                    message.totalCapacity = parseInt(object.totalCapacity, 10);
                else if (typeof object.totalCapacity === "number")
                    message.totalCapacity = object.totalCapacity;
                else if (typeof object.totalCapacity === "object")
                    message.totalCapacity = new $util.LongBits(object.totalCapacity.low >>> 0, object.totalCapacity.high >>> 0).toNumber();
            if (object.channels) {
                if (!Array.isArray(object.channels))
                    throw TypeError(".lnrpc.NodeInfo.channels: array expected");
                message.channels = [];
                for (let i = 0; i < object.channels.length; ++i) {
                    if (typeof object.channels[i] !== "object")
                        throw TypeError(".lnrpc.NodeInfo.channels: object expected");
                    message.channels[i] = $root.lnrpc.ChannelEdge.fromObject(object.channels[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a NodeInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeInfo
         * @static
         * @param {lnrpc.NodeInfo} message NodeInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.channels = [];
            if (options.defaults) {
                object.node = null;
                object.numChannels = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalCapacity = options.longs === String ? "0" : 0;
            }
            if (message.node != null && message.hasOwnProperty("node"))
                object.node = $root.lnrpc.LightningNode.toObject(message.node, options);
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                object.numChannels = message.numChannels;
            if (message.totalCapacity != null && message.hasOwnProperty("totalCapacity"))
                if (typeof message.totalCapacity === "number")
                    object.totalCapacity = options.longs === String ? String(message.totalCapacity) : message.totalCapacity;
                else
                    object.totalCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.totalCapacity) : options.longs === Number ? new $util.LongBits(message.totalCapacity.low >>> 0, message.totalCapacity.high >>> 0).toNumber() : message.totalCapacity;
            if (message.channels && message.channels.length) {
                object.channels = [];
                for (let j = 0; j < message.channels.length; ++j)
                    object.channels[j] = $root.lnrpc.ChannelEdge.toObject(message.channels[j], options);
            }
            return object;
        };

        /**
         * Converts this NodeInfo to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeInfo;
    })();

    lnrpc.LightningNode = (function() {

        /**
         * Properties of a LightningNode.
         * @memberof lnrpc
         * @interface ILightningNode
         * @property {number|null} [lastUpdate] LightningNode lastUpdate
         * @property {string|null} [pubKey] LightningNode pubKey
         * @property {string|null} [alias] LightningNode alias
         * @property {Array.<lnrpc.INodeAddress>|null} [addresses] LightningNode addresses
         * @property {string|null} [color] LightningNode color
         */

        /**
         * Constructs a new LightningNode.
         * @memberof lnrpc
         * @classdesc An individual vertex/node within the channel graph. A node is
         * connected to other nodes by one or more channel edges emanating from it. As the
         * graph is directed, a node will also have an incoming edge attached to it for
         * each outgoing edge.
         * @implements ILightningNode
         * @constructor
         * @param {lnrpc.ILightningNode=} [properties] Properties to set
         */
        function LightningNode(properties) {
            this.addresses = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LightningNode lastUpdate.
         * @member {number} lastUpdate
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.lastUpdate = 0;

        /**
         * LightningNode pubKey.
         * @member {string} pubKey
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.pubKey = "";

        /**
         * LightningNode alias.
         * @member {string} alias
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.alias = "";

        /**
         * LightningNode addresses.
         * @member {Array.<lnrpc.INodeAddress>} addresses
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.addresses = $util.emptyArray;

        /**
         * LightningNode color.
         * @member {string} color
         * @memberof lnrpc.LightningNode
         * @instance
         */
        LightningNode.prototype.color = "";

        /**
         * Creates a new LightningNode instance using the specified properties.
         * @function create
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode=} [properties] Properties to set
         * @returns {lnrpc.LightningNode} LightningNode instance
         */
        LightningNode.create = function create(properties) {
            return new LightningNode(properties);
        };

        /**
         * Encodes the specified LightningNode message. Does not implicitly {@link lnrpc.LightningNode.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode} message LightningNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningNode.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.lastUpdate);
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.pubKey);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.alias);
            if (message.addresses != null && message.addresses.length)
                for (let i = 0; i < message.addresses.length; ++i)
                    $root.lnrpc.NodeAddress.encode(message.addresses[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.color != null && message.hasOwnProperty("color"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.color);
            return writer;
        };

        /**
         * Encodes the specified LightningNode message, length delimited. Does not implicitly {@link lnrpc.LightningNode.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.ILightningNode} message LightningNode message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LightningNode.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LightningNode message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.LightningNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.LightningNode} LightningNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningNode.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.LightningNode();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lastUpdate = reader.uint32();
                    break;
                case 2:
                    message.pubKey = reader.string();
                    break;
                case 3:
                    message.alias = reader.string();
                    break;
                case 4:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push($root.lnrpc.NodeAddress.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LightningNode message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.LightningNode
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.LightningNode} LightningNode
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LightningNode.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LightningNode message.
         * @function verify
         * @memberof lnrpc.LightningNode
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LightningNode.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                if (!$util.isInteger(message.lastUpdate))
                    return "lastUpdate: integer expected";
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                if (!$util.isString(message.pubKey))
                    return "pubKey: string expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (let i = 0; i < message.addresses.length; ++i) {
                    let error = $root.lnrpc.NodeAddress.verify(message.addresses[i]);
                    if (error)
                        return "addresses." + error;
                }
            }
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            return null;
        };

        /**
         * Creates a LightningNode message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.LightningNode
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.LightningNode} LightningNode
         */
        LightningNode.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.LightningNode)
                return object;
            let message = new $root.lnrpc.LightningNode();
            if (object.lastUpdate != null)
                message.lastUpdate = object.lastUpdate >>> 0;
            if (object.pubKey != null)
                message.pubKey = String(object.pubKey);
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".lnrpc.LightningNode.addresses: array expected");
                message.addresses = [];
                for (let i = 0; i < object.addresses.length; ++i) {
                    if (typeof object.addresses[i] !== "object")
                        throw TypeError(".lnrpc.LightningNode.addresses: object expected");
                    message.addresses[i] = $root.lnrpc.NodeAddress.fromObject(object.addresses[i]);
                }
            }
            if (object.color != null)
                message.color = String(object.color);
            return message;
        };

        /**
         * Creates a plain object from a LightningNode message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.LightningNode
         * @static
         * @param {lnrpc.LightningNode} message LightningNode
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LightningNode.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (options.defaults) {
                object.lastUpdate = 0;
                object.pubKey = "";
                object.alias = "";
                object.color = "";
            }
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                object.lastUpdate = message.lastUpdate;
            if (message.pubKey != null && message.hasOwnProperty("pubKey"))
                object.pubKey = message.pubKey;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (let j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = $root.lnrpc.NodeAddress.toObject(message.addresses[j], options);
            }
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            return object;
        };

        /**
         * Converts this LightningNode to JSON.
         * @function toJSON
         * @memberof lnrpc.LightningNode
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LightningNode.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return LightningNode;
    })();

    lnrpc.NodeAddress = (function() {

        /**
         * Properties of a NodeAddress.
         * @memberof lnrpc
         * @interface INodeAddress
         * @property {string|null} [network] NodeAddress network
         * @property {string|null} [addr] NodeAddress addr
         */

        /**
         * Constructs a new NodeAddress.
         * @memberof lnrpc
         * @classdesc Represents a NodeAddress.
         * @implements INodeAddress
         * @constructor
         * @param {lnrpc.INodeAddress=} [properties] Properties to set
         */
        function NodeAddress(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeAddress network.
         * @member {string} network
         * @memberof lnrpc.NodeAddress
         * @instance
         */
        NodeAddress.prototype.network = "";

        /**
         * NodeAddress addr.
         * @member {string} addr
         * @memberof lnrpc.NodeAddress
         * @instance
         */
        NodeAddress.prototype.addr = "";

        /**
         * Creates a new NodeAddress instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress=} [properties] Properties to set
         * @returns {lnrpc.NodeAddress} NodeAddress instance
         */
        NodeAddress.create = function create(properties) {
            return new NodeAddress(properties);
        };

        /**
         * Encodes the specified NodeAddress message. Does not implicitly {@link lnrpc.NodeAddress.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.network != null && message.hasOwnProperty("network"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.network);
            if (message.addr != null && message.hasOwnProperty("addr"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.addr);
            return writer;
        };

        /**
         * Encodes the specified NodeAddress message, length delimited. Does not implicitly {@link lnrpc.NodeAddress.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.INodeAddress} message NodeAddress message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeAddress.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeAddress();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.network = reader.string();
                    break;
                case 2:
                    message.addr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeAddress message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeAddress} NodeAddress
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeAddress.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeAddress message.
         * @function verify
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeAddress.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.network != null && message.hasOwnProperty("network"))
                if (!$util.isString(message.network))
                    return "network: string expected";
            if (message.addr != null && message.hasOwnProperty("addr"))
                if (!$util.isString(message.addr))
                    return "addr: string expected";
            return null;
        };

        /**
         * Creates a NodeAddress message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeAddress} NodeAddress
         */
        NodeAddress.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeAddress)
                return object;
            let message = new $root.lnrpc.NodeAddress();
            if (object.network != null)
                message.network = String(object.network);
            if (object.addr != null)
                message.addr = String(object.addr);
            return message;
        };

        /**
         * Creates a plain object from a NodeAddress message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeAddress
         * @static
         * @param {lnrpc.NodeAddress} message NodeAddress
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeAddress.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.network = "";
                object.addr = "";
            }
            if (message.network != null && message.hasOwnProperty("network"))
                object.network = message.network;
            if (message.addr != null && message.hasOwnProperty("addr"))
                object.addr = message.addr;
            return object;
        };

        /**
         * Converts this NodeAddress to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeAddress
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeAddress.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeAddress;
    })();

    lnrpc.RoutingPolicy = (function() {

        /**
         * Properties of a RoutingPolicy.
         * @memberof lnrpc
         * @interface IRoutingPolicy
         * @property {number|null} [timeLockDelta] RoutingPolicy timeLockDelta
         * @property {number|Long|null} [minHtlc] RoutingPolicy minHtlc
         * @property {number|Long|null} [feeBaseMsat] RoutingPolicy feeBaseMsat
         * @property {number|Long|null} [feeRateMilliMsat] RoutingPolicy feeRateMilliMsat
         * @property {boolean|null} [disabled] RoutingPolicy disabled
         * @property {number|Long|null} [maxHtlcMsat] RoutingPolicy maxHtlcMsat
         * @property {number|null} [lastUpdate] RoutingPolicy lastUpdate
         */

        /**
         * Constructs a new RoutingPolicy.
         * @memberof lnrpc
         * @classdesc Represents a RoutingPolicy.
         * @implements IRoutingPolicy
         * @constructor
         * @param {lnrpc.IRoutingPolicy=} [properties] Properties to set
         */
        function RoutingPolicy(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RoutingPolicy timeLockDelta.
         * @member {number} timeLockDelta
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.timeLockDelta = 0;

        /**
         * RoutingPolicy minHtlc.
         * @member {number|Long} minHtlc
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.minHtlc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoutingPolicy feeBaseMsat.
         * @member {number|Long} feeBaseMsat
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.feeBaseMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoutingPolicy feeRateMilliMsat.
         * @member {number|Long} feeRateMilliMsat
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.feeRateMilliMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RoutingPolicy disabled.
         * @member {boolean} disabled
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.disabled = false;

        /**
         * RoutingPolicy maxHtlcMsat.
         * @member {number|Long} maxHtlcMsat
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.maxHtlcMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RoutingPolicy lastUpdate.
         * @member {number} lastUpdate
         * @memberof lnrpc.RoutingPolicy
         * @instance
         */
        RoutingPolicy.prototype.lastUpdate = 0;

        /**
         * Creates a new RoutingPolicy instance using the specified properties.
         * @function create
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy=} [properties] Properties to set
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy instance
         */
        RoutingPolicy.create = function create(properties) {
            return new RoutingPolicy(properties);
        };

        /**
         * Encodes the specified RoutingPolicy message. Does not implicitly {@link lnrpc.RoutingPolicy.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy} message RoutingPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingPolicy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeLockDelta);
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.minHtlc);
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.feeBaseMsat);
            if (message.feeRateMilliMsat != null && message.hasOwnProperty("feeRateMilliMsat"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.feeRateMilliMsat);
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.disabled);
            if (message.maxHtlcMsat != null && message.hasOwnProperty("maxHtlcMsat"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.maxHtlcMsat);
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.lastUpdate);
            return writer;
        };

        /**
         * Encodes the specified RoutingPolicy message, length delimited. Does not implicitly {@link lnrpc.RoutingPolicy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.IRoutingPolicy} message RoutingPolicy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RoutingPolicy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RoutingPolicy message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingPolicy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RoutingPolicy();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timeLockDelta = reader.uint32();
                    break;
                case 2:
                    message.minHtlc = reader.int64();
                    break;
                case 3:
                    message.feeBaseMsat = reader.int64();
                    break;
                case 4:
                    message.feeRateMilliMsat = reader.int64();
                    break;
                case 5:
                    message.disabled = reader.bool();
                    break;
                case 6:
                    message.maxHtlcMsat = reader.uint64();
                    break;
                case 7:
                    message.lastUpdate = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RoutingPolicy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RoutingPolicy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RoutingPolicy message.
         * @function verify
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RoutingPolicy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                if (!$util.isInteger(message.timeLockDelta))
                    return "timeLockDelta: integer expected";
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                if (!$util.isInteger(message.minHtlc) && !(message.minHtlc && $util.isInteger(message.minHtlc.low) && $util.isInteger(message.minHtlc.high)))
                    return "minHtlc: integer|Long expected";
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (!$util.isInteger(message.feeBaseMsat) && !(message.feeBaseMsat && $util.isInteger(message.feeBaseMsat.low) && $util.isInteger(message.feeBaseMsat.high)))
                    return "feeBaseMsat: integer|Long expected";
            if (message.feeRateMilliMsat != null && message.hasOwnProperty("feeRateMilliMsat"))
                if (!$util.isInteger(message.feeRateMilliMsat) && !(message.feeRateMilliMsat && $util.isInteger(message.feeRateMilliMsat.low) && $util.isInteger(message.feeRateMilliMsat.high)))
                    return "feeRateMilliMsat: integer|Long expected";
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                if (typeof message.disabled !== "boolean")
                    return "disabled: boolean expected";
            if (message.maxHtlcMsat != null && message.hasOwnProperty("maxHtlcMsat"))
                if (!$util.isInteger(message.maxHtlcMsat) && !(message.maxHtlcMsat && $util.isInteger(message.maxHtlcMsat.low) && $util.isInteger(message.maxHtlcMsat.high)))
                    return "maxHtlcMsat: integer|Long expected";
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                if (!$util.isInteger(message.lastUpdate))
                    return "lastUpdate: integer expected";
            return null;
        };

        /**
         * Creates a RoutingPolicy message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RoutingPolicy} RoutingPolicy
         */
        RoutingPolicy.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RoutingPolicy)
                return object;
            let message = new $root.lnrpc.RoutingPolicy();
            if (object.timeLockDelta != null)
                message.timeLockDelta = object.timeLockDelta >>> 0;
            if (object.minHtlc != null)
                if ($util.Long)
                    (message.minHtlc = $util.Long.fromValue(object.minHtlc)).unsigned = false;
                else if (typeof object.minHtlc === "string")
                    message.minHtlc = parseInt(object.minHtlc, 10);
                else if (typeof object.minHtlc === "number")
                    message.minHtlc = object.minHtlc;
                else if (typeof object.minHtlc === "object")
                    message.minHtlc = new $util.LongBits(object.minHtlc.low >>> 0, object.minHtlc.high >>> 0).toNumber();
            if (object.feeBaseMsat != null)
                if ($util.Long)
                    (message.feeBaseMsat = $util.Long.fromValue(object.feeBaseMsat)).unsigned = false;
                else if (typeof object.feeBaseMsat === "string")
                    message.feeBaseMsat = parseInt(object.feeBaseMsat, 10);
                else if (typeof object.feeBaseMsat === "number")
                    message.feeBaseMsat = object.feeBaseMsat;
                else if (typeof object.feeBaseMsat === "object")
                    message.feeBaseMsat = new $util.LongBits(object.feeBaseMsat.low >>> 0, object.feeBaseMsat.high >>> 0).toNumber();
            if (object.feeRateMilliMsat != null)
                if ($util.Long)
                    (message.feeRateMilliMsat = $util.Long.fromValue(object.feeRateMilliMsat)).unsigned = false;
                else if (typeof object.feeRateMilliMsat === "string")
                    message.feeRateMilliMsat = parseInt(object.feeRateMilliMsat, 10);
                else if (typeof object.feeRateMilliMsat === "number")
                    message.feeRateMilliMsat = object.feeRateMilliMsat;
                else if (typeof object.feeRateMilliMsat === "object")
                    message.feeRateMilliMsat = new $util.LongBits(object.feeRateMilliMsat.low >>> 0, object.feeRateMilliMsat.high >>> 0).toNumber();
            if (object.disabled != null)
                message.disabled = Boolean(object.disabled);
            if (object.maxHtlcMsat != null)
                if ($util.Long)
                    (message.maxHtlcMsat = $util.Long.fromValue(object.maxHtlcMsat)).unsigned = true;
                else if (typeof object.maxHtlcMsat === "string")
                    message.maxHtlcMsat = parseInt(object.maxHtlcMsat, 10);
                else if (typeof object.maxHtlcMsat === "number")
                    message.maxHtlcMsat = object.maxHtlcMsat;
                else if (typeof object.maxHtlcMsat === "object")
                    message.maxHtlcMsat = new $util.LongBits(object.maxHtlcMsat.low >>> 0, object.maxHtlcMsat.high >>> 0).toNumber(true);
            if (object.lastUpdate != null)
                message.lastUpdate = object.lastUpdate >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a RoutingPolicy message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RoutingPolicy
         * @static
         * @param {lnrpc.RoutingPolicy} message RoutingPolicy
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RoutingPolicy.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.timeLockDelta = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.minHtlc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minHtlc = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeBaseMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeBaseMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeRateMilliMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeRateMilliMsat = options.longs === String ? "0" : 0;
                object.disabled = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxHtlcMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxHtlcMsat = options.longs === String ? "0" : 0;
                object.lastUpdate = 0;
            }
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                object.timeLockDelta = message.timeLockDelta;
            if (message.minHtlc != null && message.hasOwnProperty("minHtlc"))
                if (typeof message.minHtlc === "number")
                    object.minHtlc = options.longs === String ? String(message.minHtlc) : message.minHtlc;
                else
                    object.minHtlc = options.longs === String ? $util.Long.prototype.toString.call(message.minHtlc) : options.longs === Number ? new $util.LongBits(message.minHtlc.low >>> 0, message.minHtlc.high >>> 0).toNumber() : message.minHtlc;
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (typeof message.feeBaseMsat === "number")
                    object.feeBaseMsat = options.longs === String ? String(message.feeBaseMsat) : message.feeBaseMsat;
                else
                    object.feeBaseMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeBaseMsat) : options.longs === Number ? new $util.LongBits(message.feeBaseMsat.low >>> 0, message.feeBaseMsat.high >>> 0).toNumber() : message.feeBaseMsat;
            if (message.feeRateMilliMsat != null && message.hasOwnProperty("feeRateMilliMsat"))
                if (typeof message.feeRateMilliMsat === "number")
                    object.feeRateMilliMsat = options.longs === String ? String(message.feeRateMilliMsat) : message.feeRateMilliMsat;
                else
                    object.feeRateMilliMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeRateMilliMsat) : options.longs === Number ? new $util.LongBits(message.feeRateMilliMsat.low >>> 0, message.feeRateMilliMsat.high >>> 0).toNumber() : message.feeRateMilliMsat;
            if (message.disabled != null && message.hasOwnProperty("disabled"))
                object.disabled = message.disabled;
            if (message.maxHtlcMsat != null && message.hasOwnProperty("maxHtlcMsat"))
                if (typeof message.maxHtlcMsat === "number")
                    object.maxHtlcMsat = options.longs === String ? String(message.maxHtlcMsat) : message.maxHtlcMsat;
                else
                    object.maxHtlcMsat = options.longs === String ? $util.Long.prototype.toString.call(message.maxHtlcMsat) : options.longs === Number ? new $util.LongBits(message.maxHtlcMsat.low >>> 0, message.maxHtlcMsat.high >>> 0).toNumber(true) : message.maxHtlcMsat;
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                object.lastUpdate = message.lastUpdate;
            return object;
        };

        /**
         * Converts this RoutingPolicy to JSON.
         * @function toJSON
         * @memberof lnrpc.RoutingPolicy
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RoutingPolicy.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RoutingPolicy;
    })();

    lnrpc.ChannelEdge = (function() {

        /**
         * Properties of a ChannelEdge.
         * @memberof lnrpc
         * @interface IChannelEdge
         * @property {number|Long|null} [channelId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {string|null} [chanPoint] ChannelEdge chanPoint
         * @property {number|null} [lastUpdate] ChannelEdge lastUpdate
         * @property {string|null} [node1Pub] ChannelEdge node1Pub
         * @property {string|null} [node2Pub] ChannelEdge node2Pub
         * @property {number|Long|null} [capacity] ChannelEdge capacity
         * @property {lnrpc.IRoutingPolicy|null} [node1Policy] ChannelEdge node1Policy
         * @property {lnrpc.IRoutingPolicy|null} [node2Policy] ChannelEdge node2Policy
         */

        /**
         * Constructs a new ChannelEdge.
         * @memberof lnrpc
         * @classdesc A fully authenticated channel along with all its unique attributes.
         * Once an authenticated channel announcement has been processed on the network,
         * then an instance of ChannelEdgeInfo encapsulating the channels attributes is
         * stored. The other portions relevant to routing policy of a channel are stored
         * within a ChannelEdgePolicy for each direction of the channel.
         * @implements IChannelEdge
         * @constructor
         * @param {lnrpc.IChannelEdge=} [properties] Properties to set
         */
        function ChannelEdge(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} channelId
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelEdge chanPoint.
         * @member {string} chanPoint
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.chanPoint = "";

        /**
         * ChannelEdge lastUpdate.
         * @member {number} lastUpdate
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.lastUpdate = 0;

        /**
         * ChannelEdge node1Pub.
         * @member {string} node1Pub
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node1Pub = "";

        /**
         * ChannelEdge node2Pub.
         * @member {string} node2Pub
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node2Pub = "";

        /**
         * ChannelEdge capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelEdge node1Policy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} node1Policy
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node1Policy = null;

        /**
         * ChannelEdge node2Policy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} node2Policy
         * @memberof lnrpc.ChannelEdge
         * @instance
         */
        ChannelEdge.prototype.node2Policy = null;

        /**
         * Creates a new ChannelEdge instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge=} [properties] Properties to set
         * @returns {lnrpc.ChannelEdge} ChannelEdge instance
         */
        ChannelEdge.create = function create(properties) {
            return new ChannelEdge(properties);
        };

        /**
         * Encodes the specified ChannelEdge message. Does not implicitly {@link lnrpc.ChannelEdge.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge} message ChannelEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.chanPoint);
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.lastUpdate);
            if (message.node1Pub != null && message.hasOwnProperty("node1Pub"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.node1Pub);
            if (message.node2Pub != null && message.hasOwnProperty("node2Pub"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.node2Pub);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.capacity);
            if (message.node1Policy != null && message.hasOwnProperty("node1Policy"))
                $root.lnrpc.RoutingPolicy.encode(message.node1Policy, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.node2Policy != null && message.hasOwnProperty("node2Policy"))
                $root.lnrpc.RoutingPolicy.encode(message.node2Policy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelEdge message, length delimited. Does not implicitly {@link lnrpc.ChannelEdge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.IChannelEdge} message ChannelEdge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEdge message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEdge();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelId = reader.uint64();
                    break;
                case 2:
                    message.chanPoint = reader.string();
                    break;
                case 3:
                    message.lastUpdate = reader.uint32();
                    break;
                case 4:
                    message.node1Pub = reader.string();
                    break;
                case 5:
                    message.node2Pub = reader.string();
                    break;
                case 6:
                    message.capacity = reader.int64();
                    break;
                case 7:
                    message.node1Policy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.node2Policy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEdge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEdge message.
         * @function verify
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEdge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                    return "channelId: integer|Long expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                if (!$util.isString(message.chanPoint))
                    return "chanPoint: string expected";
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                if (!$util.isInteger(message.lastUpdate))
                    return "lastUpdate: integer expected";
            if (message.node1Pub != null && message.hasOwnProperty("node1Pub"))
                if (!$util.isString(message.node1Pub))
                    return "node1Pub: string expected";
            if (message.node2Pub != null && message.hasOwnProperty("node2Pub"))
                if (!$util.isString(message.node2Pub))
                    return "node2Pub: string expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.node1Policy != null && message.hasOwnProperty("node1Policy")) {
                let error = $root.lnrpc.RoutingPolicy.verify(message.node1Policy);
                if (error)
                    return "node1Policy." + error;
            }
            if (message.node2Policy != null && message.hasOwnProperty("node2Policy")) {
                let error = $root.lnrpc.RoutingPolicy.verify(message.node2Policy);
                if (error)
                    return "node2Policy." + error;
            }
            return null;
        };

        /**
         * Creates a ChannelEdge message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEdge} ChannelEdge
         */
        ChannelEdge.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEdge)
                return object;
            let message = new $root.lnrpc.ChannelEdge();
            if (object.channelId != null)
                if ($util.Long)
                    (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                else if (typeof object.channelId === "string")
                    message.channelId = parseInt(object.channelId, 10);
                else if (typeof object.channelId === "number")
                    message.channelId = object.channelId;
                else if (typeof object.channelId === "object")
                    message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
            if (object.chanPoint != null)
                message.chanPoint = String(object.chanPoint);
            if (object.lastUpdate != null)
                message.lastUpdate = object.lastUpdate >>> 0;
            if (object.node1Pub != null)
                message.node1Pub = String(object.node1Pub);
            if (object.node2Pub != null)
                message.node2Pub = String(object.node2Pub);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.node1Policy != null) {
                if (typeof object.node1Policy !== "object")
                    throw TypeError(".lnrpc.ChannelEdge.node1Policy: object expected");
                message.node1Policy = $root.lnrpc.RoutingPolicy.fromObject(object.node1Policy);
            }
            if (object.node2Policy != null) {
                if (typeof object.node2Policy !== "object")
                    throw TypeError(".lnrpc.ChannelEdge.node2Policy: object expected");
                message.node2Policy = $root.lnrpc.RoutingPolicy.fromObject(object.node2Policy);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelEdge message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEdge
         * @static
         * @param {lnrpc.ChannelEdge} message ChannelEdge
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEdge.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.channelId = options.longs === String ? "0" : 0;
                object.chanPoint = "";
                object.lastUpdate = 0;
                object.node1Pub = "";
                object.node2Pub = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.node1Policy = null;
                object.node2Policy = null;
            }
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (typeof message.channelId === "number")
                    object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                else
                    object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = message.chanPoint;
            if (message.lastUpdate != null && message.hasOwnProperty("lastUpdate"))
                object.lastUpdate = message.lastUpdate;
            if (message.node1Pub != null && message.hasOwnProperty("node1Pub"))
                object.node1Pub = message.node1Pub;
            if (message.node2Pub != null && message.hasOwnProperty("node2Pub"))
                object.node2Pub = message.node2Pub;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.node1Policy != null && message.hasOwnProperty("node1Policy"))
                object.node1Policy = $root.lnrpc.RoutingPolicy.toObject(message.node1Policy, options);
            if (message.node2Policy != null && message.hasOwnProperty("node2Policy"))
                object.node2Policy = $root.lnrpc.RoutingPolicy.toObject(message.node2Policy, options);
            return object;
        };

        /**
         * Converts this ChannelEdge to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEdge
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEdge.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelEdge;
    })();

    lnrpc.ChannelGraphRequest = (function() {

        /**
         * Properties of a ChannelGraphRequest.
         * @memberof lnrpc
         * @interface IChannelGraphRequest
         * @property {boolean|null} [includeUnannounced] Whether unannounced channels are included in the response or not. If set,
         * unannounced channels are included. Unannounced channels are both private
         * channels, and public channels that are not yet announced to the network.
         */

        /**
         * Constructs a new ChannelGraphRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChannelGraphRequest.
         * @implements IChannelGraphRequest
         * @constructor
         * @param {lnrpc.IChannelGraphRequest=} [properties] Properties to set
         */
        function ChannelGraphRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Whether unannounced channels are included in the response or not. If set,
         * unannounced channels are included. Unannounced channels are both private
         * channels, and public channels that are not yet announced to the network.
         * @member {boolean} includeUnannounced
         * @memberof lnrpc.ChannelGraphRequest
         * @instance
         */
        ChannelGraphRequest.prototype.includeUnannounced = false;

        /**
         * Creates a new ChannelGraphRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest=} [properties] Properties to set
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest instance
         */
        ChannelGraphRequest.create = function create(properties) {
            return new ChannelGraphRequest(properties);
        };

        /**
         * Encodes the specified ChannelGraphRequest message. Does not implicitly {@link lnrpc.ChannelGraphRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest} message ChannelGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraphRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.includeUnannounced != null && message.hasOwnProperty("includeUnannounced"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.includeUnannounced);
            return writer;
        };

        /**
         * Encodes the specified ChannelGraphRequest message, length delimited. Does not implicitly {@link lnrpc.ChannelGraphRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.IChannelGraphRequest} message ChannelGraphRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraphRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGraphRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraphRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelGraphRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.includeUnannounced = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGraphRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraphRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGraphRequest message.
         * @function verify
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGraphRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.includeUnannounced != null && message.hasOwnProperty("includeUnannounced"))
                if (typeof message.includeUnannounced !== "boolean")
                    return "includeUnannounced: boolean expected";
            return null;
        };

        /**
         * Creates a ChannelGraphRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelGraphRequest} ChannelGraphRequest
         */
        ChannelGraphRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelGraphRequest)
                return object;
            let message = new $root.lnrpc.ChannelGraphRequest();
            if (object.includeUnannounced != null)
                message.includeUnannounced = Boolean(object.includeUnannounced);
            return message;
        };

        /**
         * Creates a plain object from a ChannelGraphRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelGraphRequest
         * @static
         * @param {lnrpc.ChannelGraphRequest} message ChannelGraphRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGraphRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.includeUnannounced = false;
            if (message.includeUnannounced != null && message.hasOwnProperty("includeUnannounced"))
                object.includeUnannounced = message.includeUnannounced;
            return object;
        };

        /**
         * Converts this ChannelGraphRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelGraphRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGraphRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGraphRequest;
    })();

    lnrpc.ChannelGraph = (function() {

        /**
         * Properties of a ChannelGraph.
         * @memberof lnrpc
         * @interface IChannelGraph
         * @property {Array.<lnrpc.ILightningNode>|null} [nodes] The list of `LightningNode`s in this channel graph
         * @property {Array.<lnrpc.IChannelEdge>|null} [edges] The list of `ChannelEdge`s in this channel graph
         */

        /**
         * Constructs a new ChannelGraph.
         * @memberof lnrpc
         * @classdesc Returns a new instance of the directed channel graph.
         * @implements IChannelGraph
         * @constructor
         * @param {lnrpc.IChannelGraph=} [properties] Properties to set
         */
        function ChannelGraph(properties) {
            this.nodes = [];
            this.edges = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of `LightningNode`s in this channel graph
         * @member {Array.<lnrpc.ILightningNode>} nodes
         * @memberof lnrpc.ChannelGraph
         * @instance
         */
        ChannelGraph.prototype.nodes = $util.emptyArray;

        /**
         * The list of `ChannelEdge`s in this channel graph
         * @member {Array.<lnrpc.IChannelEdge>} edges
         * @memberof lnrpc.ChannelGraph
         * @instance
         */
        ChannelGraph.prototype.edges = $util.emptyArray;

        /**
         * Creates a new ChannelGraph instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph=} [properties] Properties to set
         * @returns {lnrpc.ChannelGraph} ChannelGraph instance
         */
        ChannelGraph.create = function create(properties) {
            return new ChannelGraph(properties);
        };

        /**
         * Encodes the specified ChannelGraph message. Does not implicitly {@link lnrpc.ChannelGraph.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph} message ChannelGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraph.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodes != null && message.nodes.length)
                for (let i = 0; i < message.nodes.length; ++i)
                    $root.lnrpc.LightningNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.edges != null && message.edges.length)
                for (let i = 0; i < message.edges.length; ++i)
                    $root.lnrpc.ChannelEdge.encode(message.edges[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelGraph message, length delimited. Does not implicitly {@link lnrpc.ChannelGraph.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.IChannelGraph} message ChannelGraph message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelGraph.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelGraph message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraph.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelGraph();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodes && message.nodes.length))
                        message.nodes = [];
                    message.nodes.push($root.lnrpc.LightningNode.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.edges && message.edges.length))
                        message.edges = [];
                    message.edges.push($root.lnrpc.ChannelEdge.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelGraph message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelGraph.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelGraph message.
         * @function verify
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelGraph.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodes != null && message.hasOwnProperty("nodes")) {
                if (!Array.isArray(message.nodes))
                    return "nodes: array expected";
                for (let i = 0; i < message.nodes.length; ++i) {
                    let error = $root.lnrpc.LightningNode.verify(message.nodes[i]);
                    if (error)
                        return "nodes." + error;
                }
            }
            if (message.edges != null && message.hasOwnProperty("edges")) {
                if (!Array.isArray(message.edges))
                    return "edges: array expected";
                for (let i = 0; i < message.edges.length; ++i) {
                    let error = $root.lnrpc.ChannelEdge.verify(message.edges[i]);
                    if (error)
                        return "edges." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChannelGraph message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelGraph} ChannelGraph
         */
        ChannelGraph.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelGraph)
                return object;
            let message = new $root.lnrpc.ChannelGraph();
            if (object.nodes) {
                if (!Array.isArray(object.nodes))
                    throw TypeError(".lnrpc.ChannelGraph.nodes: array expected");
                message.nodes = [];
                for (let i = 0; i < object.nodes.length; ++i) {
                    if (typeof object.nodes[i] !== "object")
                        throw TypeError(".lnrpc.ChannelGraph.nodes: object expected");
                    message.nodes[i] = $root.lnrpc.LightningNode.fromObject(object.nodes[i]);
                }
            }
            if (object.edges) {
                if (!Array.isArray(object.edges))
                    throw TypeError(".lnrpc.ChannelGraph.edges: array expected");
                message.edges = [];
                for (let i = 0; i < object.edges.length; ++i) {
                    if (typeof object.edges[i] !== "object")
                        throw TypeError(".lnrpc.ChannelGraph.edges: object expected");
                    message.edges[i] = $root.lnrpc.ChannelEdge.fromObject(object.edges[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelGraph message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelGraph
         * @static
         * @param {lnrpc.ChannelGraph} message ChannelGraph
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelGraph.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.nodes = [];
                object.edges = [];
            }
            if (message.nodes && message.nodes.length) {
                object.nodes = [];
                for (let j = 0; j < message.nodes.length; ++j)
                    object.nodes[j] = $root.lnrpc.LightningNode.toObject(message.nodes[j], options);
            }
            if (message.edges && message.edges.length) {
                object.edges = [];
                for (let j = 0; j < message.edges.length; ++j)
                    object.edges[j] = $root.lnrpc.ChannelEdge.toObject(message.edges[j], options);
            }
            return object;
        };

        /**
         * Converts this ChannelGraph to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelGraph
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelGraph.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelGraph;
    })();

    lnrpc.ChanInfoRequest = (function() {

        /**
         * Properties of a ChanInfoRequest.
         * @memberof lnrpc
         * @interface IChanInfoRequest
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         */

        /**
         * Constructs a new ChanInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChanInfoRequest.
         * @implements IChanInfoRequest
         * @constructor
         * @param {lnrpc.IChanInfoRequest=} [properties] Properties to set
         */
        function ChanInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChanInfoRequest
         * @instance
         */
        ChanInfoRequest.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ChanInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest instance
         */
        ChanInfoRequest.create = function create(properties) {
            return new ChanInfoRequest(properties);
        };

        /**
         * Encodes the specified ChanInfoRequest message. Does not implicitly {@link lnrpc.ChanInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest} message ChanInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            return writer;
        };

        /**
         * Encodes the specified ChanInfoRequest message, length delimited. Does not implicitly {@link lnrpc.ChanInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.IChanInfoRequest} message ChanInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChanInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChanInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChanInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChanInfoRequest message.
         * @function verify
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChanInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            return null;
        };

        /**
         * Creates a ChanInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChanInfoRequest} ChanInfoRequest
         */
        ChanInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChanInfoRequest)
                return object;
            let message = new $root.lnrpc.ChanInfoRequest();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ChanInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChanInfoRequest
         * @static
         * @param {lnrpc.ChanInfoRequest} message ChanInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChanInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            return object;
        };

        /**
         * Converts this ChanInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChanInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChanInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChanInfoRequest;
    })();

    lnrpc.NetworkInfoRequest = (function() {

        /**
         * Properties of a NetworkInfoRequest.
         * @memberof lnrpc
         * @interface INetworkInfoRequest
         */

        /**
         * Constructs a new NetworkInfoRequest.
         * @memberof lnrpc
         * @classdesc Represents a NetworkInfoRequest.
         * @implements INetworkInfoRequest
         * @constructor
         * @param {lnrpc.INetworkInfoRequest=} [properties] Properties to set
         */
        function NetworkInfoRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NetworkInfoRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest=} [properties] Properties to set
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest instance
         */
        NetworkInfoRequest.create = function create(properties) {
            return new NetworkInfoRequest(properties);
        };

        /**
         * Encodes the specified NetworkInfoRequest message. Does not implicitly {@link lnrpc.NetworkInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest} message NetworkInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NetworkInfoRequest message, length delimited. Does not implicitly {@link lnrpc.NetworkInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.INetworkInfoRequest} message NetworkInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NetworkInfoRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkInfoRequest message.
         * @function verify
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a NetworkInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NetworkInfoRequest} NetworkInfoRequest
         */
        NetworkInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NetworkInfoRequest)
                return object;
            return new $root.lnrpc.NetworkInfoRequest();
        };

        /**
         * Creates a plain object from a NetworkInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NetworkInfoRequest
         * @static
         * @param {lnrpc.NetworkInfoRequest} message NetworkInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkInfoRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this NetworkInfoRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.NetworkInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkInfoRequest;
    })();

    lnrpc.NetworkInfo = (function() {

        /**
         * Properties of a NetworkInfo.
         * @memberof lnrpc
         * @interface INetworkInfo
         * @property {number|null} [graphDiameter] NetworkInfo graphDiameter
         * @property {number|null} [avgOutDegree] NetworkInfo avgOutDegree
         * @property {number|null} [maxOutDegree] NetworkInfo maxOutDegree
         * @property {number|null} [numNodes] NetworkInfo numNodes
         * @property {number|null} [numChannels] NetworkInfo numChannels
         * @property {number|Long|null} [totalNetworkCapacity] NetworkInfo totalNetworkCapacity
         * @property {number|null} [avgChannelSize] NetworkInfo avgChannelSize
         * @property {number|Long|null} [minChannelSize] NetworkInfo minChannelSize
         * @property {number|Long|null} [maxChannelSize] NetworkInfo maxChannelSize
         * @property {number|Long|null} [medianChannelSizeSat] NetworkInfo medianChannelSizeSat
         * @property {number|Long|null} [numZombieChans] NetworkInfo numZombieChans
         */

        /**
         * Constructs a new NetworkInfo.
         * @memberof lnrpc
         * @classdesc Represents a NetworkInfo.
         * @implements INetworkInfo
         * @constructor
         * @param {lnrpc.INetworkInfo=} [properties] Properties to set
         */
        function NetworkInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NetworkInfo graphDiameter.
         * @member {number} graphDiameter
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.graphDiameter = 0;

        /**
         * NetworkInfo avgOutDegree.
         * @member {number} avgOutDegree
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.avgOutDegree = 0;

        /**
         * NetworkInfo maxOutDegree.
         * @member {number} maxOutDegree
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.maxOutDegree = 0;

        /**
         * NetworkInfo numNodes.
         * @member {number} numNodes
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.numNodes = 0;

        /**
         * NetworkInfo numChannels.
         * @member {number} numChannels
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.numChannels = 0;

        /**
         * NetworkInfo totalNetworkCapacity.
         * @member {number|Long} totalNetworkCapacity
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.totalNetworkCapacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo avgChannelSize.
         * @member {number} avgChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.avgChannelSize = 0;

        /**
         * NetworkInfo minChannelSize.
         * @member {number|Long} minChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.minChannelSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo maxChannelSize.
         * @member {number|Long} maxChannelSize
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.maxChannelSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo medianChannelSizeSat.
         * @member {number|Long} medianChannelSizeSat
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.medianChannelSizeSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * NetworkInfo numZombieChans.
         * @member {number|Long} numZombieChans
         * @memberof lnrpc.NetworkInfo
         * @instance
         */
        NetworkInfo.prototype.numZombieChans = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new NetworkInfo instance using the specified properties.
         * @function create
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo=} [properties] Properties to set
         * @returns {lnrpc.NetworkInfo} NetworkInfo instance
         */
        NetworkInfo.create = function create(properties) {
            return new NetworkInfo(properties);
        };

        /**
         * Encodes the specified NetworkInfo message. Does not implicitly {@link lnrpc.NetworkInfo.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo} message NetworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.graphDiameter != null && message.hasOwnProperty("graphDiameter"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.graphDiameter);
            if (message.avgOutDegree != null && message.hasOwnProperty("avgOutDegree"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.avgOutDegree);
            if (message.maxOutDegree != null && message.hasOwnProperty("maxOutDegree"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxOutDegree);
            if (message.numNodes != null && message.hasOwnProperty("numNodes"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numNodes);
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.numChannels);
            if (message.totalNetworkCapacity != null && message.hasOwnProperty("totalNetworkCapacity"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.totalNetworkCapacity);
            if (message.avgChannelSize != null && message.hasOwnProperty("avgChannelSize"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.avgChannelSize);
            if (message.minChannelSize != null && message.hasOwnProperty("minChannelSize"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.minChannelSize);
            if (message.maxChannelSize != null && message.hasOwnProperty("maxChannelSize"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.maxChannelSize);
            if (message.medianChannelSizeSat != null && message.hasOwnProperty("medianChannelSizeSat"))
                writer.uint32(/* id 10, wireType 0 =*/80).int64(message.medianChannelSizeSat);
            if (message.numZombieChans != null && message.hasOwnProperty("numZombieChans"))
                writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.numZombieChans);
            return writer;
        };

        /**
         * Encodes the specified NetworkInfo message, length delimited. Does not implicitly {@link lnrpc.NetworkInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.INetworkInfo} message NetworkInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NetworkInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NetworkInfo message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NetworkInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.graphDiameter = reader.uint32();
                    break;
                case 2:
                    message.avgOutDegree = reader.double();
                    break;
                case 3:
                    message.maxOutDegree = reader.uint32();
                    break;
                case 4:
                    message.numNodes = reader.uint32();
                    break;
                case 5:
                    message.numChannels = reader.uint32();
                    break;
                case 6:
                    message.totalNetworkCapacity = reader.int64();
                    break;
                case 7:
                    message.avgChannelSize = reader.double();
                    break;
                case 8:
                    message.minChannelSize = reader.int64();
                    break;
                case 9:
                    message.maxChannelSize = reader.int64();
                    break;
                case 10:
                    message.medianChannelSizeSat = reader.int64();
                    break;
                case 11:
                    message.numZombieChans = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NetworkInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NetworkInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NetworkInfo message.
         * @function verify
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NetworkInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.graphDiameter != null && message.hasOwnProperty("graphDiameter"))
                if (!$util.isInteger(message.graphDiameter))
                    return "graphDiameter: integer expected";
            if (message.avgOutDegree != null && message.hasOwnProperty("avgOutDegree"))
                if (typeof message.avgOutDegree !== "number")
                    return "avgOutDegree: number expected";
            if (message.maxOutDegree != null && message.hasOwnProperty("maxOutDegree"))
                if (!$util.isInteger(message.maxOutDegree))
                    return "maxOutDegree: integer expected";
            if (message.numNodes != null && message.hasOwnProperty("numNodes"))
                if (!$util.isInteger(message.numNodes))
                    return "numNodes: integer expected";
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                if (!$util.isInteger(message.numChannels))
                    return "numChannels: integer expected";
            if (message.totalNetworkCapacity != null && message.hasOwnProperty("totalNetworkCapacity"))
                if (!$util.isInteger(message.totalNetworkCapacity) && !(message.totalNetworkCapacity && $util.isInteger(message.totalNetworkCapacity.low) && $util.isInteger(message.totalNetworkCapacity.high)))
                    return "totalNetworkCapacity: integer|Long expected";
            if (message.avgChannelSize != null && message.hasOwnProperty("avgChannelSize"))
                if (typeof message.avgChannelSize !== "number")
                    return "avgChannelSize: number expected";
            if (message.minChannelSize != null && message.hasOwnProperty("minChannelSize"))
                if (!$util.isInteger(message.minChannelSize) && !(message.minChannelSize && $util.isInteger(message.minChannelSize.low) && $util.isInteger(message.minChannelSize.high)))
                    return "minChannelSize: integer|Long expected";
            if (message.maxChannelSize != null && message.hasOwnProperty("maxChannelSize"))
                if (!$util.isInteger(message.maxChannelSize) && !(message.maxChannelSize && $util.isInteger(message.maxChannelSize.low) && $util.isInteger(message.maxChannelSize.high)))
                    return "maxChannelSize: integer|Long expected";
            if (message.medianChannelSizeSat != null && message.hasOwnProperty("medianChannelSizeSat"))
                if (!$util.isInteger(message.medianChannelSizeSat) && !(message.medianChannelSizeSat && $util.isInteger(message.medianChannelSizeSat.low) && $util.isInteger(message.medianChannelSizeSat.high)))
                    return "medianChannelSizeSat: integer|Long expected";
            if (message.numZombieChans != null && message.hasOwnProperty("numZombieChans"))
                if (!$util.isInteger(message.numZombieChans) && !(message.numZombieChans && $util.isInteger(message.numZombieChans.low) && $util.isInteger(message.numZombieChans.high)))
                    return "numZombieChans: integer|Long expected";
            return null;
        };

        /**
         * Creates a NetworkInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NetworkInfo} NetworkInfo
         */
        NetworkInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NetworkInfo)
                return object;
            let message = new $root.lnrpc.NetworkInfo();
            if (object.graphDiameter != null)
                message.graphDiameter = object.graphDiameter >>> 0;
            if (object.avgOutDegree != null)
                message.avgOutDegree = Number(object.avgOutDegree);
            if (object.maxOutDegree != null)
                message.maxOutDegree = object.maxOutDegree >>> 0;
            if (object.numNodes != null)
                message.numNodes = object.numNodes >>> 0;
            if (object.numChannels != null)
                message.numChannels = object.numChannels >>> 0;
            if (object.totalNetworkCapacity != null)
                if ($util.Long)
                    (message.totalNetworkCapacity = $util.Long.fromValue(object.totalNetworkCapacity)).unsigned = false;
                else if (typeof object.totalNetworkCapacity === "string")
                    message.totalNetworkCapacity = parseInt(object.totalNetworkCapacity, 10);
                else if (typeof object.totalNetworkCapacity === "number")
                    message.totalNetworkCapacity = object.totalNetworkCapacity;
                else if (typeof object.totalNetworkCapacity === "object")
                    message.totalNetworkCapacity = new $util.LongBits(object.totalNetworkCapacity.low >>> 0, object.totalNetworkCapacity.high >>> 0).toNumber();
            if (object.avgChannelSize != null)
                message.avgChannelSize = Number(object.avgChannelSize);
            if (object.minChannelSize != null)
                if ($util.Long)
                    (message.minChannelSize = $util.Long.fromValue(object.minChannelSize)).unsigned = false;
                else if (typeof object.minChannelSize === "string")
                    message.minChannelSize = parseInt(object.minChannelSize, 10);
                else if (typeof object.minChannelSize === "number")
                    message.minChannelSize = object.minChannelSize;
                else if (typeof object.minChannelSize === "object")
                    message.minChannelSize = new $util.LongBits(object.minChannelSize.low >>> 0, object.minChannelSize.high >>> 0).toNumber();
            if (object.maxChannelSize != null)
                if ($util.Long)
                    (message.maxChannelSize = $util.Long.fromValue(object.maxChannelSize)).unsigned = false;
                else if (typeof object.maxChannelSize === "string")
                    message.maxChannelSize = parseInt(object.maxChannelSize, 10);
                else if (typeof object.maxChannelSize === "number")
                    message.maxChannelSize = object.maxChannelSize;
                else if (typeof object.maxChannelSize === "object")
                    message.maxChannelSize = new $util.LongBits(object.maxChannelSize.low >>> 0, object.maxChannelSize.high >>> 0).toNumber();
            if (object.medianChannelSizeSat != null)
                if ($util.Long)
                    (message.medianChannelSizeSat = $util.Long.fromValue(object.medianChannelSizeSat)).unsigned = false;
                else if (typeof object.medianChannelSizeSat === "string")
                    message.medianChannelSizeSat = parseInt(object.medianChannelSizeSat, 10);
                else if (typeof object.medianChannelSizeSat === "number")
                    message.medianChannelSizeSat = object.medianChannelSizeSat;
                else if (typeof object.medianChannelSizeSat === "object")
                    message.medianChannelSizeSat = new $util.LongBits(object.medianChannelSizeSat.low >>> 0, object.medianChannelSizeSat.high >>> 0).toNumber();
            if (object.numZombieChans != null)
                if ($util.Long)
                    (message.numZombieChans = $util.Long.fromValue(object.numZombieChans)).unsigned = true;
                else if (typeof object.numZombieChans === "string")
                    message.numZombieChans = parseInt(object.numZombieChans, 10);
                else if (typeof object.numZombieChans === "number")
                    message.numZombieChans = object.numZombieChans;
                else if (typeof object.numZombieChans === "object")
                    message.numZombieChans = new $util.LongBits(object.numZombieChans.low >>> 0, object.numZombieChans.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a NetworkInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NetworkInfo
         * @static
         * @param {lnrpc.NetworkInfo} message NetworkInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NetworkInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.graphDiameter = 0;
                object.avgOutDegree = 0;
                object.maxOutDegree = 0;
                object.numNodes = 0;
                object.numChannels = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.totalNetworkCapacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalNetworkCapacity = options.longs === String ? "0" : 0;
                object.avgChannelSize = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.minChannelSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minChannelSize = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.maxChannelSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxChannelSize = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.medianChannelSizeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.medianChannelSizeSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.numZombieChans = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numZombieChans = options.longs === String ? "0" : 0;
            }
            if (message.graphDiameter != null && message.hasOwnProperty("graphDiameter"))
                object.graphDiameter = message.graphDiameter;
            if (message.avgOutDegree != null && message.hasOwnProperty("avgOutDegree"))
                object.avgOutDegree = options.json && !isFinite(message.avgOutDegree) ? String(message.avgOutDegree) : message.avgOutDegree;
            if (message.maxOutDegree != null && message.hasOwnProperty("maxOutDegree"))
                object.maxOutDegree = message.maxOutDegree;
            if (message.numNodes != null && message.hasOwnProperty("numNodes"))
                object.numNodes = message.numNodes;
            if (message.numChannels != null && message.hasOwnProperty("numChannels"))
                object.numChannels = message.numChannels;
            if (message.totalNetworkCapacity != null && message.hasOwnProperty("totalNetworkCapacity"))
                if (typeof message.totalNetworkCapacity === "number")
                    object.totalNetworkCapacity = options.longs === String ? String(message.totalNetworkCapacity) : message.totalNetworkCapacity;
                else
                    object.totalNetworkCapacity = options.longs === String ? $util.Long.prototype.toString.call(message.totalNetworkCapacity) : options.longs === Number ? new $util.LongBits(message.totalNetworkCapacity.low >>> 0, message.totalNetworkCapacity.high >>> 0).toNumber() : message.totalNetworkCapacity;
            if (message.avgChannelSize != null && message.hasOwnProperty("avgChannelSize"))
                object.avgChannelSize = options.json && !isFinite(message.avgChannelSize) ? String(message.avgChannelSize) : message.avgChannelSize;
            if (message.minChannelSize != null && message.hasOwnProperty("minChannelSize"))
                if (typeof message.minChannelSize === "number")
                    object.minChannelSize = options.longs === String ? String(message.minChannelSize) : message.minChannelSize;
                else
                    object.minChannelSize = options.longs === String ? $util.Long.prototype.toString.call(message.minChannelSize) : options.longs === Number ? new $util.LongBits(message.minChannelSize.low >>> 0, message.minChannelSize.high >>> 0).toNumber() : message.minChannelSize;
            if (message.maxChannelSize != null && message.hasOwnProperty("maxChannelSize"))
                if (typeof message.maxChannelSize === "number")
                    object.maxChannelSize = options.longs === String ? String(message.maxChannelSize) : message.maxChannelSize;
                else
                    object.maxChannelSize = options.longs === String ? $util.Long.prototype.toString.call(message.maxChannelSize) : options.longs === Number ? new $util.LongBits(message.maxChannelSize.low >>> 0, message.maxChannelSize.high >>> 0).toNumber() : message.maxChannelSize;
            if (message.medianChannelSizeSat != null && message.hasOwnProperty("medianChannelSizeSat"))
                if (typeof message.medianChannelSizeSat === "number")
                    object.medianChannelSizeSat = options.longs === String ? String(message.medianChannelSizeSat) : message.medianChannelSizeSat;
                else
                    object.medianChannelSizeSat = options.longs === String ? $util.Long.prototype.toString.call(message.medianChannelSizeSat) : options.longs === Number ? new $util.LongBits(message.medianChannelSizeSat.low >>> 0, message.medianChannelSizeSat.high >>> 0).toNumber() : message.medianChannelSizeSat;
            if (message.numZombieChans != null && message.hasOwnProperty("numZombieChans"))
                if (typeof message.numZombieChans === "number")
                    object.numZombieChans = options.longs === String ? String(message.numZombieChans) : message.numZombieChans;
                else
                    object.numZombieChans = options.longs === String ? $util.Long.prototype.toString.call(message.numZombieChans) : options.longs === Number ? new $util.LongBits(message.numZombieChans.low >>> 0, message.numZombieChans.high >>> 0).toNumber(true) : message.numZombieChans;
            return object;
        };

        /**
         * Converts this NetworkInfo to JSON.
         * @function toJSON
         * @memberof lnrpc.NetworkInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NetworkInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NetworkInfo;
    })();

    lnrpc.StopRequest = (function() {

        /**
         * Properties of a StopRequest.
         * @memberof lnrpc
         * @interface IStopRequest
         */

        /**
         * Constructs a new StopRequest.
         * @memberof lnrpc
         * @classdesc Represents a StopRequest.
         * @implements IStopRequest
         * @constructor
         * @param {lnrpc.IStopRequest=} [properties] Properties to set
         */
        function StopRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StopRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest=} [properties] Properties to set
         * @returns {lnrpc.StopRequest} StopRequest instance
         */
        StopRequest.create = function create(properties) {
            return new StopRequest(properties);
        };

        /**
         * Encodes the specified StopRequest message. Does not implicitly {@link lnrpc.StopRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest} message StopRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StopRequest message, length delimited. Does not implicitly {@link lnrpc.StopRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.IStopRequest} message StopRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.StopRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.StopRequest} StopRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.StopRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.StopRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.StopRequest} StopRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopRequest message.
         * @function verify
         * @memberof lnrpc.StopRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StopRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.StopRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.StopRequest} StopRequest
         */
        StopRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.StopRequest)
                return object;
            return new $root.lnrpc.StopRequest();
        };

        /**
         * Creates a plain object from a StopRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.StopRequest
         * @static
         * @param {lnrpc.StopRequest} message StopRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StopRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.StopRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopRequest;
    })();

    lnrpc.StopResponse = (function() {

        /**
         * Properties of a StopResponse.
         * @memberof lnrpc
         * @interface IStopResponse
         */

        /**
         * Constructs a new StopResponse.
         * @memberof lnrpc
         * @classdesc Represents a StopResponse.
         * @implements IStopResponse
         * @constructor
         * @param {lnrpc.IStopResponse=} [properties] Properties to set
         */
        function StopResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StopResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse=} [properties] Properties to set
         * @returns {lnrpc.StopResponse} StopResponse instance
         */
        StopResponse.create = function create(properties) {
            return new StopResponse(properties);
        };

        /**
         * Encodes the specified StopResponse message. Does not implicitly {@link lnrpc.StopResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse} message StopResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StopResponse message, length delimited. Does not implicitly {@link lnrpc.StopResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.IStopResponse} message StopResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StopResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StopResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.StopResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.StopResponse} StopResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.StopResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StopResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.StopResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.StopResponse} StopResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StopResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StopResponse message.
         * @function verify
         * @memberof lnrpc.StopResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StopResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StopResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.StopResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.StopResponse} StopResponse
         */
        StopResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.StopResponse)
                return object;
            return new $root.lnrpc.StopResponse();
        };

        /**
         * Creates a plain object from a StopResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.StopResponse
         * @static
         * @param {lnrpc.StopResponse} message StopResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StopResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StopResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.StopResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StopResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StopResponse;
    })();

    lnrpc.GraphTopologySubscription = (function() {

        /**
         * Properties of a GraphTopologySubscription.
         * @memberof lnrpc
         * @interface IGraphTopologySubscription
         */

        /**
         * Constructs a new GraphTopologySubscription.
         * @memberof lnrpc
         * @classdesc Represents a GraphTopologySubscription.
         * @implements IGraphTopologySubscription
         * @constructor
         * @param {lnrpc.IGraphTopologySubscription=} [properties] Properties to set
         */
        function GraphTopologySubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GraphTopologySubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription=} [properties] Properties to set
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription instance
         */
        GraphTopologySubscription.create = function create(properties) {
            return new GraphTopologySubscription(properties);
        };

        /**
         * Encodes the specified GraphTopologySubscription message. Does not implicitly {@link lnrpc.GraphTopologySubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription} message GraphTopologySubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologySubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GraphTopologySubscription message, length delimited. Does not implicitly {@link lnrpc.GraphTopologySubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.IGraphTopologySubscription} message GraphTopologySubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologySubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphTopologySubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologySubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GraphTopologySubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphTopologySubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologySubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphTopologySubscription message.
         * @function verify
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphTopologySubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a GraphTopologySubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GraphTopologySubscription} GraphTopologySubscription
         */
        GraphTopologySubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GraphTopologySubscription)
                return object;
            return new $root.lnrpc.GraphTopologySubscription();
        };

        /**
         * Creates a plain object from a GraphTopologySubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GraphTopologySubscription
         * @static
         * @param {lnrpc.GraphTopologySubscription} message GraphTopologySubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphTopologySubscription.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this GraphTopologySubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.GraphTopologySubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphTopologySubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphTopologySubscription;
    })();

    lnrpc.GraphTopologyUpdate = (function() {

        /**
         * Properties of a GraphTopologyUpdate.
         * @memberof lnrpc
         * @interface IGraphTopologyUpdate
         * @property {Array.<lnrpc.INodeUpdate>|null} [nodeUpdates] GraphTopologyUpdate nodeUpdates
         * @property {Array.<lnrpc.IChannelEdgeUpdate>|null} [channelUpdates] GraphTopologyUpdate channelUpdates
         * @property {Array.<lnrpc.IClosedChannelUpdate>|null} [closedChans] GraphTopologyUpdate closedChans
         */

        /**
         * Constructs a new GraphTopologyUpdate.
         * @memberof lnrpc
         * @classdesc Represents a GraphTopologyUpdate.
         * @implements IGraphTopologyUpdate
         * @constructor
         * @param {lnrpc.IGraphTopologyUpdate=} [properties] Properties to set
         */
        function GraphTopologyUpdate(properties) {
            this.nodeUpdates = [];
            this.channelUpdates = [];
            this.closedChans = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GraphTopologyUpdate nodeUpdates.
         * @member {Array.<lnrpc.INodeUpdate>} nodeUpdates
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.nodeUpdates = $util.emptyArray;

        /**
         * GraphTopologyUpdate channelUpdates.
         * @member {Array.<lnrpc.IChannelEdgeUpdate>} channelUpdates
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.channelUpdates = $util.emptyArray;

        /**
         * GraphTopologyUpdate closedChans.
         * @member {Array.<lnrpc.IClosedChannelUpdate>} closedChans
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         */
        GraphTopologyUpdate.prototype.closedChans = $util.emptyArray;

        /**
         * Creates a new GraphTopologyUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate=} [properties] Properties to set
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate instance
         */
        GraphTopologyUpdate.create = function create(properties) {
            return new GraphTopologyUpdate(properties);
        };

        /**
         * Encodes the specified GraphTopologyUpdate message. Does not implicitly {@link lnrpc.GraphTopologyUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate} message GraphTopologyUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologyUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeUpdates != null && message.nodeUpdates.length)
                for (let i = 0; i < message.nodeUpdates.length; ++i)
                    $root.lnrpc.NodeUpdate.encode(message.nodeUpdates[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.channelUpdates != null && message.channelUpdates.length)
                for (let i = 0; i < message.channelUpdates.length; ++i)
                    $root.lnrpc.ChannelEdgeUpdate.encode(message.channelUpdates[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.closedChans != null && message.closedChans.length)
                for (let i = 0; i < message.closedChans.length; ++i)
                    $root.lnrpc.ClosedChannelUpdate.encode(message.closedChans[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GraphTopologyUpdate message, length delimited. Does not implicitly {@link lnrpc.GraphTopologyUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.IGraphTopologyUpdate} message GraphTopologyUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GraphTopologyUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GraphTopologyUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologyUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.GraphTopologyUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.nodeUpdates && message.nodeUpdates.length))
                        message.nodeUpdates = [];
                    message.nodeUpdates.push($root.lnrpc.NodeUpdate.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.channelUpdates && message.channelUpdates.length))
                        message.channelUpdates = [];
                    message.channelUpdates.push($root.lnrpc.ChannelEdgeUpdate.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.closedChans && message.closedChans.length))
                        message.closedChans = [];
                    message.closedChans.push($root.lnrpc.ClosedChannelUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GraphTopologyUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GraphTopologyUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GraphTopologyUpdate message.
         * @function verify
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GraphTopologyUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeUpdates != null && message.hasOwnProperty("nodeUpdates")) {
                if (!Array.isArray(message.nodeUpdates))
                    return "nodeUpdates: array expected";
                for (let i = 0; i < message.nodeUpdates.length; ++i) {
                    let error = $root.lnrpc.NodeUpdate.verify(message.nodeUpdates[i]);
                    if (error)
                        return "nodeUpdates." + error;
                }
            }
            if (message.channelUpdates != null && message.hasOwnProperty("channelUpdates")) {
                if (!Array.isArray(message.channelUpdates))
                    return "channelUpdates: array expected";
                for (let i = 0; i < message.channelUpdates.length; ++i) {
                    let error = $root.lnrpc.ChannelEdgeUpdate.verify(message.channelUpdates[i]);
                    if (error)
                        return "channelUpdates." + error;
                }
            }
            if (message.closedChans != null && message.hasOwnProperty("closedChans")) {
                if (!Array.isArray(message.closedChans))
                    return "closedChans: array expected";
                for (let i = 0; i < message.closedChans.length; ++i) {
                    let error = $root.lnrpc.ClosedChannelUpdate.verify(message.closedChans[i]);
                    if (error)
                        return "closedChans." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GraphTopologyUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.GraphTopologyUpdate} GraphTopologyUpdate
         */
        GraphTopologyUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.GraphTopologyUpdate)
                return object;
            let message = new $root.lnrpc.GraphTopologyUpdate();
            if (object.nodeUpdates) {
                if (!Array.isArray(object.nodeUpdates))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.nodeUpdates: array expected");
                message.nodeUpdates = [];
                for (let i = 0; i < object.nodeUpdates.length; ++i) {
                    if (typeof object.nodeUpdates[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.nodeUpdates: object expected");
                    message.nodeUpdates[i] = $root.lnrpc.NodeUpdate.fromObject(object.nodeUpdates[i]);
                }
            }
            if (object.channelUpdates) {
                if (!Array.isArray(object.channelUpdates))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.channelUpdates: array expected");
                message.channelUpdates = [];
                for (let i = 0; i < object.channelUpdates.length; ++i) {
                    if (typeof object.channelUpdates[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.channelUpdates: object expected");
                    message.channelUpdates[i] = $root.lnrpc.ChannelEdgeUpdate.fromObject(object.channelUpdates[i]);
                }
            }
            if (object.closedChans) {
                if (!Array.isArray(object.closedChans))
                    throw TypeError(".lnrpc.GraphTopologyUpdate.closedChans: array expected");
                message.closedChans = [];
                for (let i = 0; i < object.closedChans.length; ++i) {
                    if (typeof object.closedChans[i] !== "object")
                        throw TypeError(".lnrpc.GraphTopologyUpdate.closedChans: object expected");
                    message.closedChans[i] = $root.lnrpc.ClosedChannelUpdate.fromObject(object.closedChans[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a GraphTopologyUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.GraphTopologyUpdate
         * @static
         * @param {lnrpc.GraphTopologyUpdate} message GraphTopologyUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GraphTopologyUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.nodeUpdates = [];
                object.channelUpdates = [];
                object.closedChans = [];
            }
            if (message.nodeUpdates && message.nodeUpdates.length) {
                object.nodeUpdates = [];
                for (let j = 0; j < message.nodeUpdates.length; ++j)
                    object.nodeUpdates[j] = $root.lnrpc.NodeUpdate.toObject(message.nodeUpdates[j], options);
            }
            if (message.channelUpdates && message.channelUpdates.length) {
                object.channelUpdates = [];
                for (let j = 0; j < message.channelUpdates.length; ++j)
                    object.channelUpdates[j] = $root.lnrpc.ChannelEdgeUpdate.toObject(message.channelUpdates[j], options);
            }
            if (message.closedChans && message.closedChans.length) {
                object.closedChans = [];
                for (let j = 0; j < message.closedChans.length; ++j)
                    object.closedChans[j] = $root.lnrpc.ClosedChannelUpdate.toObject(message.closedChans[j], options);
            }
            return object;
        };

        /**
         * Converts this GraphTopologyUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.GraphTopologyUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GraphTopologyUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GraphTopologyUpdate;
    })();

    lnrpc.NodeUpdate = (function() {

        /**
         * Properties of a NodeUpdate.
         * @memberof lnrpc
         * @interface INodeUpdate
         * @property {Array.<string>|null} [addresses] NodeUpdate addresses
         * @property {string|null} [identityKey] NodeUpdate identityKey
         * @property {Uint8Array|null} [globalFeatures] NodeUpdate globalFeatures
         * @property {string|null} [alias] NodeUpdate alias
         * @property {string|null} [color] NodeUpdate color
         */

        /**
         * Constructs a new NodeUpdate.
         * @memberof lnrpc
         * @classdesc Represents a NodeUpdate.
         * @implements INodeUpdate
         * @constructor
         * @param {lnrpc.INodeUpdate=} [properties] Properties to set
         */
        function NodeUpdate(properties) {
            this.addresses = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NodeUpdate addresses.
         * @member {Array.<string>} addresses
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.addresses = $util.emptyArray;

        /**
         * NodeUpdate identityKey.
         * @member {string} identityKey
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.identityKey = "";

        /**
         * NodeUpdate globalFeatures.
         * @member {Uint8Array} globalFeatures
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.globalFeatures = $util.newBuffer([]);

        /**
         * NodeUpdate alias.
         * @member {string} alias
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.alias = "";

        /**
         * NodeUpdate color.
         * @member {string} color
         * @memberof lnrpc.NodeUpdate
         * @instance
         */
        NodeUpdate.prototype.color = "";

        /**
         * Creates a new NodeUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate=} [properties] Properties to set
         * @returns {lnrpc.NodeUpdate} NodeUpdate instance
         */
        NodeUpdate.create = function create(properties) {
            return new NodeUpdate(properties);
        };

        /**
         * Encodes the specified NodeUpdate message. Does not implicitly {@link lnrpc.NodeUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate} message NodeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addresses != null && message.addresses.length)
                for (let i = 0; i < message.addresses.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.addresses[i]);
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.identityKey);
            if (message.globalFeatures != null && message.hasOwnProperty("globalFeatures"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.globalFeatures);
            if (message.alias != null && message.hasOwnProperty("alias"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.alias);
            if (message.color != null && message.hasOwnProperty("color"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.color);
            return writer;
        };

        /**
         * Encodes the specified NodeUpdate message, length delimited. Does not implicitly {@link lnrpc.NodeUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.INodeUpdate} message NodeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NodeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NodeUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.NodeUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.addresses && message.addresses.length))
                        message.addresses = [];
                    message.addresses.push(reader.string());
                    break;
                case 2:
                    message.identityKey = reader.string();
                    break;
                case 3:
                    message.globalFeatures = reader.bytes();
                    break;
                case 4:
                    message.alias = reader.string();
                    break;
                case 5:
                    message.color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NodeUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NodeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NodeUpdate message.
         * @function verify
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NodeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addresses != null && message.hasOwnProperty("addresses")) {
                if (!Array.isArray(message.addresses))
                    return "addresses: array expected";
                for (let i = 0; i < message.addresses.length; ++i)
                    if (!$util.isString(message.addresses[i]))
                        return "addresses: string[] expected";
            }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                if (!$util.isString(message.identityKey))
                    return "identityKey: string expected";
            if (message.globalFeatures != null && message.hasOwnProperty("globalFeatures"))
                if (!(message.globalFeatures && typeof message.globalFeatures.length === "number" || $util.isString(message.globalFeatures)))
                    return "globalFeatures: buffer expected";
            if (message.alias != null && message.hasOwnProperty("alias"))
                if (!$util.isString(message.alias))
                    return "alias: string expected";
            if (message.color != null && message.hasOwnProperty("color"))
                if (!$util.isString(message.color))
                    return "color: string expected";
            return null;
        };

        /**
         * Creates a NodeUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.NodeUpdate} NodeUpdate
         */
        NodeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.NodeUpdate)
                return object;
            let message = new $root.lnrpc.NodeUpdate();
            if (object.addresses) {
                if (!Array.isArray(object.addresses))
                    throw TypeError(".lnrpc.NodeUpdate.addresses: array expected");
                message.addresses = [];
                for (let i = 0; i < object.addresses.length; ++i)
                    message.addresses[i] = String(object.addresses[i]);
            }
            if (object.identityKey != null)
                message.identityKey = String(object.identityKey);
            if (object.globalFeatures != null)
                if (typeof object.globalFeatures === "string")
                    $util.base64.decode(object.globalFeatures, message.globalFeatures = $util.newBuffer($util.base64.length(object.globalFeatures)), 0);
                else if (object.globalFeatures.length)
                    message.globalFeatures = object.globalFeatures;
            if (object.alias != null)
                message.alias = String(object.alias);
            if (object.color != null)
                message.color = String(object.color);
            return message;
        };

        /**
         * Creates a plain object from a NodeUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.NodeUpdate
         * @static
         * @param {lnrpc.NodeUpdate} message NodeUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        NodeUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.addresses = [];
            if (options.defaults) {
                object.identityKey = "";
                if (options.bytes === String)
                    object.globalFeatures = "";
                else {
                    object.globalFeatures = [];
                    if (options.bytes !== Array)
                        object.globalFeatures = $util.newBuffer(object.globalFeatures);
                }
                object.alias = "";
                object.color = "";
            }
            if (message.addresses && message.addresses.length) {
                object.addresses = [];
                for (let j = 0; j < message.addresses.length; ++j)
                    object.addresses[j] = message.addresses[j];
            }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = message.identityKey;
            if (message.globalFeatures != null && message.hasOwnProperty("globalFeatures"))
                object.globalFeatures = options.bytes === String ? $util.base64.encode(message.globalFeatures, 0, message.globalFeatures.length) : options.bytes === Array ? Array.prototype.slice.call(message.globalFeatures) : message.globalFeatures;
            if (message.alias != null && message.hasOwnProperty("alias"))
                object.alias = message.alias;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = message.color;
            return object;
        };

        /**
         * Converts this NodeUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.NodeUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        NodeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return NodeUpdate;
    })();

    lnrpc.ChannelEdgeUpdate = (function() {

        /**
         * Properties of a ChannelEdgeUpdate.
         * @memberof lnrpc
         * @interface IChannelEdgeUpdate
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ChannelEdgeUpdate chanPoint
         * @property {number|Long|null} [capacity] ChannelEdgeUpdate capacity
         * @property {lnrpc.IRoutingPolicy|null} [routingPolicy] ChannelEdgeUpdate routingPolicy
         * @property {string|null} [advertisingNode] ChannelEdgeUpdate advertisingNode
         * @property {string|null} [connectingNode] ChannelEdgeUpdate connectingNode
         */

        /**
         * Constructs a new ChannelEdgeUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ChannelEdgeUpdate.
         * @implements IChannelEdgeUpdate
         * @constructor
         * @param {lnrpc.IChannelEdgeUpdate=} [properties] Properties to set
         */
        function ChannelEdgeUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChannelEdgeUpdate chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.chanPoint = null;

        /**
         * ChannelEdgeUpdate capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChannelEdgeUpdate routingPolicy.
         * @member {lnrpc.IRoutingPolicy|null|undefined} routingPolicy
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.routingPolicy = null;

        /**
         * ChannelEdgeUpdate advertisingNode.
         * @member {string} advertisingNode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.advertisingNode = "";

        /**
         * ChannelEdgeUpdate connectingNode.
         * @member {string} connectingNode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         */
        ChannelEdgeUpdate.prototype.connectingNode = "";

        /**
         * Creates a new ChannelEdgeUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate=} [properties] Properties to set
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate instance
         */
        ChannelEdgeUpdate.create = function create(properties) {
            return new ChannelEdgeUpdate(properties);
        };

        /**
         * Encodes the specified ChannelEdgeUpdate message. Does not implicitly {@link lnrpc.ChannelEdgeUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate} message ChannelEdgeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdgeUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.capacity);
            if (message.routingPolicy != null && message.hasOwnProperty("routingPolicy"))
                $root.lnrpc.RoutingPolicy.encode(message.routingPolicy, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.advertisingNode != null && message.hasOwnProperty("advertisingNode"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.advertisingNode);
            if (message.connectingNode != null && message.hasOwnProperty("connectingNode"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.connectingNode);
            return writer;
        };

        /**
         * Encodes the specified ChannelEdgeUpdate message, length delimited. Does not implicitly {@link lnrpc.ChannelEdgeUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.IChannelEdgeUpdate} message ChannelEdgeUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelEdgeUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelEdgeUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdgeUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelEdgeUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.capacity = reader.int64();
                    break;
                case 4:
                    message.routingPolicy = $root.lnrpc.RoutingPolicy.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.advertisingNode = reader.string();
                    break;
                case 6:
                    message.connectingNode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelEdgeUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelEdgeUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelEdgeUpdate message.
         * @function verify
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelEdgeUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.routingPolicy != null && message.hasOwnProperty("routingPolicy")) {
                let error = $root.lnrpc.RoutingPolicy.verify(message.routingPolicy);
                if (error)
                    return "routingPolicy." + error;
            }
            if (message.advertisingNode != null && message.hasOwnProperty("advertisingNode"))
                if (!$util.isString(message.advertisingNode))
                    return "advertisingNode: string expected";
            if (message.connectingNode != null && message.hasOwnProperty("connectingNode"))
                if (!$util.isString(message.connectingNode))
                    return "connectingNode: string expected";
            return null;
        };

        /**
         * Creates a ChannelEdgeUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelEdgeUpdate} ChannelEdgeUpdate
         */
        ChannelEdgeUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelEdgeUpdate)
                return object;
            let message = new $root.lnrpc.ChannelEdgeUpdate();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ChannelEdgeUpdate.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.routingPolicy != null) {
                if (typeof object.routingPolicy !== "object")
                    throw TypeError(".lnrpc.ChannelEdgeUpdate.routingPolicy: object expected");
                message.routingPolicy = $root.lnrpc.RoutingPolicy.fromObject(object.routingPolicy);
            }
            if (object.advertisingNode != null)
                message.advertisingNode = String(object.advertisingNode);
            if (object.connectingNode != null)
                message.connectingNode = String(object.connectingNode);
            return message;
        };

        /**
         * Creates a plain object from a ChannelEdgeUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelEdgeUpdate
         * @static
         * @param {lnrpc.ChannelEdgeUpdate} message ChannelEdgeUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelEdgeUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.chanPoint = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.routingPolicy = null;
                object.advertisingNode = "";
                object.connectingNode = "";
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.routingPolicy != null && message.hasOwnProperty("routingPolicy"))
                object.routingPolicy = $root.lnrpc.RoutingPolicy.toObject(message.routingPolicy, options);
            if (message.advertisingNode != null && message.hasOwnProperty("advertisingNode"))
                object.advertisingNode = message.advertisingNode;
            if (message.connectingNode != null && message.hasOwnProperty("connectingNode"))
                object.connectingNode = message.connectingNode;
            return object;
        };

        /**
         * Converts this ChannelEdgeUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelEdgeUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelEdgeUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelEdgeUpdate;
    })();

    lnrpc.ClosedChannelUpdate = (function() {

        /**
         * Properties of a ClosedChannelUpdate.
         * @memberof lnrpc
         * @interface IClosedChannelUpdate
         * @property {number|Long|null} [chanId] The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @property {number|Long|null} [capacity] ClosedChannelUpdate capacity
         * @property {number|null} [closedHeight] ClosedChannelUpdate closedHeight
         * @property {lnrpc.IChannelPoint|null} [chanPoint] ClosedChannelUpdate chanPoint
         */

        /**
         * Constructs a new ClosedChannelUpdate.
         * @memberof lnrpc
         * @classdesc Represents a ClosedChannelUpdate.
         * @implements IClosedChannelUpdate
         * @constructor
         * @param {lnrpc.IClosedChannelUpdate=} [properties] Properties to set
         */
        function ClosedChannelUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The unique channel ID for the channel. The first 3 bytes are the block
         * height, the next 3 the index within the block, and the last 2 bytes are the
         * output index for the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ClosedChannelUpdate capacity.
         * @member {number|Long} capacity
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.capacity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ClosedChannelUpdate closedHeight.
         * @member {number} closedHeight
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.closedHeight = 0;

        /**
         * ClosedChannelUpdate chanPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         */
        ClosedChannelUpdate.prototype.chanPoint = null;

        /**
         * Creates a new ClosedChannelUpdate instance using the specified properties.
         * @function create
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate=} [properties] Properties to set
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate instance
         */
        ClosedChannelUpdate.create = function create(properties) {
            return new ClosedChannelUpdate(properties);
        };

        /**
         * Encodes the specified ClosedChannelUpdate message. Does not implicitly {@link lnrpc.ClosedChannelUpdate.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate} message ClosedChannelUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.chanId);
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.capacity);
            if (message.closedHeight != null && message.hasOwnProperty("closedHeight"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.closedHeight);
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClosedChannelUpdate message, length delimited. Does not implicitly {@link lnrpc.ClosedChannelUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.IClosedChannelUpdate} message ClosedChannelUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClosedChannelUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClosedChannelUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ClosedChannelUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanId = reader.uint64();
                    break;
                case 2:
                    message.capacity = reader.int64();
                    break;
                case 3:
                    message.closedHeight = reader.uint32();
                    break;
                case 4:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClosedChannelUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClosedChannelUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClosedChannelUpdate message.
         * @function verify
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClosedChannelUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity) && !(message.capacity && $util.isInteger(message.capacity.low) && $util.isInteger(message.capacity.high)))
                    return "capacity: integer|Long expected";
            if (message.closedHeight != null && message.hasOwnProperty("closedHeight"))
                if (!$util.isInteger(message.closedHeight))
                    return "closedHeight: integer expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            return null;
        };

        /**
         * Creates a ClosedChannelUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ClosedChannelUpdate} ClosedChannelUpdate
         */
        ClosedChannelUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ClosedChannelUpdate)
                return object;
            let message = new $root.lnrpc.ClosedChannelUpdate();
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.capacity != null)
                if ($util.Long)
                    (message.capacity = $util.Long.fromValue(object.capacity)).unsigned = false;
                else if (typeof object.capacity === "string")
                    message.capacity = parseInt(object.capacity, 10);
                else if (typeof object.capacity === "number")
                    message.capacity = object.capacity;
                else if (typeof object.capacity === "object")
                    message.capacity = new $util.LongBits(object.capacity.low >>> 0, object.capacity.high >>> 0).toNumber();
            if (object.closedHeight != null)
                message.closedHeight = object.closedHeight >>> 0;
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ClosedChannelUpdate.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from a ClosedChannelUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ClosedChannelUpdate
         * @static
         * @param {lnrpc.ClosedChannelUpdate} message ClosedChannelUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClosedChannelUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.capacity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.capacity = options.longs === String ? "0" : 0;
                object.closedHeight = 0;
                object.chanPoint = null;
            }
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (typeof message.capacity === "number")
                    object.capacity = options.longs === String ? String(message.capacity) : message.capacity;
                else
                    object.capacity = options.longs === String ? $util.Long.prototype.toString.call(message.capacity) : options.longs === Number ? new $util.LongBits(message.capacity.low >>> 0, message.capacity.high >>> 0).toNumber() : message.capacity;
            if (message.closedHeight != null && message.hasOwnProperty("closedHeight"))
                object.closedHeight = message.closedHeight;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            return object;
        };

        /**
         * Converts this ClosedChannelUpdate to JSON.
         * @function toJSON
         * @memberof lnrpc.ClosedChannelUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClosedChannelUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ClosedChannelUpdate;
    })();

    lnrpc.HopHint = (function() {

        /**
         * Properties of a HopHint.
         * @memberof lnrpc
         * @interface IHopHint
         * @property {string|null} [nodeId] The public key of the node at the start of the channel.
         * @property {number|Long|null} [chanId] The unique identifier of the channel.
         * @property {number|null} [feeBaseMsat] The base fee of the channel denominated in millisatoshis.
         * @property {number|null} [feeProportionalMillionths] The fee rate of the channel for sending one satoshi across it denominated in
         * millionths of a satoshi.
         * @property {number|null} [cltvExpiryDelta] The time-lock delta of the channel.
         */

        /**
         * Constructs a new HopHint.
         * @memberof lnrpc
         * @classdesc Represents a HopHint.
         * @implements IHopHint
         * @constructor
         * @param {lnrpc.IHopHint=} [properties] Properties to set
         */
        function HopHint(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The public key of the node at the start of the channel.
         * @member {string} nodeId
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.nodeId = "";

        /**
         * The unique identifier of the channel.
         * @member {number|Long} chanId
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.chanId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The base fee of the channel denominated in millisatoshis.
         * @member {number} feeBaseMsat
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.feeBaseMsat = 0;

        /**
         * The fee rate of the channel for sending one satoshi across it denominated in
         * millionths of a satoshi.
         * @member {number} feeProportionalMillionths
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.feeProportionalMillionths = 0;

        /**
         * The time-lock delta of the channel.
         * @member {number} cltvExpiryDelta
         * @memberof lnrpc.HopHint
         * @instance
         */
        HopHint.prototype.cltvExpiryDelta = 0;

        /**
         * Creates a new HopHint instance using the specified properties.
         * @function create
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint=} [properties] Properties to set
         * @returns {lnrpc.HopHint} HopHint instance
         */
        HopHint.create = function create(properties) {
            return new HopHint(properties);
        };

        /**
         * Encodes the specified HopHint message. Does not implicitly {@link lnrpc.HopHint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint} message HopHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HopHint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.nodeId);
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanId);
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.feeBaseMsat);
            if (message.feeProportionalMillionths != null && message.hasOwnProperty("feeProportionalMillionths"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.feeProportionalMillionths);
            if (message.cltvExpiryDelta != null && message.hasOwnProperty("cltvExpiryDelta"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.cltvExpiryDelta);
            return writer;
        };

        /**
         * Encodes the specified HopHint message, length delimited. Does not implicitly {@link lnrpc.HopHint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.IHopHint} message HopHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HopHint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HopHint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.HopHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.HopHint} HopHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HopHint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.HopHint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.nodeId = reader.string();
                    break;
                case 2:
                    message.chanId = reader.uint64();
                    break;
                case 3:
                    message.feeBaseMsat = reader.uint32();
                    break;
                case 4:
                    message.feeProportionalMillionths = reader.uint32();
                    break;
                case 5:
                    message.cltvExpiryDelta = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HopHint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.HopHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.HopHint} HopHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HopHint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HopHint message.
         * @function verify
         * @memberof lnrpc.HopHint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HopHint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                if (!$util.isString(message.nodeId))
                    return "nodeId: string expected";
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (!$util.isInteger(message.chanId) && !(message.chanId && $util.isInteger(message.chanId.low) && $util.isInteger(message.chanId.high)))
                    return "chanId: integer|Long expected";
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                if (!$util.isInteger(message.feeBaseMsat))
                    return "feeBaseMsat: integer expected";
            if (message.feeProportionalMillionths != null && message.hasOwnProperty("feeProportionalMillionths"))
                if (!$util.isInteger(message.feeProportionalMillionths))
                    return "feeProportionalMillionths: integer expected";
            if (message.cltvExpiryDelta != null && message.hasOwnProperty("cltvExpiryDelta"))
                if (!$util.isInteger(message.cltvExpiryDelta))
                    return "cltvExpiryDelta: integer expected";
            return null;
        };

        /**
         * Creates a HopHint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.HopHint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.HopHint} HopHint
         */
        HopHint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.HopHint)
                return object;
            let message = new $root.lnrpc.HopHint();
            if (object.nodeId != null)
                message.nodeId = String(object.nodeId);
            if (object.chanId != null)
                if ($util.Long)
                    (message.chanId = $util.Long.fromValue(object.chanId)).unsigned = true;
                else if (typeof object.chanId === "string")
                    message.chanId = parseInt(object.chanId, 10);
                else if (typeof object.chanId === "number")
                    message.chanId = object.chanId;
                else if (typeof object.chanId === "object")
                    message.chanId = new $util.LongBits(object.chanId.low >>> 0, object.chanId.high >>> 0).toNumber(true);
            if (object.feeBaseMsat != null)
                message.feeBaseMsat = object.feeBaseMsat >>> 0;
            if (object.feeProportionalMillionths != null)
                message.feeProportionalMillionths = object.feeProportionalMillionths >>> 0;
            if (object.cltvExpiryDelta != null)
                message.cltvExpiryDelta = object.cltvExpiryDelta >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a HopHint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.HopHint
         * @static
         * @param {lnrpc.HopHint} message HopHint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        HopHint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.nodeId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanId = options.longs === String ? "0" : 0;
                object.feeBaseMsat = 0;
                object.feeProportionalMillionths = 0;
                object.cltvExpiryDelta = 0;
            }
            if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                object.nodeId = message.nodeId;
            if (message.chanId != null && message.hasOwnProperty("chanId"))
                if (typeof message.chanId === "number")
                    object.chanId = options.longs === String ? String(message.chanId) : message.chanId;
                else
                    object.chanId = options.longs === String ? $util.Long.prototype.toString.call(message.chanId) : options.longs === Number ? new $util.LongBits(message.chanId.low >>> 0, message.chanId.high >>> 0).toNumber(true) : message.chanId;
            if (message.feeBaseMsat != null && message.hasOwnProperty("feeBaseMsat"))
                object.feeBaseMsat = message.feeBaseMsat;
            if (message.feeProportionalMillionths != null && message.hasOwnProperty("feeProportionalMillionths"))
                object.feeProportionalMillionths = message.feeProportionalMillionths;
            if (message.cltvExpiryDelta != null && message.hasOwnProperty("cltvExpiryDelta"))
                object.cltvExpiryDelta = message.cltvExpiryDelta;
            return object;
        };

        /**
         * Converts this HopHint to JSON.
         * @function toJSON
         * @memberof lnrpc.HopHint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        HopHint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return HopHint;
    })();

    lnrpc.RouteHint = (function() {

        /**
         * Properties of a RouteHint.
         * @memberof lnrpc
         * @interface IRouteHint
         * @property {Array.<lnrpc.IHopHint>|null} [hopHints] A list of hop hints that when chained together can assist in reaching a
         * specific destination.
         */

        /**
         * Constructs a new RouteHint.
         * @memberof lnrpc
         * @classdesc Represents a RouteHint.
         * @implements IRouteHint
         * @constructor
         * @param {lnrpc.IRouteHint=} [properties] Properties to set
         */
        function RouteHint(properties) {
            this.hopHints = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * A list of hop hints that when chained together can assist in reaching a
         * specific destination.
         * @member {Array.<lnrpc.IHopHint>} hopHints
         * @memberof lnrpc.RouteHint
         * @instance
         */
        RouteHint.prototype.hopHints = $util.emptyArray;

        /**
         * Creates a new RouteHint instance using the specified properties.
         * @function create
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint=} [properties] Properties to set
         * @returns {lnrpc.RouteHint} RouteHint instance
         */
        RouteHint.create = function create(properties) {
            return new RouteHint(properties);
        };

        /**
         * Encodes the specified RouteHint message. Does not implicitly {@link lnrpc.RouteHint.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint} message RouteHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RouteHint.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hopHints != null && message.hopHints.length)
                for (let i = 0; i < message.hopHints.length; ++i)
                    $root.lnrpc.HopHint.encode(message.hopHints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RouteHint message, length delimited. Does not implicitly {@link lnrpc.RouteHint.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.IRouteHint} message RouteHint message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RouteHint.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RouteHint message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RouteHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RouteHint} RouteHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RouteHint.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RouteHint();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.hopHints && message.hopHints.length))
                        message.hopHints = [];
                    message.hopHints.push($root.lnrpc.HopHint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RouteHint message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RouteHint
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RouteHint} RouteHint
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RouteHint.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RouteHint message.
         * @function verify
         * @memberof lnrpc.RouteHint
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RouteHint.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hopHints != null && message.hasOwnProperty("hopHints")) {
                if (!Array.isArray(message.hopHints))
                    return "hopHints: array expected";
                for (let i = 0; i < message.hopHints.length; ++i) {
                    let error = $root.lnrpc.HopHint.verify(message.hopHints[i]);
                    if (error)
                        return "hopHints." + error;
                }
            }
            return null;
        };

        /**
         * Creates a RouteHint message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RouteHint
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RouteHint} RouteHint
         */
        RouteHint.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RouteHint)
                return object;
            let message = new $root.lnrpc.RouteHint();
            if (object.hopHints) {
                if (!Array.isArray(object.hopHints))
                    throw TypeError(".lnrpc.RouteHint.hopHints: array expected");
                message.hopHints = [];
                for (let i = 0; i < object.hopHints.length; ++i) {
                    if (typeof object.hopHints[i] !== "object")
                        throw TypeError(".lnrpc.RouteHint.hopHints: object expected");
                    message.hopHints[i] = $root.lnrpc.HopHint.fromObject(object.hopHints[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a RouteHint message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RouteHint
         * @static
         * @param {lnrpc.RouteHint} message RouteHint
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RouteHint.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.hopHints = [];
            if (message.hopHints && message.hopHints.length) {
                object.hopHints = [];
                for (let j = 0; j < message.hopHints.length; ++j)
                    object.hopHints[j] = $root.lnrpc.HopHint.toObject(message.hopHints[j], options);
            }
            return object;
        };

        /**
         * Converts this RouteHint to JSON.
         * @function toJSON
         * @memberof lnrpc.RouteHint
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RouteHint.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RouteHint;
    })();

    lnrpc.Invoice = (function() {

        /**
         * Properties of an Invoice.
         * @memberof lnrpc
         * @interface IInvoice
         * @property {string|null} [memo] An optional memo to attach along with the invoice. Used for record keeping
         * purposes for the invoice's creator, and will also be set in the description
         * field of the encoded payment request if the description_hash field is not
         * being used.
         * @property {Uint8Array|null} [receipt] Deprecated. An optional cryptographic receipt of payment which is not
         * implemented.
         * @property {Uint8Array|null} [rPreimage] The hex-encoded preimage (32 byte) which will allow settling an incoming
         * HTLC payable to this preimage
         * @property {Uint8Array|null} [rHash] The hash of the preimage
         * @property {number|Long|null} [value] The value of this invoice in satoshis
         * @property {boolean|null} [settled] Whether this invoice has been fulfilled
         * @property {number|Long|null} [creationDate] When this invoice was created
         * @property {number|Long|null} [settleDate] When this invoice was settled
         * @property {string|null} [paymentRequest] A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @property {Uint8Array|null} [descriptionHash] Hash (SHA-256) of a description of the payment. Used if the description of
         * payment (memo) is too long to naturally fit within the description field
         * of an encoded payment request.
         * @property {number|Long|null} [expiry] Payment request expiry time in seconds. Default is 3600 (1 hour).
         * @property {string|null} [fallbackAddr] Fallback on-chain address.
         * @property {number|Long|null} [cltvExpiry] Delta to use for the time-lock of the CLTV extended to the final hop.
         * @property {Array.<lnrpc.IRouteHint>|null} [routeHints] Route hints that can each be individually used to assist in reaching the
         * invoice's destination.
         * @property {boolean|null} ["private"] Whether this invoice should include routing hints for private channels.
         * @property {number|Long|null} [addIndex] The "add" index of this invoice. Each newly created invoice will increment
         * this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all added
         * invoices with an add_index greater than this one.
         * @property {number|Long|null} [settleIndex] The "settle" index of this invoice. Each newly settled invoice will
         * increment this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all
         * settled invoices with an settle_index greater than this one.
         * @property {number|Long|null} [amtPaid] Deprecated, use amt_paid_sat or amt_paid_msat.
         * @property {number|Long|null} [amtPaidSat] The amount that was accepted for this invoice, in satoshis. This will ONLY
         * be set if this invoice has been settled. We provide this field as if the
         * invoice was created with a zero value, then we need to record what amount
         * was ultimately accepted. Additionally, it's possible that the sender paid
         * MORE that was specified in the original invoice. So we'll record that here
         * as well.
         * @property {number|Long|null} [amtPaidMsat] The amount that was accepted for this invoice, in millisatoshis. This will
         * ONLY be set if this invoice has been settled. We provide this field as if
         * the invoice was created with a zero value, then we need to record what
         * amount was ultimately accepted. Additionally, it's possible that the sender
         * paid MORE that was specified in the original invoice. So we'll record that
         * here as well.
         * @property {lnrpc.Invoice.InvoiceState|null} [state] The state the invoice is in.
         */

        /**
         * Constructs a new Invoice.
         * @memberof lnrpc
         * @classdesc Represents an Invoice.
         * @implements IInvoice
         * @constructor
         * @param {lnrpc.IInvoice=} [properties] Properties to set
         */
        function Invoice(properties) {
            this.routeHints = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * An optional memo to attach along with the invoice. Used for record keeping
         * purposes for the invoice's creator, and will also be set in the description
         * field of the encoded payment request if the description_hash field is not
         * being used.
         * @member {string} memo
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.memo = "";

        /**
         * Deprecated. An optional cryptographic receipt of payment which is not
         * implemented.
         * @member {Uint8Array} receipt
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.receipt = $util.newBuffer([]);

        /**
         * The hex-encoded preimage (32 byte) which will allow settling an incoming
         * HTLC payable to this preimage
         * @member {Uint8Array} rPreimage
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.rPreimage = $util.newBuffer([]);

        /**
         * The hash of the preimage
         * @member {Uint8Array} rHash
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.rHash = $util.newBuffer([]);

        /**
         * The value of this invoice in satoshis
         * @member {number|Long} value
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Whether this invoice has been fulfilled
         * @member {boolean} settled
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settled = false;

        /**
         * When this invoice was created
         * @member {number|Long} creationDate
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.creationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * When this invoice was settled
         * @member {number|Long} settleDate
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settleDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @member {string} paymentRequest
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.paymentRequest = "";

        /**
         * Hash (SHA-256) of a description of the payment. Used if the description of
         * payment (memo) is too long to naturally fit within the description field
         * of an encoded payment request.
         * @member {Uint8Array} descriptionHash
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.descriptionHash = $util.newBuffer([]);

        /**
         * Payment request expiry time in seconds. Default is 3600 (1 hour).
         * @member {number|Long} expiry
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.expiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fallback on-chain address.
         * @member {string} fallbackAddr
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.fallbackAddr = "";

        /**
         * Delta to use for the time-lock of the CLTV extended to the final hop.
         * @member {number|Long} cltvExpiry
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.cltvExpiry = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Route hints that can each be individually used to assist in reaching the
         * invoice's destination.
         * @member {Array.<lnrpc.IRouteHint>} routeHints
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.routeHints = $util.emptyArray;

        /**
         * Whether this invoice should include routing hints for private channels.
         * @member {boolean} private
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype["private"] = false;

        /**
         * The "add" index of this invoice. Each newly created invoice will increment
         * this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all added
         * invoices with an add_index greater than this one.
         * @member {number|Long} addIndex
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The "settle" index of this invoice. Each newly settled invoice will
         * increment this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all
         * settled invoices with an settle_index greater than this one.
         * @member {number|Long} settleIndex
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.settleIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Deprecated, use amt_paid_sat or amt_paid_msat.
         * @member {number|Long} amtPaid
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.amtPaid = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The amount that was accepted for this invoice, in satoshis. This will ONLY
         * be set if this invoice has been settled. We provide this field as if the
         * invoice was created with a zero value, then we need to record what amount
         * was ultimately accepted. Additionally, it's possible that the sender paid
         * MORE that was specified in the original invoice. So we'll record that here
         * as well.
         * @member {number|Long} amtPaidSat
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.amtPaidSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The amount that was accepted for this invoice, in millisatoshis. This will
         * ONLY be set if this invoice has been settled. We provide this field as if
         * the invoice was created with a zero value, then we need to record what
         * amount was ultimately accepted. Additionally, it's possible that the sender
         * paid MORE that was specified in the original invoice. So we'll record that
         * here as well.
         * @member {number|Long} amtPaidMsat
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.amtPaidMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The state the invoice is in.
         * @member {lnrpc.Invoice.InvoiceState} state
         * @memberof lnrpc.Invoice
         * @instance
         */
        Invoice.prototype.state = 0;

        /**
         * Creates a new Invoice instance using the specified properties.
         * @function create
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice=} [properties] Properties to set
         * @returns {lnrpc.Invoice} Invoice instance
         */
        Invoice.create = function create(properties) {
            return new Invoice(properties);
        };

        /**
         * Encodes the specified Invoice message. Does not implicitly {@link lnrpc.Invoice.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice} message Invoice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invoice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.memo != null && message.hasOwnProperty("memo"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.memo);
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.receipt);
            if (message.rPreimage != null && message.hasOwnProperty("rPreimage"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.rPreimage);
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.rHash);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.value);
            if (message.settled != null && message.hasOwnProperty("settled"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.settled);
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.creationDate);
            if (message.settleDate != null && message.hasOwnProperty("settleDate"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.settleDate);
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.paymentRequest);
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.descriptionHash);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.expiry);
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.fallbackAddr);
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.cltvExpiry);
            if (message.routeHints != null && message.routeHints.length)
                for (let i = 0; i < message.routeHints.length; ++i)
                    $root.lnrpc.RouteHint.encode(message.routeHints[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message["private"] != null && message.hasOwnProperty("private"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message["private"]);
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.addIndex);
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                writer.uint32(/* id 17, wireType 0 =*/136).uint64(message.settleIndex);
            if (message.amtPaid != null && message.hasOwnProperty("amtPaid"))
                writer.uint32(/* id 18, wireType 0 =*/144).int64(message.amtPaid);
            if (message.amtPaidSat != null && message.hasOwnProperty("amtPaidSat"))
                writer.uint32(/* id 19, wireType 0 =*/152).int64(message.amtPaidSat);
            if (message.amtPaidMsat != null && message.hasOwnProperty("amtPaidMsat"))
                writer.uint32(/* id 20, wireType 0 =*/160).int64(message.amtPaidMsat);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified Invoice message, length delimited. Does not implicitly {@link lnrpc.Invoice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.IInvoice} message Invoice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invoice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Invoice message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Invoice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Invoice} Invoice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invoice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Invoice();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.memo = reader.string();
                    break;
                case 2:
                    message.receipt = reader.bytes();
                    break;
                case 3:
                    message.rPreimage = reader.bytes();
                    break;
                case 4:
                    message.rHash = reader.bytes();
                    break;
                case 5:
                    message.value = reader.int64();
                    break;
                case 6:
                    message.settled = reader.bool();
                    break;
                case 7:
                    message.creationDate = reader.int64();
                    break;
                case 8:
                    message.settleDate = reader.int64();
                    break;
                case 9:
                    message.paymentRequest = reader.string();
                    break;
                case 10:
                    message.descriptionHash = reader.bytes();
                    break;
                case 11:
                    message.expiry = reader.int64();
                    break;
                case 12:
                    message.fallbackAddr = reader.string();
                    break;
                case 13:
                    message.cltvExpiry = reader.uint64();
                    break;
                case 14:
                    if (!(message.routeHints && message.routeHints.length))
                        message.routeHints = [];
                    message.routeHints.push($root.lnrpc.RouteHint.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message["private"] = reader.bool();
                    break;
                case 16:
                    message.addIndex = reader.uint64();
                    break;
                case 17:
                    message.settleIndex = reader.uint64();
                    break;
                case 18:
                    message.amtPaid = reader.int64();
                    break;
                case 19:
                    message.amtPaidSat = reader.int64();
                    break;
                case 20:
                    message.amtPaidMsat = reader.int64();
                    break;
                case 21:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Invoice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Invoice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Invoice} Invoice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invoice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Invoice message.
         * @function verify
         * @memberof lnrpc.Invoice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Invoice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.memo != null && message.hasOwnProperty("memo"))
                if (!$util.isString(message.memo))
                    return "memo: string expected";
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                if (!(message.receipt && typeof message.receipt.length === "number" || $util.isString(message.receipt)))
                    return "receipt: buffer expected";
            if (message.rPreimage != null && message.hasOwnProperty("rPreimage"))
                if (!(message.rPreimage && typeof message.rPreimage.length === "number" || $util.isString(message.rPreimage)))
                    return "rPreimage: buffer expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.settled != null && message.hasOwnProperty("settled"))
                if (typeof message.settled !== "boolean")
                    return "settled: boolean expected";
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (!$util.isInteger(message.creationDate) && !(message.creationDate && $util.isInteger(message.creationDate.low) && $util.isInteger(message.creationDate.high)))
                    return "creationDate: integer|Long expected";
            if (message.settleDate != null && message.hasOwnProperty("settleDate"))
                if (!$util.isInteger(message.settleDate) && !(message.settleDate && $util.isInteger(message.settleDate.low) && $util.isInteger(message.settleDate.high)))
                    return "settleDate: integer|Long expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                if (!(message.descriptionHash && typeof message.descriptionHash.length === "number" || $util.isString(message.descriptionHash)))
                    return "descriptionHash: buffer expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry) && !(message.expiry && $util.isInteger(message.expiry.low) && $util.isInteger(message.expiry.high)))
                    return "expiry: integer|Long expected";
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                if (!$util.isString(message.fallbackAddr))
                    return "fallbackAddr: string expected";
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (!$util.isInteger(message.cltvExpiry) && !(message.cltvExpiry && $util.isInteger(message.cltvExpiry.low) && $util.isInteger(message.cltvExpiry.high)))
                    return "cltvExpiry: integer|Long expected";
            if (message.routeHints != null && message.hasOwnProperty("routeHints")) {
                if (!Array.isArray(message.routeHints))
                    return "routeHints: array expected";
                for (let i = 0; i < message.routeHints.length; ++i) {
                    let error = $root.lnrpc.RouteHint.verify(message.routeHints[i]);
                    if (error)
                        return "routeHints." + error;
                }
            }
            if (message["private"] != null && message.hasOwnProperty("private"))
                if (typeof message["private"] !== "boolean")
                    return "private: boolean expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (!$util.isInteger(message.settleIndex) && !(message.settleIndex && $util.isInteger(message.settleIndex.low) && $util.isInteger(message.settleIndex.high)))
                    return "settleIndex: integer|Long expected";
            if (message.amtPaid != null && message.hasOwnProperty("amtPaid"))
                if (!$util.isInteger(message.amtPaid) && !(message.amtPaid && $util.isInteger(message.amtPaid.low) && $util.isInteger(message.amtPaid.high)))
                    return "amtPaid: integer|Long expected";
            if (message.amtPaidSat != null && message.hasOwnProperty("amtPaidSat"))
                if (!$util.isInteger(message.amtPaidSat) && !(message.amtPaidSat && $util.isInteger(message.amtPaidSat.low) && $util.isInteger(message.amtPaidSat.high)))
                    return "amtPaidSat: integer|Long expected";
            if (message.amtPaidMsat != null && message.hasOwnProperty("amtPaidMsat"))
                if (!$util.isInteger(message.amtPaidMsat) && !(message.amtPaidMsat && $util.isInteger(message.amtPaidMsat.low) && $util.isInteger(message.amtPaidMsat.high)))
                    return "amtPaidMsat: integer|Long expected";
            if (message.state != null && message.hasOwnProperty("state"))
                switch (message.state) {
                default:
                    return "state: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates an Invoice message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Invoice
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Invoice} Invoice
         */
        Invoice.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Invoice)
                return object;
            let message = new $root.lnrpc.Invoice();
            if (object.memo != null)
                message.memo = String(object.memo);
            if (object.receipt != null)
                if (typeof object.receipt === "string")
                    $util.base64.decode(object.receipt, message.receipt = $util.newBuffer($util.base64.length(object.receipt)), 0);
                else if (object.receipt.length)
                    message.receipt = object.receipt;
            if (object.rPreimage != null)
                if (typeof object.rPreimage === "string")
                    $util.base64.decode(object.rPreimage, message.rPreimage = $util.newBuffer($util.base64.length(object.rPreimage)), 0);
                else if (object.rPreimage.length)
                    message.rPreimage = object.rPreimage;
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.settled != null)
                message.settled = Boolean(object.settled);
            if (object.creationDate != null)
                if ($util.Long)
                    (message.creationDate = $util.Long.fromValue(object.creationDate)).unsigned = false;
                else if (typeof object.creationDate === "string")
                    message.creationDate = parseInt(object.creationDate, 10);
                else if (typeof object.creationDate === "number")
                    message.creationDate = object.creationDate;
                else if (typeof object.creationDate === "object")
                    message.creationDate = new $util.LongBits(object.creationDate.low >>> 0, object.creationDate.high >>> 0).toNumber();
            if (object.settleDate != null)
                if ($util.Long)
                    (message.settleDate = $util.Long.fromValue(object.settleDate)).unsigned = false;
                else if (typeof object.settleDate === "string")
                    message.settleDate = parseInt(object.settleDate, 10);
                else if (typeof object.settleDate === "number")
                    message.settleDate = object.settleDate;
                else if (typeof object.settleDate === "object")
                    message.settleDate = new $util.LongBits(object.settleDate.low >>> 0, object.settleDate.high >>> 0).toNumber();
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.descriptionHash != null)
                if (typeof object.descriptionHash === "string")
                    $util.base64.decode(object.descriptionHash, message.descriptionHash = $util.newBuffer($util.base64.length(object.descriptionHash)), 0);
                else if (object.descriptionHash.length)
                    message.descriptionHash = object.descriptionHash;
            if (object.expiry != null)
                if ($util.Long)
                    (message.expiry = $util.Long.fromValue(object.expiry)).unsigned = false;
                else if (typeof object.expiry === "string")
                    message.expiry = parseInt(object.expiry, 10);
                else if (typeof object.expiry === "number")
                    message.expiry = object.expiry;
                else if (typeof object.expiry === "object")
                    message.expiry = new $util.LongBits(object.expiry.low >>> 0, object.expiry.high >>> 0).toNumber();
            if (object.fallbackAddr != null)
                message.fallbackAddr = String(object.fallbackAddr);
            if (object.cltvExpiry != null)
                if ($util.Long)
                    (message.cltvExpiry = $util.Long.fromValue(object.cltvExpiry)).unsigned = true;
                else if (typeof object.cltvExpiry === "string")
                    message.cltvExpiry = parseInt(object.cltvExpiry, 10);
                else if (typeof object.cltvExpiry === "number")
                    message.cltvExpiry = object.cltvExpiry;
                else if (typeof object.cltvExpiry === "object")
                    message.cltvExpiry = new $util.LongBits(object.cltvExpiry.low >>> 0, object.cltvExpiry.high >>> 0).toNumber(true);
            if (object.routeHints) {
                if (!Array.isArray(object.routeHints))
                    throw TypeError(".lnrpc.Invoice.routeHints: array expected");
                message.routeHints = [];
                for (let i = 0; i < object.routeHints.length; ++i) {
                    if (typeof object.routeHints[i] !== "object")
                        throw TypeError(".lnrpc.Invoice.routeHints: object expected");
                    message.routeHints[i] = $root.lnrpc.RouteHint.fromObject(object.routeHints[i]);
                }
            }
            if (object["private"] != null)
                message["private"] = Boolean(object["private"]);
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            if (object.settleIndex != null)
                if ($util.Long)
                    (message.settleIndex = $util.Long.fromValue(object.settleIndex)).unsigned = true;
                else if (typeof object.settleIndex === "string")
                    message.settleIndex = parseInt(object.settleIndex, 10);
                else if (typeof object.settleIndex === "number")
                    message.settleIndex = object.settleIndex;
                else if (typeof object.settleIndex === "object")
                    message.settleIndex = new $util.LongBits(object.settleIndex.low >>> 0, object.settleIndex.high >>> 0).toNumber(true);
            if (object.amtPaid != null)
                if ($util.Long)
                    (message.amtPaid = $util.Long.fromValue(object.amtPaid)).unsigned = false;
                else if (typeof object.amtPaid === "string")
                    message.amtPaid = parseInt(object.amtPaid, 10);
                else if (typeof object.amtPaid === "number")
                    message.amtPaid = object.amtPaid;
                else if (typeof object.amtPaid === "object")
                    message.amtPaid = new $util.LongBits(object.amtPaid.low >>> 0, object.amtPaid.high >>> 0).toNumber();
            if (object.amtPaidSat != null)
                if ($util.Long)
                    (message.amtPaidSat = $util.Long.fromValue(object.amtPaidSat)).unsigned = false;
                else if (typeof object.amtPaidSat === "string")
                    message.amtPaidSat = parseInt(object.amtPaidSat, 10);
                else if (typeof object.amtPaidSat === "number")
                    message.amtPaidSat = object.amtPaidSat;
                else if (typeof object.amtPaidSat === "object")
                    message.amtPaidSat = new $util.LongBits(object.amtPaidSat.low >>> 0, object.amtPaidSat.high >>> 0).toNumber();
            if (object.amtPaidMsat != null)
                if ($util.Long)
                    (message.amtPaidMsat = $util.Long.fromValue(object.amtPaidMsat)).unsigned = false;
                else if (typeof object.amtPaidMsat === "string")
                    message.amtPaidMsat = parseInt(object.amtPaidMsat, 10);
                else if (typeof object.amtPaidMsat === "number")
                    message.amtPaidMsat = object.amtPaidMsat;
                else if (typeof object.amtPaidMsat === "object")
                    message.amtPaidMsat = new $util.LongBits(object.amtPaidMsat.low >>> 0, object.amtPaidMsat.high >>> 0).toNumber();
            switch (object.state) {
            case "OPEN":
            case 0:
                message.state = 0;
                break;
            case "SETTLED":
            case 1:
                message.state = 1;
                break;
            case "CANCELED":
            case 2:
                message.state = 2;
                break;
            case "ACCEPTED":
            case 3:
                message.state = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an Invoice message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Invoice
         * @static
         * @param {lnrpc.Invoice} message Invoice
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Invoice.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.routeHints = [];
            if (options.defaults) {
                object.memo = "";
                if (options.bytes === String)
                    object.receipt = "";
                else {
                    object.receipt = [];
                    if (options.bytes !== Array)
                        object.receipt = $util.newBuffer(object.receipt);
                }
                if (options.bytes === String)
                    object.rPreimage = "";
                else {
                    object.rPreimage = [];
                    if (options.bytes !== Array)
                        object.rPreimage = $util.newBuffer(object.rPreimage);
                }
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                object.settled = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creationDate = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.settleDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleDate = options.longs === String ? "0" : 0;
                object.paymentRequest = "";
                if (options.bytes === String)
                    object.descriptionHash = "";
                else {
                    object.descriptionHash = [];
                    if (options.bytes !== Array)
                        object.descriptionHash = $util.newBuffer(object.descriptionHash);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiry = options.longs === String ? "0" : 0;
                object.fallbackAddr = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.cltvExpiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cltvExpiry = options.longs === String ? "0" : 0;
                object["private"] = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.settleIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtPaid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtPaid = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtPaidSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtPaidSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.amtPaidMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtPaidMsat = options.longs === String ? "0" : 0;
                object.state = options.enums === String ? "OPEN" : 0;
            }
            if (message.memo != null && message.hasOwnProperty("memo"))
                object.memo = message.memo;
            if (message.receipt != null && message.hasOwnProperty("receipt"))
                object.receipt = options.bytes === String ? $util.base64.encode(message.receipt, 0, message.receipt.length) : options.bytes === Array ? Array.prototype.slice.call(message.receipt) : message.receipt;
            if (message.rPreimage != null && message.hasOwnProperty("rPreimage"))
                object.rPreimage = options.bytes === String ? $util.base64.encode(message.rPreimage, 0, message.rPreimage.length) : options.bytes === Array ? Array.prototype.slice.call(message.rPreimage) : message.rPreimage;
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.settled != null && message.hasOwnProperty("settled"))
                object.settled = message.settled;
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (typeof message.creationDate === "number")
                    object.creationDate = options.longs === String ? String(message.creationDate) : message.creationDate;
                else
                    object.creationDate = options.longs === String ? $util.Long.prototype.toString.call(message.creationDate) : options.longs === Number ? new $util.LongBits(message.creationDate.low >>> 0, message.creationDate.high >>> 0).toNumber() : message.creationDate;
            if (message.settleDate != null && message.hasOwnProperty("settleDate"))
                if (typeof message.settleDate === "number")
                    object.settleDate = options.longs === String ? String(message.settleDate) : message.settleDate;
                else
                    object.settleDate = options.longs === String ? $util.Long.prototype.toString.call(message.settleDate) : options.longs === Number ? new $util.LongBits(message.settleDate.low >>> 0, message.settleDate.high >>> 0).toNumber() : message.settleDate;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                object.descriptionHash = options.bytes === String ? $util.base64.encode(message.descriptionHash, 0, message.descriptionHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.descriptionHash) : message.descriptionHash;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (typeof message.expiry === "number")
                    object.expiry = options.longs === String ? String(message.expiry) : message.expiry;
                else
                    object.expiry = options.longs === String ? $util.Long.prototype.toString.call(message.expiry) : options.longs === Number ? new $util.LongBits(message.expiry.low >>> 0, message.expiry.high >>> 0).toNumber() : message.expiry;
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                object.fallbackAddr = message.fallbackAddr;
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (typeof message.cltvExpiry === "number")
                    object.cltvExpiry = options.longs === String ? String(message.cltvExpiry) : message.cltvExpiry;
                else
                    object.cltvExpiry = options.longs === String ? $util.Long.prototype.toString.call(message.cltvExpiry) : options.longs === Number ? new $util.LongBits(message.cltvExpiry.low >>> 0, message.cltvExpiry.high >>> 0).toNumber(true) : message.cltvExpiry;
            if (message.routeHints && message.routeHints.length) {
                object.routeHints = [];
                for (let j = 0; j < message.routeHints.length; ++j)
                    object.routeHints[j] = $root.lnrpc.RouteHint.toObject(message.routeHints[j], options);
            }
            if (message["private"] != null && message.hasOwnProperty("private"))
                object["private"] = message["private"];
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (typeof message.settleIndex === "number")
                    object.settleIndex = options.longs === String ? String(message.settleIndex) : message.settleIndex;
                else
                    object.settleIndex = options.longs === String ? $util.Long.prototype.toString.call(message.settleIndex) : options.longs === Number ? new $util.LongBits(message.settleIndex.low >>> 0, message.settleIndex.high >>> 0).toNumber(true) : message.settleIndex;
            if (message.amtPaid != null && message.hasOwnProperty("amtPaid"))
                if (typeof message.amtPaid === "number")
                    object.amtPaid = options.longs === String ? String(message.amtPaid) : message.amtPaid;
                else
                    object.amtPaid = options.longs === String ? $util.Long.prototype.toString.call(message.amtPaid) : options.longs === Number ? new $util.LongBits(message.amtPaid.low >>> 0, message.amtPaid.high >>> 0).toNumber() : message.amtPaid;
            if (message.amtPaidSat != null && message.hasOwnProperty("amtPaidSat"))
                if (typeof message.amtPaidSat === "number")
                    object.amtPaidSat = options.longs === String ? String(message.amtPaidSat) : message.amtPaidSat;
                else
                    object.amtPaidSat = options.longs === String ? $util.Long.prototype.toString.call(message.amtPaidSat) : options.longs === Number ? new $util.LongBits(message.amtPaidSat.low >>> 0, message.amtPaidSat.high >>> 0).toNumber() : message.amtPaidSat;
            if (message.amtPaidMsat != null && message.hasOwnProperty("amtPaidMsat"))
                if (typeof message.amtPaidMsat === "number")
                    object.amtPaidMsat = options.longs === String ? String(message.amtPaidMsat) : message.amtPaidMsat;
                else
                    object.amtPaidMsat = options.longs === String ? $util.Long.prototype.toString.call(message.amtPaidMsat) : options.longs === Number ? new $util.LongBits(message.amtPaidMsat.low >>> 0, message.amtPaidMsat.high >>> 0).toNumber() : message.amtPaidMsat;
            if (message.state != null && message.hasOwnProperty("state"))
                object.state = options.enums === String ? $root.lnrpc.Invoice.InvoiceState[message.state] : message.state;
            return object;
        };

        /**
         * Converts this Invoice to JSON.
         * @function toJSON
         * @memberof lnrpc.Invoice
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Invoice.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * InvoiceState enum.
         * @name lnrpc.Invoice.InvoiceState
         * @enum {string}
         * @property {number} OPEN=0 OPEN value
         * @property {number} SETTLED=1 SETTLED value
         * @property {number} CANCELED=2 CANCELED value
         * @property {number} ACCEPTED=3 ACCEPTED value
         */
        Invoice.InvoiceState = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OPEN"] = 0;
            values[valuesById[1] = "SETTLED"] = 1;
            values[valuesById[2] = "CANCELED"] = 2;
            values[valuesById[3] = "ACCEPTED"] = 3;
            return values;
        })();

        return Invoice;
    })();

    lnrpc.AddInvoiceResponse = (function() {

        /**
         * Properties of an AddInvoiceResponse.
         * @memberof lnrpc
         * @interface IAddInvoiceResponse
         * @property {Uint8Array|null} [rHash] AddInvoiceResponse rHash
         * @property {string|null} [paymentRequest] A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @property {number|Long|null} [addIndex] The "add" index of this invoice. Each newly created invoice will increment
         * this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all added
         * invoices with an add_index greater than this one.
         */

        /**
         * Constructs a new AddInvoiceResponse.
         * @memberof lnrpc
         * @classdesc Represents an AddInvoiceResponse.
         * @implements IAddInvoiceResponse
         * @constructor
         * @param {lnrpc.IAddInvoiceResponse=} [properties] Properties to set
         */
        function AddInvoiceResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddInvoiceResponse rHash.
         * @member {Uint8Array} rHash
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.rHash = $util.newBuffer([]);

        /**
         * A bare-bones invoice for a payment within the Lightning Network.  With the
         * details of the invoice, the sender has all the data necessary to send a
         * payment to the recipient.
         * @member {string} paymentRequest
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.paymentRequest = "";

        /**
         * The "add" index of this invoice. Each newly created invoice will increment
         * this index making it monotonically increasing. Callers to the
         * SubscribeInvoices call can use this to instantly get notified of all added
         * invoices with an add_index greater than this one.
         * @member {number|Long} addIndex
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         */
        AddInvoiceResponse.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new AddInvoiceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse=} [properties] Properties to set
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse instance
         */
        AddInvoiceResponse.create = function create(properties) {
            return new AddInvoiceResponse(properties);
        };

        /**
         * Encodes the specified AddInvoiceResponse message. Does not implicitly {@link lnrpc.AddInvoiceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse} message AddInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddInvoiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.rHash);
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentRequest);
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.addIndex);
            return writer;
        };

        /**
         * Encodes the specified AddInvoiceResponse message, length delimited. Does not implicitly {@link lnrpc.AddInvoiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.IAddInvoiceResponse} message AddInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddInvoiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddInvoiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddInvoiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.AddInvoiceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rHash = reader.bytes();
                    break;
                case 2:
                    message.paymentRequest = reader.string();
                    break;
                case 16:
                    message.addIndex = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddInvoiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddInvoiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddInvoiceResponse message.
         * @function verify
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddInvoiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates an AddInvoiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.AddInvoiceResponse} AddInvoiceResponse
         */
        AddInvoiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.AddInvoiceResponse)
                return object;
            let message = new $root.lnrpc.AddInvoiceResponse();
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an AddInvoiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.AddInvoiceResponse
         * @static
         * @param {lnrpc.AddInvoiceResponse} message AddInvoiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AddInvoiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
                object.paymentRequest = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
            }
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            return object;
        };

        /**
         * Converts this AddInvoiceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.AddInvoiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AddInvoiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AddInvoiceResponse;
    })();

    lnrpc.PaymentHash = (function() {

        /**
         * Properties of a PaymentHash.
         * @memberof lnrpc
         * @interface IPaymentHash
         * @property {string|null} [rHashStr] The hex-encoded payment hash of the invoice to be looked up. The passed
         * payment hash must be exactly 32 bytes, otherwise an error is returned.
         * @property {Uint8Array|null} [rHash] The payment hash of the invoice to be looked up.
         */

        /**
         * Constructs a new PaymentHash.
         * @memberof lnrpc
         * @classdesc Represents a PaymentHash.
         * @implements IPaymentHash
         * @constructor
         * @param {lnrpc.IPaymentHash=} [properties] Properties to set
         */
        function PaymentHash(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The hex-encoded payment hash of the invoice to be looked up. The passed
         * payment hash must be exactly 32 bytes, otherwise an error is returned.
         * @member {string} rHashStr
         * @memberof lnrpc.PaymentHash
         * @instance
         */
        PaymentHash.prototype.rHashStr = "";

        /**
         * The payment hash of the invoice to be looked up.
         * @member {Uint8Array} rHash
         * @memberof lnrpc.PaymentHash
         * @instance
         */
        PaymentHash.prototype.rHash = $util.newBuffer([]);

        /**
         * Creates a new PaymentHash instance using the specified properties.
         * @function create
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash=} [properties] Properties to set
         * @returns {lnrpc.PaymentHash} PaymentHash instance
         */
        PaymentHash.create = function create(properties) {
            return new PaymentHash(properties);
        };

        /**
         * Encodes the specified PaymentHash message. Does not implicitly {@link lnrpc.PaymentHash.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash} message PaymentHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentHash.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rHashStr != null && message.hasOwnProperty("rHashStr"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.rHashStr);
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.rHash);
            return writer;
        };

        /**
         * Encodes the specified PaymentHash message, length delimited. Does not implicitly {@link lnrpc.PaymentHash.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.IPaymentHash} message PaymentHash message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PaymentHash.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PaymentHash message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PaymentHash} PaymentHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentHash.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PaymentHash();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rHashStr = reader.string();
                    break;
                case 2:
                    message.rHash = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PaymentHash message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PaymentHash} PaymentHash
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PaymentHash.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PaymentHash message.
         * @function verify
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PaymentHash.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rHashStr != null && message.hasOwnProperty("rHashStr"))
                if (!$util.isString(message.rHashStr))
                    return "rHashStr: string expected";
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                if (!(message.rHash && typeof message.rHash.length === "number" || $util.isString(message.rHash)))
                    return "rHash: buffer expected";
            return null;
        };

        /**
         * Creates a PaymentHash message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PaymentHash} PaymentHash
         */
        PaymentHash.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PaymentHash)
                return object;
            let message = new $root.lnrpc.PaymentHash();
            if (object.rHashStr != null)
                message.rHashStr = String(object.rHashStr);
            if (object.rHash != null)
                if (typeof object.rHash === "string")
                    $util.base64.decode(object.rHash, message.rHash = $util.newBuffer($util.base64.length(object.rHash)), 0);
                else if (object.rHash.length)
                    message.rHash = object.rHash;
            return message;
        };

        /**
         * Creates a plain object from a PaymentHash message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PaymentHash
         * @static
         * @param {lnrpc.PaymentHash} message PaymentHash
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PaymentHash.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.rHashStr = "";
                if (options.bytes === String)
                    object.rHash = "";
                else {
                    object.rHash = [];
                    if (options.bytes !== Array)
                        object.rHash = $util.newBuffer(object.rHash);
                }
            }
            if (message.rHashStr != null && message.hasOwnProperty("rHashStr"))
                object.rHashStr = message.rHashStr;
            if (message.rHash != null && message.hasOwnProperty("rHash"))
                object.rHash = options.bytes === String ? $util.base64.encode(message.rHash, 0, message.rHash.length) : options.bytes === Array ? Array.prototype.slice.call(message.rHash) : message.rHash;
            return object;
        };

        /**
         * Converts this PaymentHash to JSON.
         * @function toJSON
         * @memberof lnrpc.PaymentHash
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PaymentHash.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PaymentHash;
    })();

    lnrpc.ListInvoiceRequest = (function() {

        /**
         * Properties of a ListInvoiceRequest.
         * @memberof lnrpc
         * @interface IListInvoiceRequest
         * @property {boolean|null} [pendingOnly] If set, only unsettled invoices will be returned in the response.
         * @property {number|Long|null} [indexOffset] The index of an invoice that will be used as either the start or end of a
         * query to determine which invoices should be returned in the response.
         * @property {number|Long|null} [numMaxInvoices] The max number of invoices to return in the response to this query.
         * @property {boolean|null} [reversed] If set, the invoices returned will result from seeking backwards from the
         * specified index offset. This can be used to paginate backwards.
         */

        /**
         * Constructs a new ListInvoiceRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListInvoiceRequest.
         * @implements IListInvoiceRequest
         * @constructor
         * @param {lnrpc.IListInvoiceRequest=} [properties] Properties to set
         */
        function ListInvoiceRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * If set, only unsettled invoices will be returned in the response.
         * @member {boolean} pendingOnly
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.pendingOnly = false;

        /**
         * The index of an invoice that will be used as either the start or end of a
         * query to determine which invoices should be returned in the response.
         * @member {number|Long} indexOffset
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.indexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The max number of invoices to return in the response to this query.
         * @member {number|Long} numMaxInvoices
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.numMaxInvoices = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * If set, the invoices returned will result from seeking backwards from the
         * specified index offset. This can be used to paginate backwards.
         * @member {boolean} reversed
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         */
        ListInvoiceRequest.prototype.reversed = false;

        /**
         * Creates a new ListInvoiceRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest=} [properties] Properties to set
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest instance
         */
        ListInvoiceRequest.create = function create(properties) {
            return new ListInvoiceRequest(properties);
        };

        /**
         * Encodes the specified ListInvoiceRequest message. Does not implicitly {@link lnrpc.ListInvoiceRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest} message ListInvoiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pendingOnly != null && message.hasOwnProperty("pendingOnly"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.pendingOnly);
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.indexOffset);
            if (message.numMaxInvoices != null && message.hasOwnProperty("numMaxInvoices"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.numMaxInvoices);
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.reversed);
            return writer;
        };

        /**
         * Encodes the specified ListInvoiceRequest message, length delimited. Does not implicitly {@link lnrpc.ListInvoiceRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.IListInvoiceRequest} message ListInvoiceRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListInvoiceRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListInvoiceRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.pendingOnly = reader.bool();
                    break;
                case 4:
                    message.indexOffset = reader.uint64();
                    break;
                case 5:
                    message.numMaxInvoices = reader.uint64();
                    break;
                case 6:
                    message.reversed = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListInvoiceRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListInvoiceRequest message.
         * @function verify
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListInvoiceRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pendingOnly != null && message.hasOwnProperty("pendingOnly"))
                if (typeof message.pendingOnly !== "boolean")
                    return "pendingOnly: boolean expected";
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (!$util.isInteger(message.indexOffset) && !(message.indexOffset && $util.isInteger(message.indexOffset.low) && $util.isInteger(message.indexOffset.high)))
                    return "indexOffset: integer|Long expected";
            if (message.numMaxInvoices != null && message.hasOwnProperty("numMaxInvoices"))
                if (!$util.isInteger(message.numMaxInvoices) && !(message.numMaxInvoices && $util.isInteger(message.numMaxInvoices.low) && $util.isInteger(message.numMaxInvoices.high)))
                    return "numMaxInvoices: integer|Long expected";
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                if (typeof message.reversed !== "boolean")
                    return "reversed: boolean expected";
            return null;
        };

        /**
         * Creates a ListInvoiceRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListInvoiceRequest} ListInvoiceRequest
         */
        ListInvoiceRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListInvoiceRequest)
                return object;
            let message = new $root.lnrpc.ListInvoiceRequest();
            if (object.pendingOnly != null)
                message.pendingOnly = Boolean(object.pendingOnly);
            if (object.indexOffset != null)
                if ($util.Long)
                    (message.indexOffset = $util.Long.fromValue(object.indexOffset)).unsigned = true;
                else if (typeof object.indexOffset === "string")
                    message.indexOffset = parseInt(object.indexOffset, 10);
                else if (typeof object.indexOffset === "number")
                    message.indexOffset = object.indexOffset;
                else if (typeof object.indexOffset === "object")
                    message.indexOffset = new $util.LongBits(object.indexOffset.low >>> 0, object.indexOffset.high >>> 0).toNumber(true);
            if (object.numMaxInvoices != null)
                if ($util.Long)
                    (message.numMaxInvoices = $util.Long.fromValue(object.numMaxInvoices)).unsigned = true;
                else if (typeof object.numMaxInvoices === "string")
                    message.numMaxInvoices = parseInt(object.numMaxInvoices, 10);
                else if (typeof object.numMaxInvoices === "number")
                    message.numMaxInvoices = object.numMaxInvoices;
                else if (typeof object.numMaxInvoices === "object")
                    message.numMaxInvoices = new $util.LongBits(object.numMaxInvoices.low >>> 0, object.numMaxInvoices.high >>> 0).toNumber(true);
            if (object.reversed != null)
                message.reversed = Boolean(object.reversed);
            return message;
        };

        /**
         * Creates a plain object from a ListInvoiceRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListInvoiceRequest
         * @static
         * @param {lnrpc.ListInvoiceRequest} message ListInvoiceRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListInvoiceRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.pendingOnly = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.indexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.indexOffset = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.numMaxInvoices = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numMaxInvoices = options.longs === String ? "0" : 0;
                object.reversed = false;
            }
            if (message.pendingOnly != null && message.hasOwnProperty("pendingOnly"))
                object.pendingOnly = message.pendingOnly;
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (typeof message.indexOffset === "number")
                    object.indexOffset = options.longs === String ? String(message.indexOffset) : message.indexOffset;
                else
                    object.indexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.indexOffset) : options.longs === Number ? new $util.LongBits(message.indexOffset.low >>> 0, message.indexOffset.high >>> 0).toNumber(true) : message.indexOffset;
            if (message.numMaxInvoices != null && message.hasOwnProperty("numMaxInvoices"))
                if (typeof message.numMaxInvoices === "number")
                    object.numMaxInvoices = options.longs === String ? String(message.numMaxInvoices) : message.numMaxInvoices;
                else
                    object.numMaxInvoices = options.longs === String ? $util.Long.prototype.toString.call(message.numMaxInvoices) : options.longs === Number ? new $util.LongBits(message.numMaxInvoices.low >>> 0, message.numMaxInvoices.high >>> 0).toNumber(true) : message.numMaxInvoices;
            if (message.reversed != null && message.hasOwnProperty("reversed"))
                object.reversed = message.reversed;
            return object;
        };

        /**
         * Converts this ListInvoiceRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListInvoiceRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListInvoiceRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListInvoiceRequest;
    })();

    lnrpc.ListInvoiceResponse = (function() {

        /**
         * Properties of a ListInvoiceResponse.
         * @memberof lnrpc
         * @interface IListInvoiceResponse
         * @property {Array.<lnrpc.IInvoice>|null} [invoices] A list of invoices from the time slice of the time series specified in the
         * request.
         * @property {number|Long|null} [lastIndexOffset] The index of the last item in the set of returned invoices. This can be used
         * to seek further, pagination style.
         * @property {number|Long|null} [firstIndexOffset] The index of the last item in the set of returned invoices. This can be used
         * to seek backwards, pagination style.
         */

        /**
         * Constructs a new ListInvoiceResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListInvoiceResponse.
         * @implements IListInvoiceResponse
         * @constructor
         * @param {lnrpc.IListInvoiceResponse=} [properties] Properties to set
         */
        function ListInvoiceResponse(properties) {
            this.invoices = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * A list of invoices from the time slice of the time series specified in the
         * request.
         * @member {Array.<lnrpc.IInvoice>} invoices
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         */
        ListInvoiceResponse.prototype.invoices = $util.emptyArray;

        /**
         * The index of the last item in the set of returned invoices. This can be used
         * to seek further, pagination style.
         * @member {number|Long} lastIndexOffset
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         */
        ListInvoiceResponse.prototype.lastIndexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The index of the last item in the set of returned invoices. This can be used
         * to seek backwards, pagination style.
         * @member {number|Long} firstIndexOffset
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         */
        ListInvoiceResponse.prototype.firstIndexOffset = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ListInvoiceResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse=} [properties] Properties to set
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse instance
         */
        ListInvoiceResponse.create = function create(properties) {
            return new ListInvoiceResponse(properties);
        };

        /**
         * Encodes the specified ListInvoiceResponse message. Does not implicitly {@link lnrpc.ListInvoiceResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse} message ListInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.invoices != null && message.invoices.length)
                for (let i = 0; i < message.invoices.length; ++i)
                    $root.lnrpc.Invoice.encode(message.invoices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lastIndexOffset != null && message.hasOwnProperty("lastIndexOffset"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.lastIndexOffset);
            if (message.firstIndexOffset != null && message.hasOwnProperty("firstIndexOffset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.firstIndexOffset);
            return writer;
        };

        /**
         * Encodes the specified ListInvoiceResponse message, length delimited. Does not implicitly {@link lnrpc.ListInvoiceResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.IListInvoiceResponse} message ListInvoiceResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListInvoiceResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListInvoiceResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListInvoiceResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.invoices && message.invoices.length))
                        message.invoices = [];
                    message.invoices.push($root.lnrpc.Invoice.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lastIndexOffset = reader.uint64();
                    break;
                case 3:
                    message.firstIndexOffset = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListInvoiceResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListInvoiceResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListInvoiceResponse message.
         * @function verify
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListInvoiceResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.invoices != null && message.hasOwnProperty("invoices")) {
                if (!Array.isArray(message.invoices))
                    return "invoices: array expected";
                for (let i = 0; i < message.invoices.length; ++i) {
                    let error = $root.lnrpc.Invoice.verify(message.invoices[i]);
                    if (error)
                        return "invoices." + error;
                }
            }
            if (message.lastIndexOffset != null && message.hasOwnProperty("lastIndexOffset"))
                if (!$util.isInteger(message.lastIndexOffset) && !(message.lastIndexOffset && $util.isInteger(message.lastIndexOffset.low) && $util.isInteger(message.lastIndexOffset.high)))
                    return "lastIndexOffset: integer|Long expected";
            if (message.firstIndexOffset != null && message.hasOwnProperty("firstIndexOffset"))
                if (!$util.isInteger(message.firstIndexOffset) && !(message.firstIndexOffset && $util.isInteger(message.firstIndexOffset.low) && $util.isInteger(message.firstIndexOffset.high)))
                    return "firstIndexOffset: integer|Long expected";
            return null;
        };

        /**
         * Creates a ListInvoiceResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListInvoiceResponse} ListInvoiceResponse
         */
        ListInvoiceResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListInvoiceResponse)
                return object;
            let message = new $root.lnrpc.ListInvoiceResponse();
            if (object.invoices) {
                if (!Array.isArray(object.invoices))
                    throw TypeError(".lnrpc.ListInvoiceResponse.invoices: array expected");
                message.invoices = [];
                for (let i = 0; i < object.invoices.length; ++i) {
                    if (typeof object.invoices[i] !== "object")
                        throw TypeError(".lnrpc.ListInvoiceResponse.invoices: object expected");
                    message.invoices[i] = $root.lnrpc.Invoice.fromObject(object.invoices[i]);
                }
            }
            if (object.lastIndexOffset != null)
                if ($util.Long)
                    (message.lastIndexOffset = $util.Long.fromValue(object.lastIndexOffset)).unsigned = true;
                else if (typeof object.lastIndexOffset === "string")
                    message.lastIndexOffset = parseInt(object.lastIndexOffset, 10);
                else if (typeof object.lastIndexOffset === "number")
                    message.lastIndexOffset = object.lastIndexOffset;
                else if (typeof object.lastIndexOffset === "object")
                    message.lastIndexOffset = new $util.LongBits(object.lastIndexOffset.low >>> 0, object.lastIndexOffset.high >>> 0).toNumber(true);
            if (object.firstIndexOffset != null)
                if ($util.Long)
                    (message.firstIndexOffset = $util.Long.fromValue(object.firstIndexOffset)).unsigned = true;
                else if (typeof object.firstIndexOffset === "string")
                    message.firstIndexOffset = parseInt(object.firstIndexOffset, 10);
                else if (typeof object.firstIndexOffset === "number")
                    message.firstIndexOffset = object.firstIndexOffset;
                else if (typeof object.firstIndexOffset === "object")
                    message.firstIndexOffset = new $util.LongBits(object.firstIndexOffset.low >>> 0, object.firstIndexOffset.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ListInvoiceResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListInvoiceResponse
         * @static
         * @param {lnrpc.ListInvoiceResponse} message ListInvoiceResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListInvoiceResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.invoices = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lastIndexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lastIndexOffset = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.firstIndexOffset = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.firstIndexOffset = options.longs === String ? "0" : 0;
            }
            if (message.invoices && message.invoices.length) {
                object.invoices = [];
                for (let j = 0; j < message.invoices.length; ++j)
                    object.invoices[j] = $root.lnrpc.Invoice.toObject(message.invoices[j], options);
            }
            if (message.lastIndexOffset != null && message.hasOwnProperty("lastIndexOffset"))
                if (typeof message.lastIndexOffset === "number")
                    object.lastIndexOffset = options.longs === String ? String(message.lastIndexOffset) : message.lastIndexOffset;
                else
                    object.lastIndexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.lastIndexOffset) : options.longs === Number ? new $util.LongBits(message.lastIndexOffset.low >>> 0, message.lastIndexOffset.high >>> 0).toNumber(true) : message.lastIndexOffset;
            if (message.firstIndexOffset != null && message.hasOwnProperty("firstIndexOffset"))
                if (typeof message.firstIndexOffset === "number")
                    object.firstIndexOffset = options.longs === String ? String(message.firstIndexOffset) : message.firstIndexOffset;
                else
                    object.firstIndexOffset = options.longs === String ? $util.Long.prototype.toString.call(message.firstIndexOffset) : options.longs === Number ? new $util.LongBits(message.firstIndexOffset.low >>> 0, message.firstIndexOffset.high >>> 0).toNumber(true) : message.firstIndexOffset;
            return object;
        };

        /**
         * Converts this ListInvoiceResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListInvoiceResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListInvoiceResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListInvoiceResponse;
    })();

    lnrpc.InvoiceSubscription = (function() {

        /**
         * Properties of an InvoiceSubscription.
         * @memberof lnrpc
         * @interface IInvoiceSubscription
         * @property {number|Long|null} [addIndex] If specified (non-zero), then we'll first start by sending out
         * notifications for all added indexes with an add_index greater than this
         * value. This allows callers to catch up on any events they missed while they
         * weren't connected to the streaming RPC.
         * @property {number|Long|null} [settleIndex] If specified (non-zero), then we'll first start by sending out
         * notifications for all settled indexes with an settle_index greater than
         * this value. This allows callers to catch up on any events they missed while
         * they weren't connected to the streaming RPC.
         */

        /**
         * Constructs a new InvoiceSubscription.
         * @memberof lnrpc
         * @classdesc Represents an InvoiceSubscription.
         * @implements IInvoiceSubscription
         * @constructor
         * @param {lnrpc.IInvoiceSubscription=} [properties] Properties to set
         */
        function InvoiceSubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * If specified (non-zero), then we'll first start by sending out
         * notifications for all added indexes with an add_index greater than this
         * value. This allows callers to catch up on any events they missed while they
         * weren't connected to the streaming RPC.
         * @member {number|Long} addIndex
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         */
        InvoiceSubscription.prototype.addIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * If specified (non-zero), then we'll first start by sending out
         * notifications for all settled indexes with an settle_index greater than
         * this value. This allows callers to catch up on any events they missed while
         * they weren't connected to the streaming RPC.
         * @member {number|Long} settleIndex
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         */
        InvoiceSubscription.prototype.settleIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new InvoiceSubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription=} [properties] Properties to set
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription instance
         */
        InvoiceSubscription.create = function create(properties) {
            return new InvoiceSubscription(properties);
        };

        /**
         * Encodes the specified InvoiceSubscription message. Does not implicitly {@link lnrpc.InvoiceSubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription} message InvoiceSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvoiceSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.addIndex);
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.settleIndex);
            return writer;
        };

        /**
         * Encodes the specified InvoiceSubscription message, length delimited. Does not implicitly {@link lnrpc.InvoiceSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.IInvoiceSubscription} message InvoiceSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InvoiceSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InvoiceSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvoiceSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.InvoiceSubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.addIndex = reader.uint64();
                    break;
                case 2:
                    message.settleIndex = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InvoiceSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InvoiceSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InvoiceSubscription message.
         * @function verify
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InvoiceSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (!$util.isInteger(message.addIndex) && !(message.addIndex && $util.isInteger(message.addIndex.low) && $util.isInteger(message.addIndex.high)))
                    return "addIndex: integer|Long expected";
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (!$util.isInteger(message.settleIndex) && !(message.settleIndex && $util.isInteger(message.settleIndex.low) && $util.isInteger(message.settleIndex.high)))
                    return "settleIndex: integer|Long expected";
            return null;
        };

        /**
         * Creates an InvoiceSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.InvoiceSubscription} InvoiceSubscription
         */
        InvoiceSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.InvoiceSubscription)
                return object;
            let message = new $root.lnrpc.InvoiceSubscription();
            if (object.addIndex != null)
                if ($util.Long)
                    (message.addIndex = $util.Long.fromValue(object.addIndex)).unsigned = true;
                else if (typeof object.addIndex === "string")
                    message.addIndex = parseInt(object.addIndex, 10);
                else if (typeof object.addIndex === "number")
                    message.addIndex = object.addIndex;
                else if (typeof object.addIndex === "object")
                    message.addIndex = new $util.LongBits(object.addIndex.low >>> 0, object.addIndex.high >>> 0).toNumber(true);
            if (object.settleIndex != null)
                if ($util.Long)
                    (message.settleIndex = $util.Long.fromValue(object.settleIndex)).unsigned = true;
                else if (typeof object.settleIndex === "string")
                    message.settleIndex = parseInt(object.settleIndex, 10);
                else if (typeof object.settleIndex === "number")
                    message.settleIndex = object.settleIndex;
                else if (typeof object.settleIndex === "object")
                    message.settleIndex = new $util.LongBits(object.settleIndex.low >>> 0, object.settleIndex.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from an InvoiceSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.InvoiceSubscription
         * @static
         * @param {lnrpc.InvoiceSubscription} message InvoiceSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InvoiceSubscription.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.addIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.addIndex = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.settleIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.settleIndex = options.longs === String ? "0" : 0;
            }
            if (message.addIndex != null && message.hasOwnProperty("addIndex"))
                if (typeof message.addIndex === "number")
                    object.addIndex = options.longs === String ? String(message.addIndex) : message.addIndex;
                else
                    object.addIndex = options.longs === String ? $util.Long.prototype.toString.call(message.addIndex) : options.longs === Number ? new $util.LongBits(message.addIndex.low >>> 0, message.addIndex.high >>> 0).toNumber(true) : message.addIndex;
            if (message.settleIndex != null && message.hasOwnProperty("settleIndex"))
                if (typeof message.settleIndex === "number")
                    object.settleIndex = options.longs === String ? String(message.settleIndex) : message.settleIndex;
                else
                    object.settleIndex = options.longs === String ? $util.Long.prototype.toString.call(message.settleIndex) : options.longs === Number ? new $util.LongBits(message.settleIndex.low >>> 0, message.settleIndex.high >>> 0).toNumber(true) : message.settleIndex;
            return object;
        };

        /**
         * Converts this InvoiceSubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.InvoiceSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InvoiceSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return InvoiceSubscription;
    })();

    lnrpc.Payment = (function() {

        /**
         * Properties of a Payment.
         * @memberof lnrpc
         * @interface IPayment
         * @property {string|null} [paymentHash] The payment hash
         * @property {number|Long|null} [value] Deprecated, use value_sat or value_msat.
         * @property {number|Long|null} [creationDate] The date of this payment
         * @property {Array.<string>|null} [path] The path this payment took
         * @property {number|Long|null} [fee] Deprecated, use fee_sat or fee_msat.
         * @property {string|null} [paymentPreimage] The payment preimage
         * @property {number|Long|null} [valueSat] The value of the payment in satoshis
         * @property {number|Long|null} [valueMsat] The value of the payment in milli-satoshis
         * @property {string|null} [paymentRequest] The optional payment request being fulfilled.
         * @property {lnrpc.Payment.PaymentStatus|null} [status] Payment status
         * @property {number|Long|null} [feeSat] The fee paid for this payment in satoshis
         * @property {number|Long|null} [feeMsat] The fee paid for this payment in milli-satoshis
         */

        /**
         * Constructs a new Payment.
         * @memberof lnrpc
         * @classdesc Represents a Payment.
         * @implements IPayment
         * @constructor
         * @param {lnrpc.IPayment=} [properties] Properties to set
         */
        function Payment(properties) {
            this.path = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The payment hash
         * @member {string} paymentHash
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentHash = "";

        /**
         * Deprecated, use value_sat or value_msat.
         * @member {number|Long} value
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The date of this payment
         * @member {number|Long} creationDate
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.creationDate = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The path this payment took
         * @member {Array.<string>} path
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.path = $util.emptyArray;

        /**
         * Deprecated, use fee_sat or fee_msat.
         * @member {number|Long} fee
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The payment preimage
         * @member {string} paymentPreimage
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentPreimage = "";

        /**
         * The value of the payment in satoshis
         * @member {number|Long} valueSat
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.valueSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The value of the payment in milli-satoshis
         * @member {number|Long} valueMsat
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.valueMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The optional payment request being fulfilled.
         * @member {string} paymentRequest
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.paymentRequest = "";

        /**
         * Payment status.
         * @member {lnrpc.Payment.PaymentStatus} status
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.status = 0;

        /**
         * The fee paid for this payment in satoshis
         * @member {number|Long} feeSat
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.feeSat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The fee paid for this payment in milli-satoshis
         * @member {number|Long} feeMsat
         * @memberof lnrpc.Payment
         * @instance
         */
        Payment.prototype.feeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Payment instance using the specified properties.
         * @function create
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment=} [properties] Properties to set
         * @returns {lnrpc.Payment} Payment instance
         */
        Payment.create = function create(properties) {
            return new Payment(properties);
        };

        /**
         * Encodes the specified Payment message. Does not implicitly {@link lnrpc.Payment.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.paymentHash);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.value);
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.creationDate);
            if (message.path != null && message.path.length)
                for (let i = 0; i < message.path.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.path[i]);
            if (message.fee != null && message.hasOwnProperty("fee"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.fee);
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.paymentPreimage);
            if (message.valueSat != null && message.hasOwnProperty("valueSat"))
                writer.uint32(/* id 7, wireType 0 =*/56).int64(message.valueSat);
            if (message.valueMsat != null && message.hasOwnProperty("valueMsat"))
                writer.uint32(/* id 8, wireType 0 =*/64).int64(message.valueMsat);
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.paymentRequest);
            if (message.status != null && message.hasOwnProperty("status"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.status);
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.feeSat);
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.feeMsat);
            return writer;
        };

        /**
         * Encodes the specified Payment message, length delimited. Does not implicitly {@link lnrpc.Payment.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.IPayment} message Payment message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payment.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payment message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.Payment();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.paymentHash = reader.string();
                    break;
                case 2:
                    message.value = reader.int64();
                    break;
                case 3:
                    message.creationDate = reader.int64();
                    break;
                case 4:
                    if (!(message.path && message.path.length))
                        message.path = [];
                    message.path.push(reader.string());
                    break;
                case 5:
                    message.fee = reader.int64();
                    break;
                case 6:
                    message.paymentPreimage = reader.string();
                    break;
                case 7:
                    message.valueSat = reader.int64();
                    break;
                case 8:
                    message.valueMsat = reader.int64();
                    break;
                case 9:
                    message.paymentRequest = reader.string();
                    break;
                case 10:
                    message.status = reader.int32();
                    break;
                case 11:
                    message.feeSat = reader.int64();
                    break;
                case 12:
                    message.feeMsat = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payment message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.Payment
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.Payment} Payment
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payment.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payment message.
         * @function verify
         * @memberof lnrpc.Payment
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payment.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!$util.isString(message.paymentHash))
                    return "paymentHash: string expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                    return "value: integer|Long expected";
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (!$util.isInteger(message.creationDate) && !(message.creationDate && $util.isInteger(message.creationDate.low) && $util.isInteger(message.creationDate.high)))
                    return "creationDate: integer|Long expected";
            if (message.path != null && message.hasOwnProperty("path")) {
                if (!Array.isArray(message.path))
                    return "path: array expected";
                for (let i = 0; i < message.path.length; ++i)
                    if (!$util.isString(message.path[i]))
                        return "path: string[] expected";
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                if (!$util.isString(message.paymentPreimage))
                    return "paymentPreimage: string expected";
            if (message.valueSat != null && message.hasOwnProperty("valueSat"))
                if (!$util.isInteger(message.valueSat) && !(message.valueSat && $util.isInteger(message.valueSat.low) && $util.isInteger(message.valueSat.high)))
                    return "valueSat: integer|Long expected";
            if (message.valueMsat != null && message.hasOwnProperty("valueMsat"))
                if (!$util.isInteger(message.valueMsat) && !(message.valueMsat && $util.isInteger(message.valueMsat.low) && $util.isInteger(message.valueMsat.high)))
                    return "valueMsat: integer|Long expected";
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                if (!$util.isString(message.paymentRequest))
                    return "paymentRequest: string expected";
            if (message.status != null && message.hasOwnProperty("status"))
                switch (message.status) {
                default:
                    return "status: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                if (!$util.isInteger(message.feeSat) && !(message.feeSat && $util.isInteger(message.feeSat.low) && $util.isInteger(message.feeSat.high)))
                    return "feeSat: integer|Long expected";
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (!$util.isInteger(message.feeMsat) && !(message.feeMsat && $util.isInteger(message.feeMsat.low) && $util.isInteger(message.feeMsat.high)))
                    return "feeMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a Payment message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.Payment
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.Payment} Payment
         */
        Payment.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.Payment)
                return object;
            let message = new $root.lnrpc.Payment();
            if (object.paymentHash != null)
                message.paymentHash = String(object.paymentHash);
            if (object.value != null)
                if ($util.Long)
                    (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                else if (typeof object.value === "string")
                    message.value = parseInt(object.value, 10);
                else if (typeof object.value === "number")
                    message.value = object.value;
                else if (typeof object.value === "object")
                    message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
            if (object.creationDate != null)
                if ($util.Long)
                    (message.creationDate = $util.Long.fromValue(object.creationDate)).unsigned = false;
                else if (typeof object.creationDate === "string")
                    message.creationDate = parseInt(object.creationDate, 10);
                else if (typeof object.creationDate === "number")
                    message.creationDate = object.creationDate;
                else if (typeof object.creationDate === "object")
                    message.creationDate = new $util.LongBits(object.creationDate.low >>> 0, object.creationDate.high >>> 0).toNumber();
            if (object.path) {
                if (!Array.isArray(object.path))
                    throw TypeError(".lnrpc.Payment.path: array expected");
                message.path = [];
                for (let i = 0; i < object.path.length; ++i)
                    message.path[i] = String(object.path[i]);
            }
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = false;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber();
            if (object.paymentPreimage != null)
                message.paymentPreimage = String(object.paymentPreimage);
            if (object.valueSat != null)
                if ($util.Long)
                    (message.valueSat = $util.Long.fromValue(object.valueSat)).unsigned = false;
                else if (typeof object.valueSat === "string")
                    message.valueSat = parseInt(object.valueSat, 10);
                else if (typeof object.valueSat === "number")
                    message.valueSat = object.valueSat;
                else if (typeof object.valueSat === "object")
                    message.valueSat = new $util.LongBits(object.valueSat.low >>> 0, object.valueSat.high >>> 0).toNumber();
            if (object.valueMsat != null)
                if ($util.Long)
                    (message.valueMsat = $util.Long.fromValue(object.valueMsat)).unsigned = false;
                else if (typeof object.valueMsat === "string")
                    message.valueMsat = parseInt(object.valueMsat, 10);
                else if (typeof object.valueMsat === "number")
                    message.valueMsat = object.valueMsat;
                else if (typeof object.valueMsat === "object")
                    message.valueMsat = new $util.LongBits(object.valueMsat.low >>> 0, object.valueMsat.high >>> 0).toNumber();
            if (object.paymentRequest != null)
                message.paymentRequest = String(object.paymentRequest);
            switch (object.status) {
            case "UNKNOWN":
            case 0:
                message.status = 0;
                break;
            case "IN_FLIGHT":
            case 1:
                message.status = 1;
                break;
            case "SUCCEEDED":
            case 2:
                message.status = 2;
                break;
            case "FAILED":
            case 3:
                message.status = 3;
                break;
            }
            if (object.feeSat != null)
                if ($util.Long)
                    (message.feeSat = $util.Long.fromValue(object.feeSat)).unsigned = false;
                else if (typeof object.feeSat === "string")
                    message.feeSat = parseInt(object.feeSat, 10);
                else if (typeof object.feeSat === "number")
                    message.feeSat = object.feeSat;
                else if (typeof object.feeSat === "object")
                    message.feeSat = new $util.LongBits(object.feeSat.low >>> 0, object.feeSat.high >>> 0).toNumber();
            if (object.feeMsat != null)
                if ($util.Long)
                    (message.feeMsat = $util.Long.fromValue(object.feeMsat)).unsigned = false;
                else if (typeof object.feeMsat === "string")
                    message.feeMsat = parseInt(object.feeMsat, 10);
                else if (typeof object.feeMsat === "number")
                    message.feeMsat = object.feeMsat;
                else if (typeof object.feeMsat === "object")
                    message.feeMsat = new $util.LongBits(object.feeMsat.low >>> 0, object.feeMsat.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a Payment message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.Payment
         * @static
         * @param {lnrpc.Payment} message Payment
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payment.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.path = [];
            if (options.defaults) {
                object.paymentHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.value = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.creationDate = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.creationDate = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                object.paymentPreimage = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.valueSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.valueSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.valueMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.valueMsat = options.longs === String ? "0" : 0;
                object.paymentRequest = "";
                object.status = options.enums === String ? "UNKNOWN" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeSat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeSat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeMsat = options.longs === String ? "0" : 0;
            }
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = message.paymentHash;
            if (message.value != null && message.hasOwnProperty("value"))
                if (typeof message.value === "number")
                    object.value = options.longs === String ? String(message.value) : message.value;
                else
                    object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
            if (message.creationDate != null && message.hasOwnProperty("creationDate"))
                if (typeof message.creationDate === "number")
                    object.creationDate = options.longs === String ? String(message.creationDate) : message.creationDate;
                else
                    object.creationDate = options.longs === String ? $util.Long.prototype.toString.call(message.creationDate) : options.longs === Number ? new $util.LongBits(message.creationDate.low >>> 0, message.creationDate.high >>> 0).toNumber() : message.creationDate;
            if (message.path && message.path.length) {
                object.path = [];
                for (let j = 0; j < message.path.length; ++j)
                    object.path[j] = message.path[j];
            }
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber() : message.fee;
            if (message.paymentPreimage != null && message.hasOwnProperty("paymentPreimage"))
                object.paymentPreimage = message.paymentPreimage;
            if (message.valueSat != null && message.hasOwnProperty("valueSat"))
                if (typeof message.valueSat === "number")
                    object.valueSat = options.longs === String ? String(message.valueSat) : message.valueSat;
                else
                    object.valueSat = options.longs === String ? $util.Long.prototype.toString.call(message.valueSat) : options.longs === Number ? new $util.LongBits(message.valueSat.low >>> 0, message.valueSat.high >>> 0).toNumber() : message.valueSat;
            if (message.valueMsat != null && message.hasOwnProperty("valueMsat"))
                if (typeof message.valueMsat === "number")
                    object.valueMsat = options.longs === String ? String(message.valueMsat) : message.valueMsat;
                else
                    object.valueMsat = options.longs === String ? $util.Long.prototype.toString.call(message.valueMsat) : options.longs === Number ? new $util.LongBits(message.valueMsat.low >>> 0, message.valueMsat.high >>> 0).toNumber() : message.valueMsat;
            if (message.paymentRequest != null && message.hasOwnProperty("paymentRequest"))
                object.paymentRequest = message.paymentRequest;
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = options.enums === String ? $root.lnrpc.Payment.PaymentStatus[message.status] : message.status;
            if (message.feeSat != null && message.hasOwnProperty("feeSat"))
                if (typeof message.feeSat === "number")
                    object.feeSat = options.longs === String ? String(message.feeSat) : message.feeSat;
                else
                    object.feeSat = options.longs === String ? $util.Long.prototype.toString.call(message.feeSat) : options.longs === Number ? new $util.LongBits(message.feeSat.low >>> 0, message.feeSat.high >>> 0).toNumber() : message.feeSat;
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (typeof message.feeMsat === "number")
                    object.feeMsat = options.longs === String ? String(message.feeMsat) : message.feeMsat;
                else
                    object.feeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeMsat) : options.longs === Number ? new $util.LongBits(message.feeMsat.low >>> 0, message.feeMsat.high >>> 0).toNumber() : message.feeMsat;
            return object;
        };

        /**
         * Converts this Payment to JSON.
         * @function toJSON
         * @memberof lnrpc.Payment
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payment.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * PaymentStatus enum.
         * @name lnrpc.Payment.PaymentStatus
         * @enum {string}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} IN_FLIGHT=1 IN_FLIGHT value
         * @property {number} SUCCEEDED=2 SUCCEEDED value
         * @property {number} FAILED=3 FAILED value
         */
        Payment.PaymentStatus = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "IN_FLIGHT"] = 1;
            values[valuesById[2] = "SUCCEEDED"] = 2;
            values[valuesById[3] = "FAILED"] = 3;
            return values;
        })();

        return Payment;
    })();

    lnrpc.ListPaymentsRequest = (function() {

        /**
         * Properties of a ListPaymentsRequest.
         * @memberof lnrpc
         * @interface IListPaymentsRequest
         * @property {boolean|null} [includeIncomplete] If true, then return payments that have not yet fully completed. This means
         * that pending payments, as well as failed payments will show up if this
         * field is set to True.
         */

        /**
         * Constructs a new ListPaymentsRequest.
         * @memberof lnrpc
         * @classdesc Represents a ListPaymentsRequest.
         * @implements IListPaymentsRequest
         * @constructor
         * @param {lnrpc.IListPaymentsRequest=} [properties] Properties to set
         */
        function ListPaymentsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * If true, then return payments that have not yet fully completed. This means
         * that pending payments, as well as failed payments will show up if this
         * field is set to True.
         * @member {boolean} includeIncomplete
         * @memberof lnrpc.ListPaymentsRequest
         * @instance
         */
        ListPaymentsRequest.prototype.includeIncomplete = false;

        /**
         * Creates a new ListPaymentsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest=} [properties] Properties to set
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest instance
         */
        ListPaymentsRequest.create = function create(properties) {
            return new ListPaymentsRequest(properties);
        };

        /**
         * Encodes the specified ListPaymentsRequest message. Does not implicitly {@link lnrpc.ListPaymentsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest} message ListPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.includeIncomplete != null && message.hasOwnProperty("includeIncomplete"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.includeIncomplete);
            return writer;
        };

        /**
         * Encodes the specified ListPaymentsRequest message, length delimited. Does not implicitly {@link lnrpc.ListPaymentsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.IListPaymentsRequest} message ListPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPaymentsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPaymentsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.includeIncomplete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPaymentsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPaymentsRequest message.
         * @function verify
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPaymentsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.includeIncomplete != null && message.hasOwnProperty("includeIncomplete"))
                if (typeof message.includeIncomplete !== "boolean")
                    return "includeIncomplete: boolean expected";
            return null;
        };

        /**
         * Creates a ListPaymentsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPaymentsRequest} ListPaymentsRequest
         */
        ListPaymentsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPaymentsRequest)
                return object;
            let message = new $root.lnrpc.ListPaymentsRequest();
            if (object.includeIncomplete != null)
                message.includeIncomplete = Boolean(object.includeIncomplete);
            return message;
        };

        /**
         * Creates a plain object from a ListPaymentsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPaymentsRequest
         * @static
         * @param {lnrpc.ListPaymentsRequest} message ListPaymentsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPaymentsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.includeIncomplete = false;
            if (message.includeIncomplete != null && message.hasOwnProperty("includeIncomplete"))
                object.includeIncomplete = message.includeIncomplete;
            return object;
        };

        /**
         * Converts this ListPaymentsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPaymentsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPaymentsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPaymentsRequest;
    })();

    lnrpc.ListPaymentsResponse = (function() {

        /**
         * Properties of a ListPaymentsResponse.
         * @memberof lnrpc
         * @interface IListPaymentsResponse
         * @property {Array.<lnrpc.IPayment>|null} [payments] The list of payments
         */

        /**
         * Constructs a new ListPaymentsResponse.
         * @memberof lnrpc
         * @classdesc Represents a ListPaymentsResponse.
         * @implements IListPaymentsResponse
         * @constructor
         * @param {lnrpc.IListPaymentsResponse=} [properties] Properties to set
         */
        function ListPaymentsResponse(properties) {
            this.payments = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The list of payments
         * @member {Array.<lnrpc.IPayment>} payments
         * @memberof lnrpc.ListPaymentsResponse
         * @instance
         */
        ListPaymentsResponse.prototype.payments = $util.emptyArray;

        /**
         * Creates a new ListPaymentsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse=} [properties] Properties to set
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse instance
         */
        ListPaymentsResponse.create = function create(properties) {
            return new ListPaymentsResponse(properties);
        };

        /**
         * Encodes the specified ListPaymentsResponse message. Does not implicitly {@link lnrpc.ListPaymentsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse} message ListPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payments != null && message.payments.length)
                for (let i = 0; i < message.payments.length; ++i)
                    $root.lnrpc.Payment.encode(message.payments[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ListPaymentsResponse message, length delimited. Does not implicitly {@link lnrpc.ListPaymentsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.IListPaymentsResponse} message ListPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ListPaymentsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ListPaymentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ListPaymentsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.payments && message.payments.length))
                        message.payments = [];
                    message.payments.push($root.lnrpc.Payment.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ListPaymentsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ListPaymentsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ListPaymentsResponse message.
         * @function verify
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ListPaymentsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payments != null && message.hasOwnProperty("payments")) {
                if (!Array.isArray(message.payments))
                    return "payments: array expected";
                for (let i = 0; i < message.payments.length; ++i) {
                    let error = $root.lnrpc.Payment.verify(message.payments[i]);
                    if (error)
                        return "payments." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ListPaymentsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ListPaymentsResponse} ListPaymentsResponse
         */
        ListPaymentsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ListPaymentsResponse)
                return object;
            let message = new $root.lnrpc.ListPaymentsResponse();
            if (object.payments) {
                if (!Array.isArray(object.payments))
                    throw TypeError(".lnrpc.ListPaymentsResponse.payments: array expected");
                message.payments = [];
                for (let i = 0; i < object.payments.length; ++i) {
                    if (typeof object.payments[i] !== "object")
                        throw TypeError(".lnrpc.ListPaymentsResponse.payments: object expected");
                    message.payments[i] = $root.lnrpc.Payment.fromObject(object.payments[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ListPaymentsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ListPaymentsResponse
         * @static
         * @param {lnrpc.ListPaymentsResponse} message ListPaymentsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ListPaymentsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.payments = [];
            if (message.payments && message.payments.length) {
                object.payments = [];
                for (let j = 0; j < message.payments.length; ++j)
                    object.payments[j] = $root.lnrpc.Payment.toObject(message.payments[j], options);
            }
            return object;
        };

        /**
         * Converts this ListPaymentsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ListPaymentsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ListPaymentsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ListPaymentsResponse;
    })();

    lnrpc.DeleteAllPaymentsRequest = (function() {

        /**
         * Properties of a DeleteAllPaymentsRequest.
         * @memberof lnrpc
         * @interface IDeleteAllPaymentsRequest
         */

        /**
         * Constructs a new DeleteAllPaymentsRequest.
         * @memberof lnrpc
         * @classdesc Represents a DeleteAllPaymentsRequest.
         * @implements IDeleteAllPaymentsRequest
         * @constructor
         * @param {lnrpc.IDeleteAllPaymentsRequest=} [properties] Properties to set
         */
        function DeleteAllPaymentsRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteAllPaymentsRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest=} [properties] Properties to set
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest instance
         */
        DeleteAllPaymentsRequest.create = function create(properties) {
            return new DeleteAllPaymentsRequest(properties);
        };

        /**
         * Encodes the specified DeleteAllPaymentsRequest message. Does not implicitly {@link lnrpc.DeleteAllPaymentsRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest} message DeleteAllPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteAllPaymentsRequest message, length delimited. Does not implicitly {@link lnrpc.DeleteAllPaymentsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.IDeleteAllPaymentsRequest} message DeleteAllPaymentsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAllPaymentsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DeleteAllPaymentsRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAllPaymentsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAllPaymentsRequest message.
         * @function verify
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAllPaymentsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteAllPaymentsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DeleteAllPaymentsRequest} DeleteAllPaymentsRequest
         */
        DeleteAllPaymentsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DeleteAllPaymentsRequest)
                return object;
            return new $root.lnrpc.DeleteAllPaymentsRequest();
        };

        /**
         * Creates a plain object from a DeleteAllPaymentsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @static
         * @param {lnrpc.DeleteAllPaymentsRequest} message DeleteAllPaymentsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAllPaymentsRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteAllPaymentsRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DeleteAllPaymentsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAllPaymentsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteAllPaymentsRequest;
    })();

    lnrpc.DeleteAllPaymentsResponse = (function() {

        /**
         * Properties of a DeleteAllPaymentsResponse.
         * @memberof lnrpc
         * @interface IDeleteAllPaymentsResponse
         */

        /**
         * Constructs a new DeleteAllPaymentsResponse.
         * @memberof lnrpc
         * @classdesc Represents a DeleteAllPaymentsResponse.
         * @implements IDeleteAllPaymentsResponse
         * @constructor
         * @param {lnrpc.IDeleteAllPaymentsResponse=} [properties] Properties to set
         */
        function DeleteAllPaymentsResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new DeleteAllPaymentsResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse=} [properties] Properties to set
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse instance
         */
        DeleteAllPaymentsResponse.create = function create(properties) {
            return new DeleteAllPaymentsResponse(properties);
        };

        /**
         * Encodes the specified DeleteAllPaymentsResponse message. Does not implicitly {@link lnrpc.DeleteAllPaymentsResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse} message DeleteAllPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified DeleteAllPaymentsResponse message, length delimited. Does not implicitly {@link lnrpc.DeleteAllPaymentsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.IDeleteAllPaymentsResponse} message DeleteAllPaymentsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteAllPaymentsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteAllPaymentsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DeleteAllPaymentsResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteAllPaymentsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteAllPaymentsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteAllPaymentsResponse message.
         * @function verify
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteAllPaymentsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a DeleteAllPaymentsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DeleteAllPaymentsResponse} DeleteAllPaymentsResponse
         */
        DeleteAllPaymentsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DeleteAllPaymentsResponse)
                return object;
            return new $root.lnrpc.DeleteAllPaymentsResponse();
        };

        /**
         * Creates a plain object from a DeleteAllPaymentsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @static
         * @param {lnrpc.DeleteAllPaymentsResponse} message DeleteAllPaymentsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeleteAllPaymentsResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this DeleteAllPaymentsResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DeleteAllPaymentsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeleteAllPaymentsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DeleteAllPaymentsResponse;
    })();

    lnrpc.AbandonChannelRequest = (function() {

        /**
         * Properties of an AbandonChannelRequest.
         * @memberof lnrpc
         * @interface IAbandonChannelRequest
         * @property {lnrpc.IChannelPoint|null} [channelPoint] AbandonChannelRequest channelPoint
         */

        /**
         * Constructs a new AbandonChannelRequest.
         * @memberof lnrpc
         * @classdesc Represents an AbandonChannelRequest.
         * @implements IAbandonChannelRequest
         * @constructor
         * @param {lnrpc.IAbandonChannelRequest=} [properties] Properties to set
         */
        function AbandonChannelRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AbandonChannelRequest channelPoint.
         * @member {lnrpc.IChannelPoint|null|undefined} channelPoint
         * @memberof lnrpc.AbandonChannelRequest
         * @instance
         */
        AbandonChannelRequest.prototype.channelPoint = null;

        /**
         * Creates a new AbandonChannelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {lnrpc.IAbandonChannelRequest=} [properties] Properties to set
         * @returns {lnrpc.AbandonChannelRequest} AbandonChannelRequest instance
         */
        AbandonChannelRequest.create = function create(properties) {
            return new AbandonChannelRequest(properties);
        };

        /**
         * Encodes the specified AbandonChannelRequest message. Does not implicitly {@link lnrpc.AbandonChannelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {lnrpc.IAbandonChannelRequest} message AbandonChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbandonChannelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                $root.lnrpc.ChannelPoint.encode(message.channelPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AbandonChannelRequest message, length delimited. Does not implicitly {@link lnrpc.AbandonChannelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {lnrpc.IAbandonChannelRequest} message AbandonChannelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbandonChannelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AbandonChannelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.AbandonChannelRequest} AbandonChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbandonChannelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.AbandonChannelRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.channelPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AbandonChannelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.AbandonChannelRequest} AbandonChannelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbandonChannelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AbandonChannelRequest message.
         * @function verify
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AbandonChannelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.channelPoint);
                if (error)
                    return "channelPoint." + error;
            }
            return null;
        };

        /**
         * Creates an AbandonChannelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.AbandonChannelRequest} AbandonChannelRequest
         */
        AbandonChannelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.AbandonChannelRequest)
                return object;
            let message = new $root.lnrpc.AbandonChannelRequest();
            if (object.channelPoint != null) {
                if (typeof object.channelPoint !== "object")
                    throw TypeError(".lnrpc.AbandonChannelRequest.channelPoint: object expected");
                message.channelPoint = $root.lnrpc.ChannelPoint.fromObject(object.channelPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from an AbandonChannelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.AbandonChannelRequest
         * @static
         * @param {lnrpc.AbandonChannelRequest} message AbandonChannelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AbandonChannelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.channelPoint = null;
            if (message.channelPoint != null && message.hasOwnProperty("channelPoint"))
                object.channelPoint = $root.lnrpc.ChannelPoint.toObject(message.channelPoint, options);
            return object;
        };

        /**
         * Converts this AbandonChannelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.AbandonChannelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AbandonChannelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AbandonChannelRequest;
    })();

    lnrpc.AbandonChannelResponse = (function() {

        /**
         * Properties of an AbandonChannelResponse.
         * @memberof lnrpc
         * @interface IAbandonChannelResponse
         */

        /**
         * Constructs a new AbandonChannelResponse.
         * @memberof lnrpc
         * @classdesc Represents an AbandonChannelResponse.
         * @implements IAbandonChannelResponse
         * @constructor
         * @param {lnrpc.IAbandonChannelResponse=} [properties] Properties to set
         */
        function AbandonChannelResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AbandonChannelResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {lnrpc.IAbandonChannelResponse=} [properties] Properties to set
         * @returns {lnrpc.AbandonChannelResponse} AbandonChannelResponse instance
         */
        AbandonChannelResponse.create = function create(properties) {
            return new AbandonChannelResponse(properties);
        };

        /**
         * Encodes the specified AbandonChannelResponse message. Does not implicitly {@link lnrpc.AbandonChannelResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {lnrpc.IAbandonChannelResponse} message AbandonChannelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbandonChannelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AbandonChannelResponse message, length delimited. Does not implicitly {@link lnrpc.AbandonChannelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {lnrpc.IAbandonChannelResponse} message AbandonChannelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AbandonChannelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AbandonChannelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.AbandonChannelResponse} AbandonChannelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbandonChannelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.AbandonChannelResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AbandonChannelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.AbandonChannelResponse} AbandonChannelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AbandonChannelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AbandonChannelResponse message.
         * @function verify
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AbandonChannelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates an AbandonChannelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.AbandonChannelResponse} AbandonChannelResponse
         */
        AbandonChannelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.AbandonChannelResponse)
                return object;
            return new $root.lnrpc.AbandonChannelResponse();
        };

        /**
         * Creates a plain object from an AbandonChannelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.AbandonChannelResponse
         * @static
         * @param {lnrpc.AbandonChannelResponse} message AbandonChannelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AbandonChannelResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this AbandonChannelResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.AbandonChannelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AbandonChannelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AbandonChannelResponse;
    })();

    lnrpc.DebugLevelRequest = (function() {

        /**
         * Properties of a DebugLevelRequest.
         * @memberof lnrpc
         * @interface IDebugLevelRequest
         * @property {boolean|null} [show] DebugLevelRequest show
         * @property {string|null} [levelSpec] DebugLevelRequest levelSpec
         */

        /**
         * Constructs a new DebugLevelRequest.
         * @memberof lnrpc
         * @classdesc Represents a DebugLevelRequest.
         * @implements IDebugLevelRequest
         * @constructor
         * @param {lnrpc.IDebugLevelRequest=} [properties] Properties to set
         */
        function DebugLevelRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebugLevelRequest show.
         * @member {boolean} show
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         */
        DebugLevelRequest.prototype.show = false;

        /**
         * DebugLevelRequest levelSpec.
         * @member {string} levelSpec
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         */
        DebugLevelRequest.prototype.levelSpec = "";

        /**
         * Creates a new DebugLevelRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest=} [properties] Properties to set
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest instance
         */
        DebugLevelRequest.create = function create(properties) {
            return new DebugLevelRequest(properties);
        };

        /**
         * Encodes the specified DebugLevelRequest message. Does not implicitly {@link lnrpc.DebugLevelRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest} message DebugLevelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.show != null && message.hasOwnProperty("show"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.show);
            if (message.levelSpec != null && message.hasOwnProperty("levelSpec"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.levelSpec);
            return writer;
        };

        /**
         * Encodes the specified DebugLevelRequest message, length delimited. Does not implicitly {@link lnrpc.DebugLevelRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.IDebugLevelRequest} message DebugLevelRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebugLevelRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DebugLevelRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.show = reader.bool();
                    break;
                case 2:
                    message.levelSpec = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DebugLevelRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebugLevelRequest message.
         * @function verify
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugLevelRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.show != null && message.hasOwnProperty("show"))
                if (typeof message.show !== "boolean")
                    return "show: boolean expected";
            if (message.levelSpec != null && message.hasOwnProperty("levelSpec"))
                if (!$util.isString(message.levelSpec))
                    return "levelSpec: string expected";
            return null;
        };

        /**
         * Creates a DebugLevelRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DebugLevelRequest} DebugLevelRequest
         */
        DebugLevelRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DebugLevelRequest)
                return object;
            let message = new $root.lnrpc.DebugLevelRequest();
            if (object.show != null)
                message.show = Boolean(object.show);
            if (object.levelSpec != null)
                message.levelSpec = String(object.levelSpec);
            return message;
        };

        /**
         * Creates a plain object from a DebugLevelRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DebugLevelRequest
         * @static
         * @param {lnrpc.DebugLevelRequest} message DebugLevelRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugLevelRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.show = false;
                object.levelSpec = "";
            }
            if (message.show != null && message.hasOwnProperty("show"))
                object.show = message.show;
            if (message.levelSpec != null && message.hasOwnProperty("levelSpec"))
                object.levelSpec = message.levelSpec;
            return object;
        };

        /**
         * Converts this DebugLevelRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.DebugLevelRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugLevelRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DebugLevelRequest;
    })();

    lnrpc.DebugLevelResponse = (function() {

        /**
         * Properties of a DebugLevelResponse.
         * @memberof lnrpc
         * @interface IDebugLevelResponse
         * @property {string|null} [subSystems] DebugLevelResponse subSystems
         */

        /**
         * Constructs a new DebugLevelResponse.
         * @memberof lnrpc
         * @classdesc Represents a DebugLevelResponse.
         * @implements IDebugLevelResponse
         * @constructor
         * @param {lnrpc.IDebugLevelResponse=} [properties] Properties to set
         */
        function DebugLevelResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DebugLevelResponse subSystems.
         * @member {string} subSystems
         * @memberof lnrpc.DebugLevelResponse
         * @instance
         */
        DebugLevelResponse.prototype.subSystems = "";

        /**
         * Creates a new DebugLevelResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse=} [properties] Properties to set
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse instance
         */
        DebugLevelResponse.create = function create(properties) {
            return new DebugLevelResponse(properties);
        };

        /**
         * Encodes the specified DebugLevelResponse message. Does not implicitly {@link lnrpc.DebugLevelResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse} message DebugLevelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.subSystems != null && message.hasOwnProperty("subSystems"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.subSystems);
            return writer;
        };

        /**
         * Encodes the specified DebugLevelResponse message, length delimited. Does not implicitly {@link lnrpc.DebugLevelResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.IDebugLevelResponse} message DebugLevelResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DebugLevelResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DebugLevelResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.DebugLevelResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.subSystems = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DebugLevelResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DebugLevelResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DebugLevelResponse message.
         * @function verify
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DebugLevelResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.subSystems != null && message.hasOwnProperty("subSystems"))
                if (!$util.isString(message.subSystems))
                    return "subSystems: string expected";
            return null;
        };

        /**
         * Creates a DebugLevelResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.DebugLevelResponse} DebugLevelResponse
         */
        DebugLevelResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.DebugLevelResponse)
                return object;
            let message = new $root.lnrpc.DebugLevelResponse();
            if (object.subSystems != null)
                message.subSystems = String(object.subSystems);
            return message;
        };

        /**
         * Creates a plain object from a DebugLevelResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.DebugLevelResponse
         * @static
         * @param {lnrpc.DebugLevelResponse} message DebugLevelResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DebugLevelResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.subSystems = "";
            if (message.subSystems != null && message.hasOwnProperty("subSystems"))
                object.subSystems = message.subSystems;
            return object;
        };

        /**
         * Converts this DebugLevelResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.DebugLevelResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DebugLevelResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DebugLevelResponse;
    })();

    lnrpc.PayReqString = (function() {

        /**
         * Properties of a PayReqString.
         * @memberof lnrpc
         * @interface IPayReqString
         * @property {string|null} [payReq] The payment request string to be decoded
         */

        /**
         * Constructs a new PayReqString.
         * @memberof lnrpc
         * @classdesc Represents a PayReqString.
         * @implements IPayReqString
         * @constructor
         * @param {lnrpc.IPayReqString=} [properties] Properties to set
         */
        function PayReqString(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The payment request string to be decoded
         * @member {string} payReq
         * @memberof lnrpc.PayReqString
         * @instance
         */
        PayReqString.prototype.payReq = "";

        /**
         * Creates a new PayReqString instance using the specified properties.
         * @function create
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString=} [properties] Properties to set
         * @returns {lnrpc.PayReqString} PayReqString instance
         */
        PayReqString.create = function create(properties) {
            return new PayReqString(properties);
        };

        /**
         * Encodes the specified PayReqString message. Does not implicitly {@link lnrpc.PayReqString.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString} message PayReqString message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReqString.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payReq != null && message.hasOwnProperty("payReq"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.payReq);
            return writer;
        };

        /**
         * Encodes the specified PayReqString message, length delimited. Does not implicitly {@link lnrpc.PayReqString.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.IPayReqString} message PayReqString message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReqString.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayReqString message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PayReqString
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PayReqString} PayReqString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReqString.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PayReqString();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.payReq = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayReqString message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PayReqString
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PayReqString} PayReqString
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReqString.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayReqString message.
         * @function verify
         * @memberof lnrpc.PayReqString
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayReqString.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payReq != null && message.hasOwnProperty("payReq"))
                if (!$util.isString(message.payReq))
                    return "payReq: string expected";
            return null;
        };

        /**
         * Creates a PayReqString message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PayReqString
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PayReqString} PayReqString
         */
        PayReqString.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PayReqString)
                return object;
            let message = new $root.lnrpc.PayReqString();
            if (object.payReq != null)
                message.payReq = String(object.payReq);
            return message;
        };

        /**
         * Creates a plain object from a PayReqString message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PayReqString
         * @static
         * @param {lnrpc.PayReqString} message PayReqString
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayReqString.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.payReq = "";
            if (message.payReq != null && message.hasOwnProperty("payReq"))
                object.payReq = message.payReq;
            return object;
        };

        /**
         * Converts this PayReqString to JSON.
         * @function toJSON
         * @memberof lnrpc.PayReqString
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayReqString.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayReqString;
    })();

    lnrpc.PayReq = (function() {

        /**
         * Properties of a PayReq.
         * @memberof lnrpc
         * @interface IPayReq
         * @property {string|null} [destination] PayReq destination
         * @property {string|null} [paymentHash] PayReq paymentHash
         * @property {number|Long|null} [numSatoshis] PayReq numSatoshis
         * @property {number|Long|null} [timestamp] PayReq timestamp
         * @property {number|Long|null} [expiry] PayReq expiry
         * @property {string|null} [description] PayReq description
         * @property {string|null} [descriptionHash] PayReq descriptionHash
         * @property {string|null} [fallbackAddr] PayReq fallbackAddr
         * @property {number|Long|null} [cltvExpiry] PayReq cltvExpiry
         * @property {Array.<lnrpc.IRouteHint>|null} [routeHints] PayReq routeHints
         */

        /**
         * Constructs a new PayReq.
         * @memberof lnrpc
         * @classdesc Represents a PayReq.
         * @implements IPayReq
         * @constructor
         * @param {lnrpc.IPayReq=} [properties] Properties to set
         */
        function PayReq(properties) {
            this.routeHints = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PayReq destination.
         * @member {string} destination
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.destination = "";

        /**
         * PayReq paymentHash.
         * @member {string} paymentHash
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.paymentHash = "";

        /**
         * PayReq numSatoshis.
         * @member {number|Long} numSatoshis
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.numSatoshis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq timestamp.
         * @member {number|Long} timestamp
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq expiry.
         * @member {number|Long} expiry
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.expiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq description.
         * @member {string} description
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.description = "";

        /**
         * PayReq descriptionHash.
         * @member {string} descriptionHash
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.descriptionHash = "";

        /**
         * PayReq fallbackAddr.
         * @member {string} fallbackAddr
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.fallbackAddr = "";

        /**
         * PayReq cltvExpiry.
         * @member {number|Long} cltvExpiry
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.cltvExpiry = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PayReq routeHints.
         * @member {Array.<lnrpc.IRouteHint>} routeHints
         * @memberof lnrpc.PayReq
         * @instance
         */
        PayReq.prototype.routeHints = $util.emptyArray;

        /**
         * Creates a new PayReq instance using the specified properties.
         * @function create
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq=} [properties] Properties to set
         * @returns {lnrpc.PayReq} PayReq instance
         */
        PayReq.create = function create(properties) {
            return new PayReq(properties);
        };

        /**
         * Encodes the specified PayReq message. Does not implicitly {@link lnrpc.PayReq.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq} message PayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.destination != null && message.hasOwnProperty("destination"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.destination);
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.paymentHash);
            if (message.numSatoshis != null && message.hasOwnProperty("numSatoshis"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.numSatoshis);
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.timestamp);
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                writer.uint32(/* id 5, wireType 0 =*/40).int64(message.expiry);
            if (message.description != null && message.hasOwnProperty("description"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.description);
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.descriptionHash);
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.fallbackAddr);
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                writer.uint32(/* id 9, wireType 0 =*/72).int64(message.cltvExpiry);
            if (message.routeHints != null && message.routeHints.length)
                for (let i = 0; i < message.routeHints.length; ++i)
                    $root.lnrpc.RouteHint.encode(message.routeHints[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PayReq message, length delimited. Does not implicitly {@link lnrpc.PayReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.IPayReq} message PayReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PayReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PayReq message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PayReq} PayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PayReq();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.destination = reader.string();
                    break;
                case 2:
                    message.paymentHash = reader.string();
                    break;
                case 3:
                    message.numSatoshis = reader.int64();
                    break;
                case 4:
                    message.timestamp = reader.int64();
                    break;
                case 5:
                    message.expiry = reader.int64();
                    break;
                case 6:
                    message.description = reader.string();
                    break;
                case 7:
                    message.descriptionHash = reader.string();
                    break;
                case 8:
                    message.fallbackAddr = reader.string();
                    break;
                case 9:
                    message.cltvExpiry = reader.int64();
                    break;
                case 10:
                    if (!(message.routeHints && message.routeHints.length))
                        message.routeHints = [];
                    message.routeHints.push($root.lnrpc.RouteHint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PayReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PayReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PayReq} PayReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PayReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PayReq message.
         * @function verify
         * @memberof lnrpc.PayReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PayReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.destination != null && message.hasOwnProperty("destination"))
                if (!$util.isString(message.destination))
                    return "destination: string expected";
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                if (!$util.isString(message.paymentHash))
                    return "paymentHash: string expected";
            if (message.numSatoshis != null && message.hasOwnProperty("numSatoshis"))
                if (!$util.isInteger(message.numSatoshis) && !(message.numSatoshis && $util.isInteger(message.numSatoshis.low) && $util.isInteger(message.numSatoshis.high)))
                    return "numSatoshis: integer|Long expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (!$util.isInteger(message.expiry) && !(message.expiry && $util.isInteger(message.expiry.low) && $util.isInteger(message.expiry.high)))
                    return "expiry: integer|Long expected";
            if (message.description != null && message.hasOwnProperty("description"))
                if (!$util.isString(message.description))
                    return "description: string expected";
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                if (!$util.isString(message.descriptionHash))
                    return "descriptionHash: string expected";
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                if (!$util.isString(message.fallbackAddr))
                    return "fallbackAddr: string expected";
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (!$util.isInteger(message.cltvExpiry) && !(message.cltvExpiry && $util.isInteger(message.cltvExpiry.low) && $util.isInteger(message.cltvExpiry.high)))
                    return "cltvExpiry: integer|Long expected";
            if (message.routeHints != null && message.hasOwnProperty("routeHints")) {
                if (!Array.isArray(message.routeHints))
                    return "routeHints: array expected";
                for (let i = 0; i < message.routeHints.length; ++i) {
                    let error = $root.lnrpc.RouteHint.verify(message.routeHints[i]);
                    if (error)
                        return "routeHints." + error;
                }
            }
            return null;
        };

        /**
         * Creates a PayReq message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PayReq
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PayReq} PayReq
         */
        PayReq.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PayReq)
                return object;
            let message = new $root.lnrpc.PayReq();
            if (object.destination != null)
                message.destination = String(object.destination);
            if (object.paymentHash != null)
                message.paymentHash = String(object.paymentHash);
            if (object.numSatoshis != null)
                if ($util.Long)
                    (message.numSatoshis = $util.Long.fromValue(object.numSatoshis)).unsigned = false;
                else if (typeof object.numSatoshis === "string")
                    message.numSatoshis = parseInt(object.numSatoshis, 10);
                else if (typeof object.numSatoshis === "number")
                    message.numSatoshis = object.numSatoshis;
                else if (typeof object.numSatoshis === "object")
                    message.numSatoshis = new $util.LongBits(object.numSatoshis.low >>> 0, object.numSatoshis.high >>> 0).toNumber();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
            if (object.expiry != null)
                if ($util.Long)
                    (message.expiry = $util.Long.fromValue(object.expiry)).unsigned = false;
                else if (typeof object.expiry === "string")
                    message.expiry = parseInt(object.expiry, 10);
                else if (typeof object.expiry === "number")
                    message.expiry = object.expiry;
                else if (typeof object.expiry === "object")
                    message.expiry = new $util.LongBits(object.expiry.low >>> 0, object.expiry.high >>> 0).toNumber();
            if (object.description != null)
                message.description = String(object.description);
            if (object.descriptionHash != null)
                message.descriptionHash = String(object.descriptionHash);
            if (object.fallbackAddr != null)
                message.fallbackAddr = String(object.fallbackAddr);
            if (object.cltvExpiry != null)
                if ($util.Long)
                    (message.cltvExpiry = $util.Long.fromValue(object.cltvExpiry)).unsigned = false;
                else if (typeof object.cltvExpiry === "string")
                    message.cltvExpiry = parseInt(object.cltvExpiry, 10);
                else if (typeof object.cltvExpiry === "number")
                    message.cltvExpiry = object.cltvExpiry;
                else if (typeof object.cltvExpiry === "object")
                    message.cltvExpiry = new $util.LongBits(object.cltvExpiry.low >>> 0, object.cltvExpiry.high >>> 0).toNumber();
            if (object.routeHints) {
                if (!Array.isArray(object.routeHints))
                    throw TypeError(".lnrpc.PayReq.routeHints: array expected");
                message.routeHints = [];
                for (let i = 0; i < object.routeHints.length; ++i) {
                    if (typeof object.routeHints[i] !== "object")
                        throw TypeError(".lnrpc.PayReq.routeHints: object expected");
                    message.routeHints[i] = $root.lnrpc.RouteHint.fromObject(object.routeHints[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a PayReq message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PayReq
         * @static
         * @param {lnrpc.PayReq} message PayReq
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PayReq.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.routeHints = [];
            if (options.defaults) {
                object.destination = "";
                object.paymentHash = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.numSatoshis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.numSatoshis = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.expiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.expiry = options.longs === String ? "0" : 0;
                object.description = "";
                object.descriptionHash = "";
                object.fallbackAddr = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.cltvExpiry = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.cltvExpiry = options.longs === String ? "0" : 0;
            }
            if (message.destination != null && message.hasOwnProperty("destination"))
                object.destination = message.destination;
            if (message.paymentHash != null && message.hasOwnProperty("paymentHash"))
                object.paymentHash = message.paymentHash;
            if (message.numSatoshis != null && message.hasOwnProperty("numSatoshis"))
                if (typeof message.numSatoshis === "number")
                    object.numSatoshis = options.longs === String ? String(message.numSatoshis) : message.numSatoshis;
                else
                    object.numSatoshis = options.longs === String ? $util.Long.prototype.toString.call(message.numSatoshis) : options.longs === Number ? new $util.LongBits(message.numSatoshis.low >>> 0, message.numSatoshis.high >>> 0).toNumber() : message.numSatoshis;
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
            if (message.expiry != null && message.hasOwnProperty("expiry"))
                if (typeof message.expiry === "number")
                    object.expiry = options.longs === String ? String(message.expiry) : message.expiry;
                else
                    object.expiry = options.longs === String ? $util.Long.prototype.toString.call(message.expiry) : options.longs === Number ? new $util.LongBits(message.expiry.low >>> 0, message.expiry.high >>> 0).toNumber() : message.expiry;
            if (message.description != null && message.hasOwnProperty("description"))
                object.description = message.description;
            if (message.descriptionHash != null && message.hasOwnProperty("descriptionHash"))
                object.descriptionHash = message.descriptionHash;
            if (message.fallbackAddr != null && message.hasOwnProperty("fallbackAddr"))
                object.fallbackAddr = message.fallbackAddr;
            if (message.cltvExpiry != null && message.hasOwnProperty("cltvExpiry"))
                if (typeof message.cltvExpiry === "number")
                    object.cltvExpiry = options.longs === String ? String(message.cltvExpiry) : message.cltvExpiry;
                else
                    object.cltvExpiry = options.longs === String ? $util.Long.prototype.toString.call(message.cltvExpiry) : options.longs === Number ? new $util.LongBits(message.cltvExpiry.low >>> 0, message.cltvExpiry.high >>> 0).toNumber() : message.cltvExpiry;
            if (message.routeHints && message.routeHints.length) {
                object.routeHints = [];
                for (let j = 0; j < message.routeHints.length; ++j)
                    object.routeHints[j] = $root.lnrpc.RouteHint.toObject(message.routeHints[j], options);
            }
            return object;
        };

        /**
         * Converts this PayReq to JSON.
         * @function toJSON
         * @memberof lnrpc.PayReq
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PayReq.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PayReq;
    })();

    lnrpc.FeeReportRequest = (function() {

        /**
         * Properties of a FeeReportRequest.
         * @memberof lnrpc
         * @interface IFeeReportRequest
         */

        /**
         * Constructs a new FeeReportRequest.
         * @memberof lnrpc
         * @classdesc Represents a FeeReportRequest.
         * @implements IFeeReportRequest
         * @constructor
         * @param {lnrpc.IFeeReportRequest=} [properties] Properties to set
         */
        function FeeReportRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FeeReportRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest=} [properties] Properties to set
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest instance
         */
        FeeReportRequest.create = function create(properties) {
            return new FeeReportRequest(properties);
        };

        /**
         * Encodes the specified FeeReportRequest message. Does not implicitly {@link lnrpc.FeeReportRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest} message FeeReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FeeReportRequest message, length delimited. Does not implicitly {@link lnrpc.FeeReportRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.IFeeReportRequest} message FeeReportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeReportRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeReportRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeReportRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeReportRequest message.
         * @function verify
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeReportRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a FeeReportRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeReportRequest} FeeReportRequest
         */
        FeeReportRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeReportRequest)
                return object;
            return new $root.lnrpc.FeeReportRequest();
        };

        /**
         * Creates a plain object from a FeeReportRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeReportRequest
         * @static
         * @param {lnrpc.FeeReportRequest} message FeeReportRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeReportRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this FeeReportRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeReportRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeReportRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeReportRequest;
    })();

    lnrpc.ChannelFeeReport = (function() {

        /**
         * Properties of a ChannelFeeReport.
         * @memberof lnrpc
         * @interface IChannelFeeReport
         * @property {string|null} [chanPoint] The channel that this fee report belongs to.
         * @property {number|Long|null} [baseFeeMsat] The base fee charged regardless of the number of milli-satoshis sent.
         * @property {number|Long|null} [feePerMil] The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
         * @property {number|null} [feeRate] The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
         */

        /**
         * Constructs a new ChannelFeeReport.
         * @memberof lnrpc
         * @classdesc Represents a ChannelFeeReport.
         * @implements IChannelFeeReport
         * @constructor
         * @param {lnrpc.IChannelFeeReport=} [properties] Properties to set
         */
        function ChannelFeeReport(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The channel that this fee report belongs to.
         * @member {string} chanPoint
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.chanPoint = "";

        /**
         * The base fee charged regardless of the number of milli-satoshis sent.
         * @member {number|Long} baseFeeMsat
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.baseFeeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The amount charged per milli-satoshis transferred expressed in millionths of a satoshi.
         * @member {number|Long} feePerMil
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.feePerMil = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The effective fee rate in milli-satoshis. Computed by dividing the fee_per_mil value by 1 million.
         * @member {number} feeRate
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         */
        ChannelFeeReport.prototype.feeRate = 0;

        /**
         * Creates a new ChannelFeeReport instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport=} [properties] Properties to set
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport instance
         */
        ChannelFeeReport.create = function create(properties) {
            return new ChannelFeeReport(properties);
        };

        /**
         * Encodes the specified ChannelFeeReport message. Does not implicitly {@link lnrpc.ChannelFeeReport.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport} message ChannelFeeReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelFeeReport.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.chanPoint);
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.baseFeeMsat);
            if (message.feePerMil != null && message.hasOwnProperty("feePerMil"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.feePerMil);
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.feeRate);
            return writer;
        };

        /**
         * Encodes the specified ChannelFeeReport message, length delimited. Does not implicitly {@link lnrpc.ChannelFeeReport.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.IChannelFeeReport} message ChannelFeeReport message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelFeeReport.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelFeeReport message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelFeeReport.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelFeeReport();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPoint = reader.string();
                    break;
                case 2:
                    message.baseFeeMsat = reader.int64();
                    break;
                case 3:
                    message.feePerMil = reader.int64();
                    break;
                case 4:
                    message.feeRate = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelFeeReport message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelFeeReport.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelFeeReport message.
         * @function verify
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelFeeReport.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                if (!$util.isString(message.chanPoint))
                    return "chanPoint: string expected";
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (!$util.isInteger(message.baseFeeMsat) && !(message.baseFeeMsat && $util.isInteger(message.baseFeeMsat.low) && $util.isInteger(message.baseFeeMsat.high)))
                    return "baseFeeMsat: integer|Long expected";
            if (message.feePerMil != null && message.hasOwnProperty("feePerMil"))
                if (!$util.isInteger(message.feePerMil) && !(message.feePerMil && $util.isInteger(message.feePerMil.low) && $util.isInteger(message.feePerMil.high)))
                    return "feePerMil: integer|Long expected";
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                if (typeof message.feeRate !== "number")
                    return "feeRate: number expected";
            return null;
        };

        /**
         * Creates a ChannelFeeReport message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelFeeReport} ChannelFeeReport
         */
        ChannelFeeReport.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelFeeReport)
                return object;
            let message = new $root.lnrpc.ChannelFeeReport();
            if (object.chanPoint != null)
                message.chanPoint = String(object.chanPoint);
            if (object.baseFeeMsat != null)
                if ($util.Long)
                    (message.baseFeeMsat = $util.Long.fromValue(object.baseFeeMsat)).unsigned = false;
                else if (typeof object.baseFeeMsat === "string")
                    message.baseFeeMsat = parseInt(object.baseFeeMsat, 10);
                else if (typeof object.baseFeeMsat === "number")
                    message.baseFeeMsat = object.baseFeeMsat;
                else if (typeof object.baseFeeMsat === "object")
                    message.baseFeeMsat = new $util.LongBits(object.baseFeeMsat.low >>> 0, object.baseFeeMsat.high >>> 0).toNumber();
            if (object.feePerMil != null)
                if ($util.Long)
                    (message.feePerMil = $util.Long.fromValue(object.feePerMil)).unsigned = false;
                else if (typeof object.feePerMil === "string")
                    message.feePerMil = parseInt(object.feePerMil, 10);
                else if (typeof object.feePerMil === "number")
                    message.feePerMil = object.feePerMil;
                else if (typeof object.feePerMil === "object")
                    message.feePerMil = new $util.LongBits(object.feePerMil.low >>> 0, object.feePerMil.high >>> 0).toNumber();
            if (object.feeRate != null)
                message.feeRate = Number(object.feeRate);
            return message;
        };

        /**
         * Creates a plain object from a ChannelFeeReport message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelFeeReport
         * @static
         * @param {lnrpc.ChannelFeeReport} message ChannelFeeReport
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelFeeReport.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chanPoint = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.baseFeeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.baseFeeMsat = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.feePerMil = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feePerMil = options.longs === String ? "0" : 0;
                object.feeRate = 0;
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = message.chanPoint;
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (typeof message.baseFeeMsat === "number")
                    object.baseFeeMsat = options.longs === String ? String(message.baseFeeMsat) : message.baseFeeMsat;
                else
                    object.baseFeeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.baseFeeMsat) : options.longs === Number ? new $util.LongBits(message.baseFeeMsat.low >>> 0, message.baseFeeMsat.high >>> 0).toNumber() : message.baseFeeMsat;
            if (message.feePerMil != null && message.hasOwnProperty("feePerMil"))
                if (typeof message.feePerMil === "number")
                    object.feePerMil = options.longs === String ? String(message.feePerMil) : message.feePerMil;
                else
                    object.feePerMil = options.longs === String ? $util.Long.prototype.toString.call(message.feePerMil) : options.longs === Number ? new $util.LongBits(message.feePerMil.low >>> 0, message.feePerMil.high >>> 0).toNumber() : message.feePerMil;
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                object.feeRate = options.json && !isFinite(message.feeRate) ? String(message.feeRate) : message.feeRate;
            return object;
        };

        /**
         * Converts this ChannelFeeReport to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelFeeReport
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelFeeReport.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelFeeReport;
    })();

    lnrpc.FeeReportResponse = (function() {

        /**
         * Properties of a FeeReportResponse.
         * @memberof lnrpc
         * @interface IFeeReportResponse
         * @property {Array.<lnrpc.IChannelFeeReport>|null} [channelFees] An array of channel fee reports which describes the current fee schedule for each channel.
         * @property {number|Long|null} [dayFeeSum] The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
         * @property {number|Long|null} [weekFeeSum] The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
         * @property {number|Long|null} [monthFeeSum] The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
         */

        /**
         * Constructs a new FeeReportResponse.
         * @memberof lnrpc
         * @classdesc Represents a FeeReportResponse.
         * @implements IFeeReportResponse
         * @constructor
         * @param {lnrpc.IFeeReportResponse=} [properties] Properties to set
         */
        function FeeReportResponse(properties) {
            this.channelFees = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * An array of channel fee reports which describes the current fee schedule for each channel.
         * @member {Array.<lnrpc.IChannelFeeReport>} channelFees
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.channelFees = $util.emptyArray;

        /**
         * The total amount of fee revenue (in satoshis) the switch has collected over the past 24 hrs.
         * @member {number|Long} dayFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.dayFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount of fee revenue (in satoshis) the switch has collected over the past 1 week.
         * @member {number|Long} weekFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.weekFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount of fee revenue (in satoshis) the switch has collected over the past 1 month.
         * @member {number|Long} monthFeeSum
         * @memberof lnrpc.FeeReportResponse
         * @instance
         */
        FeeReportResponse.prototype.monthFeeSum = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new FeeReportResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse=} [properties] Properties to set
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse instance
         */
        FeeReportResponse.create = function create(properties) {
            return new FeeReportResponse(properties);
        };

        /**
         * Encodes the specified FeeReportResponse message. Does not implicitly {@link lnrpc.FeeReportResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse} message FeeReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.channelFees != null && message.channelFees.length)
                for (let i = 0; i < message.channelFees.length; ++i)
                    $root.lnrpc.ChannelFeeReport.encode(message.channelFees[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.dayFeeSum != null && message.hasOwnProperty("dayFeeSum"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.dayFeeSum);
            if (message.weekFeeSum != null && message.hasOwnProperty("weekFeeSum"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.weekFeeSum);
            if (message.monthFeeSum != null && message.hasOwnProperty("monthFeeSum"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.monthFeeSum);
            return writer;
        };

        /**
         * Encodes the specified FeeReportResponse message, length delimited. Does not implicitly {@link lnrpc.FeeReportResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.IFeeReportResponse} message FeeReportResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FeeReportResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FeeReportResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.FeeReportResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.channelFees && message.channelFees.length))
                        message.channelFees = [];
                    message.channelFees.push($root.lnrpc.ChannelFeeReport.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.dayFeeSum = reader.uint64();
                    break;
                case 3:
                    message.weekFeeSum = reader.uint64();
                    break;
                case 4:
                    message.monthFeeSum = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FeeReportResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FeeReportResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FeeReportResponse message.
         * @function verify
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FeeReportResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.channelFees != null && message.hasOwnProperty("channelFees")) {
                if (!Array.isArray(message.channelFees))
                    return "channelFees: array expected";
                for (let i = 0; i < message.channelFees.length; ++i) {
                    let error = $root.lnrpc.ChannelFeeReport.verify(message.channelFees[i]);
                    if (error)
                        return "channelFees." + error;
                }
            }
            if (message.dayFeeSum != null && message.hasOwnProperty("dayFeeSum"))
                if (!$util.isInteger(message.dayFeeSum) && !(message.dayFeeSum && $util.isInteger(message.dayFeeSum.low) && $util.isInteger(message.dayFeeSum.high)))
                    return "dayFeeSum: integer|Long expected";
            if (message.weekFeeSum != null && message.hasOwnProperty("weekFeeSum"))
                if (!$util.isInteger(message.weekFeeSum) && !(message.weekFeeSum && $util.isInteger(message.weekFeeSum.low) && $util.isInteger(message.weekFeeSum.high)))
                    return "weekFeeSum: integer|Long expected";
            if (message.monthFeeSum != null && message.hasOwnProperty("monthFeeSum"))
                if (!$util.isInteger(message.monthFeeSum) && !(message.monthFeeSum && $util.isInteger(message.monthFeeSum.low) && $util.isInteger(message.monthFeeSum.high)))
                    return "monthFeeSum: integer|Long expected";
            return null;
        };

        /**
         * Creates a FeeReportResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.FeeReportResponse} FeeReportResponse
         */
        FeeReportResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.FeeReportResponse)
                return object;
            let message = new $root.lnrpc.FeeReportResponse();
            if (object.channelFees) {
                if (!Array.isArray(object.channelFees))
                    throw TypeError(".lnrpc.FeeReportResponse.channelFees: array expected");
                message.channelFees = [];
                for (let i = 0; i < object.channelFees.length; ++i) {
                    if (typeof object.channelFees[i] !== "object")
                        throw TypeError(".lnrpc.FeeReportResponse.channelFees: object expected");
                    message.channelFees[i] = $root.lnrpc.ChannelFeeReport.fromObject(object.channelFees[i]);
                }
            }
            if (object.dayFeeSum != null)
                if ($util.Long)
                    (message.dayFeeSum = $util.Long.fromValue(object.dayFeeSum)).unsigned = true;
                else if (typeof object.dayFeeSum === "string")
                    message.dayFeeSum = parseInt(object.dayFeeSum, 10);
                else if (typeof object.dayFeeSum === "number")
                    message.dayFeeSum = object.dayFeeSum;
                else if (typeof object.dayFeeSum === "object")
                    message.dayFeeSum = new $util.LongBits(object.dayFeeSum.low >>> 0, object.dayFeeSum.high >>> 0).toNumber(true);
            if (object.weekFeeSum != null)
                if ($util.Long)
                    (message.weekFeeSum = $util.Long.fromValue(object.weekFeeSum)).unsigned = true;
                else if (typeof object.weekFeeSum === "string")
                    message.weekFeeSum = parseInt(object.weekFeeSum, 10);
                else if (typeof object.weekFeeSum === "number")
                    message.weekFeeSum = object.weekFeeSum;
                else if (typeof object.weekFeeSum === "object")
                    message.weekFeeSum = new $util.LongBits(object.weekFeeSum.low >>> 0, object.weekFeeSum.high >>> 0).toNumber(true);
            if (object.monthFeeSum != null)
                if ($util.Long)
                    (message.monthFeeSum = $util.Long.fromValue(object.monthFeeSum)).unsigned = true;
                else if (typeof object.monthFeeSum === "string")
                    message.monthFeeSum = parseInt(object.monthFeeSum, 10);
                else if (typeof object.monthFeeSum === "number")
                    message.monthFeeSum = object.monthFeeSum;
                else if (typeof object.monthFeeSum === "object")
                    message.monthFeeSum = new $util.LongBits(object.monthFeeSum.low >>> 0, object.monthFeeSum.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a FeeReportResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.FeeReportResponse
         * @static
         * @param {lnrpc.FeeReportResponse} message FeeReportResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FeeReportResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.channelFees = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.dayFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.dayFeeSum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.weekFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.weekFeeSum = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.monthFeeSum = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.monthFeeSum = options.longs === String ? "0" : 0;
            }
            if (message.channelFees && message.channelFees.length) {
                object.channelFees = [];
                for (let j = 0; j < message.channelFees.length; ++j)
                    object.channelFees[j] = $root.lnrpc.ChannelFeeReport.toObject(message.channelFees[j], options);
            }
            if (message.dayFeeSum != null && message.hasOwnProperty("dayFeeSum"))
                if (typeof message.dayFeeSum === "number")
                    object.dayFeeSum = options.longs === String ? String(message.dayFeeSum) : message.dayFeeSum;
                else
                    object.dayFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.dayFeeSum) : options.longs === Number ? new $util.LongBits(message.dayFeeSum.low >>> 0, message.dayFeeSum.high >>> 0).toNumber(true) : message.dayFeeSum;
            if (message.weekFeeSum != null && message.hasOwnProperty("weekFeeSum"))
                if (typeof message.weekFeeSum === "number")
                    object.weekFeeSum = options.longs === String ? String(message.weekFeeSum) : message.weekFeeSum;
                else
                    object.weekFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.weekFeeSum) : options.longs === Number ? new $util.LongBits(message.weekFeeSum.low >>> 0, message.weekFeeSum.high >>> 0).toNumber(true) : message.weekFeeSum;
            if (message.monthFeeSum != null && message.hasOwnProperty("monthFeeSum"))
                if (typeof message.monthFeeSum === "number")
                    object.monthFeeSum = options.longs === String ? String(message.monthFeeSum) : message.monthFeeSum;
                else
                    object.monthFeeSum = options.longs === String ? $util.Long.prototype.toString.call(message.monthFeeSum) : options.longs === Number ? new $util.LongBits(message.monthFeeSum.low >>> 0, message.monthFeeSum.high >>> 0).toNumber(true) : message.monthFeeSum;
            return object;
        };

        /**
         * Converts this FeeReportResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.FeeReportResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FeeReportResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FeeReportResponse;
    })();

    lnrpc.PolicyUpdateRequest = (function() {

        /**
         * Properties of a PolicyUpdateRequest.
         * @memberof lnrpc
         * @interface IPolicyUpdateRequest
         * @property {boolean|null} [global] If set, then this update applies to all currently active channels.
         * @property {lnrpc.IChannelPoint|null} [chanPoint] If set, this update will target a specific channel.
         * @property {number|Long|null} [baseFeeMsat] The base fee charged regardless of the number of milli-satoshis sent.
         * @property {number|null} [feeRate] The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
         * @property {number|null} [timeLockDelta] The required timelock delta for HTLCs forwarded over the channel.
         */

        /**
         * Constructs a new PolicyUpdateRequest.
         * @memberof lnrpc
         * @classdesc Represents a PolicyUpdateRequest.
         * @implements IPolicyUpdateRequest
         * @constructor
         * @param {lnrpc.IPolicyUpdateRequest=} [properties] Properties to set
         */
        function PolicyUpdateRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * If set, then this update applies to all currently active channels.
         * @member {boolean} global
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.global = false;

        /**
         * If set, this update will target a specific channel.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.chanPoint = null;

        /**
         * The base fee charged regardless of the number of milli-satoshis sent.
         * @member {number|Long} baseFeeMsat
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.baseFeeMsat = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * The effective fee rate in milli-satoshis. The precision of this value goes up to 6 decimal places, so 1e-6.
         * @member {number} feeRate
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.feeRate = 0;

        /**
         * The required timelock delta for HTLCs forwarded over the channel.
         * @member {number} timeLockDelta
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        PolicyUpdateRequest.prototype.timeLockDelta = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * PolicyUpdateRequest scope.
         * @member {"global"|"chanPoint"|undefined} scope
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         */
        Object.defineProperty(PolicyUpdateRequest.prototype, "scope", {
            get: $util.oneOfGetter($oneOfFields = ["global", "chanPoint"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PolicyUpdateRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest=} [properties] Properties to set
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest instance
         */
        PolicyUpdateRequest.create = function create(properties) {
            return new PolicyUpdateRequest(properties);
        };

        /**
         * Encodes the specified PolicyUpdateRequest message. Does not implicitly {@link lnrpc.PolicyUpdateRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest} message PolicyUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.global != null && message.hasOwnProperty("global"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.global);
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.baseFeeMsat);
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.feeRate);
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.timeLockDelta);
            return writer;
        };

        /**
         * Encodes the specified PolicyUpdateRequest message, length delimited. Does not implicitly {@link lnrpc.PolicyUpdateRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.IPolicyUpdateRequest} message PolicyUpdateRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PolicyUpdateRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PolicyUpdateRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.global = reader.bool();
                    break;
                case 2:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.baseFeeMsat = reader.int64();
                    break;
                case 4:
                    message.feeRate = reader.double();
                    break;
                case 5:
                    message.timeLockDelta = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PolicyUpdateRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PolicyUpdateRequest message.
         * @function verify
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PolicyUpdateRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.global != null && message.hasOwnProperty("global")) {
                properties.scope = 1;
                if (typeof message.global !== "boolean")
                    return "global: boolean expected";
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                if (properties.scope === 1)
                    return "scope: multiple values";
                properties.scope = 1;
                {
                    let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                    if (error)
                        return "chanPoint." + error;
                }
            }
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (!$util.isInteger(message.baseFeeMsat) && !(message.baseFeeMsat && $util.isInteger(message.baseFeeMsat.low) && $util.isInteger(message.baseFeeMsat.high)))
                    return "baseFeeMsat: integer|Long expected";
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                if (typeof message.feeRate !== "number")
                    return "feeRate: number expected";
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                if (!$util.isInteger(message.timeLockDelta))
                    return "timeLockDelta: integer expected";
            return null;
        };

        /**
         * Creates a PolicyUpdateRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PolicyUpdateRequest} PolicyUpdateRequest
         */
        PolicyUpdateRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PolicyUpdateRequest)
                return object;
            let message = new $root.lnrpc.PolicyUpdateRequest();
            if (object.global != null)
                message.global = Boolean(object.global);
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.PolicyUpdateRequest.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.baseFeeMsat != null)
                if ($util.Long)
                    (message.baseFeeMsat = $util.Long.fromValue(object.baseFeeMsat)).unsigned = false;
                else if (typeof object.baseFeeMsat === "string")
                    message.baseFeeMsat = parseInt(object.baseFeeMsat, 10);
                else if (typeof object.baseFeeMsat === "number")
                    message.baseFeeMsat = object.baseFeeMsat;
                else if (typeof object.baseFeeMsat === "object")
                    message.baseFeeMsat = new $util.LongBits(object.baseFeeMsat.low >>> 0, object.baseFeeMsat.high >>> 0).toNumber();
            if (object.feeRate != null)
                message.feeRate = Number(object.feeRate);
            if (object.timeLockDelta != null)
                message.timeLockDelta = object.timeLockDelta >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a PolicyUpdateRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PolicyUpdateRequest
         * @static
         * @param {lnrpc.PolicyUpdateRequest} message PolicyUpdateRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PolicyUpdateRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.baseFeeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.baseFeeMsat = options.longs === String ? "0" : 0;
                object.feeRate = 0;
                object.timeLockDelta = 0;
            }
            if (message.global != null && message.hasOwnProperty("global")) {
                object.global = message.global;
                if (options.oneofs)
                    object.scope = "global";
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
                if (options.oneofs)
                    object.scope = "chanPoint";
            }
            if (message.baseFeeMsat != null && message.hasOwnProperty("baseFeeMsat"))
                if (typeof message.baseFeeMsat === "number")
                    object.baseFeeMsat = options.longs === String ? String(message.baseFeeMsat) : message.baseFeeMsat;
                else
                    object.baseFeeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.baseFeeMsat) : options.longs === Number ? new $util.LongBits(message.baseFeeMsat.low >>> 0, message.baseFeeMsat.high >>> 0).toNumber() : message.baseFeeMsat;
            if (message.feeRate != null && message.hasOwnProperty("feeRate"))
                object.feeRate = options.json && !isFinite(message.feeRate) ? String(message.feeRate) : message.feeRate;
            if (message.timeLockDelta != null && message.hasOwnProperty("timeLockDelta"))
                object.timeLockDelta = message.timeLockDelta;
            return object;
        };

        /**
         * Converts this PolicyUpdateRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.PolicyUpdateRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PolicyUpdateRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PolicyUpdateRequest;
    })();

    lnrpc.PolicyUpdateResponse = (function() {

        /**
         * Properties of a PolicyUpdateResponse.
         * @memberof lnrpc
         * @interface IPolicyUpdateResponse
         */

        /**
         * Constructs a new PolicyUpdateResponse.
         * @memberof lnrpc
         * @classdesc Represents a PolicyUpdateResponse.
         * @implements IPolicyUpdateResponse
         * @constructor
         * @param {lnrpc.IPolicyUpdateResponse=} [properties] Properties to set
         */
        function PolicyUpdateResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PolicyUpdateResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse=} [properties] Properties to set
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse instance
         */
        PolicyUpdateResponse.create = function create(properties) {
            return new PolicyUpdateResponse(properties);
        };

        /**
         * Encodes the specified PolicyUpdateResponse message. Does not implicitly {@link lnrpc.PolicyUpdateResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse} message PolicyUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PolicyUpdateResponse message, length delimited. Does not implicitly {@link lnrpc.PolicyUpdateResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.IPolicyUpdateResponse} message PolicyUpdateResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PolicyUpdateResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PolicyUpdateResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.PolicyUpdateResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PolicyUpdateResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PolicyUpdateResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PolicyUpdateResponse message.
         * @function verify
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PolicyUpdateResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a PolicyUpdateResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.PolicyUpdateResponse} PolicyUpdateResponse
         */
        PolicyUpdateResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.PolicyUpdateResponse)
                return object;
            return new $root.lnrpc.PolicyUpdateResponse();
        };

        /**
         * Creates a plain object from a PolicyUpdateResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.PolicyUpdateResponse
         * @static
         * @param {lnrpc.PolicyUpdateResponse} message PolicyUpdateResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PolicyUpdateResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this PolicyUpdateResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.PolicyUpdateResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PolicyUpdateResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return PolicyUpdateResponse;
    })();

    lnrpc.ForwardingHistoryRequest = (function() {

        /**
         * Properties of a ForwardingHistoryRequest.
         * @memberof lnrpc
         * @interface IForwardingHistoryRequest
         * @property {number|Long|null} [startTime] Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
         * @property {number|Long|null} [endTime] End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
         * @property {number|null} [indexOffset] Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
         * @property {number|null} [numMaxEvents] The max number of events to return in the response to this query.
         */

        /**
         * Constructs a new ForwardingHistoryRequest.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingHistoryRequest.
         * @implements IForwardingHistoryRequest
         * @constructor
         * @param {lnrpc.IForwardingHistoryRequest=} [properties] Properties to set
         */
        function ForwardingHistoryRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Start time is the starting point of the forwarding history request. All records beyond this point will be included, respecting the end time, and the index offset.
         * @member {number|Long} startTime
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.startTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * End time is the end point of the forwarding history request. The response will carry at most 50k records between the start time and the end time. The index offset can be used to implement pagination.
         * @member {number|Long} endTime
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.endTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Index offset is the offset in the time series to start at. As each response can only contain 50k records, callers can use this to skip around within a packed time series.
         * @member {number} indexOffset
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.indexOffset = 0;

        /**
         * The max number of events to return in the response to this query.
         * @member {number} numMaxEvents
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         */
        ForwardingHistoryRequest.prototype.numMaxEvents = 0;

        /**
         * Creates a new ForwardingHistoryRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest=} [properties] Properties to set
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest instance
         */
        ForwardingHistoryRequest.create = function create(properties) {
            return new ForwardingHistoryRequest(properties);
        };

        /**
         * Encodes the specified ForwardingHistoryRequest message. Does not implicitly {@link lnrpc.ForwardingHistoryRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest} message ForwardingHistoryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.startTime);
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.endTime);
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.indexOffset);
            if (message.numMaxEvents != null && message.hasOwnProperty("numMaxEvents"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.numMaxEvents);
            return writer;
        };

        /**
         * Encodes the specified ForwardingHistoryRequest message, length delimited. Does not implicitly {@link lnrpc.ForwardingHistoryRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.IForwardingHistoryRequest} message ForwardingHistoryRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingHistoryRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingHistoryRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.startTime = reader.uint64();
                    break;
                case 2:
                    message.endTime = reader.uint64();
                    break;
                case 3:
                    message.indexOffset = reader.uint32();
                    break;
                case 4:
                    message.numMaxEvents = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingHistoryRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingHistoryRequest message.
         * @function verify
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingHistoryRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (!$util.isInteger(message.startTime) && !(message.startTime && $util.isInteger(message.startTime.low) && $util.isInteger(message.startTime.high)))
                    return "startTime: integer|Long expected";
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (!$util.isInteger(message.endTime) && !(message.endTime && $util.isInteger(message.endTime.low) && $util.isInteger(message.endTime.high)))
                    return "endTime: integer|Long expected";
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                if (!$util.isInteger(message.indexOffset))
                    return "indexOffset: integer expected";
            if (message.numMaxEvents != null && message.hasOwnProperty("numMaxEvents"))
                if (!$util.isInteger(message.numMaxEvents))
                    return "numMaxEvents: integer expected";
            return null;
        };

        /**
         * Creates a ForwardingHistoryRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingHistoryRequest} ForwardingHistoryRequest
         */
        ForwardingHistoryRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingHistoryRequest)
                return object;
            let message = new $root.lnrpc.ForwardingHistoryRequest();
            if (object.startTime != null)
                if ($util.Long)
                    (message.startTime = $util.Long.fromValue(object.startTime)).unsigned = true;
                else if (typeof object.startTime === "string")
                    message.startTime = parseInt(object.startTime, 10);
                else if (typeof object.startTime === "number")
                    message.startTime = object.startTime;
                else if (typeof object.startTime === "object")
                    message.startTime = new $util.LongBits(object.startTime.low >>> 0, object.startTime.high >>> 0).toNumber(true);
            if (object.endTime != null)
                if ($util.Long)
                    (message.endTime = $util.Long.fromValue(object.endTime)).unsigned = true;
                else if (typeof object.endTime === "string")
                    message.endTime = parseInt(object.endTime, 10);
                else if (typeof object.endTime === "number")
                    message.endTime = object.endTime;
                else if (typeof object.endTime === "object")
                    message.endTime = new $util.LongBits(object.endTime.low >>> 0, object.endTime.high >>> 0).toNumber(true);
            if (object.indexOffset != null)
                message.indexOffset = object.indexOffset >>> 0;
            if (object.numMaxEvents != null)
                message.numMaxEvents = object.numMaxEvents >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ForwardingHistoryRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingHistoryRequest
         * @static
         * @param {lnrpc.ForwardingHistoryRequest} message ForwardingHistoryRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingHistoryRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.startTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.startTime = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.endTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.endTime = options.longs === String ? "0" : 0;
                object.indexOffset = 0;
                object.numMaxEvents = 0;
            }
            if (message.startTime != null && message.hasOwnProperty("startTime"))
                if (typeof message.startTime === "number")
                    object.startTime = options.longs === String ? String(message.startTime) : message.startTime;
                else
                    object.startTime = options.longs === String ? $util.Long.prototype.toString.call(message.startTime) : options.longs === Number ? new $util.LongBits(message.startTime.low >>> 0, message.startTime.high >>> 0).toNumber(true) : message.startTime;
            if (message.endTime != null && message.hasOwnProperty("endTime"))
                if (typeof message.endTime === "number")
                    object.endTime = options.longs === String ? String(message.endTime) : message.endTime;
                else
                    object.endTime = options.longs === String ? $util.Long.prototype.toString.call(message.endTime) : options.longs === Number ? new $util.LongBits(message.endTime.low >>> 0, message.endTime.high >>> 0).toNumber(true) : message.endTime;
            if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
                object.indexOffset = message.indexOffset;
            if (message.numMaxEvents != null && message.hasOwnProperty("numMaxEvents"))
                object.numMaxEvents = message.numMaxEvents;
            return object;
        };

        /**
         * Converts this ForwardingHistoryRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingHistoryRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingHistoryRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingHistoryRequest;
    })();

    lnrpc.ForwardingEvent = (function() {

        /**
         * Properties of a ForwardingEvent.
         * @memberof lnrpc
         * @interface IForwardingEvent
         * @property {number|Long|null} [timestamp] Timestamp is the time (unix epoch offset) that this circuit was completed.
         * @property {number|Long|null} [chanIdIn] The incoming channel ID that carried the HTLC that created the circuit.
         * @property {number|Long|null} [chanIdOut] The outgoing channel ID that carried the preimage that completed the circuit.
         * @property {number|Long|null} [amtIn] The total amount (in satoshis) of the incoming HTLC that created half the circuit.
         * @property {number|Long|null} [amtOut] The total amount (in satoshis) of the outgoing HTLC that created the second half of the circuit.
         * @property {number|Long|null} [fee] The total fee (in satoshis) that this payment circuit carried.
         * @property {number|Long|null} [feeMsat] The total fee (in milli-satoshis) that this payment circuit carried.
         */

        /**
         * Constructs a new ForwardingEvent.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingEvent.
         * @implements IForwardingEvent
         * @constructor
         * @param {lnrpc.IForwardingEvent=} [properties] Properties to set
         */
        function ForwardingEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Timestamp is the time (unix epoch offset) that this circuit was completed.
         * @member {number|Long} timestamp
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The incoming channel ID that carried the HTLC that created the circuit.
         * @member {number|Long} chanIdIn
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.chanIdIn = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The outgoing channel ID that carried the preimage that completed the circuit.
         * @member {number|Long} chanIdOut
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.chanIdOut = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount (in satoshis) of the incoming HTLC that created half the circuit.
         * @member {number|Long} amtIn
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.amtIn = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total amount (in satoshis) of the outgoing HTLC that created the second half of the circuit.
         * @member {number|Long} amtOut
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.amtOut = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total fee (in satoshis) that this payment circuit carried.
         * @member {number|Long} fee
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.fee = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * The total fee (in milli-satoshis) that this payment circuit carried.
         * @member {number|Long} feeMsat
         * @memberof lnrpc.ForwardingEvent
         * @instance
         */
        ForwardingEvent.prototype.feeMsat = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ForwardingEvent instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent=} [properties] Properties to set
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent instance
         */
        ForwardingEvent.create = function create(properties) {
            return new ForwardingEvent(properties);
        };

        /**
         * Encodes the specified ForwardingEvent message. Does not implicitly {@link lnrpc.ForwardingEvent.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent} message ForwardingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.timestamp);
            if (message.chanIdIn != null && message.hasOwnProperty("chanIdIn"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.chanIdIn);
            if (message.chanIdOut != null && message.hasOwnProperty("chanIdOut"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.chanIdOut);
            if (message.amtIn != null && message.hasOwnProperty("amtIn"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.amtIn);
            if (message.amtOut != null && message.hasOwnProperty("amtOut"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.amtOut);
            if (message.fee != null && message.hasOwnProperty("fee"))
                writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.fee);
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.feeMsat);
            return writer;
        };

        /**
         * Encodes the specified ForwardingEvent message, length delimited. Does not implicitly {@link lnrpc.ForwardingEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.IForwardingEvent} message ForwardingEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingEvent message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.timestamp = reader.uint64();
                    break;
                case 2:
                    message.chanIdIn = reader.uint64();
                    break;
                case 4:
                    message.chanIdOut = reader.uint64();
                    break;
                case 5:
                    message.amtIn = reader.uint64();
                    break;
                case 6:
                    message.amtOut = reader.uint64();
                    break;
                case 7:
                    message.fee = reader.uint64();
                    break;
                case 8:
                    message.feeMsat = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingEvent message.
         * @function verify
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                    return "timestamp: integer|Long expected";
            if (message.chanIdIn != null && message.hasOwnProperty("chanIdIn"))
                if (!$util.isInteger(message.chanIdIn) && !(message.chanIdIn && $util.isInteger(message.chanIdIn.low) && $util.isInteger(message.chanIdIn.high)))
                    return "chanIdIn: integer|Long expected";
            if (message.chanIdOut != null && message.hasOwnProperty("chanIdOut"))
                if (!$util.isInteger(message.chanIdOut) && !(message.chanIdOut && $util.isInteger(message.chanIdOut.low) && $util.isInteger(message.chanIdOut.high)))
                    return "chanIdOut: integer|Long expected";
            if (message.amtIn != null && message.hasOwnProperty("amtIn"))
                if (!$util.isInteger(message.amtIn) && !(message.amtIn && $util.isInteger(message.amtIn.low) && $util.isInteger(message.amtIn.high)))
                    return "amtIn: integer|Long expected";
            if (message.amtOut != null && message.hasOwnProperty("amtOut"))
                if (!$util.isInteger(message.amtOut) && !(message.amtOut && $util.isInteger(message.amtOut.low) && $util.isInteger(message.amtOut.high)))
                    return "amtOut: integer|Long expected";
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (!$util.isInteger(message.fee) && !(message.fee && $util.isInteger(message.fee.low) && $util.isInteger(message.fee.high)))
                    return "fee: integer|Long expected";
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (!$util.isInteger(message.feeMsat) && !(message.feeMsat && $util.isInteger(message.feeMsat.low) && $util.isInteger(message.feeMsat.high)))
                    return "feeMsat: integer|Long expected";
            return null;
        };

        /**
         * Creates a ForwardingEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingEvent} ForwardingEvent
         */
        ForwardingEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingEvent)
                return object;
            let message = new $root.lnrpc.ForwardingEvent();
            if (object.timestamp != null)
                if ($util.Long)
                    (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                else if (typeof object.timestamp === "string")
                    message.timestamp = parseInt(object.timestamp, 10);
                else if (typeof object.timestamp === "number")
                    message.timestamp = object.timestamp;
                else if (typeof object.timestamp === "object")
                    message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
            if (object.chanIdIn != null)
                if ($util.Long)
                    (message.chanIdIn = $util.Long.fromValue(object.chanIdIn)).unsigned = true;
                else if (typeof object.chanIdIn === "string")
                    message.chanIdIn = parseInt(object.chanIdIn, 10);
                else if (typeof object.chanIdIn === "number")
                    message.chanIdIn = object.chanIdIn;
                else if (typeof object.chanIdIn === "object")
                    message.chanIdIn = new $util.LongBits(object.chanIdIn.low >>> 0, object.chanIdIn.high >>> 0).toNumber(true);
            if (object.chanIdOut != null)
                if ($util.Long)
                    (message.chanIdOut = $util.Long.fromValue(object.chanIdOut)).unsigned = true;
                else if (typeof object.chanIdOut === "string")
                    message.chanIdOut = parseInt(object.chanIdOut, 10);
                else if (typeof object.chanIdOut === "number")
                    message.chanIdOut = object.chanIdOut;
                else if (typeof object.chanIdOut === "object")
                    message.chanIdOut = new $util.LongBits(object.chanIdOut.low >>> 0, object.chanIdOut.high >>> 0).toNumber(true);
            if (object.amtIn != null)
                if ($util.Long)
                    (message.amtIn = $util.Long.fromValue(object.amtIn)).unsigned = true;
                else if (typeof object.amtIn === "string")
                    message.amtIn = parseInt(object.amtIn, 10);
                else if (typeof object.amtIn === "number")
                    message.amtIn = object.amtIn;
                else if (typeof object.amtIn === "object")
                    message.amtIn = new $util.LongBits(object.amtIn.low >>> 0, object.amtIn.high >>> 0).toNumber(true);
            if (object.amtOut != null)
                if ($util.Long)
                    (message.amtOut = $util.Long.fromValue(object.amtOut)).unsigned = true;
                else if (typeof object.amtOut === "string")
                    message.amtOut = parseInt(object.amtOut, 10);
                else if (typeof object.amtOut === "number")
                    message.amtOut = object.amtOut;
                else if (typeof object.amtOut === "object")
                    message.amtOut = new $util.LongBits(object.amtOut.low >>> 0, object.amtOut.high >>> 0).toNumber(true);
            if (object.fee != null)
                if ($util.Long)
                    (message.fee = $util.Long.fromValue(object.fee)).unsigned = true;
                else if (typeof object.fee === "string")
                    message.fee = parseInt(object.fee, 10);
                else if (typeof object.fee === "number")
                    message.fee = object.fee;
                else if (typeof object.fee === "object")
                    message.fee = new $util.LongBits(object.fee.low >>> 0, object.fee.high >>> 0).toNumber(true);
            if (object.feeMsat != null)
                if ($util.Long)
                    (message.feeMsat = $util.Long.fromValue(object.feeMsat)).unsigned = true;
                else if (typeof object.feeMsat === "string")
                    message.feeMsat = parseInt(object.feeMsat, 10);
                else if (typeof object.feeMsat === "number")
                    message.feeMsat = object.feeMsat;
                else if (typeof object.feeMsat === "object")
                    message.feeMsat = new $util.LongBits(object.feeMsat.low >>> 0, object.feeMsat.high >>> 0).toNumber(true);
            return message;
        };

        /**
         * Creates a plain object from a ForwardingEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingEvent
         * @static
         * @param {lnrpc.ForwardingEvent} message ForwardingEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.timestamp = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanIdIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanIdIn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.chanIdOut = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chanIdOut = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.amtIn = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtIn = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.amtOut = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.amtOut = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.fee = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.fee = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.feeMsat = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.feeMsat = options.longs === String ? "0" : 0;
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                if (typeof message.timestamp === "number")
                    object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                else
                    object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
            if (message.chanIdIn != null && message.hasOwnProperty("chanIdIn"))
                if (typeof message.chanIdIn === "number")
                    object.chanIdIn = options.longs === String ? String(message.chanIdIn) : message.chanIdIn;
                else
                    object.chanIdIn = options.longs === String ? $util.Long.prototype.toString.call(message.chanIdIn) : options.longs === Number ? new $util.LongBits(message.chanIdIn.low >>> 0, message.chanIdIn.high >>> 0).toNumber(true) : message.chanIdIn;
            if (message.chanIdOut != null && message.hasOwnProperty("chanIdOut"))
                if (typeof message.chanIdOut === "number")
                    object.chanIdOut = options.longs === String ? String(message.chanIdOut) : message.chanIdOut;
                else
                    object.chanIdOut = options.longs === String ? $util.Long.prototype.toString.call(message.chanIdOut) : options.longs === Number ? new $util.LongBits(message.chanIdOut.low >>> 0, message.chanIdOut.high >>> 0).toNumber(true) : message.chanIdOut;
            if (message.amtIn != null && message.hasOwnProperty("amtIn"))
                if (typeof message.amtIn === "number")
                    object.amtIn = options.longs === String ? String(message.amtIn) : message.amtIn;
                else
                    object.amtIn = options.longs === String ? $util.Long.prototype.toString.call(message.amtIn) : options.longs === Number ? new $util.LongBits(message.amtIn.low >>> 0, message.amtIn.high >>> 0).toNumber(true) : message.amtIn;
            if (message.amtOut != null && message.hasOwnProperty("amtOut"))
                if (typeof message.amtOut === "number")
                    object.amtOut = options.longs === String ? String(message.amtOut) : message.amtOut;
                else
                    object.amtOut = options.longs === String ? $util.Long.prototype.toString.call(message.amtOut) : options.longs === Number ? new $util.LongBits(message.amtOut.low >>> 0, message.amtOut.high >>> 0).toNumber(true) : message.amtOut;
            if (message.fee != null && message.hasOwnProperty("fee"))
                if (typeof message.fee === "number")
                    object.fee = options.longs === String ? String(message.fee) : message.fee;
                else
                    object.fee = options.longs === String ? $util.Long.prototype.toString.call(message.fee) : options.longs === Number ? new $util.LongBits(message.fee.low >>> 0, message.fee.high >>> 0).toNumber(true) : message.fee;
            if (message.feeMsat != null && message.hasOwnProperty("feeMsat"))
                if (typeof message.feeMsat === "number")
                    object.feeMsat = options.longs === String ? String(message.feeMsat) : message.feeMsat;
                else
                    object.feeMsat = options.longs === String ? $util.Long.prototype.toString.call(message.feeMsat) : options.longs === Number ? new $util.LongBits(message.feeMsat.low >>> 0, message.feeMsat.high >>> 0).toNumber(true) : message.feeMsat;
            return object;
        };

        /**
         * Converts this ForwardingEvent to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingEvent;
    })();

    lnrpc.ForwardingHistoryResponse = (function() {

        /**
         * Properties of a ForwardingHistoryResponse.
         * @memberof lnrpc
         * @interface IForwardingHistoryResponse
         * @property {Array.<lnrpc.IForwardingEvent>|null} [forwardingEvents] A list of forwarding events from the time slice of the time series specified in the request.
         * @property {number|null} [lastOffsetIndex] The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
         */

        /**
         * Constructs a new ForwardingHistoryResponse.
         * @memberof lnrpc
         * @classdesc Represents a ForwardingHistoryResponse.
         * @implements IForwardingHistoryResponse
         * @constructor
         * @param {lnrpc.IForwardingHistoryResponse=} [properties] Properties to set
         */
        function ForwardingHistoryResponse(properties) {
            this.forwardingEvents = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * A list of forwarding events from the time slice of the time series specified in the request.
         * @member {Array.<lnrpc.IForwardingEvent>} forwardingEvents
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         */
        ForwardingHistoryResponse.prototype.forwardingEvents = $util.emptyArray;

        /**
         * The index of the last time in the set of returned forwarding events. Can be used to seek further, pagination style.
         * @member {number} lastOffsetIndex
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         */
        ForwardingHistoryResponse.prototype.lastOffsetIndex = 0;

        /**
         * Creates a new ForwardingHistoryResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse=} [properties] Properties to set
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse instance
         */
        ForwardingHistoryResponse.create = function create(properties) {
            return new ForwardingHistoryResponse(properties);
        };

        /**
         * Encodes the specified ForwardingHistoryResponse message. Does not implicitly {@link lnrpc.ForwardingHistoryResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse} message ForwardingHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.forwardingEvents != null && message.forwardingEvents.length)
                for (let i = 0; i < message.forwardingEvents.length; ++i)
                    $root.lnrpc.ForwardingEvent.encode(message.forwardingEvents[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lastOffsetIndex != null && message.hasOwnProperty("lastOffsetIndex"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.lastOffsetIndex);
            return writer;
        };

        /**
         * Encodes the specified ForwardingHistoryResponse message, length delimited. Does not implicitly {@link lnrpc.ForwardingHistoryResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.IForwardingHistoryResponse} message ForwardingHistoryResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ForwardingHistoryResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ForwardingHistoryResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ForwardingHistoryResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.forwardingEvents && message.forwardingEvents.length))
                        message.forwardingEvents = [];
                    message.forwardingEvents.push($root.lnrpc.ForwardingEvent.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.lastOffsetIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ForwardingHistoryResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ForwardingHistoryResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ForwardingHistoryResponse message.
         * @function verify
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ForwardingHistoryResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.forwardingEvents != null && message.hasOwnProperty("forwardingEvents")) {
                if (!Array.isArray(message.forwardingEvents))
                    return "forwardingEvents: array expected";
                for (let i = 0; i < message.forwardingEvents.length; ++i) {
                    let error = $root.lnrpc.ForwardingEvent.verify(message.forwardingEvents[i]);
                    if (error)
                        return "forwardingEvents." + error;
                }
            }
            if (message.lastOffsetIndex != null && message.hasOwnProperty("lastOffsetIndex"))
                if (!$util.isInteger(message.lastOffsetIndex))
                    return "lastOffsetIndex: integer expected";
            return null;
        };

        /**
         * Creates a ForwardingHistoryResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ForwardingHistoryResponse} ForwardingHistoryResponse
         */
        ForwardingHistoryResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ForwardingHistoryResponse)
                return object;
            let message = new $root.lnrpc.ForwardingHistoryResponse();
            if (object.forwardingEvents) {
                if (!Array.isArray(object.forwardingEvents))
                    throw TypeError(".lnrpc.ForwardingHistoryResponse.forwardingEvents: array expected");
                message.forwardingEvents = [];
                for (let i = 0; i < object.forwardingEvents.length; ++i) {
                    if (typeof object.forwardingEvents[i] !== "object")
                        throw TypeError(".lnrpc.ForwardingHistoryResponse.forwardingEvents: object expected");
                    message.forwardingEvents[i] = $root.lnrpc.ForwardingEvent.fromObject(object.forwardingEvents[i]);
                }
            }
            if (object.lastOffsetIndex != null)
                message.lastOffsetIndex = object.lastOffsetIndex >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ForwardingHistoryResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ForwardingHistoryResponse
         * @static
         * @param {lnrpc.ForwardingHistoryResponse} message ForwardingHistoryResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ForwardingHistoryResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.forwardingEvents = [];
            if (options.defaults)
                object.lastOffsetIndex = 0;
            if (message.forwardingEvents && message.forwardingEvents.length) {
                object.forwardingEvents = [];
                for (let j = 0; j < message.forwardingEvents.length; ++j)
                    object.forwardingEvents[j] = $root.lnrpc.ForwardingEvent.toObject(message.forwardingEvents[j], options);
            }
            if (message.lastOffsetIndex != null && message.hasOwnProperty("lastOffsetIndex"))
                object.lastOffsetIndex = message.lastOffsetIndex;
            return object;
        };

        /**
         * Converts this ForwardingHistoryResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ForwardingHistoryResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ForwardingHistoryResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ForwardingHistoryResponse;
    })();

    lnrpc.ExportChannelBackupRequest = (function() {

        /**
         * Properties of an ExportChannelBackupRequest.
         * @memberof lnrpc
         * @interface IExportChannelBackupRequest
         * @property {lnrpc.IChannelPoint|null} [chanPoint] The target channel point to obtain a back up for.
         */

        /**
         * Constructs a new ExportChannelBackupRequest.
         * @memberof lnrpc
         * @classdesc Represents an ExportChannelBackupRequest.
         * @implements IExportChannelBackupRequest
         * @constructor
         * @param {lnrpc.IExportChannelBackupRequest=} [properties] Properties to set
         */
        function ExportChannelBackupRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The target channel point to obtain a back up for.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ExportChannelBackupRequest
         * @instance
         */
        ExportChannelBackupRequest.prototype.chanPoint = null;

        /**
         * Creates a new ExportChannelBackupRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {lnrpc.IExportChannelBackupRequest=} [properties] Properties to set
         * @returns {lnrpc.ExportChannelBackupRequest} ExportChannelBackupRequest instance
         */
        ExportChannelBackupRequest.create = function create(properties) {
            return new ExportChannelBackupRequest(properties);
        };

        /**
         * Encodes the specified ExportChannelBackupRequest message. Does not implicitly {@link lnrpc.ExportChannelBackupRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {lnrpc.IExportChannelBackupRequest} message ExportChannelBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportChannelBackupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExportChannelBackupRequest message, length delimited. Does not implicitly {@link lnrpc.ExportChannelBackupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {lnrpc.IExportChannelBackupRequest} message ExportChannelBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExportChannelBackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExportChannelBackupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ExportChannelBackupRequest} ExportChannelBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportChannelBackupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ExportChannelBackupRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExportChannelBackupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ExportChannelBackupRequest} ExportChannelBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExportChannelBackupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExportChannelBackupRequest message.
         * @function verify
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExportChannelBackupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            return null;
        };

        /**
         * Creates an ExportChannelBackupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ExportChannelBackupRequest} ExportChannelBackupRequest
         */
        ExportChannelBackupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ExportChannelBackupRequest)
                return object;
            let message = new $root.lnrpc.ExportChannelBackupRequest();
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ExportChannelBackupRequest.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            return message;
        };

        /**
         * Creates a plain object from an ExportChannelBackupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ExportChannelBackupRequest
         * @static
         * @param {lnrpc.ExportChannelBackupRequest} message ExportChannelBackupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ExportChannelBackupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.chanPoint = null;
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            return object;
        };

        /**
         * Converts this ExportChannelBackupRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ExportChannelBackupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ExportChannelBackupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ExportChannelBackupRequest;
    })();

    lnrpc.ChannelBackup = (function() {

        /**
         * Properties of a ChannelBackup.
         * @memberof lnrpc
         * @interface IChannelBackup
         * @property {lnrpc.IChannelPoint|null} [chanPoint] Identifies the channel that this backup belongs to.
         * @property {Uint8Array|null} [chanBackup] Is an encrypted single-chan backup. this can be passed to
         * RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
         * order to trigger the recovery protocol.
         */

        /**
         * Constructs a new ChannelBackup.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBackup.
         * @implements IChannelBackup
         * @constructor
         * @param {lnrpc.IChannelBackup=} [properties] Properties to set
         */
        function ChannelBackup(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Identifies the channel that this backup belongs to.
         * @member {lnrpc.IChannelPoint|null|undefined} chanPoint
         * @memberof lnrpc.ChannelBackup
         * @instance
         */
        ChannelBackup.prototype.chanPoint = null;

        /**
         * Is an encrypted single-chan backup. this can be passed to
         * RestoreChannelBackups, or the WalletUnlocker Init and Unlock methods in
         * order to trigger the recovery protocol.
         * @member {Uint8Array} chanBackup
         * @memberof lnrpc.ChannelBackup
         * @instance
         */
        ChannelBackup.prototype.chanBackup = $util.newBuffer([]);

        /**
         * Creates a new ChannelBackup instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {lnrpc.IChannelBackup=} [properties] Properties to set
         * @returns {lnrpc.ChannelBackup} ChannelBackup instance
         */
        ChannelBackup.create = function create(properties) {
            return new ChannelBackup(properties);
        };

        /**
         * Encodes the specified ChannelBackup message. Does not implicitly {@link lnrpc.ChannelBackup.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {lnrpc.IChannelBackup} message ChannelBackup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                $root.lnrpc.ChannelPoint.encode(message.chanPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.chanBackup != null && message.hasOwnProperty("chanBackup"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.chanBackup);
            return writer;
        };

        /**
         * Encodes the specified ChannelBackup message, length delimited. Does not implicitly {@link lnrpc.ChannelBackup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {lnrpc.IChannelBackup} message ChannelBackup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBackup message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBackup} ChannelBackup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBackup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanPoint = $root.lnrpc.ChannelPoint.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.chanBackup = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBackup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBackup} ChannelBackup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBackup message.
         * @function verify
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBackup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint")) {
                let error = $root.lnrpc.ChannelPoint.verify(message.chanPoint);
                if (error)
                    return "chanPoint." + error;
            }
            if (message.chanBackup != null && message.hasOwnProperty("chanBackup"))
                if (!(message.chanBackup && typeof message.chanBackup.length === "number" || $util.isString(message.chanBackup)))
                    return "chanBackup: buffer expected";
            return null;
        };

        /**
         * Creates a ChannelBackup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBackup} ChannelBackup
         */
        ChannelBackup.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBackup)
                return object;
            let message = new $root.lnrpc.ChannelBackup();
            if (object.chanPoint != null) {
                if (typeof object.chanPoint !== "object")
                    throw TypeError(".lnrpc.ChannelBackup.chanPoint: object expected");
                message.chanPoint = $root.lnrpc.ChannelPoint.fromObject(object.chanPoint);
            }
            if (object.chanBackup != null)
                if (typeof object.chanBackup === "string")
                    $util.base64.decode(object.chanBackup, message.chanBackup = $util.newBuffer($util.base64.length(object.chanBackup)), 0);
                else if (object.chanBackup.length)
                    message.chanBackup = object.chanBackup;
            return message;
        };

        /**
         * Creates a plain object from a ChannelBackup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBackup
         * @static
         * @param {lnrpc.ChannelBackup} message ChannelBackup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBackup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.chanPoint = null;
                if (options.bytes === String)
                    object.chanBackup = "";
                else {
                    object.chanBackup = [];
                    if (options.bytes !== Array)
                        object.chanBackup = $util.newBuffer(object.chanBackup);
                }
            }
            if (message.chanPoint != null && message.hasOwnProperty("chanPoint"))
                object.chanPoint = $root.lnrpc.ChannelPoint.toObject(message.chanPoint, options);
            if (message.chanBackup != null && message.hasOwnProperty("chanBackup"))
                object.chanBackup = options.bytes === String ? $util.base64.encode(message.chanBackup, 0, message.chanBackup.length) : options.bytes === Array ? Array.prototype.slice.call(message.chanBackup) : message.chanBackup;
            return object;
        };

        /**
         * Converts this ChannelBackup to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBackup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBackup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBackup;
    })();

    lnrpc.MultiChanBackup = (function() {

        /**
         * Properties of a MultiChanBackup.
         * @memberof lnrpc
         * @interface IMultiChanBackup
         * @property {Array.<lnrpc.IChannelPoint>|null} [chanPoints] Is the set of all channels that are included in this multi-channel backup.
         * @property {Uint8Array|null} [multiChanBackup] A single encrypted blob containing all the static channel backups of the
         * channel listed above. This can be stored as a single file or blob, and
         * safely be replaced with any prior/future versions.
         */

        /**
         * Constructs a new MultiChanBackup.
         * @memberof lnrpc
         * @classdesc Represents a MultiChanBackup.
         * @implements IMultiChanBackup
         * @constructor
         * @param {lnrpc.IMultiChanBackup=} [properties] Properties to set
         */
        function MultiChanBackup(properties) {
            this.chanPoints = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Is the set of all channels that are included in this multi-channel backup.
         * @member {Array.<lnrpc.IChannelPoint>} chanPoints
         * @memberof lnrpc.MultiChanBackup
         * @instance
         */
        MultiChanBackup.prototype.chanPoints = $util.emptyArray;

        /**
         * A single encrypted blob containing all the static channel backups of the
         * channel listed above. This can be stored as a single file or blob, and
         * safely be replaced with any prior/future versions.
         * @member {Uint8Array} multiChanBackup
         * @memberof lnrpc.MultiChanBackup
         * @instance
         */
        MultiChanBackup.prototype.multiChanBackup = $util.newBuffer([]);

        /**
         * Creates a new MultiChanBackup instance using the specified properties.
         * @function create
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {lnrpc.IMultiChanBackup=} [properties] Properties to set
         * @returns {lnrpc.MultiChanBackup} MultiChanBackup instance
         */
        MultiChanBackup.create = function create(properties) {
            return new MultiChanBackup(properties);
        };

        /**
         * Encodes the specified MultiChanBackup message. Does not implicitly {@link lnrpc.MultiChanBackup.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {lnrpc.IMultiChanBackup} message MultiChanBackup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiChanBackup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanPoints != null && message.chanPoints.length)
                for (let i = 0; i < message.chanPoints.length; ++i)
                    $root.lnrpc.ChannelPoint.encode(message.chanPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.multiChanBackup);
            return writer;
        };

        /**
         * Encodes the specified MultiChanBackup message, length delimited. Does not implicitly {@link lnrpc.MultiChanBackup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {lnrpc.IMultiChanBackup} message MultiChanBackup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MultiChanBackup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MultiChanBackup message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.MultiChanBackup} MultiChanBackup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiChanBackup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.MultiChanBackup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chanPoints && message.chanPoints.length))
                        message.chanPoints = [];
                    message.chanPoints.push($root.lnrpc.ChannelPoint.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.multiChanBackup = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MultiChanBackup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.MultiChanBackup} MultiChanBackup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultiChanBackup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MultiChanBackup message.
         * @function verify
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MultiChanBackup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanPoints != null && message.hasOwnProperty("chanPoints")) {
                if (!Array.isArray(message.chanPoints))
                    return "chanPoints: array expected";
                for (let i = 0; i < message.chanPoints.length; ++i) {
                    let error = $root.lnrpc.ChannelPoint.verify(message.chanPoints[i]);
                    if (error)
                        return "chanPoints." + error;
                }
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                if (!(message.multiChanBackup && typeof message.multiChanBackup.length === "number" || $util.isString(message.multiChanBackup)))
                    return "multiChanBackup: buffer expected";
            return null;
        };

        /**
         * Creates a MultiChanBackup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.MultiChanBackup} MultiChanBackup
         */
        MultiChanBackup.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.MultiChanBackup)
                return object;
            let message = new $root.lnrpc.MultiChanBackup();
            if (object.chanPoints) {
                if (!Array.isArray(object.chanPoints))
                    throw TypeError(".lnrpc.MultiChanBackup.chanPoints: array expected");
                message.chanPoints = [];
                for (let i = 0; i < object.chanPoints.length; ++i) {
                    if (typeof object.chanPoints[i] !== "object")
                        throw TypeError(".lnrpc.MultiChanBackup.chanPoints: object expected");
                    message.chanPoints[i] = $root.lnrpc.ChannelPoint.fromObject(object.chanPoints[i]);
                }
            }
            if (object.multiChanBackup != null)
                if (typeof object.multiChanBackup === "string")
                    $util.base64.decode(object.multiChanBackup, message.multiChanBackup = $util.newBuffer($util.base64.length(object.multiChanBackup)), 0);
                else if (object.multiChanBackup.length)
                    message.multiChanBackup = object.multiChanBackup;
            return message;
        };

        /**
         * Creates a plain object from a MultiChanBackup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.MultiChanBackup
         * @static
         * @param {lnrpc.MultiChanBackup} message MultiChanBackup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MultiChanBackup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.chanPoints = [];
            if (options.defaults)
                if (options.bytes === String)
                    object.multiChanBackup = "";
                else {
                    object.multiChanBackup = [];
                    if (options.bytes !== Array)
                        object.multiChanBackup = $util.newBuffer(object.multiChanBackup);
                }
            if (message.chanPoints && message.chanPoints.length) {
                object.chanPoints = [];
                for (let j = 0; j < message.chanPoints.length; ++j)
                    object.chanPoints[j] = $root.lnrpc.ChannelPoint.toObject(message.chanPoints[j], options);
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                object.multiChanBackup = options.bytes === String ? $util.base64.encode(message.multiChanBackup, 0, message.multiChanBackup.length) : options.bytes === Array ? Array.prototype.slice.call(message.multiChanBackup) : message.multiChanBackup;
            return object;
        };

        /**
         * Converts this MultiChanBackup to JSON.
         * @function toJSON
         * @memberof lnrpc.MultiChanBackup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MultiChanBackup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MultiChanBackup;
    })();

    lnrpc.ChanBackupExportRequest = (function() {

        /**
         * Properties of a ChanBackupExportRequest.
         * @memberof lnrpc
         * @interface IChanBackupExportRequest
         */

        /**
         * Constructs a new ChanBackupExportRequest.
         * @memberof lnrpc
         * @classdesc Represents a ChanBackupExportRequest.
         * @implements IChanBackupExportRequest
         * @constructor
         * @param {lnrpc.IChanBackupExportRequest=} [properties] Properties to set
         */
        function ChanBackupExportRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChanBackupExportRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {lnrpc.IChanBackupExportRequest=} [properties] Properties to set
         * @returns {lnrpc.ChanBackupExportRequest} ChanBackupExportRequest instance
         */
        ChanBackupExportRequest.create = function create(properties) {
            return new ChanBackupExportRequest(properties);
        };

        /**
         * Encodes the specified ChanBackupExportRequest message. Does not implicitly {@link lnrpc.ChanBackupExportRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {lnrpc.IChanBackupExportRequest} message ChanBackupExportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanBackupExportRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChanBackupExportRequest message, length delimited. Does not implicitly {@link lnrpc.ChanBackupExportRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {lnrpc.IChanBackupExportRequest} message ChanBackupExportRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanBackupExportRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChanBackupExportRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChanBackupExportRequest} ChanBackupExportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanBackupExportRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChanBackupExportRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChanBackupExportRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChanBackupExportRequest} ChanBackupExportRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanBackupExportRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChanBackupExportRequest message.
         * @function verify
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChanBackupExportRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChanBackupExportRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChanBackupExportRequest} ChanBackupExportRequest
         */
        ChanBackupExportRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChanBackupExportRequest)
                return object;
            return new $root.lnrpc.ChanBackupExportRequest();
        };

        /**
         * Creates a plain object from a ChanBackupExportRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChanBackupExportRequest
         * @static
         * @param {lnrpc.ChanBackupExportRequest} message ChanBackupExportRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChanBackupExportRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChanBackupExportRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ChanBackupExportRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChanBackupExportRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChanBackupExportRequest;
    })();

    lnrpc.ChanBackupSnapshot = (function() {

        /**
         * Properties of a ChanBackupSnapshot.
         * @memberof lnrpc
         * @interface IChanBackupSnapshot
         * @property {lnrpc.IChannelBackups|null} [singleChanBackups] The set of new channels that have been added since the last channel backup
         * snapshot was requested.
         * @property {lnrpc.IMultiChanBackup|null} [multiChanBackup] A multi-channel backup that covers all open channels currently known to
         * lnd.
         */

        /**
         * Constructs a new ChanBackupSnapshot.
         * @memberof lnrpc
         * @classdesc Represents a ChanBackupSnapshot.
         * @implements IChanBackupSnapshot
         * @constructor
         * @param {lnrpc.IChanBackupSnapshot=} [properties] Properties to set
         */
        function ChanBackupSnapshot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The set of new channels that have been added since the last channel backup
         * snapshot was requested.
         * @member {lnrpc.IChannelBackups|null|undefined} singleChanBackups
         * @memberof lnrpc.ChanBackupSnapshot
         * @instance
         */
        ChanBackupSnapshot.prototype.singleChanBackups = null;

        /**
         * A multi-channel backup that covers all open channels currently known to
         * lnd.
         * @member {lnrpc.IMultiChanBackup|null|undefined} multiChanBackup
         * @memberof lnrpc.ChanBackupSnapshot
         * @instance
         */
        ChanBackupSnapshot.prototype.multiChanBackup = null;

        /**
         * Creates a new ChanBackupSnapshot instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {lnrpc.IChanBackupSnapshot=} [properties] Properties to set
         * @returns {lnrpc.ChanBackupSnapshot} ChanBackupSnapshot instance
         */
        ChanBackupSnapshot.create = function create(properties) {
            return new ChanBackupSnapshot(properties);
        };

        /**
         * Encodes the specified ChanBackupSnapshot message. Does not implicitly {@link lnrpc.ChanBackupSnapshot.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {lnrpc.IChanBackupSnapshot} message ChanBackupSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanBackupSnapshot.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.singleChanBackups != null && message.hasOwnProperty("singleChanBackups"))
                $root.lnrpc.ChannelBackups.encode(message.singleChanBackups, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                $root.lnrpc.MultiChanBackup.encode(message.multiChanBackup, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChanBackupSnapshot message, length delimited. Does not implicitly {@link lnrpc.ChanBackupSnapshot.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {lnrpc.IChanBackupSnapshot} message ChanBackupSnapshot message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChanBackupSnapshot.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChanBackupSnapshot message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChanBackupSnapshot} ChanBackupSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanBackupSnapshot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChanBackupSnapshot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.singleChanBackups = $root.lnrpc.ChannelBackups.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.multiChanBackup = $root.lnrpc.MultiChanBackup.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChanBackupSnapshot message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChanBackupSnapshot} ChanBackupSnapshot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChanBackupSnapshot.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChanBackupSnapshot message.
         * @function verify
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChanBackupSnapshot.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.singleChanBackups != null && message.hasOwnProperty("singleChanBackups")) {
                let error = $root.lnrpc.ChannelBackups.verify(message.singleChanBackups);
                if (error)
                    return "singleChanBackups." + error;
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup")) {
                let error = $root.lnrpc.MultiChanBackup.verify(message.multiChanBackup);
                if (error)
                    return "multiChanBackup." + error;
            }
            return null;
        };

        /**
         * Creates a ChanBackupSnapshot message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChanBackupSnapshot} ChanBackupSnapshot
         */
        ChanBackupSnapshot.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChanBackupSnapshot)
                return object;
            let message = new $root.lnrpc.ChanBackupSnapshot();
            if (object.singleChanBackups != null) {
                if (typeof object.singleChanBackups !== "object")
                    throw TypeError(".lnrpc.ChanBackupSnapshot.singleChanBackups: object expected");
                message.singleChanBackups = $root.lnrpc.ChannelBackups.fromObject(object.singleChanBackups);
            }
            if (object.multiChanBackup != null) {
                if (typeof object.multiChanBackup !== "object")
                    throw TypeError(".lnrpc.ChanBackupSnapshot.multiChanBackup: object expected");
                message.multiChanBackup = $root.lnrpc.MultiChanBackup.fromObject(object.multiChanBackup);
            }
            return message;
        };

        /**
         * Creates a plain object from a ChanBackupSnapshot message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChanBackupSnapshot
         * @static
         * @param {lnrpc.ChanBackupSnapshot} message ChanBackupSnapshot
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChanBackupSnapshot.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.singleChanBackups = null;
                object.multiChanBackup = null;
            }
            if (message.singleChanBackups != null && message.hasOwnProperty("singleChanBackups"))
                object.singleChanBackups = $root.lnrpc.ChannelBackups.toObject(message.singleChanBackups, options);
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                object.multiChanBackup = $root.lnrpc.MultiChanBackup.toObject(message.multiChanBackup, options);
            return object;
        };

        /**
         * Converts this ChanBackupSnapshot to JSON.
         * @function toJSON
         * @memberof lnrpc.ChanBackupSnapshot
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChanBackupSnapshot.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChanBackupSnapshot;
    })();

    lnrpc.ChannelBackups = (function() {

        /**
         * Properties of a ChannelBackups.
         * @memberof lnrpc
         * @interface IChannelBackups
         * @property {Array.<lnrpc.IChannelBackup>|null} [chanBackups] A set of single-chan static channel backups.
         */

        /**
         * Constructs a new ChannelBackups.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBackups.
         * @implements IChannelBackups
         * @constructor
         * @param {lnrpc.IChannelBackups=} [properties] Properties to set
         */
        function ChannelBackups(properties) {
            this.chanBackups = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * A set of single-chan static channel backups.
         * @member {Array.<lnrpc.IChannelBackup>} chanBackups
         * @memberof lnrpc.ChannelBackups
         * @instance
         */
        ChannelBackups.prototype.chanBackups = $util.emptyArray;

        /**
         * Creates a new ChannelBackups instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {lnrpc.IChannelBackups=} [properties] Properties to set
         * @returns {lnrpc.ChannelBackups} ChannelBackups instance
         */
        ChannelBackups.create = function create(properties) {
            return new ChannelBackups(properties);
        };

        /**
         * Encodes the specified ChannelBackups message. Does not implicitly {@link lnrpc.ChannelBackups.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {lnrpc.IChannelBackups} message ChannelBackups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackups.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanBackups != null && message.chanBackups.length)
                for (let i = 0; i < message.chanBackups.length; ++i)
                    $root.lnrpc.ChannelBackup.encode(message.chanBackups[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChannelBackups message, length delimited. Does not implicitly {@link lnrpc.ChannelBackups.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {lnrpc.IChannelBackups} message ChannelBackups message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackups.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBackups message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBackups} ChannelBackups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackups.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBackups();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chanBackups && message.chanBackups.length))
                        message.chanBackups = [];
                    message.chanBackups.push($root.lnrpc.ChannelBackup.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBackups message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBackups} ChannelBackups
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackups.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBackups message.
         * @function verify
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBackups.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chanBackups != null && message.hasOwnProperty("chanBackups")) {
                if (!Array.isArray(message.chanBackups))
                    return "chanBackups: array expected";
                for (let i = 0; i < message.chanBackups.length; ++i) {
                    let error = $root.lnrpc.ChannelBackup.verify(message.chanBackups[i]);
                    if (error)
                        return "chanBackups." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ChannelBackups message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBackups} ChannelBackups
         */
        ChannelBackups.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBackups)
                return object;
            let message = new $root.lnrpc.ChannelBackups();
            if (object.chanBackups) {
                if (!Array.isArray(object.chanBackups))
                    throw TypeError(".lnrpc.ChannelBackups.chanBackups: array expected");
                message.chanBackups = [];
                for (let i = 0; i < object.chanBackups.length; ++i) {
                    if (typeof object.chanBackups[i] !== "object")
                        throw TypeError(".lnrpc.ChannelBackups.chanBackups: object expected");
                    message.chanBackups[i] = $root.lnrpc.ChannelBackup.fromObject(object.chanBackups[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ChannelBackups message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBackups
         * @static
         * @param {lnrpc.ChannelBackups} message ChannelBackups
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBackups.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.chanBackups = [];
            if (message.chanBackups && message.chanBackups.length) {
                object.chanBackups = [];
                for (let j = 0; j < message.chanBackups.length; ++j)
                    object.chanBackups[j] = $root.lnrpc.ChannelBackup.toObject(message.chanBackups[j], options);
            }
            return object;
        };

        /**
         * Converts this ChannelBackups to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBackups
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBackups.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBackups;
    })();

    lnrpc.RestoreChanBackupRequest = (function() {

        /**
         * Properties of a RestoreChanBackupRequest.
         * @memberof lnrpc
         * @interface IRestoreChanBackupRequest
         * @property {lnrpc.IChannelBackups|null} [chanBackups] RestoreChanBackupRequest chanBackups
         * @property {Uint8Array|null} [multiChanBackup] RestoreChanBackupRequest multiChanBackup
         */

        /**
         * Constructs a new RestoreChanBackupRequest.
         * @memberof lnrpc
         * @classdesc Represents a RestoreChanBackupRequest.
         * @implements IRestoreChanBackupRequest
         * @constructor
         * @param {lnrpc.IRestoreChanBackupRequest=} [properties] Properties to set
         */
        function RestoreChanBackupRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RestoreChanBackupRequest chanBackups.
         * @member {lnrpc.IChannelBackups|null|undefined} chanBackups
         * @memberof lnrpc.RestoreChanBackupRequest
         * @instance
         */
        RestoreChanBackupRequest.prototype.chanBackups = null;

        /**
         * RestoreChanBackupRequest multiChanBackup.
         * @member {Uint8Array} multiChanBackup
         * @memberof lnrpc.RestoreChanBackupRequest
         * @instance
         */
        RestoreChanBackupRequest.prototype.multiChanBackup = $util.newBuffer([]);

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * RestoreChanBackupRequest backup.
         * @member {"chanBackups"|"multiChanBackup"|undefined} backup
         * @memberof lnrpc.RestoreChanBackupRequest
         * @instance
         */
        Object.defineProperty(RestoreChanBackupRequest.prototype, "backup", {
            get: $util.oneOfGetter($oneOfFields = ["chanBackups", "multiChanBackup"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new RestoreChanBackupRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {lnrpc.IRestoreChanBackupRequest=} [properties] Properties to set
         * @returns {lnrpc.RestoreChanBackupRequest} RestoreChanBackupRequest instance
         */
        RestoreChanBackupRequest.create = function create(properties) {
            return new RestoreChanBackupRequest(properties);
        };

        /**
         * Encodes the specified RestoreChanBackupRequest message. Does not implicitly {@link lnrpc.RestoreChanBackupRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {lnrpc.IRestoreChanBackupRequest} message RestoreChanBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreChanBackupRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chanBackups != null && message.hasOwnProperty("chanBackups"))
                $root.lnrpc.ChannelBackups.encode(message.chanBackups, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.multiChanBackup);
            return writer;
        };

        /**
         * Encodes the specified RestoreChanBackupRequest message, length delimited. Does not implicitly {@link lnrpc.RestoreChanBackupRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {lnrpc.IRestoreChanBackupRequest} message RestoreChanBackupRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreChanBackupRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RestoreChanBackupRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RestoreChanBackupRequest} RestoreChanBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreChanBackupRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RestoreChanBackupRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chanBackups = $root.lnrpc.ChannelBackups.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.multiChanBackup = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RestoreChanBackupRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RestoreChanBackupRequest} RestoreChanBackupRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreChanBackupRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RestoreChanBackupRequest message.
         * @function verify
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestoreChanBackupRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.chanBackups != null && message.hasOwnProperty("chanBackups")) {
                properties.backup = 1;
                {
                    let error = $root.lnrpc.ChannelBackups.verify(message.chanBackups);
                    if (error)
                        return "chanBackups." + error;
                }
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup")) {
                if (properties.backup === 1)
                    return "backup: multiple values";
                properties.backup = 1;
                if (!(message.multiChanBackup && typeof message.multiChanBackup.length === "number" || $util.isString(message.multiChanBackup)))
                    return "multiChanBackup: buffer expected";
            }
            return null;
        };

        /**
         * Creates a RestoreChanBackupRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RestoreChanBackupRequest} RestoreChanBackupRequest
         */
        RestoreChanBackupRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RestoreChanBackupRequest)
                return object;
            let message = new $root.lnrpc.RestoreChanBackupRequest();
            if (object.chanBackups != null) {
                if (typeof object.chanBackups !== "object")
                    throw TypeError(".lnrpc.RestoreChanBackupRequest.chanBackups: object expected");
                message.chanBackups = $root.lnrpc.ChannelBackups.fromObject(object.chanBackups);
            }
            if (object.multiChanBackup != null)
                if (typeof object.multiChanBackup === "string")
                    $util.base64.decode(object.multiChanBackup, message.multiChanBackup = $util.newBuffer($util.base64.length(object.multiChanBackup)), 0);
                else if (object.multiChanBackup.length)
                    message.multiChanBackup = object.multiChanBackup;
            return message;
        };

        /**
         * Creates a plain object from a RestoreChanBackupRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RestoreChanBackupRequest
         * @static
         * @param {lnrpc.RestoreChanBackupRequest} message RestoreChanBackupRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RestoreChanBackupRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.chanBackups != null && message.hasOwnProperty("chanBackups")) {
                object.chanBackups = $root.lnrpc.ChannelBackups.toObject(message.chanBackups, options);
                if (options.oneofs)
                    object.backup = "chanBackups";
            }
            if (message.multiChanBackup != null && message.hasOwnProperty("multiChanBackup")) {
                object.multiChanBackup = options.bytes === String ? $util.base64.encode(message.multiChanBackup, 0, message.multiChanBackup.length) : options.bytes === Array ? Array.prototype.slice.call(message.multiChanBackup) : message.multiChanBackup;
                if (options.oneofs)
                    object.backup = "multiChanBackup";
            }
            return object;
        };

        /**
         * Converts this RestoreChanBackupRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.RestoreChanBackupRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RestoreChanBackupRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RestoreChanBackupRequest;
    })();

    lnrpc.RestoreBackupResponse = (function() {

        /**
         * Properties of a RestoreBackupResponse.
         * @memberof lnrpc
         * @interface IRestoreBackupResponse
         */

        /**
         * Constructs a new RestoreBackupResponse.
         * @memberof lnrpc
         * @classdesc Represents a RestoreBackupResponse.
         * @implements IRestoreBackupResponse
         * @constructor
         * @param {lnrpc.IRestoreBackupResponse=} [properties] Properties to set
         */
        function RestoreBackupResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new RestoreBackupResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {lnrpc.IRestoreBackupResponse=} [properties] Properties to set
         * @returns {lnrpc.RestoreBackupResponse} RestoreBackupResponse instance
         */
        RestoreBackupResponse.create = function create(properties) {
            return new RestoreBackupResponse(properties);
        };

        /**
         * Encodes the specified RestoreBackupResponse message. Does not implicitly {@link lnrpc.RestoreBackupResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {lnrpc.IRestoreBackupResponse} message RestoreBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreBackupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified RestoreBackupResponse message, length delimited. Does not implicitly {@link lnrpc.RestoreBackupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {lnrpc.IRestoreBackupResponse} message RestoreBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoreBackupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RestoreBackupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.RestoreBackupResponse} RestoreBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreBackupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.RestoreBackupResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RestoreBackupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.RestoreBackupResponse} RestoreBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoreBackupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RestoreBackupResponse message.
         * @function verify
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestoreBackupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a RestoreBackupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.RestoreBackupResponse} RestoreBackupResponse
         */
        RestoreBackupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.RestoreBackupResponse)
                return object;
            return new $root.lnrpc.RestoreBackupResponse();
        };

        /**
         * Creates a plain object from a RestoreBackupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.RestoreBackupResponse
         * @static
         * @param {lnrpc.RestoreBackupResponse} message RestoreBackupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RestoreBackupResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this RestoreBackupResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.RestoreBackupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RestoreBackupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RestoreBackupResponse;
    })();

    lnrpc.ChannelBackupSubscription = (function() {

        /**
         * Properties of a ChannelBackupSubscription.
         * @memberof lnrpc
         * @interface IChannelBackupSubscription
         */

        /**
         * Constructs a new ChannelBackupSubscription.
         * @memberof lnrpc
         * @classdesc Represents a ChannelBackupSubscription.
         * @implements IChannelBackupSubscription
         * @constructor
         * @param {lnrpc.IChannelBackupSubscription=} [properties] Properties to set
         */
        function ChannelBackupSubscription(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ChannelBackupSubscription instance using the specified properties.
         * @function create
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {lnrpc.IChannelBackupSubscription=} [properties] Properties to set
         * @returns {lnrpc.ChannelBackupSubscription} ChannelBackupSubscription instance
         */
        ChannelBackupSubscription.create = function create(properties) {
            return new ChannelBackupSubscription(properties);
        };

        /**
         * Encodes the specified ChannelBackupSubscription message. Does not implicitly {@link lnrpc.ChannelBackupSubscription.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {lnrpc.IChannelBackupSubscription} message ChannelBackupSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackupSubscription.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ChannelBackupSubscription message, length delimited. Does not implicitly {@link lnrpc.ChannelBackupSubscription.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {lnrpc.IChannelBackupSubscription} message ChannelBackupSubscription message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChannelBackupSubscription.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChannelBackupSubscription message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ChannelBackupSubscription} ChannelBackupSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackupSubscription.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ChannelBackupSubscription();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChannelBackupSubscription message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ChannelBackupSubscription} ChannelBackupSubscription
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChannelBackupSubscription.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChannelBackupSubscription message.
         * @function verify
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChannelBackupSubscription.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ChannelBackupSubscription message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ChannelBackupSubscription} ChannelBackupSubscription
         */
        ChannelBackupSubscription.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ChannelBackupSubscription)
                return object;
            return new $root.lnrpc.ChannelBackupSubscription();
        };

        /**
         * Creates a plain object from a ChannelBackupSubscription message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ChannelBackupSubscription
         * @static
         * @param {lnrpc.ChannelBackupSubscription} message ChannelBackupSubscription
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChannelBackupSubscription.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ChannelBackupSubscription to JSON.
         * @function toJSON
         * @memberof lnrpc.ChannelBackupSubscription
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChannelBackupSubscription.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ChannelBackupSubscription;
    })();

    lnrpc.VerifyChanBackupResponse = (function() {

        /**
         * Properties of a VerifyChanBackupResponse.
         * @memberof lnrpc
         * @interface IVerifyChanBackupResponse
         */

        /**
         * Constructs a new VerifyChanBackupResponse.
         * @memberof lnrpc
         * @classdesc Represents a VerifyChanBackupResponse.
         * @implements IVerifyChanBackupResponse
         * @constructor
         * @param {lnrpc.IVerifyChanBackupResponse=} [properties] Properties to set
         */
        function VerifyChanBackupResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new VerifyChanBackupResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {lnrpc.IVerifyChanBackupResponse=} [properties] Properties to set
         * @returns {lnrpc.VerifyChanBackupResponse} VerifyChanBackupResponse instance
         */
        VerifyChanBackupResponse.create = function create(properties) {
            return new VerifyChanBackupResponse(properties);
        };

        /**
         * Encodes the specified VerifyChanBackupResponse message. Does not implicitly {@link lnrpc.VerifyChanBackupResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {lnrpc.IVerifyChanBackupResponse} message VerifyChanBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyChanBackupResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified VerifyChanBackupResponse message, length delimited. Does not implicitly {@link lnrpc.VerifyChanBackupResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {lnrpc.IVerifyChanBackupResponse} message VerifyChanBackupResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VerifyChanBackupResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VerifyChanBackupResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.VerifyChanBackupResponse} VerifyChanBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyChanBackupResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.VerifyChanBackupResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VerifyChanBackupResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.VerifyChanBackupResponse} VerifyChanBackupResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VerifyChanBackupResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VerifyChanBackupResponse message.
         * @function verify
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VerifyChanBackupResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a VerifyChanBackupResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.VerifyChanBackupResponse} VerifyChanBackupResponse
         */
        VerifyChanBackupResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.VerifyChanBackupResponse)
                return object;
            return new $root.lnrpc.VerifyChanBackupResponse();
        };

        /**
         * Creates a plain object from a VerifyChanBackupResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.VerifyChanBackupResponse
         * @static
         * @param {lnrpc.VerifyChanBackupResponse} message VerifyChanBackupResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        VerifyChanBackupResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this VerifyChanBackupResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.VerifyChanBackupResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        VerifyChanBackupResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return VerifyChanBackupResponse;
    })();

    lnrpc.Autopilot = (function() {

        /**
         * Constructs a new Autopilot service.
         * @memberof lnrpc
         * @classdesc Represents an Autopilot
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function Autopilot(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (Autopilot.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = Autopilot;

        /**
         * Creates new Autopilot service using the specified rpc implementation.
         * @function create
         * @memberof lnrpc.Autopilot
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {Autopilot} RPC service. Useful where requests and/or responses are streamed.
         */
        Autopilot.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link lnrpc.Autopilot#status}.
         * @memberof lnrpc.Autopilot
         * @typedef StatusCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.StatusResponse} [response] StatusResponse
         */

        /**
         * Status returns whether the daemon's autopilot agent is active.
         * @function status
         * @memberof lnrpc.Autopilot
         * @instance
         * @param {lnrpc.IStatusRequest} request StatusRequest message or plain object
         * @param {lnrpc.Autopilot.StatusCallback} callback Node-style callback called with the error, if any, and StatusResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Autopilot.prototype.status = function status(request, callback) {
            return this.rpcCall(status, $root.lnrpc.StatusRequest, $root.lnrpc.StatusResponse, request, callback);
        }, "name", { value: "Status" });

        /**
         * Status returns whether the daemon's autopilot agent is active.
         * @function status
         * @memberof lnrpc.Autopilot
         * @instance
         * @param {lnrpc.IStatusRequest} request StatusRequest message or plain object
         * @returns {Promise<lnrpc.StatusResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Autopilot#modifyStatus}.
         * @memberof lnrpc.Autopilot
         * @typedef ModifyStatusCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.ModifyStatusResponse} [response] ModifyStatusResponse
         */

        /**
         * ModifyStatus is used to modify the status of the autopilot agent, like
         * enabling or disabling it.
         * @function modifyStatus
         * @memberof lnrpc.Autopilot
         * @instance
         * @param {lnrpc.IModifyStatusRequest} request ModifyStatusRequest message or plain object
         * @param {lnrpc.Autopilot.ModifyStatusCallback} callback Node-style callback called with the error, if any, and ModifyStatusResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Autopilot.prototype.modifyStatus = function modifyStatus(request, callback) {
            return this.rpcCall(modifyStatus, $root.lnrpc.ModifyStatusRequest, $root.lnrpc.ModifyStatusResponse, request, callback);
        }, "name", { value: "ModifyStatus" });

        /**
         * ModifyStatus is used to modify the status of the autopilot agent, like
         * enabling or disabling it.
         * @function modifyStatus
         * @memberof lnrpc.Autopilot
         * @instance
         * @param {lnrpc.IModifyStatusRequest} request ModifyStatusRequest message or plain object
         * @returns {Promise<lnrpc.ModifyStatusResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Autopilot#queryScores}.
         * @memberof lnrpc.Autopilot
         * @typedef QueryScoresCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.QueryScoresResponse} [response] QueryScoresResponse
         */

        /**
         * QueryScores queries all available autopilot heuristics, in addition to any
         * active combination of these heruristics, for the scores they would give to
         * the given nodes.
         * @function queryScores
         * @memberof lnrpc.Autopilot
         * @instance
         * @param {lnrpc.IQueryScoresRequest} request QueryScoresRequest message or plain object
         * @param {lnrpc.Autopilot.QueryScoresCallback} callback Node-style callback called with the error, if any, and QueryScoresResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Autopilot.prototype.queryScores = function queryScores(request, callback) {
            return this.rpcCall(queryScores, $root.lnrpc.QueryScoresRequest, $root.lnrpc.QueryScoresResponse, request, callback);
        }, "name", { value: "QueryScores" });

        /**
         * QueryScores queries all available autopilot heuristics, in addition to any
         * active combination of these heruristics, for the scores they would give to
         * the given nodes.
         * @function queryScores
         * @memberof lnrpc.Autopilot
         * @instance
         * @param {lnrpc.IQueryScoresRequest} request QueryScoresRequest message or plain object
         * @returns {Promise<lnrpc.QueryScoresResponse>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link lnrpc.Autopilot#setScores}.
         * @memberof lnrpc.Autopilot
         * @typedef SetScoresCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {lnrpc.SetScoresResponse} [response] SetScoresResponse
         */

        /**
         * SetScores attempts to set the scores used by the running autopilot agent,
         * if the external scoring heuristic is enabled.
         * @function setScores
         * @memberof lnrpc.Autopilot
         * @instance
         * @param {lnrpc.ISetScoresRequest} request SetScoresRequest message or plain object
         * @param {lnrpc.Autopilot.SetScoresCallback} callback Node-style callback called with the error, if any, and SetScoresResponse
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(Autopilot.prototype.setScores = function setScores(request, callback) {
            return this.rpcCall(setScores, $root.lnrpc.SetScoresRequest, $root.lnrpc.SetScoresResponse, request, callback);
        }, "name", { value: "SetScores" });

        /**
         * SetScores attempts to set the scores used by the running autopilot agent,
         * if the external scoring heuristic is enabled.
         * @function setScores
         * @memberof lnrpc.Autopilot
         * @instance
         * @param {lnrpc.ISetScoresRequest} request SetScoresRequest message or plain object
         * @returns {Promise<lnrpc.SetScoresResponse>} Promise
         * @variation 2
         */

        return Autopilot;
    })();

    lnrpc.StatusRequest = (function() {

        /**
         * Properties of a StatusRequest.
         * @memberof lnrpc
         * @interface IStatusRequest
         */

        /**
         * Constructs a new StatusRequest.
         * @memberof lnrpc
         * @classdesc Represents a StatusRequest.
         * @implements IStatusRequest
         * @constructor
         * @param {lnrpc.IStatusRequest=} [properties] Properties to set
         */
        function StatusRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new StatusRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.StatusRequest
         * @static
         * @param {lnrpc.IStatusRequest=} [properties] Properties to set
         * @returns {lnrpc.StatusRequest} StatusRequest instance
         */
        StatusRequest.create = function create(properties) {
            return new StatusRequest(properties);
        };

        /**
         * Encodes the specified StatusRequest message. Does not implicitly {@link lnrpc.StatusRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.StatusRequest
         * @static
         * @param {lnrpc.IStatusRequest} message StatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified StatusRequest message, length delimited. Does not implicitly {@link lnrpc.StatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.StatusRequest
         * @static
         * @param {lnrpc.IStatusRequest} message StatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.StatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.StatusRequest} StatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.StatusRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.StatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.StatusRequest} StatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StatusRequest message.
         * @function verify
         * @memberof lnrpc.StatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a StatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.StatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.StatusRequest} StatusRequest
         */
        StatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.StatusRequest)
                return object;
            return new $root.lnrpc.StatusRequest();
        };

        /**
         * Creates a plain object from a StatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.StatusRequest
         * @static
         * @param {lnrpc.StatusRequest} message StatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StatusRequest.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this StatusRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.StatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StatusRequest;
    })();

    lnrpc.StatusResponse = (function() {

        /**
         * Properties of a StatusResponse.
         * @memberof lnrpc
         * @interface IStatusResponse
         * @property {boolean|null} [active] Indicates whether the autopilot is active or not.
         */

        /**
         * Constructs a new StatusResponse.
         * @memberof lnrpc
         * @classdesc Represents a StatusResponse.
         * @implements IStatusResponse
         * @constructor
         * @param {lnrpc.IStatusResponse=} [properties] Properties to set
         */
        function StatusResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Indicates whether the autopilot is active or not.
         * @member {boolean} active
         * @memberof lnrpc.StatusResponse
         * @instance
         */
        StatusResponse.prototype.active = false;

        /**
         * Creates a new StatusResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.StatusResponse
         * @static
         * @param {lnrpc.IStatusResponse=} [properties] Properties to set
         * @returns {lnrpc.StatusResponse} StatusResponse instance
         */
        StatusResponse.create = function create(properties) {
            return new StatusResponse(properties);
        };

        /**
         * Encodes the specified StatusResponse message. Does not implicitly {@link lnrpc.StatusResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.StatusResponse
         * @static
         * @param {lnrpc.IStatusResponse} message StatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.active != null && message.hasOwnProperty("active"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.active);
            return writer;
        };

        /**
         * Encodes the specified StatusResponse message, length delimited. Does not implicitly {@link lnrpc.StatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.StatusResponse
         * @static
         * @param {lnrpc.IStatusResponse} message StatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.StatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.StatusResponse} StatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.StatusResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.active = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.StatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.StatusResponse} StatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StatusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StatusResponse message.
         * @function verify
         * @memberof lnrpc.StatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StatusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.active != null && message.hasOwnProperty("active"))
                if (typeof message.active !== "boolean")
                    return "active: boolean expected";
            return null;
        };

        /**
         * Creates a StatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.StatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.StatusResponse} StatusResponse
         */
        StatusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.StatusResponse)
                return object;
            let message = new $root.lnrpc.StatusResponse();
            if (object.active != null)
                message.active = Boolean(object.active);
            return message;
        };

        /**
         * Creates a plain object from a StatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.StatusResponse
         * @static
         * @param {lnrpc.StatusResponse} message StatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StatusResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.active = false;
            if (message.active != null && message.hasOwnProperty("active"))
                object.active = message.active;
            return object;
        };

        /**
         * Converts this StatusResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.StatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StatusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StatusResponse;
    })();

    lnrpc.ModifyStatusRequest = (function() {

        /**
         * Properties of a ModifyStatusRequest.
         * @memberof lnrpc
         * @interface IModifyStatusRequest
         * @property {boolean|null} [enable] Whether the autopilot agent should be enabled or not.
         */

        /**
         * Constructs a new ModifyStatusRequest.
         * @memberof lnrpc
         * @classdesc Represents a ModifyStatusRequest.
         * @implements IModifyStatusRequest
         * @constructor
         * @param {lnrpc.IModifyStatusRequest=} [properties] Properties to set
         */
        function ModifyStatusRequest(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Whether the autopilot agent should be enabled or not.
         * @member {boolean} enable
         * @memberof lnrpc.ModifyStatusRequest
         * @instance
         */
        ModifyStatusRequest.prototype.enable = false;

        /**
         * Creates a new ModifyStatusRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.ModifyStatusRequest
         * @static
         * @param {lnrpc.IModifyStatusRequest=} [properties] Properties to set
         * @returns {lnrpc.ModifyStatusRequest} ModifyStatusRequest instance
         */
        ModifyStatusRequest.create = function create(properties) {
            return new ModifyStatusRequest(properties);
        };

        /**
         * Encodes the specified ModifyStatusRequest message. Does not implicitly {@link lnrpc.ModifyStatusRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ModifyStatusRequest
         * @static
         * @param {lnrpc.IModifyStatusRequest} message ModifyStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyStatusRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enable != null && message.hasOwnProperty("enable"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enable);
            return writer;
        };

        /**
         * Encodes the specified ModifyStatusRequest message, length delimited. Does not implicitly {@link lnrpc.ModifyStatusRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ModifyStatusRequest
         * @static
         * @param {lnrpc.IModifyStatusRequest} message ModifyStatusRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyStatusRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyStatusRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ModifyStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ModifyStatusRequest} ModifyStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyStatusRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ModifyStatusRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.enable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyStatusRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ModifyStatusRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ModifyStatusRequest} ModifyStatusRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyStatusRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyStatusRequest message.
         * @function verify
         * @memberof lnrpc.ModifyStatusRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyStatusRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enable != null && message.hasOwnProperty("enable"))
                if (typeof message.enable !== "boolean")
                    return "enable: boolean expected";
            return null;
        };

        /**
         * Creates a ModifyStatusRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ModifyStatusRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ModifyStatusRequest} ModifyStatusRequest
         */
        ModifyStatusRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ModifyStatusRequest)
                return object;
            let message = new $root.lnrpc.ModifyStatusRequest();
            if (object.enable != null)
                message.enable = Boolean(object.enable);
            return message;
        };

        /**
         * Creates a plain object from a ModifyStatusRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ModifyStatusRequest
         * @static
         * @param {lnrpc.ModifyStatusRequest} message ModifyStatusRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyStatusRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.enable = false;
            if (message.enable != null && message.hasOwnProperty("enable"))
                object.enable = message.enable;
            return object;
        };

        /**
         * Converts this ModifyStatusRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.ModifyStatusRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyStatusRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyStatusRequest;
    })();

    lnrpc.ModifyStatusResponse = (function() {

        /**
         * Properties of a ModifyStatusResponse.
         * @memberof lnrpc
         * @interface IModifyStatusResponse
         */

        /**
         * Constructs a new ModifyStatusResponse.
         * @memberof lnrpc
         * @classdesc Represents a ModifyStatusResponse.
         * @implements IModifyStatusResponse
         * @constructor
         * @param {lnrpc.IModifyStatusResponse=} [properties] Properties to set
         */
        function ModifyStatusResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new ModifyStatusResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.ModifyStatusResponse
         * @static
         * @param {lnrpc.IModifyStatusResponse=} [properties] Properties to set
         * @returns {lnrpc.ModifyStatusResponse} ModifyStatusResponse instance
         */
        ModifyStatusResponse.create = function create(properties) {
            return new ModifyStatusResponse(properties);
        };

        /**
         * Encodes the specified ModifyStatusResponse message. Does not implicitly {@link lnrpc.ModifyStatusResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.ModifyStatusResponse
         * @static
         * @param {lnrpc.IModifyStatusResponse} message ModifyStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyStatusResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified ModifyStatusResponse message, length delimited. Does not implicitly {@link lnrpc.ModifyStatusResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.ModifyStatusResponse
         * @static
         * @param {lnrpc.IModifyStatusResponse} message ModifyStatusResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyStatusResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyStatusResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.ModifyStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.ModifyStatusResponse} ModifyStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyStatusResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.ModifyStatusResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyStatusResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.ModifyStatusResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.ModifyStatusResponse} ModifyStatusResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyStatusResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyStatusResponse message.
         * @function verify
         * @memberof lnrpc.ModifyStatusResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyStatusResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a ModifyStatusResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.ModifyStatusResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.ModifyStatusResponse} ModifyStatusResponse
         */
        ModifyStatusResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.ModifyStatusResponse)
                return object;
            return new $root.lnrpc.ModifyStatusResponse();
        };

        /**
         * Creates a plain object from a ModifyStatusResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.ModifyStatusResponse
         * @static
         * @param {lnrpc.ModifyStatusResponse} message ModifyStatusResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ModifyStatusResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this ModifyStatusResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.ModifyStatusResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ModifyStatusResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return ModifyStatusResponse;
    })();

    lnrpc.QueryScoresRequest = (function() {

        /**
         * Properties of a QueryScoresRequest.
         * @memberof lnrpc
         * @interface IQueryScoresRequest
         * @property {Array.<string>|null} [pubkeys] QueryScoresRequest pubkeys
         * @property {boolean|null} [ignoreLocalState] If set, we will ignore the local channel state when calculating scores.
         */

        /**
         * Constructs a new QueryScoresRequest.
         * @memberof lnrpc
         * @classdesc Represents a QueryScoresRequest.
         * @implements IQueryScoresRequest
         * @constructor
         * @param {lnrpc.IQueryScoresRequest=} [properties] Properties to set
         */
        function QueryScoresRequest(properties) {
            this.pubkeys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryScoresRequest pubkeys.
         * @member {Array.<string>} pubkeys
         * @memberof lnrpc.QueryScoresRequest
         * @instance
         */
        QueryScoresRequest.prototype.pubkeys = $util.emptyArray;

        /**
         * If set, we will ignore the local channel state when calculating scores.
         * @member {boolean} ignoreLocalState
         * @memberof lnrpc.QueryScoresRequest
         * @instance
         */
        QueryScoresRequest.prototype.ignoreLocalState = false;

        /**
         * Creates a new QueryScoresRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.QueryScoresRequest
         * @static
         * @param {lnrpc.IQueryScoresRequest=} [properties] Properties to set
         * @returns {lnrpc.QueryScoresRequest} QueryScoresRequest instance
         */
        QueryScoresRequest.create = function create(properties) {
            return new QueryScoresRequest(properties);
        };

        /**
         * Encodes the specified QueryScoresRequest message. Does not implicitly {@link lnrpc.QueryScoresRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.QueryScoresRequest
         * @static
         * @param {lnrpc.IQueryScoresRequest} message QueryScoresRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryScoresRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pubkeys != null && message.pubkeys.length)
                for (let i = 0; i < message.pubkeys.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.pubkeys[i]);
            if (message.ignoreLocalState != null && message.hasOwnProperty("ignoreLocalState"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ignoreLocalState);
            return writer;
        };

        /**
         * Encodes the specified QueryScoresRequest message, length delimited. Does not implicitly {@link lnrpc.QueryScoresRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.QueryScoresRequest
         * @static
         * @param {lnrpc.IQueryScoresRequest} message QueryScoresRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryScoresRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryScoresRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.QueryScoresRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.QueryScoresRequest} QueryScoresRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryScoresRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryScoresRequest();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.pubkeys && message.pubkeys.length))
                        message.pubkeys = [];
                    message.pubkeys.push(reader.string());
                    break;
                case 2:
                    message.ignoreLocalState = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryScoresRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.QueryScoresRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.QueryScoresRequest} QueryScoresRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryScoresRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryScoresRequest message.
         * @function verify
         * @memberof lnrpc.QueryScoresRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryScoresRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pubkeys != null && message.hasOwnProperty("pubkeys")) {
                if (!Array.isArray(message.pubkeys))
                    return "pubkeys: array expected";
                for (let i = 0; i < message.pubkeys.length; ++i)
                    if (!$util.isString(message.pubkeys[i]))
                        return "pubkeys: string[] expected";
            }
            if (message.ignoreLocalState != null && message.hasOwnProperty("ignoreLocalState"))
                if (typeof message.ignoreLocalState !== "boolean")
                    return "ignoreLocalState: boolean expected";
            return null;
        };

        /**
         * Creates a QueryScoresRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.QueryScoresRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.QueryScoresRequest} QueryScoresRequest
         */
        QueryScoresRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.QueryScoresRequest)
                return object;
            let message = new $root.lnrpc.QueryScoresRequest();
            if (object.pubkeys) {
                if (!Array.isArray(object.pubkeys))
                    throw TypeError(".lnrpc.QueryScoresRequest.pubkeys: array expected");
                message.pubkeys = [];
                for (let i = 0; i < object.pubkeys.length; ++i)
                    message.pubkeys[i] = String(object.pubkeys[i]);
            }
            if (object.ignoreLocalState != null)
                message.ignoreLocalState = Boolean(object.ignoreLocalState);
            return message;
        };

        /**
         * Creates a plain object from a QueryScoresRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.QueryScoresRequest
         * @static
         * @param {lnrpc.QueryScoresRequest} message QueryScoresRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryScoresRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.pubkeys = [];
            if (options.defaults)
                object.ignoreLocalState = false;
            if (message.pubkeys && message.pubkeys.length) {
                object.pubkeys = [];
                for (let j = 0; j < message.pubkeys.length; ++j)
                    object.pubkeys[j] = message.pubkeys[j];
            }
            if (message.ignoreLocalState != null && message.hasOwnProperty("ignoreLocalState"))
                object.ignoreLocalState = message.ignoreLocalState;
            return object;
        };

        /**
         * Converts this QueryScoresRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.QueryScoresRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryScoresRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return QueryScoresRequest;
    })();

    lnrpc.QueryScoresResponse = (function() {

        /**
         * Properties of a QueryScoresResponse.
         * @memberof lnrpc
         * @interface IQueryScoresResponse
         * @property {Array.<lnrpc.QueryScoresResponse.IHeuristicResult>|null} [results] QueryScoresResponse results
         */

        /**
         * Constructs a new QueryScoresResponse.
         * @memberof lnrpc
         * @classdesc Represents a QueryScoresResponse.
         * @implements IQueryScoresResponse
         * @constructor
         * @param {lnrpc.IQueryScoresResponse=} [properties] Properties to set
         */
        function QueryScoresResponse(properties) {
            this.results = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryScoresResponse results.
         * @member {Array.<lnrpc.QueryScoresResponse.IHeuristicResult>} results
         * @memberof lnrpc.QueryScoresResponse
         * @instance
         */
        QueryScoresResponse.prototype.results = $util.emptyArray;

        /**
         * Creates a new QueryScoresResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.QueryScoresResponse
         * @static
         * @param {lnrpc.IQueryScoresResponse=} [properties] Properties to set
         * @returns {lnrpc.QueryScoresResponse} QueryScoresResponse instance
         */
        QueryScoresResponse.create = function create(properties) {
            return new QueryScoresResponse(properties);
        };

        /**
         * Encodes the specified QueryScoresResponse message. Does not implicitly {@link lnrpc.QueryScoresResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.QueryScoresResponse
         * @static
         * @param {lnrpc.IQueryScoresResponse} message QueryScoresResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryScoresResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.results != null && message.results.length)
                for (let i = 0; i < message.results.length; ++i)
                    $root.lnrpc.QueryScoresResponse.HeuristicResult.encode(message.results[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryScoresResponse message, length delimited. Does not implicitly {@link lnrpc.QueryScoresResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.QueryScoresResponse
         * @static
         * @param {lnrpc.IQueryScoresResponse} message QueryScoresResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryScoresResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryScoresResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.QueryScoresResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.QueryScoresResponse} QueryScoresResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryScoresResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryScoresResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.results && message.results.length))
                        message.results = [];
                    message.results.push($root.lnrpc.QueryScoresResponse.HeuristicResult.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryScoresResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.QueryScoresResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.QueryScoresResponse} QueryScoresResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryScoresResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryScoresResponse message.
         * @function verify
         * @memberof lnrpc.QueryScoresResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryScoresResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.results != null && message.hasOwnProperty("results")) {
                if (!Array.isArray(message.results))
                    return "results: array expected";
                for (let i = 0; i < message.results.length; ++i) {
                    let error = $root.lnrpc.QueryScoresResponse.HeuristicResult.verify(message.results[i]);
                    if (error)
                        return "results." + error;
                }
            }
            return null;
        };

        /**
         * Creates a QueryScoresResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.QueryScoresResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.QueryScoresResponse} QueryScoresResponse
         */
        QueryScoresResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.QueryScoresResponse)
                return object;
            let message = new $root.lnrpc.QueryScoresResponse();
            if (object.results) {
                if (!Array.isArray(object.results))
                    throw TypeError(".lnrpc.QueryScoresResponse.results: array expected");
                message.results = [];
                for (let i = 0; i < object.results.length; ++i) {
                    if (typeof object.results[i] !== "object")
                        throw TypeError(".lnrpc.QueryScoresResponse.results: object expected");
                    message.results[i] = $root.lnrpc.QueryScoresResponse.HeuristicResult.fromObject(object.results[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a QueryScoresResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.QueryScoresResponse
         * @static
         * @param {lnrpc.QueryScoresResponse} message QueryScoresResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        QueryScoresResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.results = [];
            if (message.results && message.results.length) {
                object.results = [];
                for (let j = 0; j < message.results.length; ++j)
                    object.results[j] = $root.lnrpc.QueryScoresResponse.HeuristicResult.toObject(message.results[j], options);
            }
            return object;
        };

        /**
         * Converts this QueryScoresResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.QueryScoresResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        QueryScoresResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        QueryScoresResponse.HeuristicResult = (function() {

            /**
             * Properties of a HeuristicResult.
             * @memberof lnrpc.QueryScoresResponse
             * @interface IHeuristicResult
             * @property {string|null} [heuristic] HeuristicResult heuristic
             * @property {Object.<string,number>|null} [scores] HeuristicResult scores
             */

            /**
             * Constructs a new HeuristicResult.
             * @memberof lnrpc.QueryScoresResponse
             * @classdesc Represents a HeuristicResult.
             * @implements IHeuristicResult
             * @constructor
             * @param {lnrpc.QueryScoresResponse.IHeuristicResult=} [properties] Properties to set
             */
            function HeuristicResult(properties) {
                this.scores = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HeuristicResult heuristic.
             * @member {string} heuristic
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @instance
             */
            HeuristicResult.prototype.heuristic = "";

            /**
             * HeuristicResult scores.
             * @member {Object.<string,number>} scores
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @instance
             */
            HeuristicResult.prototype.scores = $util.emptyObject;

            /**
             * Creates a new HeuristicResult instance using the specified properties.
             * @function create
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @static
             * @param {lnrpc.QueryScoresResponse.IHeuristicResult=} [properties] Properties to set
             * @returns {lnrpc.QueryScoresResponse.HeuristicResult} HeuristicResult instance
             */
            HeuristicResult.create = function create(properties) {
                return new HeuristicResult(properties);
            };

            /**
             * Encodes the specified HeuristicResult message. Does not implicitly {@link lnrpc.QueryScoresResponse.HeuristicResult.verify|verify} messages.
             * @function encode
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @static
             * @param {lnrpc.QueryScoresResponse.IHeuristicResult} message HeuristicResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeuristicResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.heuristic != null && message.hasOwnProperty("heuristic"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.heuristic);
                if (message.scores != null && message.hasOwnProperty("scores"))
                    for (let keys = Object.keys(message.scores), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 1 =*/17).double(message.scores[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HeuristicResult message, length delimited. Does not implicitly {@link lnrpc.QueryScoresResponse.HeuristicResult.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @static
             * @param {lnrpc.QueryScoresResponse.IHeuristicResult} message HeuristicResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeuristicResult.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HeuristicResult message from the specified reader or buffer.
             * @function decode
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lnrpc.QueryScoresResponse.HeuristicResult} HeuristicResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeuristicResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.QueryScoresResponse.HeuristicResult(), key;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.heuristic = reader.string();
                        break;
                    case 2:
                        reader.skip().pos++;
                        if (message.scores === $util.emptyObject)
                            message.scores = {};
                        key = reader.string();
                        reader.pos++;
                        message.scores[key] = reader.double();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HeuristicResult message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lnrpc.QueryScoresResponse.HeuristicResult} HeuristicResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeuristicResult.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HeuristicResult message.
             * @function verify
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HeuristicResult.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.heuristic != null && message.hasOwnProperty("heuristic"))
                    if (!$util.isString(message.heuristic))
                        return "heuristic: string expected";
                if (message.scores != null && message.hasOwnProperty("scores")) {
                    if (!$util.isObject(message.scores))
                        return "scores: object expected";
                    let key = Object.keys(message.scores);
                    for (let i = 0; i < key.length; ++i)
                        if (typeof message.scores[key[i]] !== "number")
                            return "scores: number{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a HeuristicResult message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lnrpc.QueryScoresResponse.HeuristicResult} HeuristicResult
             */
            HeuristicResult.fromObject = function fromObject(object) {
                if (object instanceof $root.lnrpc.QueryScoresResponse.HeuristicResult)
                    return object;
                let message = new $root.lnrpc.QueryScoresResponse.HeuristicResult();
                if (object.heuristic != null)
                    message.heuristic = String(object.heuristic);
                if (object.scores) {
                    if (typeof object.scores !== "object")
                        throw TypeError(".lnrpc.QueryScoresResponse.HeuristicResult.scores: object expected");
                    message.scores = {};
                    for (let keys = Object.keys(object.scores), i = 0; i < keys.length; ++i)
                        message.scores[keys[i]] = Number(object.scores[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a HeuristicResult message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @static
             * @param {lnrpc.QueryScoresResponse.HeuristicResult} message HeuristicResult
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HeuristicResult.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.scores = {};
                if (options.defaults)
                    object.heuristic = "";
                if (message.heuristic != null && message.hasOwnProperty("heuristic"))
                    object.heuristic = message.heuristic;
                let keys2;
                if (message.scores && (keys2 = Object.keys(message.scores)).length) {
                    object.scores = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.scores[keys2[j]] = options.json && !isFinite(message.scores[keys2[j]]) ? String(message.scores[keys2[j]]) : message.scores[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this HeuristicResult to JSON.
             * @function toJSON
             * @memberof lnrpc.QueryScoresResponse.HeuristicResult
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HeuristicResult.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HeuristicResult;
        })();

        return QueryScoresResponse;
    })();

    lnrpc.SetScoresRequest = (function() {

        /**
         * Properties of a SetScoresRequest.
         * @memberof lnrpc
         * @interface ISetScoresRequest
         * @property {string|null} [heuristic] The name of the heuristic to provide scores to.
         * @property {Object.<string,number>|null} [scores] A map from hex-encoded public keys to scores. Scores must be in the range
         * [0.0, 1.0].
         */

        /**
         * Constructs a new SetScoresRequest.
         * @memberof lnrpc
         * @classdesc Represents a SetScoresRequest.
         * @implements ISetScoresRequest
         * @constructor
         * @param {lnrpc.ISetScoresRequest=} [properties] Properties to set
         */
        function SetScoresRequest(properties) {
            this.scores = {};
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * The name of the heuristic to provide scores to.
         * @member {string} heuristic
         * @memberof lnrpc.SetScoresRequest
         * @instance
         */
        SetScoresRequest.prototype.heuristic = "";

        /**
         * A map from hex-encoded public keys to scores. Scores must be in the range
         * [0.0, 1.0].
         * @member {Object.<string,number>} scores
         * @memberof lnrpc.SetScoresRequest
         * @instance
         */
        SetScoresRequest.prototype.scores = $util.emptyObject;

        /**
         * Creates a new SetScoresRequest instance using the specified properties.
         * @function create
         * @memberof lnrpc.SetScoresRequest
         * @static
         * @param {lnrpc.ISetScoresRequest=} [properties] Properties to set
         * @returns {lnrpc.SetScoresRequest} SetScoresRequest instance
         */
        SetScoresRequest.create = function create(properties) {
            return new SetScoresRequest(properties);
        };

        /**
         * Encodes the specified SetScoresRequest message. Does not implicitly {@link lnrpc.SetScoresRequest.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SetScoresRequest
         * @static
         * @param {lnrpc.ISetScoresRequest} message SetScoresRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetScoresRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heuristic != null && message.hasOwnProperty("heuristic"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.heuristic);
            if (message.scores != null && message.hasOwnProperty("scores"))
                for (let keys = Object.keys(message.scores), i = 0; i < keys.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 1 =*/17).double(message.scores[keys[i]]).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SetScoresRequest message, length delimited. Does not implicitly {@link lnrpc.SetScoresRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SetScoresRequest
         * @static
         * @param {lnrpc.ISetScoresRequest} message SetScoresRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetScoresRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetScoresRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SetScoresRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SetScoresRequest} SetScoresRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetScoresRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SetScoresRequest(), key;
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heuristic = reader.string();
                    break;
                case 2:
                    reader.skip().pos++;
                    if (message.scores === $util.emptyObject)
                        message.scores = {};
                    key = reader.string();
                    reader.pos++;
                    message.scores[key] = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetScoresRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SetScoresRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SetScoresRequest} SetScoresRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetScoresRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetScoresRequest message.
         * @function verify
         * @memberof lnrpc.SetScoresRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetScoresRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heuristic != null && message.hasOwnProperty("heuristic"))
                if (!$util.isString(message.heuristic))
                    return "heuristic: string expected";
            if (message.scores != null && message.hasOwnProperty("scores")) {
                if (!$util.isObject(message.scores))
                    return "scores: object expected";
                let key = Object.keys(message.scores);
                for (let i = 0; i < key.length; ++i)
                    if (typeof message.scores[key[i]] !== "number")
                        return "scores: number{k:string} expected";
            }
            return null;
        };

        /**
         * Creates a SetScoresRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SetScoresRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SetScoresRequest} SetScoresRequest
         */
        SetScoresRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SetScoresRequest)
                return object;
            let message = new $root.lnrpc.SetScoresRequest();
            if (object.heuristic != null)
                message.heuristic = String(object.heuristic);
            if (object.scores) {
                if (typeof object.scores !== "object")
                    throw TypeError(".lnrpc.SetScoresRequest.scores: object expected");
                message.scores = {};
                for (let keys = Object.keys(object.scores), i = 0; i < keys.length; ++i)
                    message.scores[keys[i]] = Number(object.scores[keys[i]]);
            }
            return message;
        };

        /**
         * Creates a plain object from a SetScoresRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SetScoresRequest
         * @static
         * @param {lnrpc.SetScoresRequest} message SetScoresRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetScoresRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.objects || options.defaults)
                object.scores = {};
            if (options.defaults)
                object.heuristic = "";
            if (message.heuristic != null && message.hasOwnProperty("heuristic"))
                object.heuristic = message.heuristic;
            let keys2;
            if (message.scores && (keys2 = Object.keys(message.scores)).length) {
                object.scores = {};
                for (let j = 0; j < keys2.length; ++j)
                    object.scores[keys2[j]] = options.json && !isFinite(message.scores[keys2[j]]) ? String(message.scores[keys2[j]]) : message.scores[keys2[j]];
            }
            return object;
        };

        /**
         * Converts this SetScoresRequest to JSON.
         * @function toJSON
         * @memberof lnrpc.SetScoresRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetScoresRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetScoresRequest;
    })();

    lnrpc.SetScoresResponse = (function() {

        /**
         * Properties of a SetScoresResponse.
         * @memberof lnrpc
         * @interface ISetScoresResponse
         */

        /**
         * Constructs a new SetScoresResponse.
         * @memberof lnrpc
         * @classdesc Represents a SetScoresResponse.
         * @implements ISetScoresResponse
         * @constructor
         * @param {lnrpc.ISetScoresResponse=} [properties] Properties to set
         */
        function SetScoresResponse(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SetScoresResponse instance using the specified properties.
         * @function create
         * @memberof lnrpc.SetScoresResponse
         * @static
         * @param {lnrpc.ISetScoresResponse=} [properties] Properties to set
         * @returns {lnrpc.SetScoresResponse} SetScoresResponse instance
         */
        SetScoresResponse.create = function create(properties) {
            return new SetScoresResponse(properties);
        };

        /**
         * Encodes the specified SetScoresResponse message. Does not implicitly {@link lnrpc.SetScoresResponse.verify|verify} messages.
         * @function encode
         * @memberof lnrpc.SetScoresResponse
         * @static
         * @param {lnrpc.ISetScoresResponse} message SetScoresResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetScoresResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SetScoresResponse message, length delimited. Does not implicitly {@link lnrpc.SetScoresResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lnrpc.SetScoresResponse
         * @static
         * @param {lnrpc.ISetScoresResponse} message SetScoresResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetScoresResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetScoresResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lnrpc.SetScoresResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lnrpc.SetScoresResponse} SetScoresResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetScoresResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.lnrpc.SetScoresResponse();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetScoresResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lnrpc.SetScoresResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lnrpc.SetScoresResponse} SetScoresResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetScoresResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetScoresResponse message.
         * @function verify
         * @memberof lnrpc.SetScoresResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetScoresResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a SetScoresResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lnrpc.SetScoresResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lnrpc.SetScoresResponse} SetScoresResponse
         */
        SetScoresResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lnrpc.SetScoresResponse)
                return object;
            return new $root.lnrpc.SetScoresResponse();
        };

        /**
         * Creates a plain object from a SetScoresResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lnrpc.SetScoresResponse
         * @static
         * @param {lnrpc.SetScoresResponse} message SetScoresResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SetScoresResponse.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this SetScoresResponse to JSON.
         * @function toJSON
         * @memberof lnrpc.SetScoresResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SetScoresResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SetScoresResponse;
    })();

    return lnrpc;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.api = (function() {

        /**
         * Namespace api.
         * @memberof google
         * @namespace
         */
        const api = {};

        api.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof google.api
             * @interface IHttp
             * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
             */

            /**
             * Constructs a new Http.
             * @memberof google.api
             * @classdesc Represents a Http.
             * @implements IHttp
             * @constructor
             * @param {google.api.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                this.rules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http rules.
             * @member {Array.<google.api.IHttpRule>} rules
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.rules = $util.emptyArray;

            /**
             * Creates a new Http instance using the specified properties.
             * @function create
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp=} [properties] Properties to set
             * @returns {google.api.Http} Http instance
             */
            Http.create = function create(properties) {
                return new Http(properties);
            };

            /**
             * Encodes the specified Http message. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encode
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rules != null && message.rules.length)
                    for (let i = 0; i < message.rules.length; ++i)
                        $root.google.api.HttpRule.encode(message.rules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Http message, length delimited. Does not implicitly {@link google.api.Http.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {google.api.IHttp} message Http message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Http.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Http message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.Http();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rules && message.rules.length))
                            message.rules = [];
                        message.rules.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Http message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.Http
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.Http} Http
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Http.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (let i = 0; i < message.rules.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.Http)
                    return object;
                let message = new $root.google.api.Http();
                if (object.rules) {
                    if (!Array.isArray(object.rules))
                        throw TypeError(".google.api.Http.rules: array expected");
                    message.rules = [];
                    for (let i = 0; i < object.rules.length; ++i) {
                        if (typeof object.rules[i] !== "object")
                            throw TypeError(".google.api.Http.rules: object expected");
                        message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.Http
             * @static
             * @param {google.api.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rules = [];
                if (message.rules && message.rules.length) {
                    object.rules = [];
                    for (let j = 0; j < message.rules.length; ++j)
                        object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
                }
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof google.api.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Http;
        })();

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @memberof google.api
             * @interface IHttpRule
             * @property {string|null} [get] HttpRule get
             * @property {string|null} [put] HttpRule put
             * @property {string|null} [post] HttpRule post
             * @property {string|null} ["delete"] HttpRule delete
             * @property {string|null} [patch] HttpRule patch
             * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
             * @property {string|null} [selector] HttpRule selector
             * @property {string|null} [body] HttpRule body
             * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
             */

            /**
             * Constructs a new HttpRule.
             * @memberof google.api
             * @classdesc Represents a HttpRule.
             * @implements IHttpRule
             * @constructor
             * @param {google.api.IHttpRule=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additionalBindings = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule get.
             * @member {string} get
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.get = "";

            /**
             * HttpRule put.
             * @member {string} put
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.put = "";

            /**
             * HttpRule post.
             * @member {string} post
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.post = "";

            /**
             * HttpRule delete.
             * @member {string} delete
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype["delete"] = "";

            /**
             * HttpRule patch.
             * @member {string} patch
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.patch = "";

            /**
             * HttpRule custom.
             * @member {google.api.ICustomHttpPattern|null|undefined} custom
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule selector.
             * @member {string} selector
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.selector = "";

            /**
             * HttpRule body.
             * @member {string} body
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule additionalBindings.
             * @member {Array.<google.api.IHttpRule>} additionalBindings
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.additionalBindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * HttpRule pattern.
             * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
             * @memberof google.api.HttpRule
             * @instance
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new HttpRule instance using the specified properties.
             * @function create
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule=} [properties] Properties to set
             * @returns {google.api.HttpRule} HttpRule instance
             */
            HttpRule.create = function create(properties) {
                return new HttpRule(properties);
            };

            /**
             * Encodes the specified HttpRule message. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encode
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selector != null && message.hasOwnProperty("selector"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.selector);
                if (message.get != null && message.hasOwnProperty("get"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.get);
                if (message.put != null && message.hasOwnProperty("put"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.put);
                if (message.post != null && message.hasOwnProperty("post"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.post);
                if (message["delete"] != null && message.hasOwnProperty("delete"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message["delete"]);
                if (message.patch != null && message.hasOwnProperty("patch"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.patch);
                if (message.body != null && message.hasOwnProperty("body"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.body);
                if (message.custom != null && message.hasOwnProperty("custom"))
                    $root.google.api.CustomHttpPattern.encode(message.custom, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.additionalBindings != null && message.additionalBindings.length)
                    for (let i = 0; i < message.additionalBindings.length; ++i)
                        $root.google.api.HttpRule.encode(message.additionalBindings[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified HttpRule message, length delimited. Does not implicitly {@link google.api.HttpRule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.IHttpRule} message HttpRule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HttpRule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.HttpRule();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.get = reader.string();
                        break;
                    case 3:
                        message.put = reader.string();
                        break;
                    case 4:
                        message.post = reader.string();
                        break;
                    case 5:
                        message["delete"] = reader.string();
                        break;
                    case 6:
                        message.patch = reader.string();
                        break;
                    case 8:
                        message.custom = $root.google.api.CustomHttpPattern.decode(reader, reader.uint32());
                        break;
                    case 1:
                        message.selector = reader.string();
                        break;
                    case 7:
                        message.body = reader.string();
                        break;
                    case 11:
                        if (!(message.additionalBindings && message.additionalBindings.length))
                            message.additionalBindings = [];
                        message.additionalBindings.push($root.google.api.HttpRule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HttpRule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.HttpRule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.HttpRule} HttpRule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HttpRule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HttpRule message.
             * @function verify
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    {
                        let error = $root.google.api.CustomHttpPattern.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                    if (!Array.isArray(message.additionalBindings))
                        return "additionalBindings: array expected";
                    for (let i = 0; i < message.additionalBindings.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                        if (error)
                            return "additionalBindings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.HttpRule)
                    return object;
                let message = new $root.google.api.HttpRule();
                if (object.get != null)
                    message.get = String(object.get);
                if (object.put != null)
                    message.put = String(object.put);
                if (object.post != null)
                    message.post = String(object.post);
                if (object["delete"] != null)
                    message["delete"] = String(object["delete"]);
                if (object.patch != null)
                    message.patch = String(object.patch);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".google.api.HttpRule.custom: object expected");
                    message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                }
                if (object.selector != null)
                    message.selector = String(object.selector);
                if (object.body != null)
                    message.body = String(object.body);
                if (object.additionalBindings) {
                    if (!Array.isArray(object.additionalBindings))
                        throw TypeError(".google.api.HttpRule.additionalBindings: array expected");
                    message.additionalBindings = [];
                    for (let i = 0; i < object.additionalBindings.length; ++i) {
                        if (typeof object.additionalBindings[i] !== "object")
                            throw TypeError(".google.api.HttpRule.additionalBindings: object expected");
                        message.additionalBindings[i] = $root.google.api.HttpRule.fromObject(object.additionalBindings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.HttpRule} message HttpRule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.additionalBindings = [];
                if (options.defaults) {
                    object.selector = "";
                    object.body = "";
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    object.selector = message.selector;
                if (message.get != null && message.hasOwnProperty("get")) {
                    object.get = message.get;
                    if (options.oneofs)
                        object.pattern = "get";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    object.put = message.put;
                    if (options.oneofs)
                        object.pattern = "put";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    object.post = message.post;
                    if (options.oneofs)
                        object.pattern = "post";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.pattern = "delete";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    object.patch = message.patch;
                    if (options.oneofs)
                        object.pattern = "patch";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                    if (options.oneofs)
                        object.pattern = "custom";
                }
                if (message.additionalBindings && message.additionalBindings.length) {
                    object.additionalBindings = [];
                    for (let j = 0; j < message.additionalBindings.length; ++j)
                        object.additionalBindings[j] = $root.google.api.HttpRule.toObject(message.additionalBindings[j], options);
                }
                return object;
            };

            /**
             * Converts this HttpRule to JSON.
             * @function toJSON
             * @memberof google.api.HttpRule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HttpRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @memberof google.api
             * @interface ICustomHttpPattern
             * @property {string|null} [kind] CustomHttpPattern kind
             * @property {string|null} [path] CustomHttpPattern path
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @memberof google.api
             * @classdesc Represents a CustomHttpPattern.
             * @implements ICustomHttpPattern
             * @constructor
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @member {string} kind
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @member {string} path
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Creates a new CustomHttpPattern instance using the specified properties.
             * @function create
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern instance
             */
            CustomHttpPattern.create = function create(properties) {
                return new CustomHttpPattern(properties);
            };

            /**
             * Encodes the specified CustomHttpPattern message. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.kind != null && message.hasOwnProperty("kind"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.kind);
                if (message.path != null && message.hasOwnProperty("path"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                return writer;
            };

            /**
             * Encodes the specified CustomHttpPattern message, length delimited. Does not implicitly {@link google.api.CustomHttpPattern.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.ICustomHttpPattern} message CustomHttpPattern message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomHttpPattern.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer.
             * @function decode
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.api.CustomHttpPattern();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.kind = reader.string();
                        break;
                    case 2:
                        message.path = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomHttpPattern message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomHttpPattern.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomHttpPattern message.
             * @function verify
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CustomHttpPattern)
                    return object;
                let message = new $root.google.api.CustomHttpPattern();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.CustomHttpPattern} message CustomHttpPattern
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.path = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this CustomHttpPattern to JSON.
             * @function toJSON
             * @memberof google.api.CustomHttpPattern
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomHttpPattern.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CustomHttpPattern;
        })();

        return api;
    })();

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (let i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (let i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (let j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && message.hasOwnProperty("package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (let i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (let i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (let i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (let i = 0; i < message.messageType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (let i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (let i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (let i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (let i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (let i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (let j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (let j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (let j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (let j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (let j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (let i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (let i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (let i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (let i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (let i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (let i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (let i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (let i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (let i = 0; i < message.nestedType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (let i = 0; i < message.extensionRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (let i = 0; i < message.oneofDecl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                let message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (let i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (let i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (let i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (let i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (let j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (let j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (let j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (let j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && message.hasOwnProperty("start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && message.hasOwnProperty("label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && message.hasOwnProperty("type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {string}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {string}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (let i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (let i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (let j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && message.hasOwnProperty("number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (let i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (let i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (let j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && message.hasOwnProperty("options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                let message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {string}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                let message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && message.hasOwnProperty("packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && message.hasOwnProperty("weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                let message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {string}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {string}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                let message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                let message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                let message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                let message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MethodOptions .google.api.http.
             * @member {google.api.IHttpRule|null|undefined} .google.api.http
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (let i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    $root.google.api.HttpRule.encode(message[".google.api.http"], writer.uint32(/* id 72295728, wireType 2 =*/578365826).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    case 72295728:
                        message[".google.api.http"] = $root.google.api.HttpRule.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    let error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                let message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".google.api.http"] != null) {
                    if (typeof object[".google.api.http"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                    message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object[".google.api.http"] = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (let i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                let message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (let i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (let j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    let message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (let i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                let message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (let i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (let j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (let i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    let message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (let i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (let i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (let j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (let j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (let i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                let message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (let i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (let j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (let i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && message.hasOwnProperty("end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        return protobuf;
    })();

    return google;
})();

export { $root as default };
